Chapter 8. Makin' Objects
$5 + 10 CHF = $10 if rate is 2:1
$5 * 2 = $10
Make "amount" private
Dollar side effects?
Money rounding?
equals()
hashCode()
Equal null
Equal object
5 CHF * 2 = 10 CHF
Dollar/Franc duplication
Common equals
Common times
Compare Francs to Dollars
Currency?
The two implementations of 
times()
 are remarkably similar:
Franc
Franc times(
int 
multiplier) {
   return new 
Franc(amount * multiplier);
}
Dollar
Dollar times(
int 
multiplier) {
   return new 
Dollar(amount * multiplier);
}
We can take a step toward reconciling them by making them both return a 
Money
:
Franc
Money times(
int 
multiplier) {
   return new 
Franc(amount * multiplier);
}
Dollar
Money times(
int 
multiplier) {
   return new 
Dollar(amount * multiplier);
}
The next step forward is not obvious. The two subclasses of 
Money
 aren't doing enough work
to justify their existence, so we would like to eliminate them. But we can't do it with one big
step, because that wouldn't make a very effective demonstration of TDD.
Okay, we would be one step closer to eliminating the subclasses if there were fewer
references to the subclasses directly. We can introduce a factory method in 
Money
 that
returns a 
Dollar
. We would use it like this:
public void 
testMultiplication() {
   
Dollar five = Money.dollar(5);
   
assertEquals(new Dollar(10), five.times(2));
   
assertEquals(new Dollar(15), five.times(3));
}
The implementation creates and returns a 
Dollar
:
Money
static 
Dollar dollar(
int 
amount) {
   return new 
Dollar(amount);
}
But we want references to 
Dollar
s to disappear, so we need to change the declaration in the
test:
public void 
testMultiplication() {
   
Money five = Money.dollar(5);
   
assertEquals(new Dollar(10), five.times(2));
   
assertEquals(new Dollar(15), five.times(3));
}
Our compiler politely informs us that 
times()
 is not defined for 
Money
. We aren't ready to
implement it just yet, so we make 
Money
 abstract (I suppose we should have done that to
begin with?) and declare 
Money.times()
:
Money
abstract 
class Money
abstract 
Money times(
int 
multiplier);
Now we can change the declaration of the factory method:
Money
static Money 
dollar(
int 
amount) {
   return new 
Dollar(amount);
}
The tests all run, so at least we haven't broken anything. We can now use our factory method
everywhere in the tests:
public void 
testMultiplication() {
   
Money five = Money.dollar(5);
   
assertEquals(Money.dollar(10), five.times(2));
   
assertEquals(Money.dollar(15), five.times(3));
}
public void 
testEquality() {
   
assertTrue(Money.dollar(5).equals(Money.dollar(5)));
   
assertFalse(Money.dollar(5).equals(Money.dollar(6)));
   
assertTrue(
new 
Franc(5).equals(
new 
Franc(5)));
   
assertFalse(
new 
Franc(5).equals(
new 
Franc(6)));
   
assertFalse(
new 
Franc(5).equals(
Money.dollar(5)));
}
We are now in a slightly better position than before. No client code knows that there is a
subclass called 
Dollar
. By decoupling the tests from the existence of the subclasses, we have
given ourselves freedom to change inheritance without affecting any model code.
Before we go blindly changing the 
testFrancMultiplication
, we notice that it isn't testing any
logic that isn't tested by the test for 
Dollar
 multiplication. If we delete the test, will we lose
any confidence in the code? Still a little, so we leave it there. But it's suspicious.
public void 
testEquality() {
   
assertTrue(Money.dollar(5).equals(Money.dollar(5)));
   
assertFalse(Money.dollar(5).equals(Money.dollar(6)));
   
assertTrue(Money.franc(5).equals(Money.franc(5)));
   
assertFalse(Money.franc(5).equals(Money.franc(6)));
   
assertFalse(Money.franc(5).equals(Money.dollar(5)));
}
public void 
testFrancMultiplication() {
   
Money five = Money.franc(5);
   
assertEquals(Money.franc(10), five.times(2));
   
assertEquals(Money.franc(15), five.times(3));
}
The implementation is just like 
Money.dollar()
:
Money
static 
Money franc(
int 
amount) {
   return new 
Franc(amount);
}
$5 + 10 CHF = $10 if rate is 2:1
$5 * 2 = $10
Make "amount" private
Dollar side effects?
Money rounding?
equals()
hashCode()
Equal null
Equal object
5 CHF * 2 = 10 CHF
Dollar/Franc duplication
Common equals
Common times
Compare Francs to Dollars
Currency?
Delete testFrancMultiplication?
Next we'll get rid of the duplication of 
times()
. For now, to review, we
Took a step toward eliminating duplication by reconciling the signatures of two variants of the
same method - 
times()
Moved at least a declaration of the method to the common superclass
Decoupled test code from the existence of concrete subclasses by introducing factory methods
Noticed that when the subclasses disappear some tests will be redundant, but took no action