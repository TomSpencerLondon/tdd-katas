Chapter 16. Abstraction, Finally
$5 + 10 CHF = $10 if rate is 2:1
$5 + $5 = $10
Return Money from $5 + $5
Bank.reduce(Money)
Reduce Money with conversion
Reduce(Bank, String)
Sum.plus
Expression.times
We need to implement 
Sum.plus()
 to finish 
Expression.plus
, and then we need
Expression.times()
, and then we're finished with the whole example. Here's the test for
Sum.plus()
:
public void 
testSumPlusMoney() {
   
Expression fiveBucks= Money.dollar(5);
   
Expression tenFrancs= Money.franc(10);
   
Bank bank=
 new 
Bank();
   
bank.addRate("CHF", "USD", 2);
   
Expression sum=
 new 
Sum(fiveBucks, tenFrancs).plus(fiveBucks);
   
Money result= bank.reduce(sum, "USD");
   
assertEquals(Money.dollar(15), result);
}
We could have created a 
Sum
 by adding 
fiveBucks
 and 
tenFrancs
, but the form above, in
which we explicitly create the 
Sum
, communicates more directly. We are writing these tests
not just to make our experience of programming more fun and rewarding, but also as a
Rosetta stone for future generations to appreciate our genius. Think, oh think, of our readers.
The test, in this case, is longer than the code. The code is the same as the code in 
Money
. (Do
I hear an abstract class in the distance?)
Sum
public 
Expression plus(Expression addend) {
   return new 
Sum(
this, 
addend);
}
$5 + 10 CHF = $10 if rate is 2:1
$5 + $5 = $10
Return Money from $5 + $5
Bank.reduce(Money)
Reduce Money with conversion
Reduce(Bank, String)
Sum.plus
Expression.times
You will likely end up with about the same number of lines of test code as model code when
implementing TDD. For TDD to make economic sense, you'll need to be able to either write
twice as many lines per day as before, or write half as many lines for the same functionality.
You'll have to measure and see what effect TDD has on your own practice. Be sure to factor
debugging, integrating, and explaining time into your metrics, though.
$5 + 10 CHF = $10 if rate is 2:1
$5 + $5 = $10
Return Money from $5 + $5
Bank.reduce(Money)
Reduce Money with conversion
Reduce(Bank, String)
Sum.plus
Expression.times
If we can make 
Sum.times()
 work, then declaring 
Expression.times()
 will be one simple step.
The test is:
public void 
testSumTimes() {
   
Expression fiveBucks= Money.dollar(5);
   
Expression tenFrancs= Money.franc(10);
   
Bank bank=
 new 
Bank();
   
bank.addRate("CHF", "USD", 2);
   
Expression sum=
 new 
Sum(fiveBucks, tenFrancs).times(2);
   
Money result= bank.reduce(sum, "USD");
   
assertEquals(Money.dollar(20), result);
}
Again, the test is longer than the code. (You JUnit geeks will know how to fix that - the rest of
you will have to read Fixture.)
Sum
Expression times(
int 
multiplier) {
   return new 
Sum(augend.times(multiplier),addend.times(multiplier));
}
Because we abstracted augend and addend to 
Expression
s in the last chapter, we now have to
declare 
times()
 in 
Expression
 for the code to compile:
Expression
Expression times(
int 
multiplier);
This forces us to raise the visibility of 
Money.times()
 and 
Sum.times()
:
Sum
public 
Expression times(
int 
multiplier) {
   return new 
Sum(augend.times(multiplier),addend.times(multiplier));
}
Money
public 
Expression times(
int 
multiplier) {
          return new 
Money(amount * multiplier, currency);
}
$5 + 10 CHF = $10 if rate is 2:1
$5 + $5 = $10
Return Money from $5 + $5
Bank.reduce(Money)
Reduce Money with conversion
Reduce(Bank, String)
Sum.plus
Expression.times
And it works.
The only loose end to tie up is to experiment with returning a 
Money
 when we add $5 + $5.
The test would be:
public void 
testPlusSameCurrencyReturnsMoney() {
   
Expression sum= Money.dollar(1).plus(Money.dollar(1));
   
assertTrue(sum
 instanceof 
Money);
}
This test is a little ugly, because it is testing the guts of the implementation, not the
externally visible behavior of the objects. However, it will drive us to make the changes we
need to make, and this is only an experiment, after all. Here is the code we would have to
modify to make it work:
Money
public 
Expression plus(Expression addend) {
   return new 
Sum(
this, 
addend);
}
$5 + 10 CHF = $10 if rate is 2:1
$5 + $5 = $10
Return Money from $5 + $5
Bank.reduce(Money)
Reduce Money with conversion
Reduce(Bank, String)
Sum.plus
Expression.times
There is no obvious, clean way (not to me, anyway; I'm sure you could think of something) to
check the currency of the argument if and only if it is a 
Money
. The experiment fails, we
delete the test (which we didn't like much anyway), and away we go.
To review, we
Wrote a test with future readers in mind
Suggested an experiment comparing TDD with your current programming style
Once again had changes of declarations ripple through the system, and once again followed
the compiler's advice to fix them
Tried a brief experiment, then discarded it when it didn't work out