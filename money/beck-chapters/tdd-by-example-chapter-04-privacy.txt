Chapter 4. Privacy
$5 + 10 CHF = $10 if rate is 2:1
$5 * 2 = $10
Make
 
"
amount
"
 private
Dollar side effects?
Money rounding?
equals()
hashCode()
Equal null
Equal object
Now that we have defined equality, we can use it to make our tests more "speaking."
Conceptually, the operation 
Dollar.times()
 should return a 
Dollar
 whose value is the value of
the receiver times the multiplier. Our test doesn't exactly say that:
public void 
testMultiplication() {
   
Dollar five=
 new 
Dollar(5);
   
Dollar product= five.times(2);
   
assertEquals(10, product.amount);
   
product= five.times(3);
   
assertEquals(15, product.amount);
}
We can rewrite the first assertion to compare 
Dollar
s to 
Dollar
s:
public void 
testMultiplication() {
   
Dollar five=
 new 
Dollar(5);
   
Dollar product= five.times(2);
   
assertEquals(
new 
Dollar(10), product);
   
product= five.times(3);
   
assertEquals(15, product.amount);
}
That looks better, so we rewrite the second assertion, too:
public void 
testMultiplication() {
   
Dollar five=
 new 
Dollar(5);
   
Dollar product= five.times(2);
   
assertEquals(
new 
Dollar(10), product);
   
product= five.times(3);
   
assertEquals(
new 
Dollar(15), product);
}
Now the temporary variable 
product
 isn't helping much, so we can inline it:
public void 
testMultiplication() {
   
Dollar five=
 new 
Dollar(5);
   
assertEquals(
new 
Dollar(10), five.times(2));
   
assertEquals(
new 
Dollar(15), five.times(3));
}
This test speaks to us more clearly, as if it were an assertion of truth, not a sequence of
operations.
With these changes to the test, 
Dollar
 is now the only class using its 
amount
 instance variable,
so we can make it private:
Dollar
private int 
amount;
$5 + 10 CHF = $10 if rate is 2:1
$5 * 2 = $10
Make "amount" private
Dollar side effects?
Money rounding?
equals()
hashCode()
Equal null
Equal object
And we can cross another item off the to-do list. Notice that we have opened ourselves up to a
risk. If the test for equality fails to accurately check that equality is working, then the test for
multiplication could also fail to accurately check that multiplication is working. This is a risk
that we actively manage in TDD. We aren't striving for perfection. By saying everything two
ways - both as code and as tests - we hope to reduce our defects enough to move forward
with confidence. From time to time our reasoning will fail us and a defect will slip through.
When that happens, we learn our lesson about the test we should have written and move on.
The rest of the time we go forward boldly under our bravely flapping green bar (my bar
doesn't actually flap, but one can dream.)
To review, we
Used functionality just developed to improve a test
Noticed that if two tests fail at once we're sunk
Proceeded in spite of the risk
Used new functionality in the object under test to reduce coupling between the tests and the
code