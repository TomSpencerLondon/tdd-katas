This version was produced from th e original files on 27 October 2022  
Updated 14 November and 4 December 2022, 17, 22 and 24 March 2023
           Author contacts:
Web site se.ethz.ch/~meyer  (see also eiffel.com , eiffel.org )
Blog and some pe rsonal pages bertrandmeyer.com
Email Bеrtrand.Мeуer@inf.ethz.сhAbout this online edition
The second edition of Object-Oriented Softw are Construction was published in 1997,  
considerably augmented from the 1 988 first edition. For more ab out the book, see the  
Wikipedia entry about it . 
Both editions were published by Prentice Hall, n ow part of Pear son Education, Inc.
With Pearson’s kind permission, this online version hast been m ade available in  
response to frequent requests an d in preparation of the forthco ming third edition. 
This version is the original text from the 1997 edition . Other than the present page,  
only a few changes have been made (removing obsolete syntax for ms). Significant  
changes, updates and a dditions will appear i n the extensively r eworked 3rd edition.
To follow the progress of the third edition, please consult bertrandmeyer.com/OOSC3 .
Copyright notice
© Bertrand Meyer, 1997, renewed 2022.
This book was previously published by Pearson Education, Inc.
The text is not in the public domain . It is copyrighted material, made available free  
of charge on the Web for the con venience of readers, in particu lar for use as a textbook in  
courses. You are not permitted to copy or redistribute it. Simp ly refer others to the present  
version at bertrandmeyer.com/OOSC2 .
A number of pirated versions have found their way to various si tes on the Web. They  
are illegal, and typically of bad typographical quality, damagi ng the book’s reputation. If  
you encounter such a version, please ask the site owners to rem ove it, or notify the author.
 
FROM THE REVIEWS OF THE FIRST EDITION:
“Tour de Force … Meyer succeeds admirably in leading the patient reader … through a presentation of the  
fundamental software developmen t issues that is independent of any programming system, language or  
application area … Well organized and highly readable … Meyer’s high standards fo r precision of expression  
do not interfere with a literate style or preclude the occasion al injection of humor.”
Ron Levin in Software  (IEEE)
“The author believes in OOP, has the experience to know that it  works, and is willing and able to show us why  
and how … The clear choice  for software people who want to dive straight into object-orie nted programming”
Walter Zintz in Unix World
“The book presents the  concepts in an orderly manner and explai ns them very well. It is even more attractive  
because it presents a technique of object-oriented design .”
Pierre America in Science of Computer Programming
A whole generation was introdu ced to object technology through the first edition of Bertrand Meyer’s OOSC . 
This long-awaited new edition re tains the qualities of clarity,  practicality and scholarship that made the first an  
instant best-seller. It has been thoroughly revised and conside rably expanded. No other book on the market  
provides such a breadth and dept h of coverage on the most impor tant technology in software development.
SOME OF THE NEW TOPICS COVERED IN DEPTH BY THIS SECOND EDITION:
• Concurrency , distribution, client-server and the Internet.
• Object-oriented databases , persistence, schema evolution.
• Design by contract : how to build software that works the first time around.
• A study of fundamental design patterns .
• How to f ind the classes  and many others topics of object-oriented methodology .
• How to use inheritance  well and detect misuses.
• Abstract data types : the theory behind object technology.
• Typing : role, issues and solutions.
• More than 400 references  to books, articles, Web pages, newsgroups; glossary  of object technology.
• And many new developments on the topics of the first edition: r eusability, modularity, software quality,  
O-O languages, inheritance techniques, genericity, memory manag ement, etc.Bertrand Meyer’s
Object-Oriented Software Construction
SECOND EDITION
The definitive reference on the m ost important new technology i n software
About the author
Bertrand Meyer is one of the pioneers of modern software engine ering, whose experience spans both industry and  
academia. He has led the development of successful O-O products  and libraries totaling thousan ds of classes. His Prentice  
Hall books include Object Success  (an introduction to object technology for managers), Introduction to the Theory of  
Programming Languages , Eiffel: The Language , Object-Oriented Applications , and Reusable Software . He is a frequent  
keynote speaker at international conferences and consultant for  Fortune 500 companies, editor of the Object-Oriented  
Series, associate member of the applications section of the Fre nch Academy of Sciences, chairman of the TOOLS  
conference series, and editor of the Object Technology departme nt of IEEE Computer .Back cover of 1997 edition

SHORT TABLE OF CONTENTS
(The full table of cont ents starts on page xvii.)
Preface v
Foreword to the second edition xiiiAbout the accompanying CD-ROM xiv
On the bibliography, Intern et sources and exercises xv
Part A:  The issues 1
1 Software quality  3
2 Criteria of object orientation  21
Part B:  The road to object orientation 37
3 Modularity  39
4 Approaches to reusability  675 Towards object technology  101
6 Abstract data types  121
Part C:  Object-oriented techniques 163
7 The static struc ture: classes  165
8 The run-time structure: objects  217
9 Memory management  279
10 Genericity  31711 Design by Contract: buildi ng reliable software 331
12 When the contract is broken: exception handling  
 411
13 Supporting mechanisms  43914 Introduction to inheritance  459
15 Multiple inheritance  519
16 Inheritance techniques  569
17 Typing  611
18 Global objects and constants  643
Part D:  Object-oriented methodology: applying the 
method well 661
19 On methodology  663
20 Design pattern: multi-panel interactive systems 67521 Inheritance case study:   “undo” in an interactive 
system  695
22 How to find the classes  71923 Principles of class design  747
24 Using inheritance well  80925 Useful techniques  871
26 A sense of style  875
27 Object-oriented analysis  90328 The software construction process  92329 Teaching the method  935
Part E:  Advanced topics 949
30 Concurrency, distribution, client-server and the 
Internet  951
31  Object persistence and databases  1037
32 Some O-O techniques for  graphical interactive 
applications  1063
Part F:  Applying the met hod in various languages and 
environments 1077
33 O-O programming and Ada  1079
34 Emulating object technology in non-O-O 
environments  1099
35 Simula to Java and beyond: major O-O languages 
and environments  1113
Part G:  Doing it right 1141
36  An object-oriented environment  1143
Epilogue, In Full Frankness Exposing the Language
1161
Part H:  Appendices 1163
Extracts from the Base libraries 1165
Genericity versus inheritance 1167
Principles, rules, prec epts and definitions 1189
A glossary of object technology 1193
Bibliography 1203
Index 1225

Preface
B orn in the ice-blue waters of th e festooned Norwegian coast; am plified (by an  
aberration of world cu rrents, for which marine geographers have  yet to find a suitable  
explanation) along the much gray er range of the Californian Pac ific; viewed by some as a  
typhoon, by some as a tsunami, a nd by some as a storm in a teac up — a tidal wave is  
hitting the shores of the computing world. 
“Object-oriented” is the latest in term, complementing and in many cases replacing  
“structured” as the high-tech version of “good”. As is inevitab le in such a case, the term  
is used by different people with different meanings; just as in evitable is the well-known  
three-step sequence of reactions  that meets the introduction of  a  n e w  m e t h o d o l o g i c a l  
principle: (1) “it’s trivial”; (2 ) “it cannot work”; (3) “that’ s how I did it all along anyway”.  
(The order may vary.) 
Let us have this clear right away, lest the reader think the au thor takes a half-hearted  
approach to his topic: I do not s ee the object-oriented method as a mere fad; I think it is  
not trivial (although I  shall strive to make it as limpid as I can); I know it works; and I  
believe it is not only different  from but even, to a certain ex tent, incompa tible with the  
techniques that most people still use today — including some of  the principles taught in  
many software engineering textbook s. I further believe that obj ect technology holds the  
potential for fundamental change s in the software industry, and  t h a t  i t  i s  h e r e  t o  s t a y .  
Finally, I hope that as the reader progresses through these pag es, he will share some of my  
excitement about this promising avenue to software analysis, de sign and implementation. 
“Avenue to software analysis, design and implementation”. To pr esent the object-
oriented method, this books resol utely takes the viewpoint of s oftware engineering — of  
the methods, tools and techniques  for developing quality softwa re in production  
environments. This is not the onl y possible perspective, as the re has also been interest in  
applying object-oriented principles to such areas as explorator y programming and  
artificial intelligence. Although  the presentation does not exc lude these applications, they  
are not its main emphasis. Our p rincipal goal in this discussio n is to study how practicing  
software developers, in indust rial as well as academic environm ents, can use object  
technology to improve (in some c ases dramatically) the quality of the software they  
produce.
PREFACE vi
Structure, reliability, epi stemology and classification
Object technology is at its core the combination of four ideas:  a structuring method, a  
reliability discipline , an epistemological principle and a clas sification t echnique. 
The structuring method  a p p l i e s  t o  s o f t w a r e  d e c o m p o s i t i o n  a n d  r e u s e .  S o f t w a r e  
systems perform certain actions on objects of certain types; to  obtain flexible and reusable  
systems, it is better to base their structure on the object typ es than on the actions. The  
resulting concept is a  remarkably powerful a nd versatile mechan ism called the class , 
which in object-oriented softwar e construction serves as the ba sis for both the modular  
structure and the type system. 
The reliability discipline  is a radical approach to the problem of building software  
that does what it is s upposed to do. The ide a is to treat any s ystem as a collection of  
components which collaborate the way successful businesses do: by adhering to contracts
defining explicitly the  obligations and benefits incumbent on e ach party.
The epistemological principle  addresses the question of h ow we should describe the  
classes. In object technology, th e objects described by a class  are only defined by what we  
can do with them: operations (also known as features ) and formal properties of these  
operations (the contracts). This  idea is formally expressed by the theory of abstract data  
types , covered in detail in a chapter  of this book. It has far-reach ing implications, some  
going beyond software, and expl ains why we must not stop at the  naïve concept of  
“object” borrowed from the ordinary meaning of that word. The t radition of information  
systems modeling usually assumes an “external reality” that pre dates any program using  
it; for the object-oriented developer, such a notion is meaning less, as the reality does not  
exist independently of what you want to do with it. (More preci sely whether it exists or  
not is an irrelevant question, as we only know what we can use,  and what we know of  
something is defined entirel y by how we can use it.) 
The classification technique follows from the observation that systematic  
intellectual work in general and  scientific reasoning in partic ular require devising  
taxonomies for the domains being studied. Software is no except i o n ,  a n d  t h e  o b j e c t -
oriented method relies heavily o n a classificati on discipline k nown as inheritance .
Simple but powerful
The four concepts of c lass, contract, abstra ct data type and in heritance immediately raise  
a number of questions. How do we find and describe classes? How  should our programs  
manipulate classes and the corresponding objects (the instances  of these classes)? What  
are the possible relations betwe en classes? How can we capitali ze on the commonalities  
that may exist between various classes? How do these ideas rela te to such key software  
engineering concerns a s extendibility, ease  of use and efficien cy? 
Answers to these questions rely on a small but powerful array o f techniques for  
producing reusable, extendible and reliable software: polymorph ism and dynamic  
binding; a new view of types and type check ing; genericity, con strained and  Abstract data types 
are discussed in chapter 6, which also addresses some of the related episte-mological issues. 
PREFACE vii
unconstrained; informa tion hiding; assertions; safe exception h andling; automatic garbage  
collection. Efficient implementat ion techniques have been devel oped which permit  
applying these ideas successfull y to both small and large proje cts under the tight  
constraints of commercial softwa re development. Object-oriented  techniques have also  
had a considerable impact on use r interfaces and development en vironments, making it  
possible to produce mu ch better interactive systems than was po ssible before. All these  
i m p o r t a n t  i d e a s  w i l l  b e  s t u d i e d  i n  d e t a i l ,  s o  a s  t o  e q u i p  t h e  r eader with tools that are  
immediately applicable to a wide range of problems. 
Organization of the text
In the pages that follow we will review the methods and techniq ues of object-oriented  
software construction. The prese ntation has been divided into s ix parts. 
Part A is an introduction and overview.  It starts by exploring the fu ndamental issue  
of software quality and continue s  w i t h  a  b r i e f  s u r v e y  o f  t h e  m e thod’s main technical  
characteristics. This part is almost a little book by itself, p roviding a first view of the  
object-oriented approach for hurried readers. 
Part B is not hurried. Entitled “The r oad to object orientation”, it takes the time to  
describe the methodological conce rns that lead to the central O -O concepts. Its focus is on  
modularity: what it takes to devise satisfactory structures for  “in-the-large” system  
construction. It ends with a pre sentation of abstract data type s, the mathematical basis for  
object technology. The mathemati cs involved is elementary, and less mathematically  
inclined readers may content the m s e l v e s  w i t h  t h e  b a s i c  i d e a s ,  b ut the presentation  
provides the theoretic al background that you will need for a fu ll understanding of O-O  
principles and issues. 
Part C is the technical core of the book. It presents, one by one, th e central technical  
components of the method: classe s; objects and the associated r un-time model; memory  
management issues; gen ericity and typing; de sign by contract, a ssertions, exceptions;  
inheritance, the associated con cepts of polymorphism and dynami c binding, and their  
many exciting a pplications. 
Part D discusses methodology , with special emphasis on analysis and d esign.  
Through several in-dep th case studies, it presents some fundame ntal design patterns , and 
covers such central questions as how to find the classes, how t o use inheritance properly,  
and how to design reusable libra ries. It starts with a meta-lev el discussion of the  
intellectual requirements on meth odologists and other advice-gi vers; it concludes with a  
review of the so ftware process (the lifec ycle model) for O-O de velopment and a  
discussion of how best to teach t he method in both industry and  universities.
Part E explores advanced topics: concur rency, distributi on, client-se rver 
development and the Internet; pe rsistence, schema evolution and  object-oriented  
databases; the design of interac tive systems with modern (“GUI” ) graphical interfaces.Chapters 1 to 2.
Chapters 3 to 6.
Chapters 7 to 18.
Chapters 19 to 29.
Chapters 30 to 32.
PREFACE viii
Part F is a review of how the ideas ca n be implemented, or in some ca ses emulated,  
in various languages and environ ments. This includes in particu lar a discussion of major  
object-oriented languages, focusi ng on Simula, Smalltalk, Objec tive-C, C++, Ada 95 and  
Java, and an assessment of how t o obtain some of the benefits o f object orientation in such  
non-O-O languages as Fortran , Cobol, Pascal, C and Ada. 
Part G (doing it right ) describes an envir onment which goes be yond these solutions  
and provides an integrated set o f tools to support the ideas of  the book.
As complementary reference mater ial, an appendix shows some imp ortant reusable  
library classes discussed in the text, providing a model for th e design of reusable software. 
A Book-Wide Web
It can be amusing to see authors t aking pains to describe recom mended paths through their  
books, sometimes with the help o f sophisticated traversal chart s — as if readers ever paid  
any attention, and were not smart enough to map their own cours e. An author is permitted,  
however, to say in what spirit he has scheduled the different c hapters, and what path he  
had in mind for what Umberto Eco calls the Model Reader — not t o be confused with the  
real reader, also known as “you” , made of flesh, blood and tast es.
The answer here is the simplest possible one. This book tells a  story, and assumes  
that the Model Reader will follow that story from beginning to end, being however invited  
to avoid the more specialized sec tions marked as “skippable on first reading” and, if not  
mathematically i nclined, to ignore a few mathematical developme nts also labeled  
explicitly. The real reader, of course, may want to discover in  advance some of the plot’s  
later developments, or to confin e his attention to just a few s ubplots; every chapter has for  
that reason been made as self-con tained as possible, so that yo u should be able to intake  
the material at th e exact dosage which suits you best.
Because the story presents a cohe rent view of software developm ent, its successive  
topics are tightly intertwined. The margin notes offer a subtex t of cross references, a Book-
Wide Web linking the various sec tions back and forth. My advice  to the Model Reader is  
to ignore them on firs t reading, except as a  reassurance that q uestions which at some stage  
are left partially open will be f ully closed later on. The real  reader, who may not want any  
advice, might use the c ross references as u nofficial guides whe n he feels like cheating on  
the prearranged o rder of topics.
Both the Model Reader and the real reader should find the cross  references mostly  
useful in subsequent readings, to make sure that they have mast ered a certain object-
oriented concept in de pth, and understood its connections with the method’s other  
components. Like the hyperlinks of a WWW document, the cross re ferences should make  
it possible to follow such associ ations quickly and effectively .
The CD-ROM that accomp anies this book and co ntains all of its t ext provides a  
convenient way to foll ow cross references: just click on them. All the cross references  
have been preserved.Chapters 33 to 35.
Chapter 36.
Appendix A.
See “About the 
accompanying CD-ROM”, page xiv.
PREFACE ix
The notation
In software perhaps even more than elsewhere, thought and langu age are closely  
connected. As we progress throug h these pages, we will carefull y develop a notation for  
expressing object-oriented concepts at all levels: modeling, an alysis, design,  
implementation, maintenance.   
Here and everywhere else in this book, the pronoun “we” does no t mean “the  
author”: as in ordinary language, “we” means you and I — the re ader and the author. In  
other words I would like you to e xpect that, as we develop the notation, you will be  
involved in the process. 
This assumption is not really true, of course, since the notati on existed before you  
started reading these pages. But  it is not completely preposter ous either, because I hope  
that as we explore the object-or iented method and carefully exa mine its implications the  
supporting notat ion will dawn on you with a kind of inevitabili ty, so that you  will indeed  
feel that you helped design it. 
This explains why although the notation has been around for mor e than ten years and  
is in fact supported by several commercial implementations, inc luding one from my  
company (ISE), I have downplayed it as a language. (Its name do es appear in one place in  
the text, and several times in the bibliography.) This book is about the object-oriented  
method for reusing, analyzing, designing, implementing and main taining software; the  
language is an important and I hope natural consequence of that  method, not an aim in itself. 
In addition, the language is str aightforward and includes very little else than direct  
support for the method. First-year students using it have comme nted that it was “no  
language at all” — meaning that the notation is in one-to-one c orrespondence with the  
method: to learn one is to learn the other, and there is scant extra linguistic decoration on  
top of the concepts. The notation indeed shows few of the pecul iarities (often stemming  
from historical circumstances, m achine constraints or the requi rement to be compatible  
with older formalisms) that characterize most of today’s progra mming languages. Of  
course you may disagree with t he choice of keywords (why do r a t h e r  t h a n  begin  o r 
perhaps faire ?), or would like to add semicol on terminators after each instr uction. (The  
syntax has been designed so as to  make semicolons optional.) Bu t these are side issues.  
What counts is the simplicity of  the notation and how directly it maps to the concepts. If  
you understand object t echnology, you almos t know it already. 
Most software books take the lan guage for grante d, whether it i s a programming  
language or a notation for analy sis or design. Here the approac h is different; involving the  
reader in the design means that one must not only explain the l anguage but also justify it  
and discuss the altern atives. Most of the chapters of part C in clude a “discussion” section  
explaining the issues encountere d during the design of the nota tion, and how they were  
resolved. I often wish ed, when reading desc riptions o f well-kno wn languages, that the  
designers had told me not only w hat solutions they chose, but w hy they chose them, and  
what alternatives they rejected.  The candid discussions include d in this book should, I  
hope, provide you with insights not only about la nguage design but also about software  
construction, as the two tasks  are so striki ngly similar. 
PREFACE x
Analysis, design a nd implementation
It is always risky to use a notat ion that externally looks like  a programming language, as  
this may suggest that it only covers the implementation phase. This impression, however  
wrong, is hard to correct, so fr equently have managers and deve lopers been told that a gap  
of metaphysical proportions exis t s  b e t w e e n  t h e  e t h e r  o f  a n a l y s i s-design and the  
underworld of implementation. 
Well-understood object technology  reduces the gap considerably by emphasizing the  
essential unity of software development over the inevitable dif ferences between levels of  
abstraction. This seamless  approach to software construct ion is one of the important  
contributions of the m ethod and is reflected  by the language of  this book, which is meant  
for analysis and de sign as well as for implementation. 
Unfortunately some of the recent  evolution of th e field goes ag ainst these principles,  
through two equally reg rettable phenomena:   
• Object-oriented implementation languages which are unfit for an alysis, for design and  
in general for high-level reasoning. 
• Object-oriented analysis or de sign methods which do not cover i mplementation (and  
are advertized as “language-inde pendent” as if this were a badg e of honor rather than  
an admission of failure). 
Such approaches threat en to cancel much of the potential benefi t of the approach. In  
contrast, both the method and the notation develop e d  i n  t h i s  b o o k  a r e  m e a n t  t o  b e  
applicable throughout the softwar e construction process. A numb er of chapters cover  
high-level design issues; one is devoted to analy sis; others ex plore implementation  
techniques and the method’s i mplications on performance. 
The environment
Software construction relies on a basic tetralogy: method, lang uage, tools, libraries. The  
method is at the center of this book; the langua ge question has  just been mentioned. Once  
in a while we will need to see what support they may require fr om tools and libraries. For  
obvious reasons of con venience, such discussions will occasiona lly refer to ISE’s object-
oriented environment, with its se t of tools and as sociated libr aries.
The environment is use d  o n l y  a s  a n  e x a m p l e  o f  w h a t  c a n  b e  d o n e  to make the  
concepts practically usable by s oftware developers. Be sure to note that there are many  
other object-oriented environmen ts available, both for the nota tion of this book and for  
other O-O analysis, design and i mplementation me thods and notat ions; and that the  
descriptions given refer to the state of the environment at the  time of writing, subject, as  
anything else in our industry, to change quickly — for the bett er. Other environments, O-O
and non O-O, are also ci ted throughou t the text.“SEAMLESSNESS 
AND REVERSIBIL-ITY”, 28.6, page 930.
The last chapter, 36, 
summarizes the environment.
PREFACE xi
Acknowledgments (quasi-absence thereof)
The first edition of this book c ontained an already long list o f thanks. For a while I kept  
writing down the names of people  who contributed comments or su ggestions, and then at  
some stage I lost track. The ros ter of colleagues from whom I h ave had help or borrowed  
ideas has now grown so long that it would run over many pages, and would inevitably omit  
some important people . Better then offend everyone a little tha n offend a few very much.
So these acknowledgments will for the most part remain collecti ve, which does not  
make my gratitude less deep. My c olleagues at ISE  and SOL have for years been a daily  
source of invaluable help. The u sers of our tools have generous ly provided us with their  
advice. The readers of the first  edition provided thousands of suggestions for  
improvement. In the preparation of this new edition (I should r eally say of this new book)  
I have sent hundreds of e-mail me ssages asking for help of many  different kinds: the  
clarification of a fine point, a bibliographical reference, a p ermission to quo te, the details  
of an attribution, the origin of an idea, the specifics of a no tation, the offic ial address of a  
Web page; the answers have invariably been positive. As draft c hapters were becoming  
ready they were circulated through variou s means, prompting man y constructive  
comments (and here I must cite by  name the referees commissione d by Prentice Hall, Paul  
D u b o i s ,  J a m e s  M c K i m  a n d  R i c h a r d  W iener, who provided invaluable  advice and  
corrections). In the past few yea rs I have given countless semi nars, lectures  and courses  
about the topics of this book, and in every case I learned some thing from the audience. I  
enjoyed the wit of fellow paneli sts at conferences and benefite d from their wisdom. Short  
sabbaticals at the University of Technology, Sydney and the Uni versità degli Studi di  
Milano provided me with a influx of new ideas — and in the firs t case with three hundred  
first-year students on whom to va lidate some of my ideas about how software engineering  
should be taught.
The large bibliography shows cle arly enough how the ideas and r ealizations of others  
have contributed to this book. A mong the most important conscio us influences are the  
Algol line of languages, with its emphasis on syntactic and sem antic elegance; the seminal  
work on structured pro gramming, in the serio us (Dijkstra-Hoare- Parnas-Wirth-Mills-
Gries) sense of the term, and sy stematic program construction; formal specification  
techniques, in particu lar the inexhaustible lessons of Jean-Ray mond Abrial’s original (late  
nineteen-seventies) version of t he Z specification language, hi s more recent design of B,  
and Cliff Jones’s work on VDM; th e languages of the modular gen eration (in particular  
Ichbiah’s Ada, Liskov’s CLU, Sha w’s Alphard, Bert’s LPG and Wir th’s Modula); and  
Simula 67, which intro duced most of the concepts many years ago  and had most of them  
right, bringing to mind Tony Hoa re’s comment about Algol 60: th at it was such an  
improvement over most of its successors. A few notes in the 
margin or in chap-ter-end bib-liographic sections give credit for some specific ideas, often 
unpublished.

Foreword to the second edition
M any events have happened in the object-oriented world since the  f i r s t  e d i t i o n  o f  
OOSC  (as the book came to be known) was published in 1988. The expl osion of interest  
alluded to in the Preface to the  first edition, reproduced in t he preceding pages in a slightly  
expanded form, was nothing then as compared to what we have see n since. Many journals  
and conferences now cover object  technology; Prentice Hall has an entire book series  
devoted to the subject; breakthro ughs have occurred in such are as as user interfaces,  
concurrency and databases; entir e new topics have emerged, such  as O-O analysis and  
formal specification;  distributed computin g, once a specialized  topic, is becoming  
relevant to more and more devel opments, thanks in part to the g rowth of the Internet; and  
the Web is affecting everyone’s daily work.
This is not the only exciting ne ws. It is gratifying to see how  much progress is  
occurring in the software field — thanks in part to the incompl ete but undeniable spread  
of object technology. Too many b ooks and articles on software e ngineering still start with  
the obligatory lament about the “software crisis” and the pitif ul state of our industry as  
compared to true engineering discipline s (which, as we all know, never mess thi ngs up).  
There is no reason for such doom . Oh, we still have a long, lon g way to go, as anyone who  
uses software products knows all  too well. But given the challe nges that we face we have  
no reason to be ashamed of ourse lves as a profession; and we ar e getting better all the time.  
It is the ambition of this book, as it was of its predecessor, to help in this process.
This second edition is not an up date but the result of a thorou gh reworking. Not a  
paragraph of the original versio n has been left untouched. (Har dly a single line, actually.)  
Countless new topics have been ad ded, including a whole chapter  on concurrency,  
distribution, client-server comp uting and Internet programming;  another on persistence  
and databases; one on user interfaces; one  on the software life cycle; many design patterns  
and implementation techniques; a n in-depth exploration of a met hodological issue on  
which little is available in the  literature, how to use inherit ance well and avoid misusing  
it; discussions of many other t opics of object-oriented methodo logy; an extensive  
presentation of the theory of abs tract data types — the mathema tical basis for our subject,  
indispensable to a complete unde rstanding of object technology yet seldom covered in  
detail by textbooks and tutorials; a presentation of O-O analys is; hundreds of new  
bibliographic and Web site refer ences; the description of a com plete object-oriented  
development environment (also in cluded on the accompanying CD-R OM for the reader’s  
enjoyment) and of the u nderlying conc epts; and scores of new id eas, principles, caveats,  
explanations, figures, examples , comparisons, citations, classe s, routines.
The reactions to OOSC -1 have been so rewarding that I know readers have high  
expectations. I hope they will find OOSC -2 challenging, useful, and up to their standards.
Santa Barbara B.M.  
January 1997
PREFACE xiv
Acknowledgments : The preparation of the hyperl inked text was made possible by the help  
of several people at Adobe Inc., in particular Sandra Knox, Sar ah Rosenbaum and the  
FrameMaker Customer Support Group . Special thanks are due — for  the printed book as  
well as the CD — to Russ Hall and Eileen Clark of Prentice Hall .About the accompanying CD-ROM
The CD-ROM that comes with  this book contains the entire hyperlinked text  in Adobe  
Acrobat format. It also includes Adobe’s Acrobat Reader softwar e, enabling you to read  
that format; the versions provid ed cover major industry platfor ms. If you do not already  
have Acrobat Reader on your comput er, you can install it by fol lowing the instructions.  
The author and the publisher make no representations as to any property of Acrobat and  
associated tools; the Acrobat Reader is simply provided as a se rvice to readers of this  
book, and any Acrobat questions s hould be directed to Adobe. Yo u may also check with  
Adobe about any versions of the Reader that may have appeared a fter the book.
To get started with the CD-ROM, open the Acrobat file README.pdf  in the OOSC_2  
directory, which will direct you to the table of contents and t he index. You can only open  
that file under Acrobat Reader; if the Reader has not been inst alled on your computer,  
examine instead the plain-text version in the file readme.txt  in the top-level directory.  
The instructions a lso appear at the end of this book.
The presence of an electronic ve rsion will be particularly usef ul to readers who want to  
take advantage of the thousands of cross-referen ces present in this book (see “A Book-
Wide Web”, page viii ). Although for a first sequenti al reading you will probably pr efer 
to follow the paper version, hav ing the electronic form availab le on a computer next to  
the book alllows you to follow a  link once in a while without h aving to turn pages back  
and forth. The electronic form i s particularly convenient for a  later reading during which  
you may wish to explore li nks more systematically.
All links (cross-refer ences) appear in blue in the Acrobat form , as illustrated twice  
above (but not visible in the pr inted version). To follow a lin k, just click on the blue part.  
If the reference is to another chapter, the chapter will appear  in a new window. The  
Acrobat Reader command to come b ack to the previous position is  normally Control-
minus-sign (that is, type – while holding down the CONT ROL key). Consult the on-line  
Acrobat Reader documentation for  other useful na vigational comm ands.
Bibliographical references al so appear as links, such as [Knuth 1968] , in the Acrobat  
form, so that you can click on any of them to see the correspon ding entry in the  
bibliography of appendix E.
The CD-ROM also contains:
• Library components providing ex tensive material for Appendix A.
• A  c h a p t e r  f r o m  t h e  m a n u a l  f o r  a  g r a p h i c a l  a p p l i c a t i o n  b u i l d e r ,  providing  
mathematical complements t o the material of chapter 32.
In addition, the CD-ROM includes a time-limited version of an a dvanced object-
oriented development environment for Windows 95 or Windows NT, as described in  
chapter 36, providing an excellent hands-o n opportunity to try out the id eas developed  
throughout the book. Th e “Readme” file directs you to the insta llation instructions and  
system requirements.
On the bibliography, Internet sources and exercises
This book relies on earlier contributions by many authors. To f acilitate reading, the  
discussion of sources appears in  most cases not in the course o f the discussion, but in the  
“Bibliographical notes” sections  at chapter end. Make sure you read these sections, so as  
to understand the origin of many ideas and result s and find out  where to learn more. 
References are of the form [ Name  19xx], where Name  is the name of the first author,  
and refer to the bibliography in appendix E. This convention is for readability only and is  
not intended to underrate the role of authors other than the fi rst. The letter M in lieu of a  
Name denotes publications by the auth or of this book, listed separat ely in the second part  
of the bibli ography. 
Aside from the bibliography prop er, some references appear in t he margin, next to  
the paragraphs which cite them. The reason for this separate tr eatment is to make the  
bibliography usable by itself, as  a collection of important ref erences on object technology  
and related topics. Appearance a s a margin reference rather tha n in the bibliography does  
not imply any unfavorable judgme nt of value; the division is si m p l y  a  p r a g m a t i c  
assessment of what belongs in a core list of object-oriented re ferences. 
***
Although electronic re ferences will undoubtedly be considered a  matter of course a few  
years from now, this must be one  of the first technical books ( other than books devoted to  
Internet-related topics) to make  extensive use of references to  World-Wide-Web pages,  
Usenet newsgroups and other Internet resources.
Electronic addresses are notorious ly volatile. I have tried to obtain from the authors  
of the quoted sources some reassu rance that the addresses given  would remain valid for  
several years. Neither they nor I, of course, can provide an ab solute guarant ee. In case of  
difficulty, note that on the Net  more things move than disappea r: keyword-based search  
tools can help.
***
Most chapters include exercises of various degre es of difficult y. I have refrained from  
providing solutions, although ma ny exercises do contain fairly precise hints. Some readers  
may regret the absence of full s olutions; I hope, however, that  they will appreciate the  
three reasons that led to this d ecision: the fear of spoiling t he reader’s enjoyment; the  
realization that many exercises are design problems, for which there is more than one good  
answer; and the desire  to provide a source o f ready-made proble ms to instruct ors using this  
book as a text.
***
For brevity and simplicity, the text follows the imperfect but long-established tradition of  
using words such as “he” and “hi s”, in reference to unspecified  persons, as shortcuts for  
“he or she” and “his or her”, wit h no intended connotation of g ender.The bibliography 
starts on page 1203.
A modest soul is shocked by objects of such kind
And all the nasty thoughts that they bring to one's mind.
 
Molière, Tartuffe , Act III.
Contents
Preface v
Foreword to the second edition xiiiAbout the accompanying CD-ROM xiv
On the bibliography, Intern et sources and exercises xv
PART A:  T HE ISSUES 1
Chapter 1: Software quality  3
1.1  EXTERNAL AND INTERNAL FACTORS 3
1.2  A REVIEW OF EXTERNAL FACTORS 4
1.3  ABOUT SOFTWARE MAINTENANCE 171.4  KEY CONCEPTS INTRODUCED IN THIS CHAPTER 19
1.5  BIBLIOGRAPHICAL NOTES 19
Chapter 2: Criteria of object orientation  21
2.1  ON THE CRITERIA 21
2.2  METHOD AND LANGUAGE 222.3  IMPLEMENTATION AND ENVIRONMENT 31
2.4  LIBRARIES 33
2.5  FOR MORE SNEAK PREVIEW 342.6  BIBLIOGRAPHICAL NOTES  AND OBJECT RESOURCES 34
PART B:  T HE ROAD  TO OBJECT  ORIENTATION 37
Chapter 3: Modularity  39
3.1  FIVE CRITERIA 40
3.2  FIVE RULES 463.3  FIVE PRINCIPLES 533.4  KEY CONCEPTS INTRODUCED IN THIS CHAPTER 64
3.5  BIBLIOGRAPHICAL NOTES 64
EXERCISES 65
 CONTENTS xviii
Chapter 4: Approaches to reusability  67
4.1  THE GOALS OF REUSABILITY 68
4.2  WHAT SHOULD WE REUSE? 70
4.3  REPETITION IN SOFTWARE DEVELOPMENT 744.4  NON-TECHNICAL OBSTACLES 74
4.5  THE TECHNICAL PROBLEM 81
4.6  FIVE REQUIREMENTS ON MODULE STRUCTURES 834.7  TRADITIONAL MODULAR STRUCTURES 894.8  OVERLOADING AND GENERICITY 93
4.9  KEY CONCEPTS INTR ODUCED IN THIS CHAPTER 98
4.10  BIBLIOGRAPHICAL NOTES 99
Chapter 5: Towards object technology  101
5.1  THE INGREDIENTS OF COMPUTATION 1015.2  FUNCTIONAL DECOMPOSITION 103
5.3  OBJECT-BASED DECOMPOSITION 114
5.4  OBJECT-ORIENTED SOFTWARE CONSTRUCTION 116
5.5  ISSUES 1175.6  KEY CONCEPTS INTRODU CED IN THIS CHAPTER 119
5.7  BIBLIOGRAPHICAL NOTES 119
Chapter 6: Abstract data types  121
6.1  CRITERIA 122
6.2  IMPLEMENTATION VARIATIONS 122
6.3  TOWARDS AN ABSTRA CT VIEW OF OBJECTS 126
6.4  FORMALIZING THE SPECIFICATION 1296.5  FROM ABSTRACT DAT A TYPES TO CLASSES 142
6.6  BEYOND SOFTWARE 147
6.7  SUPPLEMENTARY TOPICS 1486.8  KEY CONCEPTS INTRODU CED IN THIS CHAPTER 159
6.9  BIBLIOGRAPHICAL NOTES 160
EXERCISES 161
PART C:  O BJECT -ORIENTED  TECHNIQUES 163
Chapter 7: The static structure: classes  165
7.1  OBJECTS ARE NOT THE SUBJECT 1657.2  AVOIDING THE ST ANDARD CONFUSION 166
7.3  THE ROLE OF CLASSES 1697.4  A UNIFORM TYPE SYSTEM 171
7.5  A SIMPLE CLASS 172
7.6  BASIC CONVENTIONS 177
CONTENTS xix
7.7  THE OBJECT-ORIENTED STYLE OF COMPUTATION 181
7.8  SELECTIVE EXPORTS A ND INFORMATION HIDING 191
7.9  PUTTING EVERYTHING TOGETHER 194
7.10  DISCUSSION 203
7.11  KEY CONCEPTS INTROD UCED IN THIS CHAPTER 213
7.12  BIBLIOGRAPHICAL NOTES 215
EXERCISES 216
Chapter 8: The run-time structure: objects  217
8.1  OBJECTS 218
8.2  OBJECTS AS A MODELING TOOL 228
8.3  MANIPULATING OBJECTS AND REFERENCES 2318.4  CREATION PROCEDURES 236
8.5  MORE ON REFERENCES 240
8.6  OPERATIONS ON REFERENCES 2428.7  COMPOSITE OBJECTS AND EXPANDED TYPES 254
8.8  ATTACHMENT: REFERENCE AND VALUE SEMANTICS 261
8.9  DEALING WITH REFERENCES: BENEFITS AND DANGERS 2658.10  DISCUSSION 270
8.11  KEY CONCEPTS INTROD UCED IN THIS CHAPTER 276
8.12  BIBLIOGRAPHICAL NOTES 277
EXERCISES 277
Chapter 9: Memory management  279
9.1  WHAT HAPPENS TO OBJECTS 2799.2  THE CASUAL APPROACH 291
9.3  RECLAIMING MEMORY: THE ISSUES 293
9.4  PROGRAMMER-CONTROLLED DEALLOCATION 294
9.5  THE COMPONENT-LEVEL APPROACH 297
9.6  AUTOMATIC MEMORY MANAGEMENT 3019.7  REFERENCE COUNTING 302
9.8  GARBAGE COLLECTION 304
9.9  PRACTICAL ISSUES OF GARBAGE COLLECTION 3099.10  AN ENVIRONMENT WITH MEMORY MANAGEMENT 312
9.11  KEY CONCEPTS INTROD UCED IN THIS CHAPTER 315
9.12  BIBLIOGRAPHICAL NOTES 315
EXERCISES 316
Chapter 10: Genericity  317
10.1  HORIZONTAL AND VERTI CAL TYPE GENERALIZATION 317
10.2  THE NEED FOR TYPE PARAMETERIZATION 318
10.3  GENERIC CLASSES 320
 CONTENTS xx
10.4  ARRAYS 325
10.5  THE COST OF GENERICITY 32810.6  DISCUSSION: NOT DONE YET 32910.7  KEY CONCEPTS INTRODUCED IN THIS CHAPTER 32910.8  BIBLIOGRAPHICAL NOTES 330
EXERCISES 330
Chapter 11: Design by Contract: building reliable software  331
11.1  BASIC RELIABIL ITY MECHANISMS 332
11.2  ABOUT SOFTWAR E CORRECTNESS 333
11.3  EXPRESSING A SPECIFICATION 33411.4  INTRODUCING ASSERTIONS INTO SOFTWARE TEXTS 33711.5  PRECONDITIONS AND POSTCONDITIONS 33811.6  CONTRACTING FOR SOFTWARE RELIABILITY 341
11.7  WORKING WITH ASSERTIONS 348
11.8  CLASS INVARIANTS 36311.9  WHEN IS A CLASS CORRECT? 36911.10  THE ADT CONNECTION 37311.11  AN ASSERTION INSTRUCTION 37811.12  LOOP INVARIANTS AND VARIANTS 38011.13  USING ASSERTIONS 38911.14  DISCUSSION 39811.15  KEY CONCEPTS INTRO DUCED IN THIS CHAPTER 406
11.16  BIBLIOGRAP HICAL NOTES 407
EXERCISES 408
E11.11  POSTSCRIPT: THE ARIANE 5 CRASH 410
Chapter 12: When the contract i s broken: exception handling  411
12.1  BASIC CONCEPTS OF EXCEPTION HANDLING 411
12.2  HANDLING EXCEPTIONS 414
12.3  AN EXCEPTION MECHANISM 41912.4  EXCEPTION HANDLING EXAMPLES 42212.5  THE TASK OF A RESCUE CLAUSE 42712.6  ADVANCED EXCEPTION HANDLING 43112.7  DISCUSSION 435
12.8  KEY CONCEPTS INTRODUCED IN THIS CHAPTER 437
12.9  BIBLIOGRAPHICAL NOTES 438
EXERCISES 438
Chapter 13: Supporting mechanisms  439
13.1  INTERFACING WITH NON-O-O SOFTWARE 439
13.2  ARGUMENT PASSING 44413.3  INSTRUCTIONS 447
CONTENTS xxi
13.4  EXPRESSIONS 452
13.5  STRINGS 45613.6  INPUT AND OUTPUT 45713.7  LEXICAL CONVENTIONS 45713.8  KEY CONCEPTS INTROD UCED IN THIS CHAPTER 458
EXERCISES 458
Chapter 14: Introduction to inheritance  459
14.1  POLYGONS AND RECTANGLES 460
14.2  POLYMORPHISM 46714.3  TYPING FOR INHERITANCE 47214.4  DYNAMIC BINDING 480
14.5  DEFERRED FEATURES AND CLASSES 482
14.6  REDECLARATION TECHNIQUES 49114.7  THE MEANING OF INHERITANCE 49414.8  THE ROLE OF DEFERRED CLASSES 50014.9  DISCUSSION 50714.10  KEY CONCEPTS INTRODUCED IN THIS CHAPTER 51614.11  BIBLIOGRAPHICAL NOTES 517
EXERCISES 517
Chapter 15: Multiple inheritance  519
15.1  EXAMPLES OF MULTIPLE INHERITANCE 51915.2  FEATURE RENAMING 535
15.3  FLATTENING THE STRUCTURE 541
15.4  REPEATED INHERITANCE 54315.5  DISCUSSION 56315.6  KEY CONCEPTS INTROD UCED IN THIS CHAPTER 566
15.7  BIBLIOGRAPHICAL NOTES 567
EXERCISES 567
Chapter 16: Inheritance techniques  569
16.1  INHERITANCE AND ASSERTIONS 56916.2  THE GLOBAL INHERITANCE STRUCTURE 58016.3  FROZEN FEATURES 583
16.4  CONSTRAINED GENERICITY 585
16.5  ASSIGNMENT ATTEMPT 59116.6  TYPING AND REDECLARATION 59516.7  ANCHORED DECLARATION 59816.8  INHERITANCE AND INFORMATION HIDING 60516.9  KEY CONCEPTS INTROD UCED IN THIS CHAPTER 609
16.10  BIBLIOGRAPHICAL NOTE 610
EXERCISES 610
 CONTENTS xxii
Chapter 17: Typing  611
17.1  THE TYPING PROBLEM 611
17.2  STATIC TYPING: WHY AND HOW 615
17.3  COVARIANCE AND DESCENDANT HIDING 621
17.4  FIRST APPROACHES TO SYSTEM VALIDITY 62817.5  RELYING ON ANCHORED TYPES 630
17.6  GLOBAL ANALYSIS 633
17.7  BEWARE OF POLY MORPHIC CATCALLS! 636
17.8  AN ASSESSMENT 639
17.9  THE PERFECT FIT 640
17.10  KEY CONCEPTS STUDIED IN THIS CHAPTER 64117.11  BIBLIOGRAP HICAL NOTES 641
Chapter 18: Global objects and constants  643
18.1  CONSTANTS OF BASIC TYPES 643
18.2  USE OF CONSTANTS 64518.3  CONSTANTS OF CLASS TYPES 646
18.4  APPLICATIONS OF ONCE ROUTINES 648
18.5  CONSTANTS OF STRING TYPE 65318.6  UNIQUE VALUES 654
18.7  DISCUSSION 656
18.8  KEY CONCEPTS INTRODUCED IN THIS CHAPTER 65918.9  BIBLIOGRAPHICAL NOTES 660
EXERCISES 660
PART D:  O BJECT -ORIENTED  METHODOLOGY : APPLYING  
THE METHOD  WELL 661
Chapter 19: On methodology  663
19.1  SOFTWARE METHODOLOGY: WHY AND WHAT 66319.2  DEVISING GOOD RULES: ADVICE TO THE ADVISORS 664
19.3  ON USING METAPHORS 671
19.4  THE IMPORTANCE OF BEING HUMBLE 67319.5  BIBLIOGRAPHICAL NOTES 674
EXERCISES 674
Chapter 20: Design pattern: mu lti-panel interactive systems  675
20.1  MULTI-PANEL SYSTEMS 675
20.2  A SIMPLE-MINDED ATTEMPT 67720.3  A FUNCTIONAL, TOP-DOWN SOLUTION 678
20.4  A CRITIQUE OF THE SOLUTION 682
20.5  AN OBJECT-ORIENTED ARCHITECTURE 684
20.6  DISCUSSION 693
20.7  BIBLIOGRAPHICAL NOTE 694
CONTENTS xxiii
Chapter 21: Inheritance case study:  “undo” in an interactive  
   system 695
21.1  PERSEVERARE DIABOLICUM 695
21.2  FINDING THE ABSTRACTIONS 69921.3  MULTI-LEVEL UNDO-REDO 70421.4  IMPLEMENTATION ASPECTS 707
21.5  A USER INTERFACE FOR UNDOING AND REDOING 711
21.6  DISCUSSION 71221.7  BIBLIOGRAPHICAL NOTES 715
EXERCISES 715
Chapter 22: How to find the classes  719
22.1  STUDYING A REQUIREMENTS DOCUMENT 720
22.2  DANGER SIGNALS 726
22.3  GENERAL HEURISTICS FOR FINDING CLASSES 73122.4  OTHER SOURCES OF CLASSES 73522.5  REUSE 74022.6  THE METHOD FOR OBTAINING CLASSES 74122.7  KEY CONCEPTS INTROD UCED IN THIS CHAPTER 743
22.8  BIBLIOGRAPHICAL NOTES 744
Chapter 23: Principles of class design  747
23.1  SIDE EFFECTS IN FUNCTIONS 74823.2  HOW MANY ARGUMENTS FOR A FEATURE? 764
23.3  CLASS SIZE: THE SHOPPING LIST APPROACH 77023.4  ACTIVE DATA STRUCTURES 77423.5  SELECTIVE EXPORTS 79623.6  DEALING WITH ABNORMAL CASES 79723.7  CLASS EVOLUTION: THE OBSOLETE CLAUSE 80223.8  DOCUMENTING A CLASS AND A SYSTEM 803
23.9  KEY CONCEPTS INTROD UCED IN THIS CHAPTER 806
23.10  BIBLIOGRAPHICAL NOTES 806
EXERCISES 807
Chapter 24: Using inheritance well  809
24.1  HOW NOT TO USE INHERITANCE 809
24.2  WOULD YOU RATHER BUY OR INHERIT? 812
24.3  AN APPLICATION: THE HANDLE TECHNIQUE 81724.4  TAXOMANIA 82024.5  USING INHERITANCE: A  TAXONOMY OF TAXONOMY 822
24.6  ONE MECHANISM, OR MORE? 833
 CONTENTS xxiv
24.7  SUBTYPE INHERITANCE AND DESCENDANT HIDING 835
24.8  IMPLEMENTATION INHERITANCE 84424.9  FACILITY INHERITANCE 84724.10  MULTIPLE CRITERIA  AND VIEW IN HERITANCE 851
24.11  HOW TO DEVELOP INHERITANCE STRUCTURES 858
24.12  A SUMMARY VIEW: U SING INHERITANCE WELL 862
24.13  KEY CONCEPTS INTRO DUCED IN THIS CHAPTER 863
24.14  BIBLIOGRAP HICAL NOTES 863
24.15  APPENDIX: A HIS TORY OF TAXONOMY 864
EXERCISES 869
Chapter 25: Useful techniques  871
25.1  DESIGN PHILOSOPHY 871
25.2  CLASSES 872
25.3  INHERITANCE TECHNIQUES 873
Chapter 26: A sense of style  875
26.1  COSMETICS MATTERS! 875
26.2  CHOOSING THE RIGHT NAMES 87926.3  USING CONSTANTS 884
26.4  HEADER COMMENTS AND NOTE CLAUSES 886
26.5  TEXT LAYOUT AND PRESENTATION 89126.6  FONTS 900
26.7  BIBLIOGRAPHICAL NOTES 902
EXERCISES 902
Chapter 27: Object-oriented analysis  903
27.1  THE GOALS OF ANALYSIS 903
27.2  THE CHANGING NATURE OF ANALYSIS 90627.3  THE CONTRIBUTION OF OBJECT TECHNOLOGY 907
27.4  PROGRAMMING A TV STATION 907
27.5  EXPRESSING THE ANALYSIS: MULTIPLE VIEWS 91427.6  ANALYSIS METHODS 917
27.7  THE BUSINESS OBJECT NOTATION 919
27.8  BIBLIOGRAPHY 922
Chapter 28: The software construction process  923
28.1  CLUSTERS 92328.2  CONCURRENT  ENGINEERING 924
28.3  STEPS AND TASKS 926
28.4  THE CLUSTER MODEL OF THE SOFTWARE LIFECYCLE 92628.5  GENERALIZATION 928
CONTENTS xxv
28.6  SEAMLESSNESS AND REVERSIBILITY 930
28.7  WITH US, EVERYTHING IS THE FACE 93328.8  KEY CONCEPTS COVE RED IN THIS CHAPTER 934
28.9  BIBLIOGRAPHICAL NOTES 934
Chapter 29: Teaching the method  935
29.1  INDUSTRIAL TRAINING 935
29.2  INTRODUCTORY COURSES 93729.3  OTHER COURSES 940
29.4  TOWARDS A NEW SOFTWARE PEDAGOGY 942
29.5  AN OBJECT-ORIENTED PLAN 94629.6  KEY CONCEPTS STUDIED IN THIS CHAPTER 947
29.7  BIBLIOGRAPHICAL NOTES 948
PART E:  A DVANCED  TOPICS 949
Chapter 30: Concurrency, distribut ion, client-server and the 
Internet  951
30.1  A SNEAK PREVIEW 951
30.2  THE RISE OF CONCURRENCY 953
30.3  FROM PROCESSES TO OBJECTS 956
30.4  INTRODUCING CONCURRENT EXECUTION 96430.5  SYNCHRONIZATION ISSUES 977
30.6  ACCESSING SEPARATE OBJECTS 982
30.7  WAIT CONDITIONS 99030.8  REQUESTING SPECIAL SERVICE 998
30.9  EXAMPLES 1003
30.10  TOWARDS A PROOF RULE 102230.11  A SUMMARY OF THE MECHANISM 102530.12  DISCUSSION 1028
30.13  KEY CONCEPTS INTRODUCED IN THIS CHAPTER 1032
30.14  BIBLIOGRAPHICAL NOTES 1033
EXERCISES 1035
Chapter 31:  Object persis tence and databases  1037
31.1  PERSISTENCE FROM THE LANGUAGE 1037
31.2  BEYOND PERSISTENCE CLOSURE 1039
31.3  SCHEMA EVOLUTION 104131.4  FROM PERSISTENCE TO DATABASES 1047
31.5  OBJECT-RELATIONAL INTEROPERABILITY 1048
31.6  OBJECT-ORIENTED DA TABASE FUNDAMENTALS 1050
31.7  O-O DATABASE SYSTEMS: EXAMPLES 1055
 CONTENTS xxvi
31.8  DISCUSSION: BEYOND O-O DATABASES 1058
31.9  KEY CONCEPTS STUDIED IN THIS CHAPTER 106031.10  BIBLIOGRAP HICAL NOTES 1061
EXERCISES 1062
Chapter 32: Some O-O techniques for graphical interactive 
applications  1063
32.1  NEEDED TOOLS 1064
32.2  PORTABILITY AND PLATFORM ADAPTATION 106632.3  GRAPHICAL ABSTRACTIONS 106832.4  INTERACTION MECHANISMS 107132.5  HANDLING THE EVENTS 107232.6  A MATHEMATICAL MODEL 107632.7  BIBLIOGRAPHICAL NOTES 1076
PART F:  A PPLYING  THE METHOD  IN VARIOUS  
LANGUAGES  AND ENVIRONMENTS 1077
Chapter 33: O-O programming and Ada  1079
33.1  A BIT OF CONTEXT 107933.2  PACKAGES 108133.3  A STACK IMPLEMENTATION 108133.4  HIDING THE REPRESENTATION: THE PRIVATE STORY 108533.5  EXCEPTIONS 108833.6  TASKS 109133.7  FROM ADA TO ADA 95 109233.8  KEY CONCEPTS INTRODUCED IN THIS CHAPTER 109733.9  BIBLIOGRAPHICAL NOTES 1097
EXERCISES 1098
Chapter 34: Emulating object tec hnology in non-O-O environments  
1099
34.1  LEVELS OF LANGUAGE SUPPORT 1099
34.2  OBJECT-ORIENTED PROGRAMMING IN PASCAL? 110034.3  FORTRAN 110234.4  OBJECT-ORIENTED PROGRAMMING AND C 110634.5  BIBLIOGRAPHICAL NOTES 1112
EXERCISES 1112
Chapter 35: Simula to Java and be yond: major O-O languages and 
environments  1113
35.1  SIMULA 1113
35.2  SMALLTALK 1126
CONTENTS xxvii
35.3  LISP EXTENSIONS 1130
35.4  C EXTENSIONS 1131
35.5  JAVA 113635.6  OTHER O-O LANGUAGES 113735.7  BIBLIOGRAPHICAL NOTES 1138
EXERCISES 1139
PART G:  D OING  IT RIGHT 1141
Chapter 36:  An object-oriented environment  1143
36.1  COMPONENTS 1143
36.2  THE LANGUAGE 1144
36.3  THE COMPILATION TECHNOLOGY 114436.4  TOOLS 114836.5  LIBRARIES 1150
36.6  INTERFACE MECHANISMS 1152
36.7  BIBLIOGRAPHICAL NOTES 1160
Epilogue, In Full Frankness Exposing the Language 1161
PART H:  A PPENDICES 1163
Appendix A: Extracts fro m the Base libraries 1165
Appendix B: Genericity versus inheritance 1167
B.1  GENERICITY 1168
B.2  INHERITANCE 1173
B.3  EMULATING INHERITANCE WITH GENERICITY 1175
B.4  EMULATING GENERICITY WITH INHERITANCE 1176B.5  COMBINING GENERICITY AND INHERITANCE 1184B.6  KEY CONCEPTS INTRODUCED IN THIS APPENDIX 1187
B.7  BIBLIOGRAPHICAL NOTES 1188
EXERCISES 1188
Appendix C: Principles, rule s, precepts and definitions 1189
Appendix D: A glossary o f object technology 1193
Appendix E: Bibliography 1203
E.1  WORKS BY OTHER AUTHORS 1203
E.2  WORKS BY THE AUTHOR OF THE PRESENT BOOK 1221
Index 1225

Part A: 
The issues
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
Part A will define the goals of our  search by taking a close lo ok at the notion of software  
quality, and, for readers who do not fear a spoiler, provide a ca psule preview of the  
highlights of object technology.
1  
Software quality
E  ngineering seeks quality; softwar e engineering is the productio n of quality software.  
This book introdu ces a set of techniques which hold the potenti al for remarkable  
improvements in the qualit y of software products. 
Before studying these techniques , we must clarify their goals. Software quality is  
best described as a combination of several factors. This chapte r analyzes some of these  
factors, shows where improvement s are most sorely needed, and p oints to the directions  
where we shall be looking for so lutions in the rest of our jour ney. 
1.1  EXTERNAL AND INTERNAL FACTORS 
W e  a l l  w a n t  o u r  s o f t w a r e  s y s t e m s  t o  b e  f a s t ,  r e l i a b l e ,  e a s y  t o  use, readable, modular,  
structured and so on. But these a djectives describe two differe nt sorts of qualities.
On one side, we are considering s u c h  q u a l i t i e s  a s  s p e e d  o r  e a s e  o f  u s e ,  w h o s e  
presence or absence in a softwar e product may be detected by it s users. These properties  
may be called external  quality factors.
Under “users” we should include not only the people who actuall y interact with the final  
products, like an airline agent using a flight reservation syst em, but also those who  
purchase the software or contract out its development, like an airline executive in charge  
of acquiring or commissioning flight reservation systems. So a property such as the ease  
with which the software may be adapted to changes of specificat ions — defined later in  
this discussion as extendibility — falls into the category of external factors even though  
it may not be of immediate interest to such “end users” as the reservations agent.
Other qualities applicable to a software product, such as being  modular, or readable,  
are internal  factors, perceptible only to co mputer professi onals who have a ccess to the  
actual softw are text. 
I n  t h e  e n d ,  o n l y  e x t e r n a l  f a c t o r s  m a t t e r .  I f  I  u s e  a  W e b  b r o w s e r or live near a  
computer-controlled nuclear pla nt, little do I care whether the  source program is readable  
or modular if graphics take ages to load, or if a wrong input b lows up the plant. But the  
key to achieving these external factors is in the internal ones : for the users to enjoy the  
visible qualities, the designers  and implementers must have app lied internal techniques  
that will ensure the  hidden qualities. 
SOFTWARE QUALITY  §1.2 4
The following chapters present o f a set of modern techniques fo r obtaining internal  
quality. We should not, however, lose track of the global pictu re; the internal techniques  
are not an end in themselves, bu t a means to reach external sof tware qualities. So we must  
start by looking at external fac tors. The rest of this chapter examines them.
1.2  A REVIEW OF EXTERNAL FACTORS 
Here are the most important exte rnal quality fac tors, whose pur suit is the central task of  
object-oriented software construction.
Correctness
Correctness is the prime quality.  If a system does not do what it is supposed to do,  
everything else about it — whethe r it is fast, has a nice user interface … — matters little. 
But this is easier said than don e. Even the first step to corre ctness is already difficult:  
we must be able to specify the s ystem requirements in a precise  form, by itself quite a  
challenging task. 
Methods for ensuring correctness will usually be conditional . A serious software  
system, even a small one by today’s standards, touches on so ma ny areas that it would be  
impossible to guarantee its corre ctness by dealing with all com ponents and properties on  
a single level. Instead, a layer ed approach is ne cessary, each layer relying on lower ones:
In the conditional approach to correctness, we only worry about  guaranteeing that  
each layer is correct on the assumption that the lower levels are correct. This is the only  
realistic technique, as it achieves separation of concerns and lets us concentrate at each  
stage on a limited set of problems. You cannot usefully check t hat a program in a high-level  
language X is correct unless you are able to assume that the co mpiler on hand implements  
X correctly. This does not neces sarily mean that you trust the compiler blindly, simply that  
you separate the two components of the problem: compiler correc tness, and correctness of  
your program relative to the language’s semantics. 
In the method described in this book, even more layers interven e: software  
development will rely on librarie s of reusable co mponents, whic h may be used in many  
different applications.Definition: correctness
Correctness is the abil ity of software products to perform thei r exact tasks,  
as defined by their specification. 
Layers in 
software 
developmentApplication system
Compiler  
Operating System
Hardware  
§1.2   A REVIEW OF EXTERNAL FACTORS 5
The conditional approach will al so apply here: we should ensure  that the libraries are  
correct and, separately, that th e application is correct assumi ng the libraries are.
Many practitioners, when present ed with the issue of software c orrectness, think  
about testing and debugging. We can be more ambitious: in later  chapters we will explore  
a number of techniques, in particular typing and assertions, me ant to help build software  
that is correct from the start — rather than debu gging it into correctness. Debugging and  
testing remain indispe nsable, of cour se, as a means of double-c hecking the result. 
It is possible to go further and t a k e  a  c o m p l e t e l y  f o r m a l  a p p r o ach to software  
construction. This book falls sh ort of such a goal, as suggeste d by the somewhat timid  
terms “check”, “guarantee” and “e nsure” used above in preferenc e to the word “prove”.  
Yet many of the techniques described in later chapters come dir ectly from the work on  
mathematical techniques for form al program specification and ve rification, and go a long  
way towards ensuring t he correctness ideal. 
Robustness
Robustness complements correctne ss. Correctness addresses the b ehavior of a system in  
cases covered by its specifica tion; robustness characterizes wh at happens outside of  
that specification. Definition: robustness
Robustness is the ability of sof tware systems to react appropri ately to  
abnormal conditions. Application system
Application library 
Operating System… More libraries …
Base library
Kernel library
Hardware  CompilerLayers in a 
development 
process that 
includes reuse
Robustness 
versus 
correctnessSPECIFICATION
Correctness
Robustness
SOFTWARE QUALITY  §1.2 6
As reflected by the wording of its definition, robustness is by  nature a more fuzzy  
notion than correctness. Since we  are concerned here with cases  not covered by the  
specification, it is not possible to say, as with correctness, that the system should “perform  
its tasks” in such a case; were these tasks known, the abnormal  case would become part  
of the specification and we would  be back in the province of co rrectness.
This definition of “abnormal case” will be useful again when we  study exception  
handling. It implies that the notions of normal and abnormal ca se are always relative to a  
certain specification; an abnormal case is simply a case that i s not covered by the  
specification. If you widen the specification, cases that used to be abnormal become  
normal — even if they correspond to events such as erroneous us er input that you would  
prefer not to happen. “Normal” in this sense does not mean “des irable”, but simply  
“planned for in the design of the software”. Although it may se em paradoxical at first that  
erroneous input should be called a normal case, any other appro ach would have to rely on  
subjective criteria, and so would be useless.
There will always be cases that the specification does not expl icitly address. The role  
of the robustness requirement is to make sure that if such case s do arise, the system does  
not cause catastrophic events; it should pr oduce appropriate er ror messages, terminate its  
execution cleanly, or e nter a so-called “gra ceful degradation” mode. 
Extendibility
Software is supposed to be soft, and indeed is in principle; nothing can be easier than to  
change a program if you have acc ess to its source code. Just us e your favorite text editor. 
The problem of extendibility is one of scale. For small program s change is usually  
not a difficult issue; but as so ftware grows bigge r, it becomes  harder and ha rder to adapt.  
A large software system often looks to its maintainers as a gia nt house of cards in which  
pulling out any one ele ment might cause the  whole edifice to co llapse. 
We need extendibility b ecause at the basis of all software lies  some human  
phenomenon and hence fickleness. The obvious case of business s oftware (“Management  
Information Systems”), where passage of a law or a company’s ac quisition may suddenly  
invalidate the assumpt ions on which a system  r e st ed , i s no t s pe cial; even in scientific  
computation, where we may expect the laws of physics to stay in  place from one month to  
the next, our way of understanding and modeling physical system s will change.
Traditional approaches to softwa r e  e n g i n e e r i n g  d i d  n o t  t a k e  e n o ugh account of  
change, relying instead on an id eal view of the software lifecy cle where an initial analysis  
stage freezes the requirements, the rest of the process being d evoted to designing and  
building a solution. This is understandable: the first task in the progress of the discipline  
was to develop sound te chniques for stating  and solvi ng fixed p roblems, before we could  
worry about what to do if the pr oblem changes while someone is busy solving it. But now  Definition: extendibility
Extendibility is the ease of adap ting software products to chan ges of  
specification. On exception 
handling see chapter 12 .
§1.2   A REVIEW OF EXTERNAL FACTORS 7
with the basic software engineer ing techniques in place it has become essential to  
recognize and ad dress this central issue. Change is pervasive i n software development:  
change of requirements, of our u nderstanding of the requirement s, of algorithms, of data  
representation, of implementatio n techniques. Su pport for chang e is a basic goal of object  
technology and a running t heme through this book.
Although many of the techniques that improve extendibility may be introduced on  
small examples or in introductory  courses, their relevance only  becomes clear for larger  
projects. Two principl es are essential for i mproving extendibil ity: 
•Design simplicity : a simple architecture will alw ays be easier to adapt to chang es 
than a complex one. 
•Decentralization : the more autonomous the modules,  the higher the likelihood th at 
a simple change will affect just o ne module, or a small number of modules, rather  
than triggering off a chain reac tion of changes over the whole system. 
The object-oriented method is, b efore anything else, a system a rchitecture method  
which helps designers produce sys tems whose structure remains b oth simple (even for  
large systems) and decentralized . Simplicity and decentralizati on will be recurring themes  
in the discussions l eading to object -oriented princ iples in the  following chapters.
Reusability
The need for reusability comes f rom the observation that softwa re systems often follow  
similar patterns; it should be possible to exploit this commona lity and avoid reinventing  
solutions to problems that have been encountered before. By cap turing such a pattern, a  
reusable software element will b e applicable to many different developments.
Reusability has an influence on all other aspect s of software q uality, for solving the  
reusability problem es sentially means that less software must b e written, and hence that  
more effort may be devoted (for the same total cost) to improvi ng the other factors, such  
as correctness a nd robustness.
Here again is an issue that the traditional view of the softwar e lifecycle had not  
properly recognized, an d for the same histo rical reason: you mu st find ways to solve one  
problem before you worry about ap plying the solution to other p roblems. But with the  
growth of software and its attem pts to become a true industry t he need for reusability has  
become a pressing concern.
Reusability will play a central role in the disc ussions of the following chapters, one  
of which is in fact devoted entir ely to an in-depth examination  of this quality factor, its  
concrete benefits, and t he issues it raises. Definition: reusability
Reusability is the ability of software elements to serve for th e construction  
of many different applications.
Chapter 4 .
SOFTWARE QUALITY  §1.2 8
Compatibility 
Compatibility is important because we do not develop software e lements in a vacuum:  
they need to interact with each o ther. But they too often have trouble interacting because  
they make conflicting assumption s about the rest of the world. An example is the wide  
variety of incompatible file for mats supported by many operatin g systems. A program can  
directly use another’s result as i nput only if the file formats  are compatible. 
Lack of compatibility can yield disaster. Here is an extreme ca se:
DALLAS — Last week , AMR , the parent company of American Airlines , Inc., said it fell  
on its sword trying to develop a state-of-the-art , industry-wide system that could also  
handle car and hotel reservations .
AMR cut off development of its new Confirm re servation system only weeks after it was  
supposed to start taking care of transactions for partners Budget Rent-A-Car , Hilton  
Hotels Corp . and Marriott Corp . Suspension of the $125 million , 4-year-old project  
translated into a $165 million pre-tax charge against AMR’s earnings and fractured the  
company’s reputation as a pacesetter in travel technology . […]
As far back as January , the leaders of Confirm discovered that the labors of more than  
200 programmers , systems analysts and engineers had apparently been for naught . The 
main pieces of the massive project — requiring 47 ,000 pages to describe — had been  
developed separately , by different methods . When put together , they did not work with  
each other . When the developers attempted to plug the parts together , they could not .
Different “modules” could not pull the information needed from the other side of the  
bridge .
AMR Information Services fired eight senior project members , including the team leader.  
[…] In late June , Budget and Hilton said they were dropping out .
The key to compatibility lies in  homogeneity of design, and in agreeing on  
standardized con ventions for inter-program communication. Appro aches include: 
• Standardized file formats, as in the Unix system, where every text file is simply a  
sequence of characters. 
• Standardized data structures, as in Lisp systems, where all da ta, and programs as  
well, are represented by binary trees (call ed lists in Lisp). 
• Standardized user interfaces, as on various versions of Window s, OS/2 and MacOS,  
where all tools rely on a single paradigm for communication wit h the user, based on  
standard components such as windows, icons, menus etc. 
More general solutions are obtai ned by defining standardized ac cess protocols to all  
important entities manipulated b y the software. This is the ide a behind abstract data types  
and the object-oriented appro ach, as well as so-called middleware protocols such as  
CORBA and Microsoft’ s OLE-COM (ActiveX).Definition: compatibility
Compatibility is the ease of com bining software elements with o thers. 
San Jose (Calif .) 
Mercury News , July 
20, 1992 . Quoted in 
the “comp    risks” 
Usenet newsgroup , 
13.67, July 1992 . 
Slightly abridged .
On abstract data 
types see chapter 6 .
§1.2   A REVIEW OF EXTERNAL FACTORS 9
Efficiency
Almost synonymous with efficiency  is the word “performance”. Th e software community  
shows two typical attitu des towards efficiency: 
• Some developers have an obsession with performance issues, lea ding them to devote  
a lot of efforts to pr esumed optimizations. 
• But a general tendency also exists to downplay efficiency conc erns, as evidenced by  
s u c h  i n d u s t r y  l o r e  a s  “ m a k e  i t  r i g h t  b e f o r e  y o u  m a k e  i t  f a s t ”  a nd “next year’s  
computer model is going to  be 50% faster anyway”. 
It is not uncommon to see the sam e person displaying these two attitudes at different  
times, as in a softwar e case of split personality (Dr. Abstract  and Mr. Microsecond). 
Where is the truth? Clearly, deve lopers have ofte n shown an exa ggerated concern for  
micro-optimization. As already n oted, efficiency does not matte r much if the software is  
not correct (suggest ing a new dictum, “ do not worry how fast it is unless it is also right  ”,  
close to the previous one but no t  q u i t e  t h e  s a m e ) .  M o r e  g e n e r a l ly, the concern for  
efficiency must be balanced with other goals such as extendibil ity and reusability; extreme  
optimizations may make the softw are so specialized as to be unf it for change and reuse.  
Furthermore, the ever growing po wer of computer hardware does a llow us to have a more  
relaxed attitude about gaining  the last byte or  microsecond. 
All this, however, does not dimin ish the importance of efficien cy . No one likes to  
wait for the responses of an inte ractive system, or to have to purchase more memory to run  
a program. So offhand attitudes to performance i nclude much pos turing; if the final system  
is so slow or bulky as to impede  usage, those who used to decla re that “speed is not that  
important” will not be the last to complain. 
This issue reflects what I belie ve to be a major characteristic  of software engineering,  
not likely to move away soon: so ftware construction is difficul t precisely because it  
requires taking into account ma ny different requirements, some of which, such as  
correctness, are abstract and co nceptual, whereas others, such as efficiency, are concrete  
and bound to the properti es of computer hardware.
For some scientists, software development is a branch of mathem atics; for some  
engineers, it is a branch of app lied technology. In reality, it  is both. The software developer  
must reconcile the abstract concepts with their concrete implem entations, the mathematics  
of correct computation with the t ime and space constraints deri ving from physical laws  
and from limitations of current h ardware technology. This need to please the angels as well  
as the beasts may be the centra l challenge of software engineer ing.Definition: efficiency
Efficiency is the ability of a software system to place as few demands as  
possible on hardware resources, such as processor time, space o ccupied in  
internal and external memories, b andwidth used in  communication  devices.
SOFTWARE QUALITY  §1.2 10
The constant improvement in comp uter power, impressive as it is , is not an excuse  
for overlooking effic iency, for at leas t three reasons: 
• Someone who purchases a bigger and faster computer wants to se e some actual  
benefit from the extra power — t o handle new problems, process previous problems  
faster, or process bigger versi ons of the previous problems in the same amount of  
time. Using the new computer to process the previous problems i n the same amount  
of time will not do! 
• One of the most visible effects of advances in computer power is actually to increase
the lead of good algorithms over bad ones. Assume that a new ma chine is twice as  
fast as the previous one. Let n be the size of the problem to solve, and N the maximum  
n that can be handled by a certain algorithm in a given time. The n if the algorithm is  
in O (n), that is to say, runs in a time proportional to n, the new machine will enable  
you to handle problem sizes of about 2 ∗ N for large N. For an algorithm in O  (n2) the 
new machine will only yield a 41% increase of N. An algorithm in O ( 2 n), similar to  
certain combinatorial, exhaustive-search algorithms, would just  add one to N — not  
much of an improvement for your money.
• In some cases efficiency may affect correctness. A specificati on may state that the  
computer response to a certain event must occur no later than a  specified time; for  
example, an in-flight computer must be prepared to detect and p rocess a message  
from the throttle sensor fast enough to take corrective action.  This connection  
between efficiency and correctness is not restricted to applica tions commonly  
thought of as “real time”; few pe ople are interested in a weath er forecasting model  
that takes twenty-four  hours to predict the  next day’s weather.
Another example, although perhaps less critical, has been of fr equent annoyance to me:  
a window management system that I used for a while was sometime s too slow to detect  
that the mouse cursor had moved from a window to another, so th at characters typed at  
the keyboard, meant for a cert ain window, would occasionally en d up in another.
In this case a performance limitation causes a violation of the  specification, that is to say  
of correctness, which even in seemingly innocuous everyday appl ications can cause nasty  
consequences: think of what can happen if the two windows are u sed to send electronic  
mail messages to two different correspondents. For less than th is marriages have been  
broken, even wars started. 
Because this book is focused on the concepts of object-oriented  software engineering,  
not on implementation issues, only a few sections deal explicit ly with the associated  
performance costs. But the concer n for efficiency will be there  throughout. Whenever the  
discussion presents an object-oriented solution to some problem , it will make sure that the  
solution is not just elegant but also efficient; whenever it in troduces some new O-O  
mechanism, be it garbage collection (and other approaches to me mory management for  
object-oriented computation), dy namic binding, genericity or re peated inheritance, it will do  
so based on the knowledge that the mechanism may be implemented  at a reason able cost in  
time and in space; and whenever appropriate it will mention the  performance consequences  
of the techniques studied.
§1.2   A REVIEW OF EXTERNAL FACTORS 11
Efficiency is only one of the f actors of quality; we should not  (like some in the  
profession) let it rule our engi n e e r i n g  l i v e s .  B u t  i t  i s  a  f a c t or, and must be taken into  
consideration, whether in the co nstruction of a software system  o r  i n  t h e  d e s i g n  o f  a  
programming language. I f you dismiss performance, performance w ill dismiss you.
Portability  
Portability addresses variations not just of the physical hardw are but more generally of the  
hardware-software machine , the one that we really program, which includes the  
operating system, the window system if applicable, and other fu ndamental tools. In the  
rest of this book the word “platform” will be used to denote a type of hardware-software  
machine; an example of  platform is “Intel X 86 with Windows NT” (known as “Wintel”).
Many of the existing platform incompatibilities are unjustified , and to a naïve  
observer the only explanation so metimes seems to be a conspirac y to victimize humanity  
in general and programmers in pa rticular. Whatever its causes, however, this diversity  
makes portability a major concer n for both developers and users  of software. 
Ease of use
The definition insists on the va rious levels of expertise of po tential users. This requirement  
poses one of the major challenge s to software designers preoccu pied with ease of use: how  
to provide detailed guidance and explanations to novice users, without bothering expert  
users who just want to get right down to business. 
As with many of the ot her qualities discusse d in this chapter, one of the keys to ease  
of use is structural simplicity .  A well-designed system, built according to a clear, well  
thought-out structure, will tend  t o  b e  e a s i e r  t o  l e a r n  a n d  u s e  t h a n  a  m e s s y  o n e .  T h e  
condition is not sufficient, of course (what is simple and clea r to the designer may be  
difficult and obscure to users, especially if explained in desi gner’s rather than user’s  
terms), but it help s considerably. 
This is one of the areas where the object-oriented method is pa rticularly productive;  
many O-O techniques, which appear  at first to address design an d implementation, also  
yield powerful new interface ideas  that help the end users. Lat er chapters will introduce  
several examples. Definition: portability
Portability is the ease of trans ferring software products to va rious hardware  
and software environments. 
Definition: ease of use
E a s e  o f  u s e  i s  t h e  e a s e  w i t h  w h i c h  p e o p l e  o f  v a r i o u s  b a c k g r o u n d s and 
qualifications can learn to use software products and apply the m to solve  
problems. It also covers the ease of installation, operation an d monitoring. 
SOFTWARE QUALITY  §1.2 12
Software designers pre occupied with ease of use will also be we ll-advised to  
consider with some mistrust the p recept most frequently quoted in the user interface  
literature, from an early article by Hansen: know the user . The argument is that a good  
designer must make an effort to understand the system’s intende d user community. This  
view ignores one of the features  of successful systems: they al ways outgrow their initial  
audience. (Two old and famous ex amples are Fortran, conceived a s a tool to solve the  
problem of the small community of engineers and scientists prog ramming the IBM 704,  
and Unix, meant for internal use  at Bell Laboratories.) A syste m designed for a specific  
group will rely on assumptions th at simply do not hold for a la rger audience. 
Good user interface designers follow a more prudent policy. The y make as limited  
assumptions about their users as they can. When you design an i nteractive system, you  
may expect that users are member s of the human race and that th ey can read, move a  
m o u s e ,  c l i c k  a  b u t t o n ,  a n d  t y p e  (slowly); not much more. If the  software addresses a  
specialized application area, you may perhaps assume that your users are familiar with its  
basic concepts. But even  that is risky. To r everse-paraphrase H ansen’s advice:
Functionality
O n e  o f  t h e  m o s t  d i f f i c u l t  p r o b l e m s  f a c i n g  a  p r o j e c t  l e a d e r  i s  t o know how much  
functionality is enough. The pre ssure for more facilities, know n in industry parlance as  
featurism (often “ creeping featurism ”), is constantly there. Its consequences are bad for  
internal projects, where the pressure comes from users within t he same company, and  
worse for commercial p roducts, as the most prominent part of a journalist’s comparative  
review is often the ta ble listing side by side the features off ered by competing products.
Featurism is actually the combin ation of two problems, one more  difficult than the  
other. The easier problem is the loss of consistency that may r esult from the addition of  
new features, affecting its ease of use. Users are indeed known  to complain that all the  
“bells and whistles” of a product’s new version make it horrend ously complex. Such  
comments should be taken with a grain of salt, however, since t he new features do not  
come out of nowhere: most of the  time they have been requested by users — other  users.  
What to me looks  like a superfluous trink et may be an indispens able facility to you.
T h e  s o l u t i o n  h e r e  i s  t o  w o r k  a g a i n  a n d  a g a i n  o n  t h e  c o n s i s t e n c y  of the overall  
product, trying to make everythin g fit into a general mold. A g ood software product is  
based on a small number of power ful ideas; even if it has many specialized features, they  
should all be explainable as con sequences of these basic concep ts. The “grand  plan” must  
be visible, and everything s hould have its place in it.User Interface Design principle
Do not pretend you know the user; you don’t.
Definition: functionality
Functionality is the extent of p ossibilities provided by a syst em. See Wilfred J . Han-
sen, “User Engi-
neering Principles 
for Interactive Sys-tems” , Proceedings 
of FJCC 39 , AFIPS 
Press , Montvale 
(NJ), 1971 , pp 523-
532. 
§1.2   A REVIEW OF EXTERNAL FACTORS 13
The more difficult problem is to avoid being so focused on feat ures as to forget the  
other qualities. Projects commonl y make such a mistake, a situa tion vividly pictured by  
Roger Osmond in the form of  two possible paths to a project’s completion:
The bottom curve (black) is all too common: in the hectic race to add more features,  
the development loses track of the overall quality. The final p hase, intended  to get things  
right at last, can be long and stressful. If, under users’  or c ompetitors’ pr essure, you are  
forced to release the product ea rly — at stages marked by black  squares in the figure —  
the outcome may be damag ing to your reputation.
What Osmond suggests (the color curve) is, aided by the quality -enhancing  
techniques of O-O development, to maintain the quality level co nstant throughout the  
project for all aspects but func tionality. You just do not comp romise on reliability,  
extendibility and the like: you refuse to proceed with new feat ures until you are happy with  
the features you have.
This method is tougher to enforce on a day-to-day basis because  of the pressures  
mentioned, but yields a more eff ective software process and oft en a better product in the  
end. Even if the final result is the same, as assumed in the fi gure, it should be reached  
sooner (although the f igure does not show time). Following the suggested path also means  
that the decision to release an early version — at one of the p oints marked by colored  
squares in the figure — becomes, if not easier, at least simple r: it will be based on your  
assessment of whether what you have so far covers a large enoug h share of the full feature  
set to attract prospective custo mers rather than drive them awa y. The question “is it good  
enough?” (as in “will it not crash?”) should not be a factor.
As any reader who has led a software proje ct will know, it is e asier to approve such  
advice than to apply it. But eve ry project should strive to fol low the approach represented  
by the better one of the two Osmond curves. It goes well with t he cluster model  introduced  
in a later chapter as the general scheme for disciplined object -oriented development.Osmond’s 
curves; after  
[Osmond 1995]Other qualities
FunctionalityCommonDesirable
Debugging
early
releasesEnvisaged
“THE CLUSTER 
MODEL OF THE 
SOFTWARE 
LIFECYCLE”, 28.4, page 926.
SOFTWARE QUALITY  §1.2 14
Timeliness
Timeliness is one of the great fr ustrations of our industry. A great software product that  
appears too late might miss its target altogether. This is true  in other industries too, but few  
evolve as quickly as software.
Timeliness is still, for large pr ojects, an uncommon phenomenon . When Microsoft  
announced that the latest releas e of its principal operating sy stem, several years in the  
making, would be delivered one mo nth early, the event was newsw orthy enough to make  
(at the top of an article recall ing the lengthy delays that aff ected earlier projects) the front-  
page headline of ComputerWorld .
Other qualities 
Other qualities beside the ones discussed so far affect users o f software systems and the  
people who purchase th ese systems or commiss ion their developme nt. In particular: 
•Verifiability  is the ease of preparing acceptance procedures, especially tes t data, and  
procedures for detecting failure s and tracing them to errors du ring the validation and  
operation phases. 
•Integrity  is the ability of software systems to protect their various co mponents  
(programs, data) against unautho rized access and  modification. 
•Repairability  is the ability to facilitate the repair of defects. 
•Economy , the companion of timeliness, i s the ability of a system to be  completed on  
or below its assigned budget.
About documentation 
I n  a  l i s t  o f  s o f t w a r e  q u a l i t y  f a ctors, one might expect to find  t h e  p r e s e n c e  o f  g o o d  
documentation as one of the requ irements. But this is not a sep arate quality factor; instead,  
the need for documentation is a c onsequence of the other qualit y factors seen above. We  
may distinguish between three  kinds of documentation: 
• The need for external documentation, which enables users to understand the power  
of a system and use it conveniently, is a consequence of the de finition of ease of use. 
•T h e  n e e d  f o r  internal documentation, which enabl es software developers to  
understand the structure and impl ementation of a system, is a c onsequence of the  
extendibility requirement. 
• The need for module interface documentation, enabling software developers to  
understand the f unctions provided by a m odule without having to  understand its  
implementation, is a consequence of the reusability requirement . It also follows from  
extendibility, as module interface documentation makes it possi ble to determine  
whether a certain change ne ed affect a certain module. Definition: timeliness
Timeliness is the ability of a so ftware system to be released w hen or before  
its users want it.
“NT 4.0 Beats 
Clock”, Computer-
World, vol. 30, no. 30, 22 July 1996.
§1.2   A REVIEW OF EXTERNAL FACTORS 15
Rather than treating documentation as a product separate from t he software proper,  
it is preferable to make the sof tware as self-documenting as po ssible. This applies to all  
three kinds of documentation: 
• By including on-line “help” fac ilities and adhering to clear a nd consistent user  
interface conventions, you allevia te the task of the authors of  user manuals and other  
forms of external documentation. 
• A good implementation  language will remove much of the need fo r internal  
documentation if it favors clari t y  a n d  s t r u c t u r e .  T h i s  w i l l  b e  one of the major  
requirements on the object-orien ted notation dev eloped througho ut this book. 
• The notation will support information hiding and other techniq ues (such as  
assertions) for separating the in terface of modules from their implementation. It is  
then possible to use tools to pro duce module interface document ation automatically  
from module texts. This too is o ne of the topics studied in det ail in later chapters.
All these techniques lessen th e role of traditional documentati on, although of course  
we cannot expect  them to remove it completely.
Tradeoffs 
In this review of external software quality factors, we have en countered requirements that  
may conflict with one another.
How can one get integrity  without introducing protectio ns of various kinds, which  
will inevitably hamper ease of use ? Economy often seems to fight with functionality . 
Optimal efficiency  would require perfect adaptatio n to a particula r hardware and software  
environment, which i s the opposite of portability , and perfect adaptatio n to a specification,  
where reusability  pushes towards solving problems more general than the one init ially 
given. Timeliness pressures might tempt us to use “Rapid Application Development”  
techniques whose result s may not enjoy much extendibility .
Although it is in many cases possi ble to find a solution that r econciles apparently  
conflicting factors, you will so metimes need to make tradeoffs.  Too often, developers  
make these tradeoffs implicitly,  without taking the time to exa mine the issues involved and  
the various choices available; e fficiency tends to be the domin ating factor in such silent  
decisions. A true software engin eering approach implies an effo rt to state the criteria  
clearly and make the choices consciously. 
Necessary as tradeoffs between quality factors may be, one fact or stands out from  
the rest: correctness. There is n ever any justification for com promising correctness for the  
sake of other concerns such as e fficiency. If the software does  not perform its function, the  
rest is useless.
Key concerns 
All the qualities discussed abov e are important. But in the cur rent state of the software  
industry, four stand out: 
SOFTWARE QUALITY  §1.2 16
•Correctness  and robustness : it is still too difficult to produce software without defects  
(bugs), and too hard to correct the defects once they are there . Techniques for  
improving correctness and robustness are of the same general fl avors: more systematic  
approaches to software construction; more formal specifications ; built-in checks  
throughout the software construction process (not just after-th e-fact testing and  
debugging); better language mechanisms such as static typing, a ssertions, automatic  
memory management and disciplined exception handling, enabling developers to state  
correctness and robustness requirements, and enabling tools to detect inconsistencies  
before they lead to defects. Because of this closeness of corre ctness and robustness  
issues, it is convenient to use a more general term, reliability , to cover both factors. 
•Extendibility  a n d  reusability : software should be easier to change; the software  
elements we produce should be more generally applicable, and th ere should exist a  
larger inventory of general-purp ose components that we can reus e when developing  
a new system. Here again, simila r ideas are useful for improvin g both qualities: any  
idea that helps produce more dece ntralized architectures, in wh ich the components  
are self-contained and  only communicate thr ough restricted and clearly defined  
channels, will help. The term modularity  will cover reusabilit y and extendibility. 
As studied in detail i n subsequent chapters,  the object-oriente d method can  
significantly improve these four q uality factors — which is why  it is so attractive. It also  
has significant contributions to  make on other aspects, in part icular: 
•Compatibility : the method promotes a common d e s i g n  s t y l e  a n d  s t a n d a r d i z e d  
module and system interfaces, which help produce systems that w ill work together. 
•Portability : with its emphasis on abstracti on and information hiding, obje ct 
technology encourages designers to distingui sh between specific ation and  
implementation properties, facili tating porting efforts. The te chniques of  
polymorphism and dynamic binding  will even make it possible to write systems that  
automatically adapt to various components of the hardware-softw are machine, for  
example different window systems  or different da tabase manageme nt systems. 
•Ease of use : the contribution of O-O tools t o  m o d e r n  i n t e r a c t i v e  s y s t e m s  a nd 
especially their user interfaces  is well known, to the point th at it sometimes obscures  
other aspects (ad copy writers a re not the only people who call  “object-oriented” any  
system that uses icons, window s and mouse-dr iven input).   
•Efficiency : as noted above, although the e xtra power or object-oriented t echniques at  
first appears to carry a price, relying on professional-quality  reusable components  
can often yield considerable performance improvements. 
•Timeliness , economy  a n d  functionality : O-O techniques enable those who master  
them to produce software faster and at less cost; they facilita te addition of functions,  
and may even of themselves s uggest new functions to add.
In spite of all these advances, we should keep in mind that the  object-oriented method  
i s  n o t  a  p a n a c e a ,  a n d  t h a t  m a n y  o f  t h e  h a b i t u a l  i s s u e s  o f  s o f t w are engineering remain.  
Helping to address a problem is not the same as solving the pro blem. 
§1.3   ABOUT SOFTWARE MAINTENANCE 17
1.3  ABOUT SOFTWARE MAINTENANCE 
The list of factors di d not include a frequently quoted quality : maintainability. To  
understand why, we must take a c loser look at the underlying no tion, maintenance. 
Maintenance is what happens afte r a software product has been d elivered.  
Discussions of software methodol ogy tend to focus on the develo pment phase; so do  
i nt ro du ct or y p ro gr a mmin g c ou rs es . Bu t i t  is  wi de ly  es t ima te d th at  70 %  of  t he  co st  of  
software is devoted to maintenan ce. No study of software qualit y can be satisfactory if it  
neglects this aspect. 
What does “maintenance” mean for software? A minute’s reflectio n shows this term  
to be a misnomer: a software product does not wear out from rep eated usage, and thus need  
not be “maintained” the way a car  or a TV set does. In fact, th e word is used by software  
people to describe some noble and some not so noble activities.  The noble part is  
modification: as the specificati ons of computer systems change,  reflecting changes in the  
external world, so must the systems themselves. The less noble part is late debugging:  
removing errors that should n ever have been there in the first place.
The above chart, drawn from a milestone study by Lientz and Swa nson, sheds some  
light on what the catch-all term  of maintenance really covers. The study surveyed 487  
installations developing softwar e of all kinds; although it is a bit old, more recent  
publications confirm the same ge neral results. It shows the per centage of maintenance  
costs going into each of a numbe r of maintenance activities ide ntified by the authors.
More than two-fifths of the cost is devoted to user-requested e xtensions and  
modifications. This is what was called above the noble part of maintenance, which is also  
the inevitable part. The unanswered question is how much of the  overall effort the industry  
could spare if it built its soft ware from the start with more c oncern for extendibility. We may  
legitimately expect obje ct technology to help. Breakdown of 
maintenance costs . Source : 
[Lientz 1980]
12.4% 9% 6.2%5.5%4%3.4%
Emergency
FixesRoutine
FixesHardware
changesDocumen-
tationEfficiency
improvementsOther41.8%Changes in User  Requirements
17.6%Changes
in DataFormats
SOFTWARE QUALITY  §1.3 18
The second item in decreasing order of  percentage cost is particula rly interesting:  
effect of changes in data format s. When the physical structure of files and other data items  
change, programs must be adapted.  For example, when the US Post al Service, a few years  
ago, introduced the “5+4” postal code for large companies (usin g nine digits instead of  
five), numerous programs that dea lt with addresses and “knew” t hat a postal code was  
exactly five digits long had to be  rewritten, an effort which p ress accounts es timated in the  
hundreds of millions of dollars. 
Many readers will have received the beautiful brochures for a s et of conferences — not a  
single event, but a sequence of sessions in many cities — devot ed to the “millennium  
problem”: how to go about upgrading the myriads of date-sensiti ve programs whose  
authors never for a moment thought that a date could exist beyo nd the twentieth century.  
The zip code adaptation effort pales in comparison. Jorge Luis Borges would have liked  
the idea: since presumably few people care about what will happ en on 1 January 3000,  
this must be the tiniest topic to which a conference series, or  for that matter a conference,  
has been or will ever be devot ed in the history of humanity: a single decimal digit .
The issue is not that some part of the program k nows the physic al structure of data:  
this is inevitable since the dat a must eventually be accessed f or internal handling. But with  
traditional design techniques this knowledge is spread out over  to o m an y pa rt s  o f t he  
system, causing unjustifiably la rge program changes if some of the physical structure  
changes — as it inevitably will. In other words, if postal code s go from five to nine digits,  
or dates require one more digit, it is reasonable to expect tha t a program manipulating the  
codes or the dates will need to b e adapted; what is not accepta ble is to have the knowledge  
of the exact length of the data plastered all across the progra m, so that chang ing that length  
will cause program changes of a ma gnitude out of proportion wit h the conceptual size of  
the specification change. 
The theory of abstract data type s will provide the key to this problem, by allowing  
programs to access data by extern al properties rather than phys ical implementation. 
Another significant item in the distribution of activities is t he low percentage (5.5%)  
of documentation costs. Remember  that these are costs of tasks done at maintenance time.  
The observation here — at least the speculation, in the absence  of more specific data — is  
that a project will either take care of its documentation as pa rt of development or not do it  
at all. We will learn to use a design style in which much of th e documentation is actually  
embedded in the software, with sp ecial tools avai lable to extra ct it. 
T h e  n e x t  i t e m s  i n  L i e n t z  a n d  S w a n s o n ’ s  l i s t  a r e  a l s o  i n t e r e s t i n g, if less directly  
relevant to the topics of this book. Emergency bug fixes (done in haste when a user reports  
that the program is not producin g the expected results or behav es in some catastrophic  
way) cost more than routine, sch eduled corrections. This is not  only because they must be  
performed under heavy pressure, but also because they disrupt t h e  o r d e r l y  p r o c e s s  o f  
delivering new releases, and may introduce new errors. The last  two activities account for  
small percentages: For another 
example , see “How 
long is a middle 
initial?”, page 125 .
Chapter 6 covers 
abstract data types 
in detail .
§1.4   KEY CONCEPTS INTRODUCED IN THIS CHAPTER 19
• One is efficiency improvements;  this seems to suggest that onc e a system works,  
project managers and programmers  are often reluct ant to disrupt  it in the hope of  
performance improvements, and pr efer to leave go od enough alone . (When  
considering the “first make it right, then make it fast” precep t, many projects are  
probably happy enough to stop at the first of these steps.) 
• Also accounting for a small perc entage is “transfer to new env ironments”. A possible  
interpretation (again a conjecture in the absence of more detai led data) is that there  
are two kinds of program with r espect to portability, with litt le in-between: some  
programs are designed with portability in mind, and cost relati vely little to port;  
others are so closely tied to their original platform, and woul d be so difficult to port,  
that developers do  not even try. 
1.4  KEY CONCEPTS INTRODUCED IN THIS CHAPTER 
• The purpose of software enginee ring is to find ways of buildin g quality software. 
• Rather than a single factor, quality in software is best viewe d as a tradeoff between  
a set of diffe rent goals. 
• External factors, perceptible to users and clients, should be distinguished from  
internal factors, per ceptible to designer s and implementors. 
• What matters is the external fa ctors, but they can only be ach ieved through the  
internal factors. 
• A  l i s t  o f  b a s i c  e x t e r n a l  q u a l i t y factors was presented. Those for which current  
s o f tw ar e i s  m o s t b a d l y  i n  n e ed  o f better methods , and which the  object-oriented  
method directly address es, are the safety-related factors corre ctness and robustness,  
together known as reliability, a nd the factors re quiring more d ecentralized software  
architectures: reusability and e xtendibility, together known as  modularity. 
• Software maintenance, which cons umes a large portion of softwa re costs, is  
penalized by the difficulty of im plementing changes in software  products, and by the  
over-dependence of programs on t he physical structure of the da ta they manipulate. 
1.5  BIBLIOGRAPHICAL NOTES 
Several authors have proposed de finitions of software quality. Among the first articles on  
subject, two in particular  remain valuable today: [Hoare 1972] , a guest editorial, and  
[Boehm 1978] , the result of one of the first systematic studi es, by a group  at TRW. 
The distinction between external  a n d  i n t e r n a l  f a c t o r s  w a s  i n t r o duced in a 1977  
General Electric study commiss ioned by the US Air Force [McCall 1977] . McCall uses  
the terms “factors” and “criteria ” for what this chapter has ca lled external factors and  
internal factors. Many  ( a l t h o u g h  n o t  a l l )  o f  t h e  f a c t o r s  i n t r o d uced in this chapter  
correspond to some of McCall’s; one of his factors, maintainabi lity, was dropped, because,  
as explained, it is adequately covered by extendibility and ver ifiability. McCall’s study  
discusses not only external factors but also a number of intern al factors (“criteria”), as well  
SOFTWARE QUALITY  §1.5 20
as metrics , or quantitative techniques for  assessing satisfaction of the internal factors.  
With object technology, however, many of that study’s internal factors and metrics, too  
closely linked with older software practices, are obsolete. Car rying over this part of  
McCall’s work to the techniques  developed in this book would be  a useful project; see the  
bibliography and exe rcises to chapter 3.
The argument about the relative e ffect of machine improvements depending on the  
complexity of the algor ithms is derived from [Aho 1974] .
On ease of use, a standard reference is [Shneiderman 1987] , expanding on  
[Shneiderman 1980] , which was devoted to the broad er topic of software psychology . The 
Web page of Shneiderman’s lab at http://www.cs.umd. edu/projects/hcil/  contains many  
bibliographic referenc es on these topics.
The Osmond curves come from a tu torial given by Roger Osmond at  TOOLS USA  
[Osmond 1995] . Note that the form given in this chapter does not show time, enabling a  
more direct view of the tradeoff  between functionality and othe r qualities in the two  
alternative curves, bu t not reflecting the black curve’s potent ial for delayi ng a project.  
Osmond’s original curve s are plotted against time rather than f unctionality.
The chart of maintenance costs i s derived from a study by Lient z and Swanson,  
based on a maintenance questionna ire sent to 487 organizations [Lientz 1980] . See also 
[Boehm 1979] . Although some of their input data may be considered too speci alized and  
by now obsolete (the study was b ased on batch-type MIS applicat ions of an average size  
of 23,000 instructions, large then but not by today’s standards ), the results generally seem  
still applicable. The Software Management Association performs a yearly survey of  
maintenance; see [Dekleva 1992]  for a report about one of these surveys. 
The expressions programming-in-the-large and programming-in-the-small were 
introduced by [DeRemer 1976] .
For a general discussion of softw are engineering issues, see th e textbook by Ghezzi,  
Jazayeri and Mandrioli [Ghezzi 1991] . A text on programming languages by some of the  
same authors, [Ghezzi 1997] , provides complemen tary background for some of the issues  
discussed in the present book.
2  
Criteria of object orientation
In the previous chapter we explor ed the goals of the object-orie nted method. As a  
preparation for parts B a n d  C, in which we will discover the technical details of the  
method, it is useful to take a qu ick but wide glance at the key  aspects of object-oriented  
development. Such is the  aim of this chapter. 
One of the benefits will be to obtain a concise memento of what  makes a system  
object-oriented. This expression has nowadays become so indiscr iminately used that we  
need a list of precise propertie s under which we can assess any  method, language or tool  
that its proponent s claim to be O-O.
This chapter limits its explanations to a bare minimum, so if t his is your first reading  
you cannot expect to understand in detail all the criteria list ed; explaining them is the task  
of the rest of the book. Consider this discussion a preview — n ot the real movie, just a trailer.
Actually a warning is in order b ecause unlike any good trailer this chapter is also  
what film buffs call a spoiler — it gives away some of the plot  early. As such it breaks the  
step-by-step progression of this  book, especially part B, which  patiently builds the case  
for object technology by looking  at issue after issue before de ducing and justifying the  
solutions. If you like the idea of reading a broad overview bef ore getting into more depth,  
this chapter is for you. But if you prefer not to spoil the pleasure of seeing the problems  
unfold and of discovering the sol utions one by on e, then you sh ould simply skip it. You  
will not need to have read it to understand subse quent chapters .
2.1  ON THE CRITERIA
Let us first examine the choice of criteria for assessing objec tness.
How dogmatic do we need to be?
The list presented below includes all the facilities which I be lieve to be esse ntial for the  
production of quality software using the object-oriented method . It is ambitious and may  
appear uncompromising or even do gmatic. What con clusion does th i s  i m p l y  f o r  a n  
environment which satisfies some  but not all of these condition s? Should one just reject  
such a half-hearted O-O enviro nment as totally  inadequate? Warning : 
SPOILER ! 
CRITERIA FOR OBJECT ORIENTATION  §2.2 22
Only you, the reader, can answer this question relative to your  own context. Several  
reasons suggest that some co mpromises may be necessary: 
• “Object-oriented” is not a bool ean condition: environment A, a lthough not 100%  
O-O, may be “more” O-O than environment B; so if external const raints limit your  
choice to A and B you will have to pick A as the  least bad obje ct-oriented choice. 
• Not everyone will need all of  the properties all the time. 
• Object orientation may be just one of the factors guiding your  search for a software  
solution, so you may have to balance the criteria given here wi th other considerations. 
All this does not change the obvious: to make informed choices,  even if practical  
constraints impose les s-than-perfect soluti ons, you need to kno w the complete picture, as  
provided by the list below. 
Categories 
The set of criteria wh ich follows has been d ivided into three p arts: 
•Method and language : these two almost indistinguish able aspects cover the thought  
processes and the notations used to analyze and produce softwar e. Be sure to note  
that (especially in object techno logy) the term “language” cove rs not just the  
programming language in a strict s ense, but also the notations,  textual or graphical,  
used for analysis and design. 
•Implementation and environment : the criteria in this category describe the basic  
properties of the tools which al low developers to apply object- oriented ideas. 
•Libraries : object technol ogy relies on the reuse of software components.  Criteria in  
this category cover bo th the availability of basic libraries an d the mechanisms  
needed to use libraries and produce new ones. 
This division is convenient but not absolute, as some criteria straddle two or three of  
the categories. For example the criterion labeled “memory manag ement” has been  
classified under method and langu age because a language can sup port or prevent  
automatic garbage collection, but it also belongs to the implem entation and environment  
category; the “assertion” criterion similarly includes a requir ement for supporting tools.
2.2  METHOD AND LANGUAGE
The first set of  criteria covers the met hod and the supporting notation.
Seamlessness 
The object-oriented approach is a mbitious: it encompasses the e ntire software lifecycle.  
When examining object-oriented s olutions, you sho uld check that  the method and  
language, as well as t he supporting tools, apply to analysis an d design as well as  
implementation and maintenance. The language, in particular, sh ould be a vehicle for  
thought which will he lp you through all st ages of your work. 
§2.2   METHOD AND LANGUAGE 23
The result is a seamless develop ment process, wh ere the general ity of the concepts  
and notations helps reduce the magnitude of the transitions bet ween successive steps in  
the lifecycle. 
These requirements exc lude two cases, still frequently encounte red but equally  
unsatisfactory: 
• The use of object-oriented conce pts for analysis  and design on ly, with a method and  
notation that cannot be used t o write executable software. 
• The use of an object-oriented programming language which is no t suitable for  
analysis and design. 
In summary:
Classes 
The object-oriented method is based on the notion of class. Inf ormally, a class is a software  
element describing an abstract da ta type and its partial or tot al implementation. An  
abstract data type is a set of objects defined by the list of o perations, or features , applicable  
to these objects, and  the properties of these operations.
Assertions 
The features of an abstract data type have formally specified p roperties, whic h should be  
reflected in the corresponding cla s s e s .  A s s e r t i o n s  —  r o u t i n e  p r econditions, routine  
postconditions and cla ss invariants — play this role. They desc ribe the effect of features  
on objects, independent ly of how the features have been impleme nted. 
Assertions have three major applications: they help produce rel iable software; they  
provide systemat ic documentation; and the y are a central tool f or testing and debugging  
object-oriented software.
In the society of software modules, with classes serving as the  cities and instructions  
(the actual executable code) serving as the  executive branch of  government, assertions  
provide the legislativ e branch. We shall see below who takes ca re of the judicial system. An object-oriented language and en vironment, together with the supporting  
method, should a pply to the entire lifecy cle, in a way that min imizes the gaps  
between successive activities.
The method and the language should have the notion of class as their 
central concept.
The language should make it possible to equip a class and its f eatures with  
assertions (preconditions, postco nditions and invariants), rely ing on tools to  
produce documentation out of these assertions and, optionally, monitor them  
at run time.
Clusters, studied 
in chapter 28, are the countries and provinces.
CRITERIA FOR OBJECT ORIENTATION  §2.2 24
Classes as modules 
Object orientation is p rimarily an architec tural tech nique: its  m a j o r  e f f e c t  i s  o n  t h e  
modular structure of  software systems. 
The key role here is again playe d by classes. A class describes  not just a type of  
objects but also a mod ular unit. In a pure  object-oriented appr oach: 
In particular, there is no notion  of main program, and subprogr ams do not exist as  
independent modular units. (They may only appear as part of cla sses.) There is also no  
need for the “packages ” of languages such as  Ada, although we m ay find it con venient for  
management purposes to group cla sses into admini strative units,  called clusters .
Classes as types 
The notion of class is powerful e nough to avoid the need for an y other typing mechanism:  
Even basic types such as INTEGER  and REAL  can be derived from classes; normally  
such classes will be built-in ra ther than defined anew by each developer. 
Feature-based computation 
In object-oriented computation, there is only one basic computa tional mechanism: given a  
certain object, which (because of the previous rule) is always an instance of some class,  
call a feature of that class on that object. For example, to di splay a certain window on a  
screen, you call the feature display  on an object representing the window — an instance of  
class WINDOW . Features may also have argumen ts: to increase the salary of a n employee  
e by n dollars, effective at date d, you call the feature raise  on e, with n and d as arguments. 
Just as we treat basic types as predefined classes, we may view  basic operations  
(such as addition of numbers) as  special, predefined cases of f eature call, a very general  
mechanism for describing computations:
A class which contains a call to a feature of a class C is said to be a client  of C. 
Feature call is also known as message passing ; in this terminology, a call such as the above  
will be described as passing to e the message “raise your pay”, with arguments d and n.Classes should be the only modules.
Every type should be based on a class.
Feature call should be the pri mary computational mechanism.
§2.2   METHOD AND LANGUAGE 25
Information hiding 
When writing a class, you will sometimes have to include a feat ure which the class needs  
for internal pur poses only: a feature th at is part of the imple mentation of the class, but not  
of its interface. Others features  of the class — possibly avail able to clients — may call the  
feature for their own needs; but it should n ot be possible for a client to call it directly.
The mechanism which makes certai n features unfit for clients’ c alls is called  
information hiding. As  explained in a later chapter, it is esse ntial to the smo oth evolution  
of software systems. 
In practice, it is not enough for the information hiding mechan ism to support exported  
features (available to all clients) and secret features (availa ble to no client); class designers  
must also have the ability to e xport a feature selectively to a  set of designated clients.
An immediate consequenc e of this rule is that communication bet ween classes  
should be strictly limited. In particular, a good object-orient ed language should not offer  
any notion of global variable; classes will exchange informatio n exclusively through  
feature calls, and through t he inheritance mechanism. 
Exception handling 
Abnormal events may occur during  the execution of a software sy stem. In object-oriented  
computation, they often correspo nd to calls that cannot be exec uted properly, as a result  
of a hardware malfunction, of an  unexpected impossibility (such  as numerical overflow in  
an addition), o r of a bug in the software. 
To produce reliable software, it is necessary to have the abili ty to recover from such  
situations. This is the purpose of an exception mechanism. 
I n  t h e  s o c i e t y  o f  s o f t w a r e  s y s t e m s ,  a s  y o u  m a y  h a v e  g u e s s e d ,  t h e exception  
mechanism is the third branch of government, the judicial syste m (and the supporting  
police force). 
Static typing 
When the execution of a software system causes the call of a ce rtain feature on a certain  
object, how do we know that this  o b j e c t  w i l l  b e  a b l e  t o  h a n d l e  the call? (In message  
terminology: how do we know that  the object can process the mes sage?) 
To provide such a guarantee of c orrect execution, the language must be typed. This  
means that it enforces a few com patibility rules ; in particular : I t s hou ld  be p oss i bl e for  t he  a ut h or  o f a  c la ss  to  s pe ci f y th at  a feature is  
available to all clients, to no c lient, or to specified clients .
The language should provide a mec hanism to recover from unexpec ted 
abnormal situations.
CRITERIA FOR OBJECT ORIENTATION  §2.2 26
• Every entity (that is to say, every name used in the software text to refer to run-time  
objects) is explicitly  declared as being o f a certain type, der ived from a class. 
• Every feature call on a certain entity uses a feature from the  corresponding class (and  
the feature is available, in the  sense of inform ation hiding, t o the caller’s class).
• Assignment and argument  p a s s i n g  a r e  s u b j e c t  t o  conformance rules , based on  
inheritance, which require the s ource’s type to be compatible w ith the target’s type. 
In a language that imposes such a policy, it is possible to wri te a static type checker
which will accept or reject soft ware systems, guaranteeing that  the systems it accepts will  
not cause any “feature not avail able on object” error at run ti me.
Genericity 
For typing to be practical, it must be possible to define type- parameterized classes, known  
as generic. A generic class LIST  [G] will describe lists of elements of an arbitrary type  
represented by G, the “formal generic parameter”; you may then declare specific  l i s t s 
through such derivations as LIST [INTEGER ] and LIST  [WINDOW ], using types INTEGER
and WINDOW  as “actual generic parameters”. All derivations share the same  class text.
This form of type parameterization is called unconstrained genericity. A companion  
facility mentioned below, cons trained genericity, involves inhe ritance. 
Single inheritance 
Software development involves a large number of classes; many a re variants of others. To  
control the resulting potential complexity, we need a classific ation mechanism, known as  
inheritance. A class will be an heir of another if it incorpora tes the other’s features in  
addition to its own. (A descendant is a direct or indirect heir; the reverse notion is ancestor .)
Inheritance is one of the centra l concepts of the object-orient ed methods and has  
profound consequences on the so ftware development process. 
Multiple inheritance 
We will often encounter the need  to combine seve ral abstraction s. For example a class  
might model the notion of “infant”, which we may view both as a  “person”, with the  A well-defined type system shoul d, by enforcing a number of typ e 
declaration and compatibility ru les, guarantee the run-time typ e safety of the  
systems it accepts.
It should be possible to write classes with formal generic para meters  
representing arbitrary types.
It should be possible to define a class as i nheriting from anot her.
§2.2   METHOD AND LANGUAGE 27
associated features, and, more p rosaically, as a “tax-deductibl e item”, which earns some  
deduction at tax time. Inheritan ce is justified in both cases. Multiple inheritance is the  
guarantee that a class may inher it not just from one other but f r o m  a s  m a n y  a s  i s  
conceptually justified. 
Multiple inheritance raises a few technical problems, in partic ular the resolution of  
name clashes (cases in which different featur es, inherited from different cl asses, have the  
same name). Any notation offering multiple inheritance must pro vide an adequate solution  
to these problems.
The solution developed i n this book is based on renaming the conflicting features in  
the heir class. 
Repeated inheritance 
Multiple inheritance rais es the possibility of repeated inheritance, the case in which a class  
inherits from another thro ugh two or more paths, as shown.
In such a case the language must provide precise rules defining  what happens to  
features inherited repeatedl y from the common ancestor, A in the figure. As the discussion  
of repeated inheritance will sho w, it may be desirable for a fe ature of A to yield just one  
feature of D in some cases ( sharing ) ,  b u t  i n  o t h e r s  i t  s h o u l d  y i e l d  t w o  ( replication ).  
Developers must have the flexibility to prescribe either policy  separately for each feature.
Constrained genericity 
The combination of genericity an d inheritance brings about an i mportant technique,  
constrained genericity, through which you can specify a class w ith a generic parameter  
that represents not an arbitrary type as with the earlier (unco nstrained) form of genericity,  
but a type that is a desce ndant of a given class. It should be possible for a clas s to inherit fro m as many other s as necessary,  
with an adequate mechanism for  disambiguating name clashes.
Precise rules should govern the f ate of features under repeated  inheritance,  
allowing developers to choose, s eparately for each repeatedly i nherited  
feature, between shari ng and replication.Repeated 
inheritance
Inherits fromA
D
CRITERIA FOR OBJECT ORIENTATION  §2.2 28
A generic class SORTABLE_LIST , describing lists with a sort feature that will  
reorder them sequentially according to a certain order relation , needs a generic parameter  
representing the list elements’ type. That type is not arbitrar y: it must support an order  
relation. To state that any actual generic parameter must be a descendant of the library  
class COMP ARABLE , describing objects equipped wit h an order relation, use const rained  
genericity to declare the class as SORTABLE_LIST [G –> COMP ARABLE ].
Redefinition 
When a class is an heir of another , it may need to change the i mplementation or other  
properties of some of the inherited features. A class SESSION describing user sessions in  
an operating system may have a feature terminate to take care of cleanup operations at the  
end of a session; an heir might be REMOTE_SESSION , handling sessions started from a  
different computer on a network. If the termination of a remote  s e s s i o n  r e q u i r e s  
supplementary actions (such as n otifying the remote computer), class REMOTE_SESSION
will redefine feature terminate . 
Redefinition may affect the impl ementation of a feature, its si gnature (type of  
arguments and result), and its specification.
Polymorphism 
With inheritance brought into the  picture, the static typing re quirement listed earlier would  
be too restrictive if it were taken to mean that every entity d eclared of type C may only  
refer to objects whose type is exactly C. This would mean for example that an entity of  
type C (in a navigation control system)  could not be used to refer to an object of type  
MERCHANT_SHIP  or SPORTS_BOAT , both assumed to be cla sses inheriting from BOAT . 
As noted earlier, an “entity” is a name to which various values  may become attached at  
run time. This is a generaliza tion of the traditional notion of  variable.
Polymorphism is the ability for an entity to become attached to  objects of various  
possible types. In a st atically typed enviro nment, polymorphism  will not be arbitrary, but  
controlled by inheritance; for example, we should not allow our  BOAT entity to become  
attached to an object repres enting an object of type BUOY , a class which does not inherit  
from BOAT .The genericity mechanism should support the constrained form of  genericity.
It should be possible to redefine the specification, signature and 
implementation of an inherited feature.
It should be possible to attach e ntities (names in the software  t e x t s  
representing run-time objects) t o run-time object s of various p ossible types,  
under the control of the inh eritance-based type system.
§2.2   METHOD AND LANGUAGE 29
Dynamic binding 
The combination of the last two mechanisms menti oned, redefinit ion and polymorphism,  
immediately suggests the next one. Assume a call whose target i s a polymorphic entity,  
for example a call to the feature turn on an entity declared of type BOAT . The various  
descendants of BOAT may have redefined the feature in various ways. Clearly, there must 
be an automatic mechanism to guarantee that the version of turn will always be the one  
deduced from the actual object’s  type, regardless of how the en tity has been declared. This  
property is called dynamic binding.
Dynamic binding has a major infl uence on the structure of objec t-oriented  
applications, as it enables developers to write simple calls (m eaning, for example, “call  
feature turn on entity my_boat ”) to denote what is actua lly several possible calls  
depending on the corre sponding run-time sit uations. This avoids  the need for many of the  
repeated tests (“Is th is a merchant ship? Is this a sports boat ?”) which plague software  
written with more conv entional approaches. 
Run-time type interrogation 
Object-oriented software develop ers soon develop a healthy hatr e d  f o r  a n y  s t y l e  o f  
computation based on e xplicit choices between various types for  an object. Polymorphism  
and dynamic binding provide a mu ch preferable alternative. In s ome cases, however, an  
object comes from the outside, s o that the software author has no way to predict its type  
with certainty. This occurs in pa rticular if the object is retr ieved from external storage,  
received from a network transmission or passed by some other sy stem. 
The software then needs a mechanism to access the object in a s afe way, without  
violating the constraints of stat ic typing. Such a mechanism sh ould be designed with care,  
so as not to cancel the benefits  of polymorphism and dynamic bi nding. 
The assignment attempt  operation described in th is book satisfies these  
requirements. An assignment attempt is a conditional operation:  it tries to att ach an object  
to an entity; if in a given exec ution the object’s type conform s to the type declared for the  
entity, the effect is that of a normal assignment; otherwise th e entity gets a special “void”  
value. So you can handle objects  whose type you do not know for  sure, without violating  
the safety of the type system.Calling a feature on an entity should always trigger the featur e corresponding  
to the type of the attached run-t ime object, whic h is not neces sarily the same  
in different executions of the call.
It should be possible to determin e at run time whether the type  of an object  
conforms to a statically given type.
CRITERIA FOR OBJECT ORIENTATION  §2.2 30
Deferred features and classes 
In some cases for which dynamic binding provides an elegant sol ution, obviating the need  
for explicit tests, there is no initial version of a feature to  be redefined. For example class  
BOAT may be too general to provide a default implementation of turn. Yet we want to be  
able to call feature turn to an entity declared of type BOAT if we have ensured that at run  
time it will actually be attached to objects of such fully defi ned types as MERCHANT_
SHIP  and SPORTS_BOAT . 
In such cases BOAT may be declared as a deferred class (one which is not fully  
implemented), and with a deferred feature turn. Deferred features and classes may still  
possess assertions describing th e i r  a b s t r a c t  p r o p e r t i e s ,  b u t  t h eir implementation is  
postponed to descendant classes. A non-deferred class is said t o be effective .
Deferred classes (also called ab stract classes) are particularl y important for object-
oriented analysis and high-level  design, as they make it possib le to capture the essential  
aspects of a system while leaving details to a l ater stage. 
Memory management and garbage collection 
The last point on our list of m ethod and language criteria may at first appear to belong  
more properly to the next categor y — implementation and environ ment. In fact it belongs  
to both. But the crucial require ments apply to the language; th e rest is a matter of good  
engineering. 
Object-oriented systems, even mo re than traditio nal programs (e xcept in the Lisp  
world), tend to create many objects with sometimes complex inte rdependencies. A policy  
leaving developers in charge of managing the associated memory,  especially when it  
comes to reclaim ing the space occupied by objects that are no l onger needed, would harm  
both the efficiency of the devel opment process, as it would com plicate the software and  
occupy a considerable part of the developers’ time, and the saf ety of the resulting systems,  
as it raises the risk of improper recycling of memory areas. In  a good object-oriented  
environment memory management wi ll be automatic, under the cont rol of the garbage  
collector , a component of the runtime system. 
The reason this is a language is sue as much as an implementatio n requirement is that  
a language that has no t been explicitly desi gned for automatic memory management will  
often render it impossible. This  is the case with languages whe re a pointer t o an object of  
a certain type may disguise itself (through conversions known a s “casts”) as a pointer of  
another type or even as an integ er, making it impossible to wri te a safe garb age collector.It should be possible to write a  class or a feature as deferred , that is to say  
specified but not f ully implemented.
The language should make safe automatic memory management possi ble, 
and the implementation  should provide an automatic memory manag er 
taking care of gar bage collection.
§2.3   IMPLEMENTATION AND ENVIRONMENT 31
2.3  IMPLEMENTATION AND ENVIRONMENT 
We come now to the essential fea tures of a development environm ent supporting object-
oriented software construction. 
Automatic update 
Software development is an incremental process. Developers do n ot commonly write  
thousands of lines at a time; th ey proceed by addition and modi fication, starting most of  
the time from a system that is  already of substantial size. 
When performing such an update, it is essential to have the gua rantee that the  
resulting system will be consistent. For example, if you change  a feature f of class C, you 
must be certain that every descendant of C which does not redefine f will be updated to  
have the new version of f, and that every call to f in a client of C or of a descendant of C 
will trigger the new version. 
Conventional approaches to this problem are manual, forcing the  developers to  
r e c o r d  a l l  d e p e n d e n c i e s ,  a n d  t r a c k  t h e i r  c h a n g e s ,  u s i n g  s p e c i a l  mechanisms known as  
“make files” and “include files” . This is unacceptable in moder n software development,  
especially in the object-oriente d world where the dependencies between classes, resulting  
from the client and inheritance relations, are often complex bu t may be deduced from a  
systematic examination  of the soft ware text.  
I t  i s  p o s s i b l e  t o  m e e t  t h i s  r e q u irement in a compiled environme nt (where the  
compiler will work together with a tool for dependency analysis ), in an interpreted  
environment, or in one  combining both of the se language impleme ntation te chniques. 
Fast update 
In practice, the mechanism for u pdating the system after some c hanges should not only be  
automatic, it should also be fast. More precisely, it should be  proportional to the size of  
the changed parts, not to the size of the system as a whole. Wi thout this property, the  
method and environment may be app licable to small systems, but not to large ones.  
H e r e  t o o  b o t h  i n t e r p r e t e d  a n d  c o m piled environments may meet th e criterion,  
although in the latter case the compiler must be incremental. A long with an incremental  
compiler, the environment may of  course include a global optimi zing compiler working  
on an entire system, as long as that compiler only needs to be used for delivering a final  
product; development will rely  on the incremental compiler. System updating after a change s hould be automatic, the analysi s of inter-
class dependenci es being performed by t ools, not manually by de velopers.
The time to process a set of changes to a system, enabling exec ution of the  
updated version, should be a function of the size of the change d components,  
independent of the size of the system as a whole.
CRITERIA FOR OBJECT ORIENTATION  §2.3 32
Persistence 
Many applications, perhaps most, will need to conserve objects from one session to the  
next. The environment should pro vide a mechanism to do this in a simple way. 
An object will often contain refe rences to other objects; since  the same may be true  
o f  t h e s e  o b j e c t s ,  t h i s  m e a n s  t h a t  e v e r y  o b j e c t  m a y  h a v e  a  l a r g e  number of dependent  
objects, with a possibly complex  dependency graph (which may in volve cycles). It would  
usually make no sense to store or retrieve the object without a ll its direct and indirect  
dependents. A persistence mechan ism which can automatically sto re an object’s  
dependents along with the object is said to support persistence closure .
For some applications, mere persistence support is not sufficie nt; such applications  
will need full database support . The notion of object-oriented database is covered in a  
later chapter, which also explores other persistent issues such  as schema evolution , the 
ability to retrieve objects safe ly even if the c orresponding cl asses have changed.
Documentation 
Developers of classes and system s must provide management, cust omers and other  
developers with clear, high-level descriptions of the software they produce. They need  
tools to assist them in this effort; as much as possible of the  documentation should be  
produced automatically from the s oftware texts. Assertions, as already noted, help make  
such software-extracted docume nts precise and informative.
Browsing
When looking at a class, you will often need to obtain informat ion about other classes; in  
particular, the features used in  a class may have been introduc ed not in the class itself but  
in its various ancestors. This puts on the environment the burd en of providing developers  
with tools to examine a class te xt, find its dependencies on ot her classes, and switch  
rapidly from one class  text to another. 
This task is called browsing. Typical facilities offered by goo d browsing tools  
include: find the clients, suppliers, descendants, ancestors of  a  c l a s s ;  f i n d  a l l  t h e  
redefinitions of a feature; find  the original de claration of a redefined feature.A persistent storage mechanism supporting persistence closure s hould be  
available to store an object and all its dependents into extern al devices, and  
to retrieve them in the same or another session.
Automatic tools should be available to produce documentation ab out classes  
and systems.
Interactive browsing f acilities should enable software develope rs to follow up  
quickly and conveniently  the dependencies be tween classes and f eatures.S is a “supplier” of 
C if C is a client of S. 
“Client” was defined on page 24.
§2.4   LIBRARIES 33
2.4  LIBRARIES 
One of the characteristic aspects of developing software the ob ject-oriented way is the  
ability to rely on libraries. An  object-oriented environment sh ould provide good libraries,  
and mechanisms to write more. 
Basic libraries 
The fundamental data structures of computing science — sets, li sts, trees, stacks … — and  
the associated algorithms — sort ing, searching, traversing, pat tern matching — are  
ubiquitous in software developme nt. In conventio nal approaches,  each developer  
implements and re-implements the m independently all the time; t his is not only wasteful  
of efforts but detrimental to software quality, as it is unlike ly that an individual developer  
who implements a data structure not as a goal in itself but mer ely as a component of some  
application will attai n the optimum in relia bility and efficien cy. 
An object-oriented development e nvironment must provide reusabl e classes  
addressing these common needs of software systems.
Graphics and user interfaces 
M a n y  m o d e r n  s o f t w a r e  s y s t e m s  a r e  interactive, interacting with their users through  
graphics and other pleasant inte rface techniques. This is one o f the areas where the object-
oriented model has proved most imp ressive and helpful. Develope rs should be able to rely  
on graphical libraries to build i nteractive applications quickl y and effectively.
Library evolution mechanisms 
Developing high-quality librarie s is a long and arduous task. I t is impossible to guarantee  
that the design of library will be perfect the first time aroun d. An important problem, then,  
is to enable library developers to update and modify their desi gns without wreaking havoc  
in existing systems that depend on the library. This important criterion belongs to the  
library category, but also to the  method and language category.Reusable classes shoul d be available to cover the most frequent ly needed  
data structures and algorithms.
Reusable classes shoul d be available for developing application s which  
provide their users with pleas ant graphical user interface.
Mechanisms should be available t o facilitate library evolution with minimal  
disruption of client software.
CRITERIA FOR OBJECT ORIENTATION  §2.5 34
Library indexing mechanisms 
Another problem raised by libra ries is the need for mechanisms to identify the classes  
addressing a certain need. This criterion affects all three cat egories: libraries, language (as  
there must be a way to  enter indexing inform ation within the te xt of each class) and tools  
(to process queries for classes s atisfying certain  conditions).
2.5  FOR MORE SNEAK PREVIEW
Although to understand the conce pts in depth it is preferable t o read this book sequentially,  
readers who would like to comple ment the preceding theoretical overview with an  
advance glimpse of the method at work on a practical example ca n at this point read  
chapter 20, a case study of a practical de sign problem, on which it compa res an O-O  
solution with one employing more tradition al techniques.
That case study is mostly self-contained, so that you will unde rstand the essentials  
without having read the intermediate chapters. (But if you do g o ahead for this quick peek,  
you must promise to come back to the rest of the sequential pre sentation, starting with  
chapter 3, as soon as you are done.)
2.6  BIBLIOGRAPHICAL NOTES AND OBJECT RESOURCES
T h i s  i n t r o d u c t i o n  t o  t h e  c r i t e r i a  o f  o b j e c t  o r i e n t a t i o n  i s  a  g o od opportunity to list a  
selection of books that offer qu ality introductions to object t echnology in general.
[Waldén 1995]  discusses the most important issues of object technology, focu sing 
on analysis and design, on which it is probably th e best refere nce.
[Page-Jones 1995]  provides an excellent o verview of the method.
[Cox 1990]  (whose first edition was published in 1986) is based on a some what 
different view of object technolo gy and was instrumental in bri nging O-O concepts to a  
much larger audience than before.
[Henderson-Sellers 1991]  (a second edition is announced ) provides a short overview  
of O-O ideas. Meant for people who are asked by their company t o “go out and find out  
what that object stuff is about”,  it includes ready-to-be-photo copied transparency masters,  
precious on such occasio ns. Another overview is [Eliëns 1995] .
The Dictionary of Object Technology  [Firesmith 1995]  provides a comprehensive  
reference on many as pects of the method.Library classes should be equipped with indexing information al lowing  
property-based retrieval.
§2.6   BIBLIOGRAPHICAL NOTES AND OBJECT RESOURCES 35
All these books are to various de grees intended for technically -minded people. There  
is also a need to educate managers. [M 1995]  grew out of a chapter originally planned for  
the present book, which became a  full-fledged discussion of obj ect technology for  
ex ec ut i ve s.  It  s ta r ts  w i th  a  sh o rt technical presentation couch ed in business terms and  
continues with an analysis of ma nagement issues (lifecycle, pro ject management, reuse  
policies). Another mana gement-oriented book, [Goldberg 1995] , provides a  
complementary perspective on many important topics. [Baudoin 1996]  stresses lifecycle  
issues and the impo rtance of standards.
Coming back to technical presentations, three influential books  on object-oriented  
languages, written by the designe rs of these languages, contain  general methodological  
discussions that make them of interest to readers who do not us e the languages or might  
even be critical of them. (The history of programming languages  and books about them  
shows that designers are not always the best to write about the ir own creations, but in these  
cases they were.) The books are:
•Simula BEGIN [Birtwistle 1973] . (Here two other authors joined the language  
designers Nygaard and Dahl.)
•Smalltalk-80 : The Language and its Implementation [Goldberg 1983] .
•The C++ Programming Language , second edition [Stroustrup 1991] .
More recently, some introductory  programming tex tbooks have sta rted to use object-
oriented ideas right from the st art, as there is no reason to l et “ontogeny repeat phylogeny”,  
that is to say, take the poor stu dents through the history of t he hesitations and mistakes  
through which their predecessors  arrived at the right ideas. Th e first such text (to my  
knowledge) was [Rist 1995] . Another good book covering similar needs is [Wiener  
1996] . At the next level — textbooks f or a second course on programm ing, discussing data  
structures and algorithms based  on the notation of this book — you will find [Gore 1996]
and [Wiener 1997] ; [Jézéquel 1996]  presents the principles of object-oriented software  
engineering.
The Usenet newsgroup comp.object , archived on several sites around the Web, is the  
natural medium of discussion for  many issues of object technolo gy. As with all such  
forums, be prepared for a mixtur e of the good, the bad and the ugly. The Object  
Technology department of Computer (IEEE), which I have edited since it started in 1995,  
has frequent inv ited columns by leading experts.
Magazines devoted to Obje ct Technology include:
•T h e  Journal of Object-O riented Programming  (the first journal in the field,  
emphasizing technical discussi ons but for a large audience), Object Magazine  (of a 
more general scope, with some articles for managers), Objekt Spektrum (German) , 
Object Currents (on-line), all described at http://www.sigs.com .
•Theory and Practice of Object Systems , an archival journal.
•L’OBJET  (French), described at http://www.too ls.com/lobjet .Chapter 29 dis-
cusses teaching the technology.
CRITERIA FOR OBJECT ORIENTATION  §2.6 36
The major international O-O conferences are OOPSLA (yearly, USA  or Canada, see  
http://www.acm.org ); Object Expo (variable frequency and locations, described at  
http://www.sigs.com ); and TOOLS (Technology of O bject-Oriented Languages and  
Systems), organized by ISE with three sessions a year (USA, Eur ope, Pacific), whose  
home page at http://www.tools.com  also serves as a general re source on object technology  
and the topics of this book.
Part B: 
The road to object orientation
The second [ precept I devised for myself  ] was to divide each  of the difficulties  
which I would examine into as many parcels as it would be possible and  
required to solve it better.
The third was to drive my thoughts in due order, beginning with these objects  
most simple and easiest to know, and climbing little by little, so to speak by  
degrees, up to the knowledge of the most composite ones; and assuming some  
order even between thos e which do not naturally precede one another.
René Descartes, Discourse on the Method  (1637)See the comments on 
this text on page 43.
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
Part B will examine the software engineerin g requirements that lead us, almost  
inexorably, to object technology. 
3  
Modularity 
From the goals of extendibility and reusability, two of the prin cipal quality factors  
introduced in chapter 1, follows the need for flexible system architectures, made of  
autonomous software components. This is why chapter 1 also introduced the term  
modularity to cover the combination of these two quality factors. 
Modular programming was once ta ken to mean the construction of programs as  
assemblies of small pieces, usua lly subroutines. But such a tec hnique cannot bring real  
extendibility and reusa bility benefits unless we have a better way of guaranteeing that the  
resulting pieces — the modules  — are self-contained and organized in stable  
architectures. Any comprehensive definition of modularity must ensure these properties. 
A software construction method i s modular, then, if it helps de signers produce  
s o f t w a r e  s y s t e m s  m a d e  of autonomous elements connected by a coh erent, simple  
structure. The purpose of this chapter is to refine this inform al definition by exploring  
what precise properties such a method must possess to deserve t he “modular” label. The  
focus will be on design methods, but the ideas also apply to ea rlier stages of system  
construction (analysis, specification) and must of course be ma intained at the  
implementation and m aintenance stages. 
As it turns out, a single defin ition of modularity would be ins ufficient; as with  
software quality, we must look at modularity from more than one  viewpoint. This chapter  
introduces a set of complementary properties: five criteria , five rules and five principles  
o f  m o d u l a r i t y  w h i c h ,  t a k e n  c o l l e c t i v e l y ,  c o v e r  t h e  m o s t  i m p o r t a nt requirements on a  
modular design method. 
For the practicing software deve loper, the principles and the r ules are just as  
important as the criteria. The di fference is simply one of caus ality: the criteria are mutually  
independent — an d it is indeed possible for a method to satisfy  one of them while violating  
some of the others — whereas the rules follow from the criteria  and the princ iples follow  
from the rules. 
You might expect this chapter to begin with a precise descripti on of what a module  
looks like. This is not the case, and for a good reason: our go al for the exploration of  
modularity issues, in this chapt er and the next two, is precise ly to analyze the properties  
which a satisfactory module struc ture must satisfy; so the form  of modules will be a  
c o n c l u s i o n  o f  t h e  d i s c u s s i o n ,  n o t  a  p r e m i s e .  U n t i l  w e  r e a c h  t h a t conclusion the word  
MODULARITY  §3.1 40
“module” will denote the basic u nit of decomposition of our sys tems, whatever it actually  
is. If you are familiar with non- object-oriented methods you wi ll probably think of the  
subroutines present in most progr amming and desig n languages, o r perhaps of packages  
as present in Ada and (under a different name) in Modula. The d iscussion wi ll lead in a  
later chapter to the O-O form of  module — the class — which sup ersedes these ideas. If  
you have encountered classes and O-O techniques before, you sho uld still read this chapter  
to understand the requirements th at classes address, a prerequi site if you want to use them  
well.
3.1  FIVE CRITERIA 
A design method worthy of being c alled “modular” should satisfy  five fundamental  
requirements, explored in the next few sections: 
• Decomposability. 
• Composability. 
• Understandability. 
• Continuity. 
•P r o t e c t i o n .  
Modular decomposability
The process will often be self-r epeating since each subproblem may still be complex  
enough to require further decomposition.A software construction method s atisfies Modular Decomposabilit y if it  
helps in the task of decomposing  a software problem into a smal l number of  
less complex subproblems, connected by a simple structure, and independent  
enough to allow further work to p roceed separately on each of t hem
Decomposabil-
ity
§3.1   FIVE CRITERIA 41
A corollary of the decomposability requirement is division of labor : once you have  
decomposed a system into subsyste ms you should be  able to distr ibute work on these  
subsystems among different peopl e or groups. This is a difficul t goal since it limits the  
dependencies that may exis t between the subsystems: 
• You must keep such dependencies  to the bare minimum; otherwise  the development  
of each subsystem would be limit ed by the pace of the work on t he other subsystems. 
• The dependencies must be known:  if you fail to list all the re lations between  
subsystems, you may at the end of the project get a set of soft ware elements that  
appear to work individually but c annot be put together to produ ce a complete system  
satisfying the overall requirements of the original problem. 
The most obvious example of a method meant to satisfy the decomposability  
criterion is top-down design . This method directs designers to start with a most abstract  
description of the system’s func tion, and then to refine this v iew through successive steps,  
decomposing each subsystem at each step into a small number of simpler subsystems,  
until all the remaining elements  are of a sufficiently low leve l of abstraction to allow direct  
implementation. The proc ess may be modeled as a t ree.
A typical counter-example is any method en couraging you to include, in each  
software system that you produce , a global initialization modul e. Many modules in a  
system will need some kind of ini tialization — actions such as the opening of certain files  
or the initialization of certain  variables, which the module mu st execute before it performs  
its first directly use ful tasks. It may seem a good idea to con centrate all such actions, for  
all modules of the system, in a module that initializes everyth ing for everybody. Such a  
module will exhibit good “tempor al cohesion” in that all its ac tions are executed at the  
same stage of the syst em’s execution. But to obtain this tempor al cohesion the method  
would endanger the autonomy of modules: you will have to grant the initialization module  
authorization to access many sep arate data structures, belongin g to the various modules of  
the system and requiring specifi c initialization actions. This means that the author of the  
initialization module  will constantly have to peek into the int ernal data structures of the  
other modules, and interact with  their authors. This is incompa tible with the  
decomposability criterion. 
In the object-oriented method, every module will be responsible  for the initialization of  
its own data structures.As discussed below , 
top-down design is 
not as well suited to other modularity 
criteria .
A top-down 
hierarchyA
B D C
C1 I I1 C2 I2Sequence
Loop ConditionalTopmost functional abstraction
    
The term “temporal 
cohesion” comes from the method 
known as structured 
design ; see the bibli-
ographical notes .
MODULARITY  §3.1 42
Modular composability
Where decomposability was concer ned with the derivation of subs ystems from overall  
systems, composability addresses the reverse process: extractin g existing software  
elements from the cont ext for which they wer e originally design ed, so as to use them again  
in different contexts.
A modular design method should f acilitate this process by yield ing software  
elements that will be sufficient ly autonomous — sufficiently in dependent from the  
immediate goal that led to their  existence — as to make the ext raction possible. 
Composability is directly connected with the goal of reusabilit y: the aim is to find  
ways to design software elements performing well-defined tasks and usable in widely  
different contexts. Th is criterion reflects an old dream: trans forming the software design  
process into a construction box activity, so that we would buil d programs by combining  
standard prefabricated elements. 
•Example 1 : subprogram libraries . Subprogram libraries are designed as sets of  
composable elements. One of the areas where they have been succ essful is numerical  
computation, which commonly reli es on carefully designed subrou tine libraries to  
solve problems of linear algebra, finite elements, differential  equations etc. 
•Example 2 : Unix Shell conventions . Basic Unix commands operate on an input  
viewed as a sequential character  s t r e a m ,  a n d  p r o d u c e  a n  o u t p u t  with the same  
standard structure. This makes t hem potentially composable thro ugh the | operator  
of the command language (“shell”): A | B represents a program  which will take A’s 
input, have A process it, send the output to B as input, and have it processed by B. 
This systematic convention favors the co mposability of software  tools. 
•Counter-example : preprocessors . A popular way to extend the facilities of  
programming langua ges, and sometimes to correct some of their d eficiencies, is to  A method satisfies Modular Compos ability if it favors the produ ction of  
software elements which may then  be freely combined with each o ther to  
produce new systems, possibly in  an environment quite different  from the  
one in which they were  initially developed.
Composability
§3.1   FIVE CRITERIA 43
use “preprocessors” th at accept an extended  syntax as input and  map it into the  
standard form of the language. T ypical preproces s o r s  f o r  F o r t r a n and C support  
graphical primitives, extended co ntrol structures or database o perations. Usually,  
however, such extensio ns are not compatible;  then you cannot co mbine two of the  
preprocessors, leading to such di lemmas as whether to use graph ics or databases.
Composability  is independent of dec omposability. In fact , these criteria are  often at  
odds. Top-down design, for example, which we saw as a technique  f a v o r i n g  
decomposability, tends to produce modules that are not easy to combine with modules  
coming from other sources. This i s because the method suggests developing each module  
to fulfill a specific r equirement, corresp onding to a subproble m obtained at some point in  
the refinement process. Such mod ules tend to be closely linked to the immediate context  
that led to their development, a nd unfit for adaptation to othe r contexts. The method  
provides neither hints towards making modules more general than  immediately required,  
nor any incentives to do so; it helps neither avoid nor even ju st detect commonalities or  
redundancies between m odules obtained in dif ferent parts of the  hierarchy. 
That composability and decomposab ility are both part of the req uirements for a  
modular method reflects the inevi table mix of top-down and bott om-up reasoning — a  
complementarity that René Descartes had already noted almost fo ur centuries ago, as  
shown by the contrasting two paragraphs of the Discourse extract at the beginning of part B.
Modular understandability
The importance of this criterion follows from its influence on the maintenance process.  
Most maintenance activities, whe ther of the noble or not-so-nob le category, involve  
having to dig into existing soft ware elements. A method can har dly be called modular if a  
reader of the software is unabl e to understand its elements  separately.A method favors Modula r Understandability if it helps produce s oftware in  
which a human reader ca n understand each mo dule without having to know  
the others, or, at worst, by havi ng to examine only a few of th e others.The figure illustrat-
ing top-down design was on page 41 .
See “ABOUT 
SOFTWARE MAIN-
TENANCE”, 1.3, page 17 .
Understan-
dability
MODULARITY  §3.1 44
This criterion, like the others, applies to the modules of a sy stem description at any  
level: analysis, desig n, implementation. 
•Counter-example : sequential dependencies . Assume some modules have been so  
designed that they will  only function corre ctly if activated in  a certain prescribed  
order; for example, B can only work properly if you execute it after A and before C, 
perhaps because they are meant fo r use in “piped” form as in th e Unix notation  
encountered earlier:  
A | B | C 
Then it is probably hard to understand B without unde rstanding A and C too. 
In later chapters, the modular u nderstandability criterion will  help us address two  
important questions: how to docum ent reusable components; and h ow to index reusable  
components so that software deve lopers can retrieve them conven iently through queries.  
The criterion suggests that information about a component, usef ul for documentation or  
for retrieval, should whenever possible appear in the text of t he component itself; tools for  
documentation, indexing or retri eval can then process the compo nent to extrac t the needed  
pieces of information. Having the information included in each component is preferable  
to storing it elsewhere , for example in a da tabase of informati on about components. 
Modular continuity
This criterion is directly connec ted to the general goal of ext endibility. As emphasized in  
an earlier chapter, change is an integral part of the software construction process. The  
requirements will almost inevita bly change as the project progr esses. Continuity means  
that small changes should affect individual modules in the stru cture of the system, rather  
than the structure itself. 
The term “continuity” is drawn f rom an analogy with the notion of a continuous  
function in mathematical analysi s. A mathematical function is c ontinuous if (informally)  
a small change in the argument w ill yield a prop ortionally smal l change in the result. Here  
the function considered is the so ftware construction method, wh ich you can view as a  
mechanism for obtaining syst ems from specifications: 
software_construction_method : Specification  → SystemA method satisfies Modu lar Continuity if, in the software archi tectures that  
it yields, a small change in a p roblem specification will trigg er a change of  
just one module, or a sm all number of modules.See also , later in this 
chapter , “Self-
Documentation”, page 54 .
See “Extendibility”, 
page 6 .
§3.1   FIVE CRITERIA 45
This mathematical term  only provides an analogy, since we lack formal notions of  
size for software. More precisel y, it would be possible to defi ne a generally acceptable  
measure of what constitutes a “small” or “large” change to a pr ogram; but doing the same  
for the specifications  is more of a challenge. If we make no pr etense of full rigor, however,  
the concepts should be intuitively clear and correspond to an e ssential requir ement on any  
modular method. 
•Example  1: symbolic constants . A sound style rule bars the instructions of a program  
from using any numerical or text ual constant directly; instead,  they rely on symbolic  
names, and the actual values onl y appear in a constant definiti on (constant  in Pascal  
or Ada, preprocessor macros in C, P ARAMETER  in Fortran 77, constant attributes in  
the notation of this book). If th e value changes, the only thin g to update is the  
constant definition. This small but important rule is a wise pr ecaution for continuity  
since constants, in spite of the ir name, are remarkably prone t o change. 
•Example 2 : the Uniform Access principle . Another rule states that a single notation  
should be available to obtain the features of an object, whethe r they are represented  
as data fields or computed on demand. This property is sufficie ntly important to  
warrant a separate  discussion later in thi s chapter. 
•Counter-example 1 : using physical representations . A method in which program  
designs are patterned after the physical implementation of data  will yield designs  
that are very sensitiv e to slight changes in the environment. 
•Counter-example 2 : static arrays . Languages such as For tran or standard Pascal,  
which do not allow the declaration of arrays whose bounds will only be known at run  
time, make program evol ution much harder. 
Modular protection
A method satisfies Modu lar Protection if it yields architecture s in which the  
effect of an abnormal condition occurring at run time in a modu le will remain  
confined to that module, or at w orst will only propagate to a f ew neighboring  
modules.Continuity
This will be one of 
our principles of style: Symbolic 
Constant Principle , 
page 884 .
See “Uniform 
Access”, page 55.
MODULARITY  §3.2 46
The underlying issue, that of fa ilures and errors, is central t o software engineering. The  
errors considered here are run-ti me errors, resulting from hard ware failures, erroneous  
input or exhaustion of needed res ources (for example memory sto rage). The criterion does  
not address the avoidance or correction of errors, but the aspe ct that is directly relevant to  
modularity: their propagation.
•Example : validating input at the source . A method requiring that you make every  
module that inputs data also res ponsible for checking their val idity is good for  
modular protection. 
•Counter-example : undisciplined exceptions . Languages such as PL/I, CLU, Ada,  
C++ and Java support the notion of exception. An exception is a  special signal that  
may be “raised” by a certain ins truction and “handled” in anoth er, possibly remote  
part of the system. When the exception is raised, control is tr ansferred to the handler.  
(Details of the mechanism vary between languages; Ada or CLU ar e more disciplined  
in this respect than PL/I.) Such facilities make it possible to  decouple the algorithms  
for normal cases from the processing of erroneous cases. But th ey must be used  
carefully to avoid hindering modular protection. The chapter on  exceptions will  
investigate how to design a disciplined exception mechanism sat isfying the criterion.
3.2  FIVE RULES 
From the preceding criteria, five rules follow which we must ob serve to ensure  
modularity: 
• Direct Mapping. 
• Few Interfaces. 
•S m a l l  i n t e r f a c e s  (weak coupling). 
• Explicit Interfaces. 
• Information Hiding. 
The first rule addresses the co nnection between a software syst em and the external  
systems with which it is connect ed; the next four all address a  common issue — how  
modules will communicate. Obtain ing good modular architectures requires that  
communication occur in a cont rolled and disciplined way. The question of how 
to handle abnormal 
cases is discussed in 
detail in chapter 12 .
Protection 
violation
More on this topic in 
“Assertions are not an input checking mech-
anism”, page 345
On exception han-
dling , see chapter 12 . 
§3.2   FIVE RULES 47
Direct Mapping 
Any software system attempts to address the needs of some probl em domain. If you have  
a good model for describing that  d o m a i n ,  y o u  w i l l  f i n d  i t  d e s i r a b l e  t o  k e e p  a  c l e a r  
correspondence (mapping) between the structure of the solution,  as provided by the  
software, and the structure of t he problem, as described by the  model. Hence th e first rule:
This advice follows in particular from two of the modularity cr iteria: 
• Continuity: keeping a trace of t he problem’s modular structure  in the solution’s  
structure will make it easier to  assess and limit the impact of  changes. 
• Decomposability: if some work has already been done to analyze  the modular  
structure of the problem domain, it may provide a good starting  point for the modular  
decomposition of the software. 
Few Interfaces
The Few Interfaces rule restrict s the overall number of communi cation channels between  
modules in a softw are architecture: 
Communication may occur between modules in a variety of ways. M odules may call  
each other (if they are procedur es), share data structures etc.  The Few Interfaces rule limits  
the number of such  connections.
M o r e  p r e c i s e l y ,  i f  a  s y s t e m  i s  c o m p o s e d  o f  n modules, then the number of  
intermodule connections should re main much closer to the minimu m, n–1, shown as (A)
in the figure, than to the maximum, n (n – 1 ) /2, shown as (B).
This rule follows in particular from the criteria of continuity  and protectio n: if there  
are too many relations between modules, then the effect of a ch ange or of an error may  The modular structure devised in the process of building a soft ware system  
should remain compatible with an y modular structure devised in the process  
of modeling the problem domain.
Every module should communicate wi th as few others as possible.
Types of module 
interconnection 
structures
(A) (B) (C)
MODULARITY  §3.2 48
propagate to a large number of modules. It is also connected to  composability (if you want  
a module to be usable by itself i n a new environment, then it s hould not depend on too  
many others), understandability and decomposability. 
Case  (A) on the last figure shows a way to reach the minimum number of l inks, n  –
  1, through an extremely centralized structure: one master module ; everybody else talks to  
it and to it only. But there are also much more “egalitarian” s tructures, such as (C) which  
has almost the same number of links. In this scheme, every modu le just talks to its two  
immediate neighbors, but there i s no central authority. Such a style of design is a little  
surprising at first since it does not conform to the traditiona l model of functional, top-down  
design. But it can yield robust , extendible architectures; this  is the kind of structure that  
object-oriented techniques, prope rly applied, will tend to yiel d. 
Small Interfaces 
The Small Interfaces or “Weak Coupling” rule relates to the siz e of intermodule  
connections rather t han to their number: 
An electrical engineer would say that the channels of communica tion between  
modules must be of limited bandwidth:
The Small Interfaces requirement  follows in particular from the  criteria of continuity  
and protection.
An extreme counter-example is a Fortran practice which some readers will recognize:  
the “garbage common block”. A com mon block in Fortran is a dire ctive of the form 
COMMON /common_name / variable1,… variablen
indicating that the variables lis ted are accessible not just to  the enclosing module but also  
to any other module which includes a COMMON  directive with the same common_name . 
I t  i s  n o t  i n f r e q u e n t  t o  s e e  F o r t r an systems whose every module includes an identical  
gigantic COMMON  directive, listing all significan t variables and arrays so tha t every  
module may directly use  every piece of data. If two modules communicate, they  should exchange as little info rmation as  
possible
Communication
bandwidth between 
modules
zx, y
§3.2   FIVE RULES 49
The problem, of course, is that every module may also misuse th e common data, and  
hence that modules are tightly coupled to each other; the probl ems of modular continuity  
(propagation of changes) and prot ection (propagation of errors)  are particularly nasty. This  
time-honored technique has never theless remained a favorite, no  doubt accounting for  
many a late-night d ebugging session.
Developers using languages with nested structures can suffer fr om similar troubles.  
With block structure a s introduced by Algol and retained in a m ore restricted form by  
Pascal, it is possible to in clude blocks, delimited by begin  … end pairs, within other  
blocks. In addition every block may introduce its own variables , which are only  
meaningful within the syntactic scope of the block. For example :
local -- Beginning of block  B1
x, y: INTEGER
do
… Instructions of B1 …
local  -- Beginning of block  B2
z: BOOLEAN
do
… Instructions of B2 …
end --- of block  B2
local  -- Beginning of block  B3
y, z: INTEGER
do
… Instructions of B3 …
end -- of block  B3
… Instructions of B1 (continued) …
end -- of block  B1
Variable x is accessible to all instructions throughout this extract, whe reas the two  
variables called z (one BOOLEAN , the other INTEGER ) have scopes limited to B2 and B3
respectively. Like x, variable y is declared at the level of B1, but its scope does not include  
B3, where another variable of the same name (and also of type INTEGER ) locally takes  
precedence over the outermost y. In Pascal this form of bloc k structure exists only for  
blocks associated wi th routines (procedures and functions).
With block structure, the equiva lent of the Fortran garbage com mon block is the  
practice of declaring all variabl es at the topmost level. (The equivalent in C-based  
languages is to introduce al l variables as external.) 
Block structure, although an ing enious idea, introduces many op portunities to  
violate the Small Interfaces rul e. For that reason we will refr ain from using it in the object-
oriented notation devised later in this book, esp ecially since the experience of Simula, an  
object-oriented Algol derivative supporting block structure, sh ows that the ability to nest  
classes is redundant with some o f the facilities provided by in heritance. The architecture  The Body of a block 
is a sequence of 
instructions . The syn-
tax used here is com-
patible with the 
notation used in sub-sequent chapters , so 
it is not exactly 
Algol’s . “
--” intro-
duces a comment . 
On clusters see 
chapter 28 . The 
O-O alternative to 
nesting is studied in “The architectural 
role of selective 
exports”, page 209 .
MODULARITY  §3.2 50
of object-oriented software will involve three levels: a system  is a set of clusters; a cluster  
i s  a  s e t  o f  c l a s s e s ;  a  c l a s s  i s  a set of features (attributes a nd routines). Clusters, an  
organizational tool rather than a linguistic construct, can be nested to allow a project leader  
to structure a large system in as many levels as necessary; but  classes as well as features  
have a flat structure, since nesting at either of those levels would cause unnecessary  
complication.
Explicit Interfaces
With the fourth rule, we go one step further in enforcing a tot alitarian regime upon the  
society of modules: not only do we demand that any conversation  be limited to few  
participants and consist of just a few words; we also require t hat such conversations must  
be held in public and loudly!
Behind this rule stand the criteria of decomposability and comp osability (if you need  
to decompose a module into sever al submodules or compose it wit h other modules, any  
outside connection should be clearly visible), continuity (it s hould be easy to  find out what  
elements a potential change may a ffect) and understandability ( how can you understand A
by itself if B can influence its behavio r in some devious way?). 
One of the problems in applying the Explicit Interfaces rule is  that there is more to  
intermodule coupling than procedu re call; data sharing, in part i c u l a r ,  i s  a  s o u r c e  o f  
indirect coupling: 
Assume that module A modifies and module B uses the same data item x. Then A and 
B are in fact strongl y coupled through x even though there may be  no apparent  connection,  
such as a procedure call, between them. Whenever two modules A and B communicate, this mus t be obvious from the  
text of A or B or both.
Data sharingModule
AModule
B
Data
item
xmodifies accesses
§3.2   FIVE RULES 51
Information Hiding 
The rule of Information Hidi ng may be stated as follows:
Application of this rule assumes that every module is known to the rest of the  
world (that is to say, to designers of other modules) through s ome official description,  
or public properties.
Of course, the whole text of the module itself (program text, d esign text) could serve  
as the description: it provides a correct view of the module si nce it is the module! The  
Information Hiding rul e states that this should not in general be the case: the description  
should onl y include some  of the module’s properties. The  rest should rem ain non-public,  
or secret . Instead of public and secret properties, one may also talk of  exported and private  
properties. The public properties  of a module are also known as  t h e  interface  of the  
module (not to be confused with the user interface of a softwar e system). 
The fundamental reason behind the rule of Information Hiding is  t h e  c o n t i n u i t y  
criterion. Assume a module change s, but the changes apply only to its secret elements,  
leaving the public ones untouched; then other modules who use i t, called its clients , will 
not be affected. The smaller the public part, the higher the ch ances that changes to the  
module will indeed b e in the s ecret part.
We may picture a module supporti ng Information Hi ding as an ice berg; only the tip  
— the interface — is visible to t he clients. The designer of every module must select a subset of the module ’s properties  
as the official information abou t the module, to be made availa ble to authors  
of client modules.
A module under 
Information 
Hiding
Secret PartPublic Part
MODULARITY  §3.2 52
As a typical example, consider a  procedure for retrieving the a ttributes associated  
with a key in a certain table, such as a personnel file or the symbol table of a compiler. The  
procedure will internally be very different depending on how th e table is stored (sequential  
array or file, hash table, binar y or B-Tree etc.). Information hiding implies that uses of this  
procedure should be ind ependent of the part icular implementatio n chosen. That way client  
modules will not suffer from a ny change in implementation. 
Information hiding emphasizes sep aration of function from imple mentation. Besides  
continuity, this rule is also re lated to the criteria of decomp osability, com posability and  
understandability. You cannot develop the modules of a system s eparately, combine  
various existing modules, or understand individual modules, unl ess you know precisely  
what each of them may and may not expect from the others. 
Which properties of a module sho uld be public, and which ones s ecret? As a general  
guideline, the public part should  include the specification of the module’s functionality;  
anything that relates to the impl ementation of that functionali ty should be kept secret, so  
as to preserve other modules fro m later reversals of implementa tion decisions. 
This first answer is still fairly vague, however, as it does no t tell us what is the  
specification and what is the impl ementation; in fact, one migh t be tempted to reverse the  
definition by stating that the s pecification consists of whatev er public properties the  
module has, and the implementation of its secrets! The object-o riented approach will give  
us a much more precise guideline thanks to the theory of abstra ct data types. 
To understand information hiding  and apply the rule properly, i t is important to avoid  
a common misunderstanding. In spite of its name, information hi ding does not imply  
protection in the sense of security restrictions — physically prohibiting authors of client  
modules from accessing the intern al text of a supplier module. Client authors may well be  
permitted to read all the details they want: preventing them fr om doing so may be  
reasonable in some circumstances , but it is a pr oject managemen t decision which does not  
necessarily follow from the information hiding rule. As a techn ical requirement,  
information hiding mea ns that client modules (whether or not th eir authors are permitted  
to read the secret properties of  suppliers) should only rely on  the suppliers’ public  
properties. More precisely, it sh ould be impossibl e to write cl ient modules whose correct  
functioning depends on  secret information. 
In a completely formal approach to software construction, this definition would be stated  
as follows. To prove the correctness of a module, you will need  to assume some properties  
about its suppliers. Information hiding means that such proofs are only permitted to rely  
on public properties of the supp liers, never on their secret pr operties. 
Consider again the example of a module providing a table search ing mechanism.  
Some client module, which might belong to a spreadsheet program , uses a table, and relies  
on the table module to look for a certain element in the table.  Assume further that the  
algorithm uses a binary search t ree implementation, but that th is property is secret — not  
part of the interface. Then you may or may not allow the author  of the table searching  
module to tell the aut hor of the spreadsheet program what imple mentation he has used for  
tables. This is a project manage ment decision, or perhaps (for commercially released  
software) a marketing decision; in either case it is irrelevant  to the question  of information  See chapter 6 , in par-
ticular “Abstract 
data types and infor-
mation hiding”, page 144 . 
See the comments on 
conditional correct-
ness on page 4.
§3.3   FIVE PRINCIPLES 53
hiding. Information hiding m eans something else: that even if the author of the  
spreadsheet program knows that the implementat ion uses a binary search tree, he should  
b e  u n a b l e  t o  w r i t e  a  c l i e n t  m o d u le which will only function cor rectly with this  
implementation — and would not work any more if the table imple mentation was changed  
to something else, such as hash coding. 
One of the reasons for the misunderstanding mentioned above is the very term  
“information hiding”, which tend s to suggest physical protectio n. “Encapsulation”,  
sometimes used as a synonym for information hidi ng, is probably  preferable in this  
respect, although this discussion  will retain the more common t erm. 
As a summary of this d iscussion: the key to  information hiding is not management  
or marketing policies as to who may or may not access the sourc e text of a module, but  
strict language rules  to define what access rights a module has on properties of its  
suppliers. As explained in the n ext chapter, “encapsulation lan guages” such as Ada and  
Modula-2 made the first steps in the right direction. Object te chnology will bring a more  
complete solution.
3.3  FIVE PRINCIPLES
From the preceding rules, and in directly from the criteria, fiv e principles of software  
construction follow: 
• The Linguistic Modu lar Units principle.
• The Self-Documenta tion principle.
• The Uniform Acc ess principle. 
• The Open-Clos ed principle. 
• The Single Choice principle. 
Linguistic Modular Units
The Linguistic Modular Units principle expresses that the forma lism used to describe  
software at various le vels (specifications, designs, implementa tions) must support the  
view of modularity retained:
The language mentioned may be a programming language, a design language, a  
sp ec i fi c at io n l an gu ag e e tc .  I n t he  ca se  of  pr og ra m m i ng  la ng ua ge s, modules should be  
separately compilable. Linguistic Modular Units principle
Modules must correspond to synt actic units in the language used .By default “Ada” 
always means the most 
widespread form of the language (83), not the 
more recent Ada 95. 
Chapter 33 presents both versions.
MODULARITY  §3.3 54
What this principle excludes at any level — analysis, design, i mplementation — is  
combining a method tha t suggests a certain module concept and a  language that does not  
offer the corresponding modular construct, forcing software dev elopers to perform manual  
translation or restructuring. It is indeed not uncommon to see companies hoping to apply  
certain methodological concepts ( such as modules in the Ada sen se, or object-oriented  
principles) but then implement the result in a programming lang uage such as Pascal or C  
which does not support them. Such an approach defeats several o f the modularity criteria: 
• Continuity: if module boundaries in the final text do not corr espond to the logical  
decomposition of the specificati on or design, it will be dif fic ult or impossible to  
maintain consistency between the various levels when the system  evolves. A change  
of the specification may be considered small if it affects only  a small number of  
specification modules; to ensure continuity, there must be a di rect correspondence  
between specification, design and implementation modules. 
• Direct Mapping: to maintain a c lear correspondence between the  structure of the  
model and the structure of the solution, you must have a clear syntactical  
identification of the conceptual  units on both sides, reflectin g the division suggested  
by your development method.
• Decomposability: to divide syste m development into separate ta sks, you need to  
make sure that every task result s in a well-delimited syntactic  u n i t ;  a t  t h e  
implementation stage, these units  must be separately compilable . 
• Composability: how could we com bine anything other than module s with  
unambiguous syntac tic boundaries? 
• Protection: you can only hope to control the scope of errors i f modules are  
syntactically delimited. 
Self-Documentation
Like the rule of Information Hid ing, the Self-Do cumentation pri nciple governs how we  
should document modules:
What this precludes is the commo n situation in which informatio n about the module  
is kept in separate project documents.
The documentation under review here is internal  documentation about components of  
the software, not user documentation about the resulting product, which may require  
separate products, whether pape r, CD-ROM or Web pages — althoug h, as noted in the  
discussion of software quality, one may see in the modern trend  towards providing more  
and more on-line help a consequ ence of the same general idea.
The most obvious justification fo r the Self-Documentation princ iple is the criterion  
of modular understandability. Perhaps more important, however, is the role of this  Self-Documentation principle
The designer of a module should strive to make all information about the  
module part of the module itself.
“About documen-
tation”, page 14 . 
§3.3   FIVE PRINCIPLES 55
principle in helping to meet the continuity criterion. If the s oftware and its documentation  
are treated as separate entities, it is difficult to guarantee that they will remain compatible  
— “in sync” — when things start changing. Keeping everything at  the same place,  
although not a guarantee, is a g ood way to help maintain this c ompatibility.
Innocuous as this principle may seem at first, it goes against much of what the  
software engineering literature has usually suggested as good s oftware development  
practices. The dominant view is t hat software developers, to de serve the title of software  
engineers, need to do what other engineers are supposed to: pro duce a kilogram of paper  
for every gram of actual deliver able. The encour agement to keep  a record of the software  
construction process is good advi ce — but not the implication t hat software and its  
documentation are different products. 
Such an approach ignor es the specific proper ty of software, whi ch again and again  
comes back in this dis cussion: its changeab ility. If you treat the two products as separate,  
you risk finding yourself quickly in a situation where the docu mentation says one thing  
and the software does something else. If there is any worse sit uation than having no  
documentation, it must be ha ving wrong documentation.
A major advance of the past few years has been the appearance o f quality standards  for 
software, such as ISO certification, the “2167” standard and it s successors from the US  
Department of Defense, and the  Capability Maturity Model of the  Software Engineering  
Institute. Perhaps because they often sprang out of models from  other disciplines, they  
tend to specify a heavy paper trail. Several of these standards  could have a stronger effect  
on software quality (beyond providing a mechanism for managers to cover their bases in  
case of later trouble) by enforcing the Self-Documentation prin ciple.
This book will draw on the Self-Do cumentation principle to defi ne a method for  
documenting classes — the modules of object-oriented software c onstruction — that  
includes the documentation of ev ery module in the module itself . Not that the module is 
its documentation: there is usua lly too much detail in the soft ware text to mak e it suitable  
as documentation (this was the a rgument for information hiding) . Instead, the module  
should contain its documentation.
In this approach software become s a single product that support s multiple views . 
One view, suitable for compilati on and execution, is the full s ource code. Another is the  
abstract interface documentation of each module, enabling softw are developers to write  
client modules without having to learn the module’s own interna ls, in accordance with the  
rule of Informati on Hiding. Other views are possible.
W e  w i l l  n e e d  t o  r e m e m b e r  t h i s  r u l e  w h e n  w e  e x a m i n e  t h e  q u e s t i o n  o f  h o w  t o  
document the classes o f object-oriented software construction.
Uniform Access 
Although it may at first appear just to address a notational is sue, the Uniform Access  
principle is in fact a design ru le which influen ces many aspect s of object-oriented design  
and the supporting notation. It follows from the Continuity cri terion; you may also view  
it as a special case of  Information Hiding. “Using assertions 
for documentation: 
the short form of a 
class”, page 389. See also chapter 23 and 
its last two exercises.
Also known as the 
Uniform Reference principle . 
MODULARITY  §3.3 56
Let x be a name used to access a cert ain data item (w hat will later be called an object)  
and f the name of a feature applicable to x. (A feature is an operation; this terminology will  
also be defined more precisely.) For example, x might be a variable representing a bank  
account, and f the feature that yields an acco unt’s current balance. Uniform Access  
addresses the question  of how to express th e result of applying  f to x, using a no tation that  
does not make any premat ure commitment as to how f is implemented.
In most design and programming lan guages, the expression denoti ng the application  
of f to x depends on what implementation the original software developer  has chosen for  
feature f: is the value stored along with x, or must it be computed whenever requested?  
Both techniques are po ssible in the example of accounts and the ir balances:
A1 • Y ou may represent the balance as one of the fields of the reco rd describing each  
account, as shown in the figure. With this technique, every ope ration that changes  
the balance must take care of updating the balance  field.
A2 • Or you may define a function which computes the balance using other fields of the  
record, for example fields repre senting the lists of withdrawal s and deposits. With  
this technique the balance of an account is not stored (there i s no balance field) but  
computed on demand.
A common notation, in l anguages such as Pascal, Ada, C, C++ and  Java, uses x    f in 
case A 1 and f (x) in case A 2.
Choosing between representations A 1 a n d  A 2 i s  a  s p a c e - t i m e  t r a d e o f f :  o n e  
economizes on computation, the oth er on storage. The resolution  of this tradeoff in favor  
of one of the solutions is typic al of representation decisions that developers often reverse  
at least once during a project’s lifetime. So for continuity’s sake it is desirable to have a  
feature access notation that doe s not distinguish  between the t wo cases; then if you are in  
charge of x’s implementation and change you r mind at some stage, it will n ot be necessary  
to change the modules that use f. This is an example of the Uniform Access  principle.Two 
representation for a bank 
accountdeposits_list
withdrawals_list
balance(A1)
(A2)deposits_list
withdrawals_list
§3.3   FIVE PRINCIPLES 57
In its general form the prin ciple may be e xpressed as:
Few languages satisfy this princi ple. An older one that did was  Algol W, where both  
the function call and the ac cess to a field were written a (x). Object-oriented languages  
should satisfy Uniform Access, as did the first of them, Simula  67, whose notation is x   f
in both cases. The notat ion developed in part C will retain this convention.
The Open-Closed principle 
Another requirement t hat any modular decomposition technique mu st satisfy is the Open-
Closed principle:
The contradiction between the tw o terms is only apparent as the y correspond to goals  
of a different nature: 
• A module is said to be open if it is still available for exten sion. For example, it should  
be possible to expand i ts set of operations or add fields to it s data structures.
• A module is said to be closed if it is available for use by ot her modules. This assumes  
that the module has been given a  well-defined, stable descripti on (its interface in the  
sense of information hiding). At the implementation level, clos ure for a module also  
implies that you may compile it, perhaps store it in a library,  and make it available  
for others (its clients ) to use. In the case of a design or specification module, clos ing 
a module simply means having it approved by management, adding it to the project’s  
official repository of accepted software items (often called th e project baseline ), and 
publishing its interface for the  benefit of other module author s. 
The need for modules to be closed, and the need for them to rem ain open, arise for  
different reasons. Openness is a natural concern for software d evelopers, as they know that  
it is almost impossible to fores ee all the elements — data, ope rations — that a module will  
need in its lifetime; so they will wish to retain as much flexi bility as possible for future  
changes and extensions. But it is just as necessary to close mo dules, especially from a  
project manager’s viewpoint: in a system comprising many module s, most will depend on  
s o m e  o t h e r s ;  a  u s e r  i n t e r f a c e  m o d u l e  m a y  d e p e n d  o n  a  p a r s i n g  m o dule (for parsing  
command texts) and on a graphics module, the parsing module its elf may depend on a  Uniform Access principle
All services offered by a module  should be available through a uniform  
notation, which does not betray w h e t h e r  t h e y  a r e  i m p l e m e n t e d  t h rough 
storage or through computation.
Open-Closed principle
Modules should be both open and closed.
MODULARITY  §3.3 58
lexical analysis module, and so on. If we never closed a module  until we were sure it  
includes all the needed features , no multi-module software woul d ever reach completion:  
every developer would always be waiting for the completion of s omeone else’s job. 
With traditional techniques, the  t w o  g o a l s  a r e  i n c o m p a t i b l e .  E i t h e r  y o u  k e e p  a  
module open, and other s cannot use it yet; or you close it, and  any change or extension can  
trigger a painful chain reaction of changes in many other modul es, which relied on the  
original module directly or indirectly. 
The two figures below illustrate a typical situation where the needs for open and  
c l o s e d  m o d u l e s  a r e  h a r d  t o  r e c o n c i l e .  I n  t h e  f i r s t  f i g u r e ,  m o d u le A is used by client  
modules B, C, D, which may themselv es have their own  clients ( E, F, …).
Later on, however, the situation is disrupted by the arrival of  new clients — B' and 
others — which need an extended or adapted version of A, which we  may call  A': 
With non-O-O methods, there seem to be only two solutions, equa lly unsatisfactory:
N1 • You may adapt module A so that it will offer the extended or modified functionality  
(A'  ) required by the new clients. 
N2 • You may also decide to leave A as it is, make a copy, change the module’s name to  
A' in the copy, and perform all the necessary adaptations on the new module. With  
this technique  A' retains no further connection to A.A module and 
its clients B A C E
D
Client of
Old and new 
clients
F A'
GI HB A C E
D
§3.3   FIVE PRINCIPLES 59
The potential for disaster with solution N 1 is obvious. A may have been around for  
a long time and have many clients such as B, C and D. The adaptations needed to satisfy  
the new clients’ requirements may invalidate the assumptions on  the basis of which the  
old ones used A; if so the change to A may start a dramatic series of changes in clients,  
clients of clients and so on. Fo r the project ma nager, this is a nightmare come true:  
suddenly, entire parts of the so ftware that were supposed to ha ve been finished and sealed  
off ages ago get reopened, triggering a new cycle of developmen t, testing, debugging and  
documentation. If many a software project manager has the impre ssion of living the  
Sisyphus syndrome — the  impression of being sentenced forever t o carry a rock to the top  
of the hill, only to see it roll back down each time — it is fo r a large part because of the  
problems caused by thi s need to reopen previously closed module s. 
On the surface, solution N 2 seems better: it avoids the Sisyphus syndrome since it  
does not require modif ying any existing software (anything in t he top half of the last  
figure). But in fact this solution may be even more catastrophi c since it only postpones the  
day of reckoning. If you extrap olate its effects to many module s, many modification  
requests and a long period, the consequences are appalling: an explosion of variants of the  
original modules, many of them v ery similar to each other altho ugh never quite identical.
In many organizations, this abundance of modules, not matched b y abundance of  
available functionalit y (many of the apparen t variants being in  fact quasi-clones), creates  
a huge configuration management problem, which people atte mpt to address through the  
use of complex tools. U seful as these tools  may be, they offer a cure in an area where the  
first concern should be preventi on. Better avoid redundancy tha n manage it.
Configuration management will remain useful, of course, if only  to find the modules  
which must be reopened after a  change, and to avoid unneeded mo dule recompilations.
But how can we have modules that are both open and closed? How can we keep A
and everything in the top part o f the figure unchanged, while p roviding A' to the bottom  
clients, and avoiding duplicatio n of software? The object-orien ted method will offer a  
particularly elegant contribu tion thanks to inheritance. 
The detailed study of inheritance appears in later chapters, bu t here is a preview of  
the basic idea. To get us out of the change or redo dilemma, inheritance will allow us to  
define a new module A' in terms of an existing module A by stating the differences only.  
We will write A' as 
class  A' inherit
Aredefine f, g, … end
feature
f …
g …
…
u …
…
endExercise E3.6, page 
66, asks you to dis-
cuss how much need 
will remain for con-figuration manage-
ment in an O-O 
context .
MODULARITY  §3.3 60
where the feature  clause contains both the defini tion of the new features specif ic to A', 
such as u, and the redefinition of those features (such as f, g, …) whose form in A' is 
different from the one they had in A. 
The pictorial representation for  inheritance will use an arrow from the heir (the new  
class, here A' ) to the parent  (here A): 
Thanks to inheritance, O-O develo pers can adopt a much more inc remental approach  
to software development than use d to be possible  with earlier m ethods. 
One way to describe the open-closed principle and the consequen t object-oriented  
techniques is to think of them as a organized hacking . “Hacking” is understood here as a  
slipshod approach to building and modifying code (not in the mo re recent sense of breaking  
into computer networks, which, organized or not, no one should condone). The hacker may  
seem bad but often his heart is pure. He sees a useful piece of  software, which is almost
able to address the needs of the moment, more general than the software’s original purpose.  
Spurred by a laudable desire not  to redo what can be reused, ou r hacker starts modifying  
the original to add provisions f or new cases. The impulse is go od but the effect is often to  
pollute the software with many clauses of the form if that_special_case  then …, so that  
after a few rounds of hacking, p erhaps by a few different hacke rs, the software starts  
resembling a chunk of Swiss chees e that has been left outside f or too long in August (if the  
tastelessness of thi s metaphor may be for given on the grounds t hat it does its best to convey  
the presence in such softwar e of both holes and growth).
The organized form of hacking wi ll enable us to cater to the va riants without  
affecting the consistency of the original version.
A word of caution: nothing i n this discussion suggests disorganized hacking.  
In particular:
• If you have control over the original software and can rewrite  it so that it will address  
the needs of several kinds of cl ient at no extra complication, you should do so.Adapting a 
module to new 
clients
F A'
GI HB A C E
DInherits from
Client of
§3.3   FIVE PRINCIPLES 61
• Neither the Open-Closed principle nor redefinition in inherita nce is a way to address  
design flaws, le t alone bugs. If there is somethin g wrong with a module , you should  
fix it — not leave the original as it is and try to correct the proble m in a derived  
module. (The only potential excep tion to this rule is the case of flawed software  
which you are not at liberty to modify.) The Open-Closed princi ple and associated  
techniques are intended for the adaptation of healthy modules: modules that,  
although they may not suffice fo r some new uses, meet their own  well-defined  
requirements, to the satisf action of their own clients.
Single Choice
The last of the five modularity principles may be viewed as a c onsequence of both the  
Open-Closed and Inform ation Hiding rules. 
Before examining the Single Choi ce principle in its full genera lity, let us look at a  
typical example. Assume you are building a system to manage a l i b r a r y  ( i n  t h e  n o n -
software sense of the term: a co llection of books and other pub lications, not software  
modules). The system will manipu late data structures representi ng publications. You may  
have declared the corr esponding type as fo llows in Pascal-Ada s yntax: 
type PUBLICATION =
record
author , title: STRING ;
publication_  year: INTEGER
case pubtype : (book , journal , conference_proceedings ) of
book : (publisher : STRING );
journal : (volume , issue : STRING );
proceedings : (editor , place : STRING )   -- Conference proceedings
end
This particular form uses the Pa scal-Ada notion of “record type  with variants” to  
describe sets of data structures with some fields (here author , title, publication_year ) 
common to all instances, and othe rs specific to i ndividual vari ants.
The use of a particular syntax is not crucial here; Algol 68 an d C provide an equivalent  
mechanism through the notion of union type. A union type is a t ype T defined as the union  
of pre-existing types A, B, …: a value of type  T is either a value of type A, or a value of  
type B, … Record types with variants have t he advantage of clearly associ ating a tag, here  
book , journal , conference_proceedings , with each variant.
Let A be the module that contains the above declaration or its equiv alent using  
another mechanism. As long as A is considered open, you may  add fields or introduce new  
variants. To enable  A to have clients, however, you must close the module; this mean s that 
you implicitly consider that you  have listed all the relevant f ields and variants. Let B be a 
typical client of A. B will manipulate publications through a variable such as 
p: PUBLICATION
MODULARITY  §3.3 62
and, to do just about anything useful with p, will need to discriminate explicitly between  
the various cases, as in: 
case p of
book : … Instructions which may access the field  p   publisher …
journal : … Instructions which  may access fields  p   volume , p   issue …
proceedings : … Instructions which may access fields  p   editor , p   place …
end
The case instruction of Pascal and Ada co m e s  i n  h a n d y  h e r e ;  i t  i s  o f  c o urse on  
purpose that its syntax mirrors the form of the declaration of a record type with variants.  
Fortran and C will emulate the ef fect through multi-target goto  instructions ( switch  in C).  
In these and other languages a mu lti-branch conditional instruc tion ( if … then  … elseif
… elseif  … else … end) will also do the job. 
Aside from syntactic v ariants, the principa l observation is tha t to perform such a  
discrimination every client must  know the exact list of variant s of the notion of publication  
supported by A. The consequence is easy to foresee. Sooner or later, you will  realize the  
need for a new variant, such as technical reports of companies and universities. Then you  
will have to extend the definition of type PUBLICATION  in module A to support the new  
case. Fair enough: you have modifi ed the conceptual notion of p ublication, so you should  
update the corresponding type dec laration. This change is logic al and inevitable. Far  
harder to justify, however, is the other consequence: any clien t of A, such as B, will also  
require updating if it used a structure such as the above, rely ing on an explicit list of cases  
for p. This may, as we have seen, b e the case for most clients. 
What we observe here is a disast rous situation fo r software cha nge and evolution:  
a simple and natural addition ma y cause a chain reaction of cha nges across many client  
modules. 
The issue will arise whenever a certain notion admits a number of variants. Here the  
notion was “publication” and its i nitial variants were book, jo urnal article, conference  
proceedings; other typi cal examples include: 
• In a graphics system: the notio n of figure, with such variants  as polygon, circle,  
ellipse, segment and oth er basic figure types.
• In a text editor: the notion of user command, with such varian ts as line insertion, line  
deletion, character deletion, glo bal replacement of a word by a nother.
• In a compiler for a programming language, the notion of langua ge construct, with  
such variants as instructi on, expression, procedure.
In any such case, we must accept the possibility that the list of variants, although  
fixed and known at some point of the software’s evolution, may later be changed by the  
addition or removal of variants. To support our long-term, soft ware engineering view of  
the software constru ction process, we mu st find a way to protect  the software’s structure  
against the effects of such chan ges. Hence the Single Choice pr inciple:
§3.3   FIVE PRINCIPLES 63
By requiring that knowledge of the list of choices be confined to just one module, we  
prepare the scene for later chan ges: if variants are added, we will only have  to update the  
module which has the information  — the point of single choice. All others, in particular  
its clients, will be able to con tinue their business as usual. 
Once again, as the publications e xample shows, traditional meth ods do not provide  
a solution; once again, object te chnology will show the way, he re thanks to two techniques  
connected with inheritance: poly morphism and dynamic binding. N o sneak preview in  
this case, however; th ese techniques must be understood in the context of the full method. 
The Single Choice principle pr ompts a few more comments: 
• The number of modules that know  the list of choices should be,  according to the  
principle, exactly one. The modu larity goals suggest that we wa nt at most one  
module to have this knowledge; bu t then it is also clear that at least one module must  
possess it. You cannot write an editor unless at least one comp onent of the system  
has the list of all supported co mmands, or a graphics system un less at least one  
component has the list of all sup ported figure types, or a Pasc al compiler unless at  
least one component “knows” the list of Pascal constructs.
• Like many of the othe r rules and principles studied in this ch apter, the principle is  
about distribution of knowledge  in a software system. T his question is indeed  
crucial to the search for extendible, reusable software. To obt ain solid, durable  
system architectures you must take stringent steps to limit the  amount of information  
available to each module. By ana logy with the methods employed by certain human  
organizations, we may call this a need-to-know  policy: barring every module from  
accessing any information that i s not strictly required for its  proper functioning. 
•You may view the Single Choice principle as a direct consequenc e of the Open-
Closed principle. Consider the p ublications example in light of  t h e  f i g u r e  t h a t  
illustrated the need for open-closed modules: A is the module which includes the  
original declaration of type PUBLICATION ; the clients  B, C, … are the modules that  
relied on the initial  list of variants; A' is the updated version of A offering an extra  
variant (techni cal reports). 
• You may also understand the pri nciple as a strong form of Info rmation Hiding. The  
designer of supplier modules such as A and A' seeks to hide information (regarding  
the precise list of va riants available for a  certain notion) fr om the clients. Single Choice principle
Whenever a software system must support a set of alternatives, one and only  
one module in the system shoul d know their exhaustive list.
See “DYNAMIC 
BINDING”, 14.4, 
page 480 .
See the second figure 
on page 58 .
MODULARITY  §3.4 64
3.4  KEY CONCEPTS INTRO DUCED IN THIS CHAPTER 
• T h e  c h o i c e  o f  a  p r o p e r  m o d u l e  s t r u c t u r e  i s  t h e  k e y  t o  a c h i e v i n g the aims of  
reusability and extendibility. 
• Modules serve for both software decomposition (the top-down vi ew) and software  
composition (bottom-up).
• Modular concepts apply to spec ification and design as well as implementation. 
• A  comprehensive definition of m odularity must co mbine several perspectives; the  
various requirements ma y sometimes appear at odds with each oth er, as with  
decomposability (which encourages  top-down methods ) and composa bility (which  
favors a bottom- up approach). 
• Controlling the amount and form  of communication between modul es is a  
fundamental step in producing a good modular architecture. 
• The long-term integrity of modul ar system structures requires information hiding,  
which enforces a rigorous separa tion of interface and implement ation. 
• Uniform access frees clients fr om internal representation choi ces in their suppliers.
• A closed module is one  that may be used, t hrough its interface , by client modules. 
• An open module is one that is still subject to extension. 
• Effective project management re quires support fo r modules that  are both open and  
closed. But traditional approach es to design a nd programming do  not permit this. 
• The principle of Single Choice directs us to limit the dissemi nation of exhaustive  
knowledge about varian ts of a certain notion.
3.5  BIBLIOGRAPHICAL NOTES 
The design method known a s “structured design” [Yourdon  1979]  emphasized the  
importance of modular structures. It was based on an analysis o f module “cohesion” and  
“coupling”. But the view of modul es implicit in structured desi gn was influenced by the  
traditional notion of subroutine , which limits the scope of the  discussion. 
The principle of uniform access comes originally (under the nam e “uniform  
reference”) from [Geschke 1975] . 
The discussion of uniform access cited the Algol W language, a successor to Algol  
60 and forerunner to Pascal (but offering some interesting mech anisms not retained in  
Pascal), designed by Wirth and Hoare  and described in [Hoare 1966] . 
Information hiding was  introduced in two milestone articles by David Parnas [Parnas  
1972]  [Parnas 1972a] .
§E3.1   EXERCISES 65
Configuration management tools that will recompile the modules affected by  
modifications in other modules, based on an explicit list of mo dule dependencies, are  
based on the ideas of the Make  tool, originally for Unix [Feldman 1979] . Recent tools —  
there are many on the market — have added considerable function ality to the basic ideas.
Some of the exercises below ask you to develop metrics to evalu ate quantitatively  
the various informal measures o f modularity developed in this c hapter. For some results  
in O-O metrics, see the wo rk of Christine Mingins [Mingins 1993]  [Mingins 1995]  and 
Brian Henderson-Sellers [Henderson-Sellers 1996a] .
EXERCISES
E3.1  Modularity in pr ogramming languages
Examine the modular st ructures of any prog ramming language whic h you know well and  
assess how they support the crit eria and principles developed i n this chapter. 
E3.2  The Open-Closed princ iple (for Lisp programmers) 
Many Lisp implementations associ ate functions wi th function nam es at run time rather  
than statically. Does this featur e make Lisp more supportive of  the Open-Clos ed principle  
than more static languages? 
E3.3  Limits to information hiding
Can you think of circu mstances where information hiding should not be applied to  
relations between modules? 
E3.4  Metrics for modularity (term project) 
The criteria, rules and principl es of modularity of this chapte r were all intro duced through  
qualitative definitions. Some of them, however, may be amenable  to quantitative analysis.  
The possible candidates include: 
• Modular continuity. 
• Few Interfaces. 
•S m a l l  I n t e r f a c e s .  
• Explicit Interfaces. 
• Information Hiding. 
•S i n g l e  C h o i c e .  
Explore the possibility of devel oping modularity metrics to eva luate how modular a  
software architecture is accordi ng to some of these viewpoints.  The metrics should be  
size-independent: incr easing the size of a system without chang ing its modular structure  
should not change its complexity  measures. (See also the next e xercise.) 
MODULARITY  §E3.5 66
E3.5  Modularity of existing systems
Apply the modularity criteria, rules and principles of this cha pter to evaluate a system to  
which you have access. If you hav e answered the previous exerci se, apply any proposed  
modularity metric. 
Can you draw any correlations between the results of this analy sis (qualitative,  
quantitative or both) and assessments of structural complexity for the systems under study,  
based either on informal analysi s or, if available, on actual m easurements of debugging  
and maintenance costs? 
E3.6  Configuration man agement and inheritance
(This exercise assumes knowledge  of inheritance techniques desc ribed in the rest of this  
book. It is not applicable if yo u have read this chapter as par t of a first, sequential reading  
of the book.) 
The discussion of the open-close d principle indicated that in n on-object-oriented  
approaches the absence of inheri tance places undue burden on co nfiguration management  
tools, since the desire to avoid  reopening closed modules may l ead to the creation of too  
many module variants. Discuss what role remains for configurati on management in an  
object-oriented environm ent where inheritance is present, and more ge nerally how the use  
of object technology affects the  problem of configuration manag ement. 
If you are familiar with specif ic configuration management tool s ,  d i s c u s s  h o w  t h e y  
interact with inheritance and ot her principles o f O-O developme nt. 
4  
Approaches to reusability 
“Follow the lead of hardware design ! It is not righ t that every new  
development should start from scratch . There should be catalogs of software  
modules , as there are catalogs of VLSI devices : when we build a new system ,
we should be ordering components fr om these catalogs and combining them ,
rather than reinventing the wheel every time . We would write less software ,
and perhaps do a better job at that which we do get to write . Wouldn’t then  
some of the problems that everybod y complains about — the high costs , the 
overruns , the lack of reliability — just go away ? Why is it not so ?” 
You have probably heard remarks of this kind; perhaps you have uttered them yourself. As  
early as 1968, at the now famous  NATO conference on software en gineering, Doug McIlroy  
was advocating “ mass-produced software components ”. Reusability, as a dream, is not new. 
It would be absurd to deny that some reuse occurs in software d evelopment. In fact  
one of the most impressive devel opments in the industry since t he first edition of this book  
was published in 1988 has been t he gradual emergence of reusabl e components, often  
modest individually but regularl y gaining ground; they range fr om small modules meant  
to work with Microsoft’s Visual Basic (VBX) and OLE 2 (OCX, now  ActiveX) to full  
libraries, also known as “frameworks”, for object-oriented envi ronments.
Another exciting development is the growth of the Internet: the  advent of a wired  
society has eased or in some cases removed some of the logistic  obstacles to reuse which,  
only a few years ago, might have  appeared almost insurmountable .
But this is only a beginning. We  are far from McIlroy’s vision of turning software  
development into a component-bas ed industry. The techniques of object-oriented software  
construction make it possible fo r the first time to envision a state of the discipline, in the  
not too distant future, in which  this vision will have become t he reality, for the greatest  
benefit not just of software developers but, more importantly, of those who need their  
products — quickly, and at a high level of quality.
In this chapter we will explore some of the issues that must be  addressed for  
reusability to succeed on such a large scale. The resulting con cepts will guide the  
discussion of object-oriented te chniques througho ut the rest of  this book.
APPROACHES TO REUSABILITY  §4.1 68
4.1  THE GOALS OF REUSABILITY
We should first understand why i t is so important to improve so ftware reusability. No need  
here for “motherhood a nd apple pie” arguments: as we will see, the most commonly touted  
benefits are not necessarily the  most significant; by going bey ond the obvious we can  
make sure that our quest for reuse will pursue the right target s, avoid mirages, and yield  
the highest return o n our investment.
Expected benefits
From more reusable software you may expect impro vements on the following fronts:
•Timeliness  (in the sense defined in the di scussion of soft ware quality fa ctors: speed  
of bringing projects to completio n and products to market). By relying on existing  
components we have less software to develop and h ence can build it faster.
•Decreased maintenance effort . If someone else is responsible for the software, that  
someone is also responsible for its future evolu tions. This avo ids the competent  
developer’s paradox : the more you work, the more wo rk you create for yourself as  
users of your products start ask ing you for new functionalities , ports to new  
platforms etc. (Other than relying on someone else to do the jo b, or retiring, the only  
solution to the competent software developer’s paradox is to be come an incompetent  
developer so tha t no one is interested in  your products any mor e — not a solution  
promoted by this book.)
•Reliability . By relying on components from  a reputed source, you have the  
gu ar an te e ,  or  at  le as t t he  ex pe ct a ti on ,  th at  th ei r  a ut h or s w i ll  have applied all the  
required care, including extensive testing and other validation  techniques; not to  
mention the expectation, in most cases, that many other applica tion developers will  
have had the opportunity to try these components before you, an d to come across any  
remaining bugs. The assumption here is not necessarily that the  component  
developers are any smarter than you are; simply that the compon ents they build —  
be they graphics modules, databa se interfaces, sorting algorith ms … — are their
official assignment, whereas for  you they might just be a neces sary but secondary  
chore for the attainment of your official goal of building an application system in  
your own area of development.
•Efficiency . The same factors that favor reu sability incite the component developers  
to use the best possible algorithms and data structures known i n their field of  
specialization, whereas in a lar ge application project you can hardly expect to have  
an expert on board for every  field touched on by the development. (Most people,  
when they think of the connectio n between reusability and effic iency, tend to see the  
reverse effect: the loss of fine -tuned optimizations that resul ts from using general  
so lu ti o n s.  B u t  th is  is  a  n ar r o w  v ie w  o f e f f ic i en cy : i n  a  la r g e project, you cannot  
realistically perform such optim izations on every piece of the development. You can,  
however, aim at the best possible solutions in your group’s are as of excellence, and  
for the rest rely on som eone else’s expertise.)This section is 
based on the more extensive discus-sion of manage-ment aspects of reuse in the book “Object Success” [M 1995].
§4.1   THE GOALS OF REUSABILITY 69
•Consistency . There is no good library without a strict emphasis on regular , coherent  
design. If you start using such a library — in particular some of the best current  
object-oriented libraries — its style will start to influence, through a natural process  
of osmosis, the style of the sof tware that you de velop. This is  a great boost to the  
quality of the software prod uced by an application group.
•Investment . Making software reusable is a way to preserve the know-how an d 
inventions of the best developer s; to turn a fragile resource i nto a permanent asset.
Many people, when they accept reusability as desirable, think o nly of the first  
argument on this list, improving productivity. But it is not ne cessarily the most important  
contribution of a reuse-based sof tware process. The reliability  benefit, for example, is just  
as significant. It is extremely difficult to build guaranteeabl y reusable software if every new  
development must independently validate every single piece of a  possibly huge  
construction. By relying on components produced, in each area, by the best experts around,  
we can at last hope to build systems that we trust, because ins tead of redoing what  
thousands have done before us — and, most likely, running again  into the mistakes that they  
made — we will concentrate on enfo rcing the reliability of our truly new contributions.
This ar gum ent does not just apply to reliability . The comment o n efficiency was  
based on the same reasoning. In this respect we can see reusabi lity as standing apart from  
the other quality factors studied in chapter 1: by enhancing it you have the potential of  
enhancing almost all  of the other qualities. The rea son is economic: if, instead of  being  
developed for just one  project, a software element has the pote ntial of serving again and  
again for many projects, it beco mes economically attractive to s u b m i t  i t  t o  t h e  b e s t  
possible quality-enhancing techni ques — such as formal verifica tion, usually too  
demanding to be cost-effective for most projects but the most m ission-critical ones, or  
extensive optimization, which in ordinary circumstances can oft en be dismissed as undue  
perfectionism. For reusable com ponents, the reasoning changes d ramatically; improve  
just one element, and  thousands of devel opments may benefit.
This reasoning is of course not completely new; it is in part t he transposition to  
software of ideas that have fund amentally affected other discip lines when they turned  
from individual craftsmanship to mass-production industry. A VL SI chip is more  
expensive to build than a run-of -the-mill special-purpose circu it, but if well done it will  
show up in countless systems and benefit their quality because of all the design work that  
went into it once and for all.
Reuse consumers, reuse producers
If you examined carefully the preceding list of arguments for r eusability, you may have  
noted that it involves benefits of  two kinds. The first four ar e benefits you will derive from  
basing your application developmen ts on existing reusable compo nents; the last one, from  
making your own software reusable. The next-to-last (consistency) is a little of both.
This distinction reflects the two aspects of reusability: the consumer view , enjoyed  
by application developers who can  rely on components; and the producer view , available  
to groups that build reusability  into their own developments.
APPROACHES TO REUSABILITY  §4.2 70
In discussing reusability and re usability policies you should a lways make sure which  
one of these two views you have in mind. In particular , if your  organization is new to  
reuse, remember that it is essen tially impossible to start as a  reuse producer. One often  
meets managers who think they can  make development reusable ove rnight, and decree  
that no development shall hencef orth be specific. (Often the in junction is to start  
developing “business ob jects” capturing the  company’s applicati on expertise, and ignore  
general-purpose components — algorithms, data structures, graph ics, windowing and the  
like — since they are c onsidered too “low-level” to yield the r eal benefits of reuse.) This  
is absurd: developing reusable c omponents is a challenging disc ipline; the only known  
way to learn is to start by usin g, studying and imitating good existing components. Such  
an approach will yield immediate benefits as your developments will take advantage of  
these components, and it will st art you, should you persist in your decision to become a  
producer too, on the right learning path.
4.2  WHAT SHOULD WE REUSE?
Convincing ourselves that Reusab ility Is Good was the easy part  (although we needed to  
clarify what  is really good about it). Now for the real challenge: how in t he world are we  
going to get it?
The first question to ask is what exactly we should expect to r euse among the various  
levels that have been proposed a nd applied: reuse of personnel,  o f  s p e c i f i c a t i o n s ,  o f  
designs, of “patterns”, of source  code, of specified components , of abstracted modules.
Reuse of personnel 
The most common source  of reusability is the developers themsel ves. This form of reuse  
is widely practiced in the indust ry: by transferring software e ngineers from project to  
project, companies avoid losing know-how and ensure that previo us experience benefits  
new developments. 
This non-technical approach to r eusability is obviously limited  in scope, if only  
because of the high turnover in the so ftware pro fession. 
Reuse of designs and specifications 
Occasionally you will encounter t he argument that we should be reusing desi gns rather  
than actual software. The idea is  that an organization should a ccumulate a repository of  
blueprints describing accepted d esign structures for the most c ommon applications it  
develops. For example, a company  that produces ai rcraft guidanc e systems will have a set  
of model designs summarizing its experience in this area; such documents describe  
module templates rather than actual modules. Reuse Path principle
Be a reuse consumer before you  try to be a reuse producer.Here too “Object 
Success” explores the policy issues further .
§4.2   WHAT SHOULD WE REUSE? 71
This approach is essentially a m ore organized version of the pr evious one — reuse  
of know-how and experience. As t he discussion of  documentation has already suggested,  
the very notion of a design as an independent software product,  having its own life  
separate from that of the corres ponding implementation, seems d ubious, since it is hard to  
guarantee that the design and the  implementation will remain co mpatible throughout the  
evolution of a software system. So if you only reuse the design  you run the risk of reusing  
incorrect or obsolete elements. 
These comments are also applicable to a related form of reuse: reuse of specifications. 
To a certain extent, one can view the progress of reusability i n recent years, aided by  
progress in the spread of object technology and aiding it in re turn, as resulting in part from  
the downfall of the old idea, long popular in software engineer ing circles, that the only  
reuse worthy of interest is reuse of design and specification. A narrow form of that idea  
was the most effective obstacle to progress, since it meant tha t all attempts to build actual  
components could be dismissed as only addressing trivial needs and not touching the truly  
difficult aspects. It used to be the dominant view; then a comb ination of theoretical  
arguments (the arguments of object technology) and practical ac hievements (the  
appearance of successful reusable components) essentially manag ed to defeat it.
“Defeat” is perhaps too strong a  term because, as often happens  in such disputes, the  
result takes a little from both sides. The idea of reusing desi gns becomes much more  
interesting with an approach (su ch as the view of object techno logy developed in this  
book) which removes muc h of the gap between design and implemen tation. Then the  
difference between a module and a design for a module is one of  degree, not of nature: a  
module design is simply a module of which some parts are not fu lly implemented; and a  
fully implemented modu le can also serve, t hanks to abstraction tools, as a module design.  
With this approach the distincti on between reusing modules (as discussed below) and  
reusing designs tends to fade away.
Design patterns
In the mid-nineteen-nineties the idea of design patterns  started to attract considerable  
attention in object-oriented cir cles. Design patterns are archi tectural ideas applicable  
across a broad range of application domains; each pattern makes  it possible to build a  
solution to a certain design issue.
Here is a typical example, discu ssed in detail in a later chapt er. The issue : how to  
provide an interactive system with a mechanism enabling its use rs to undo a previously  
executed command if the y decide it was not appropriate, and to reexecute an undone  
command if they change their mind again. The pattern : use a class COMMAND  with a  
precise structure (which we will  study) and an associated “hist ory list”. We will encounter  
many other design patterns.
One of the reasons for the succe ss of the design pattern idea i s that it was more than  
an idea: the book that  introduced the concep t, and others that have followed, came with a  
catalog of directly ap plicable patterns whic h readers could lea rn and apply.
Design patterns have a lready made an importa nt contribution to the development of  
object technology, and as new one s continue to be  published the y will help developers to  Chapter 21 discuss-
es the undoing pat-tern.
[Gamma 1995];  see 
also [Pree 1994].
APPROACHES TO REUSABILITY  §4.2 72
benefit from the experience of their elders and peers. How can the general idea contribute  
to reuse? Design patterns should  not encourage a throwback to t he “all that counts is  
design reuse ” attitude mentioned earlier. A pattern that is only a book pattern, however  
elegant and general, is a pedago gical tool, not a reuse tool; a fter all, computing science  
students have for three decades been learning from their textbo oks about relational query  
optimization, Gouraud shading, A VL trees, Hoare’s Quicksort and  Dijkstra’s shortest path  
algorithm without anyone claiming  that these techniques were br eakthroughs in  
reusability. In a sens e, the patterns devel oped in the past few  years are only incremental  
additions to the software profes sional’s bag of standard tricks .  I n  t h i s  v i e w  t h e  n e w  
contribution is the patterns the mselves, not the  idea of patter n.
As most people who have looked ca refully at the pattern work ha ve recognized, such  
a view is too limited. There seem s to be in the very notion of pattern a truly new  
contribution, even if it has not been fully understood yet. To go beyond their mere  
pedagogical value, patterns must go further. A successful patte rn cannot just be a book  
description: it must be a software component , or a set of components. This goal may  
seem remote at first because man y of the patterns are so genera l and abstract as to seem  
impossible to capture in actual software modules; but here the object-oriented method  
provides a radical contribution. Unlike earlier approaches, it will enable us to build  
reusable modules that still have replaceable, not completely fr ozen elements: modules that  
serve as general schemes ( patterns  is indeed the app ropriate word) and  can be adapted to  
various specific situations. This is the notion of behavior class  (a more picturesque term  
is programs with holes ); it is based on O-O techniques  that we will study in later ch apters,  
i n  p a r t i c u l a r  t h e  n o t i o n  o f  d e f e r r e d  c l a s s .  C o m b i n e  t h i s  w i t h  t he idea of groups of  
components intended to work together — often known as frameworks  or more simply as  
libraries — and you get a remarkable way o f reconciling re usability with adaptability.  
These techniques hold, for the pattern movement, the promise of  exerting, beyond the  
new-bag-of-important-tricks effe ct, an in-depth influence on re usability practices.
Reusability through the source code 
Personnel, design and specificatio n forms of reuse, useful as t hey may be, ignore a key  
goal of reusability. If we are to come up with the software equ ivalent of the reusable parts  
of older engineering disciplines, what we need to reuse is the actual stuff of which our  
products are made: executable sof tware. None of the targets of reuse seen so far — people,  
designs, specifications — can qua lify as the off-the-shelf comp onents ready to be included  
in a new software produ ct under development. 
If what we need to reuse is software, in what form should we re use it? The most  
natural answer is to use the sof tware in its original form: sou rce text. This approach has  
worked very well in some cases. Much of the Unix culture, for e xample, originally spread  
in universities and laboratories  thanks to the on-line availabi lity of the source code,  
enabling users to study, imitate  and extend the system. This is  also true of the Lisp world. 
The economic and psych ological impediments t o source code disse mination limit  
the effect that this form of reu se can have in more traditional  industrial environments. But  
a more serious l imitation comes from two technical obstacles: See “Programs 
with holes”, page 505.
See also “Formats 
for reusable compo-nent distribution”, page 79 below .
§4.2   WHAT SHOULD WE REUSE? 73
• Identifying reusable software w ith reusable source removes inf ormation hiding. Yet  
no large-scale reuse is possible without a systematic effort to  protect reusers from  
having to know the myriad de tails of reused elements.
• Developers of software distribu t e d  i n  s o u r c e  f o r m  m a y  b e  t e m p t ed to violate  
modularity rules. Some parts may  depend on others in a non-obvi ous way, violating  
the careful limitations which the  discussion of modularity in t he previous chapter  
imposed on inter-module communicat ion. This often makes it diff icult to reuse some  
elements of a complex system wit hout having to reuse everything  else. 
A satisfactory form of reuse mus t remove these obstacles by sup porting abstraction  
and providing a finer grain of reuse. 
Reuse of abstracted modules 
All the preceding approaches, al though of limited applicability , highlight important  
aspects of the reu sability problem: 
• Personnel reusability is necessary if not sufficient. The best  reusable components are  
useless without well-trained deve lopers, who have acquired suff icient experience to  
recognize a situation in which e xisting componen ts may provide help. 
• Design reusability emphasizes th e need for reusable components  to be of sufficiently  
high conceptual level and generality — not just ready-made solu tions to special  
problems. The classes which we w ill encounter in object technol ogy may be viewed  
as design modules as well as implementation modules. 
• Source code reusability serves as a reminder that software is in the end defined by  
program texts. A successful reus ability policy must produce reu sable program elements. 
The discussion of source code reu sability also helps narrow dow n our search for the  
proper units of reuse. A basic r eusable component should be a s oftware element. (From  
there we can of course go to collections  of software elements.) That element should be a  
module of reasonable size, satisfying the modularity requirements of t he previous chapter;  
in particular, its relations to other software, i f any, should be severely limited to facilitate  
independent reuse. The information describi ng the module’s capa bilities, and serving as  
primary documentation for reusers  or prospective reusers, shoul d be abstract : rather than  
describing all the details of the module (as with source code),  it should, in accordance with  
the principle of Infor mation Hiding, highlig ht the properties r elevant to clients.
The term abstracted module  will serve as a name for such  units of reuse, consisting  
of directly usable software, available to the outside world thr ough a description which  
contains only a su bset of each unit’s properties. 
The rest of part B of this book is devoted to devi s i n g  t h e  p r e c i s e  f o r m  o f  s u c h  
abstracted modules; part C will then explore their properties.
The emphasis on abstraction, and the rejection of source code a s the vehicle for reuse, do  
not necessarily prohibit distributing  modules in source form. The contradiction is only  
apparent: what is at stake in the present discussion is not how  we will deliver modules to  
their reusers, but what they will use as the primary source of information about them. It  
may be acceptable for a module to be distributed in source form  but reused on the basis  
of an abstract interface description.More on distribu-
tion formats below.
APPROACHES TO REUSABILITY  §4.3 74
4.3  REPETITION IN SOFTWARE DEVELOPMENT 
To progress in our search for th e ideal abstracted module, we s hould take a closer look at  
the nature of software construct ion, to understand what in soft ware is most subject to reuse. 
Anyone who observes software dev elopment cannot but be impresse d by its  
repetitive nature. Over and again, programmers weave a number o f basic patterns: sorting,  
searching, reading, writing, com paring, traversing, allocating,  synchronizing …
Experienced developers know this feeling of déjà vu , so characteristic of their trade.
A good way to assess this situat ion (assuming y ou develop softw are, or direct people  
who do) is to answer t he following question:
Table searching is defined here as the problem of finding out w hether a certain element  
x appears in a table t of similar elements. The problem has many variants, depending o n 
the element types, the data structure representation for t, the choice of searching  
algorithm. 
Chances are you or your colleagu es will indeed have tackled thi s problem one or  
more times. But what i s truly remarkable is that — if you are l ike others in the profession  
— the program fragment handling th e search operation will have been written at the  
lowest reasonable level of abstra ction: by writin g code in some  programming language,  
rather than calling ex isting routines. 
To an observer from outside our field, however, table searching  would seem an  
obvious target for widely available reusable components. It is one of the most researched  
areas of computing science, the subject of hundreds of articles , and many books starting  
with volume 3 of Knuth’s famous treatise. The undergraduate cur riculum of all computing  
science departme nts covers the most impo rtant algorithms and da ta structures. Certainly  
not a mysterious t opic. In addition:
• It is hardly possible , as  n ot ed , t o wr it e  a  u se fu l so f twa r e sy stem which does not  
include one or ( usually) several cases of table searching. The investment needed to  
produce reusable m odules is not hard to justify. 
• As will be seen in more detail b elow, most searc hing algorithm s follow a common  
pattern, providing what would se em to be an ideal basis for a r eusable solution. 
4.4  NON-TECHNICAL OBSTACLES
Why then is reuse not more common? 
Most of the serious impediments t o reuse are technical; removin g them will be the  
subject of the following sections  of this chapter (and of much of the rest of this book). But  
of course there are al so some organizational, economical and po litical obstacles. How many times over the past six months did you , or people working for you ,
write some program fragment for table searching ?
See bibliographic 
references on  
page 99 .
§4.4   NON-TECHNICAL OBSTACLES 75
The NIH syndrome 
An often quoted psychological obs tacle to reuse is the famous N ot Invented Here (“NIH”)  
syndrome. Software developers, i t is said, are individualists, who prefer to redo everything  
by themselves rather than rel y on someone else’s work. 
This contention (commonly heard in managerial circles) is not b orne out by  
experience. Software developers d o not like usele ss work more t han anyone else. When a  
good, well-publicized a nd easily acce ssible reusable solution i s available, it gets reused. 
Consider the typical case of lex ical and syntactic analysis. Us ing parser generators  
such as the Lex-Yacc combination , it is much easier to produce a parser for a command  
language or a simple programming  language than if you must prog ram it from scratch. The  
result is clear: where such tools  are available, competent soft ware developers routinely  
reuse them. Writing your own tailor-made parser still makes sen se in some cases, since the  
tools mentioned have their limitations. But the developers’ rea ction is usually to go by  
default to one of these tools; i t is when you want to use a sol ution not based on the reusable  
mechanisms that you have to argu e for it. This may in fact caus e a new syndrome, the  
reverse  of NIH, which we may call HIN (Habit Inhibiting Novelty): a us eful but limited  
reusable solution, so entrenched that it narrows the developers ’ outlook and stifles  
innovation, becomes counter-produ ctive. Try to convince some Un ix developers to use a  
parser generator other  than Yacc, and you m ay encounter HIN fir st-hand.
Something which may externally look like NIH does exist, but of ten it is simply the  
developers’ understanda bly cautious reacti on to new and unknown  components. They  
may fear that bugs or other prob lems will be more difficult to correct than with a solution  
over which they have full control. Often such fears are justifi ed by unfortunate earlier  
attempts at reusing co mponents, especially if they followed fro m a management mandate  
to reuse at all costs, not accom panied by proper quality checks . If the new components are  
of good quality and provide a re al service, fears will soon dis appear. 
What this means for the producer  of reusable components is that  quality is even more  
important here than for more ord inary forms of software. If the  cost of a non-reusable, one-
of-a-kind solution is N, the cost R of a solution relying on re usable components is never  
zero: there is a learning cost, at least the first time; develo pers may have to bend their  
software to accommodate the components; and they must write som e interfacing software,  
however small, to call them. So e ven if the reusability savings
and other benefits of reuse are potentially great, you must als o convince the candidate  
reusers that the reusable soluti on’s quality is good enough to justify relinquishing control.rNR–
N------------ =
APPROACHES TO REUSABILITY  §4.4 76
This explains why it is a mistake to target a company’s reusabi lity policy to the potential  
reusers (the consumers , that is to say the applicati on developers). Instead you shoul d put 
the heat on the producers , including people in charge of acquiring external components,  
to ensure the quality and usefulness of their offering. Preachi ng reuse to application  
developers, as some companies do by way of reusability policy, is futile: because  
application developers are ultimately judged by how effectively  they produce their  
applications, they should and will reuse not because you tell t hem to but because you have  
done a good enough job with the reusable components (developed or acquired) that it will  
be profitable  for their applications  to rely on these components.
The economics of procurement 
A potential obstacle to reuse comes from the procurement policy  o f  m a n y  l a r g e  
corporations and gover nment organizations, which tends to imped e reusability efforts by  
focusing on short-term  costs. US regulations, for example, make  it hard for a government  
agency to pay a contractor for w ork that was not explicitly com missioned (normally as  
part of a Request For Proposals) . Such rules come from a legiti mate concern to protect  
taxpayers or sharehold ers, but can also discourage software bui lders from applying the  
crucial effort of generalization  to transform good  software into reusable components. 
On closer examination this obsta cle does not look so insurmount able. As the concern  
for reusability spreads, there i s nothing to prevent the commis sioning agency from  
including in the RFP itself the requirement that the solution m ust be general-purpose and  
reusable, and the description of  how candidate solutions will b e evaluated against these  
criteria. Then the software developers can devote the proper at tention to the generalization  
task and be paid for it. 
Software companies and their strategies 
Even if customers play their pa rt in removing obstacles to reus e, a potential problem  
remains on the side of the contra ctors themselves. For a softwa re company, there is a  
constant temptation to provide  solutions that are purposely not reusable, for fear of not  
getting the next job from the customer — because if the result of the current job is too  
widely applicable th e customer may not need a next job! 
I once heard a remarkably candid exposé of this view after givi ng a talk on reuse and  
object technology. A high-level executive from a major software  house came to tell me  
that, although intelle ctually he admired the  ideas, he would ne ver implement them in his  
own company, because that would be killing the goose that laid the golden egg: more than  
90% of the company’s business derived from renting manpower — p roviding analysts and  
programmers on assignme nt to customers — and the management’s o bjective was to bring  
the figure to 100%. With such an  outlook on software engineerin g, one is not likely to  
greet with enthusiasm the prospe ct of widely ava ilable librarie s of reusable components. 
The comment was notable for its f rankness, but it triggered the  obvious retort: if it is  
at all possible to build reusable components to replace some of  the expensive services of  
a software house’s consultants,  sooner or later someone will bu ild them. At that time a  See [M 1995].
“GENERALIZA-
TION”, 28.5, page 928
§4.4   NON-TECHNICAL OBSTACLES 77
company that has refused to take this route, and is left with n othing to sell but its  
consultants’ services,  may feel sorry for having kept its head buried in the sand. 
It is hard not to think here of the many enginee ring discipline s that used to be heavily  
labor-intensive but became indust r i a l i z e d ,  t h a t  i s  t o  s a y  t o o l - based — with painful  
economic consequ ences for companies and countries that did not understand early enough  
what was happening. To a certain e xtent, object technology is b ringing a similar change to  
the software trade. The choice b etween people and tools need no t, however, be an  
exclusive one. The engineering pa rt of software engineering is not identical to that of  
mass-production industries; huma ns will likely continue to play  t h e  k e y  r o l e  i n  t h e  
software construction process. T he aim of reuse is not to repla ce humans by tools (which  
is often, in spite of all claims, what has happened in other di sciplines) but to change the  
distribution of what we entrust to humans and to tools. So the news is not all bad for a  
software company that has made its name thro ugh its co nsultants . In particular: 
• In many cases developers using sophisticated reusable componen ts may still benefit  
from the help of experts, who can advise them on how best to us e the components.  
This leaves a meaningf ul role for software houses and their con sultants.
• As will be discussed below, reu sability is inseparable from ex tendibility: good  
reusable components will still b e open for adaptation to specif ic cases. Consultants  
from a company that de veloped a library are in an ideal positio n to perform such  
tuning for individual customers.  So selling components and sell ing services are not  
necessarily exclusive activities ; a components business can ser ve as a basis for a  
service business. 
• More generally, a good reusable library can play a strategic r ole in the policy of a  
successful software company, even if the company sells specific  solutions rather  
than the library itself, and use s the library for internal purp oses only. If the library  
covers the most common needs and provides an extendible basis f or the more  
advanced cases, it can enable the company to gain a competitive  edge in certain  
application areas by developing tailored solutions to customers ’ needs, faster and at  
lower cost than competitors who cannot rely on such a ready-mad e basis.
Accessing components 
Another argument used to justify  skepticism about reuse is the difficulty of the component  
management task: progress in the  production of reusable softwar e, it is said, would result  
in developers being swamped by s o many components as to make th eir life worse than if  
the components were not available. 
Cast in a more positive style, this comment should be understoo d as a warning to  
developers of reusable software that the best reusable componen ts in the world are useless  
if nobody knows they exist, or if it takes too much time and ef fort to obtain them. The  
practical success of reusability  techniques requires the develo pment of adequate databases  
of components, which interested developers may search by approp riate keywords to find  
o u t  q u i c k l y  w h e t h e r  s o m e  e x i s t i n g  component satisfies a particu lar need. Network  
APPROACHES TO REUSABILITY  §4.4 78
services must also be available,  allowing electronic ordering a nd immediate downloading  
of selected components. 
These goals do raise technical a nd organizational problems. But  we must keep things  
in proportion. Indexing, retriev ing and delivering reusable com ponents are engineering  
issues, to which we ca n apply known tools, in particular databa se technology;  there is no  
reason why software components s hould be more di fficult to mana ge than customer  
records, flight informa tion or library books.
Reusability discussion s used to delve forever into the grave qu estion “how in the  
world are we going to make the c omponents availa ble to develope rs?”. After the advances  
in networking of the past few ye ars, such debates no longer app ear so momentous. With  
the World-Wide Web, in particular, have appeared powerful searc h tools (A ltaVista,  
Yahoo …) which have made it far easier to locate useful information, e ither on the Internet  
or on a company’s Intranet. Even more advanced solutions (produ ced, one may expect,  
with the help of object technolog y) will undoubtedly follow. Al l this makes it increasingly  
clear that the really hard part of progress in reusability lies  not in organizing reusable  
components, but in building the w retched things in the first pl ace.
A note about component indexing 
On the matter of indexing and re trieving components, a question  presents itself, at the  
borderline between tec hnical and organizational issues: how sho uld we associate indexing  
information, such as keywords , with software components? 
The Self-Documentation principle  suggests that, as much as poss ible, information  
about a module — indexing inform ation as well as other forms of  module documentation  
— should appear in the module its elf rather than externally. Th is leads to an important  
requirement on the notation th at will be developed in part C of this book to write software  
components, called classes. Rega rdless of the exact form of the se classes, we  must equip  
ourselves with a mechan ism to attach indexin g information to ea ch component. 
The syntax is straightforward. A t the beginning of a module tex t, you will be invited  
to write a note clause of the form 
note
index_word1 : value , value , value …
index_word2 : value , value , value …
…
… Normal module def inition (see part C) …
Each index_word  is an identifier; each value  i s  a  c o n s t a n t  ( i n t e g e r ,  r e a l  e t c . ) ,  a n  
identifier, or some othe r basic lexical element.
There is no particular constraint  on index words and values, bu t an industry, a  
standards group, an organization  or a project may wish to defin e their own conventions.  
Indexing and retrieva l tools can then extr act this information to help software developers  
find components  satisfying certain criteria.“Self-Documenta-
tion”, page 54 .
More details in 
“Note clauses”, page 890 .
§4.4   NON-TECHNICAL OBSTACLES 79
As we saw in the discussion of Self-Documentation, storing such  information in the  
module itself — rather than in an outside document or database — decreases the  
likelihood of including wrong inf ormation, and in particular of  forgetting to update the  
information when updating the mo dule (or convers ely). Indexing clauses, modest as they  
may  s ee m, pl ay  a  ma j or  r ol e i n h elping developers keep their so ftware organized and  
register its properties so that others can find out about it.
Formats for reusable c omponent distribution
Another question straddling the t echnical-organizational line i s the form under which we  
should distribute reusable compo nents: source or binary? This i s a touchy issue, so we will  
limit ourselves to examining a f ew of the arguments on both sid es.
For a professional, for-profit s oftware developer, it often see ms desirable to provide  
buyers of reusable components w ith an interface description (th e short form  discussed in  
a later chapter) and the binary code for their platform of choi ce, but not the source form.  
This protects the de veloper’s investment and trade secrets. 
Binary is indeed the preferred f orm of distributi on for commerc ial application  
programs, operating systems and ot her tools, including compiler s, interpreters and  
development environments for obj ect-oriented languages. In spit e of recurring attacks on  
the very idea, emanating in parti cular from an advocacy group c alled the League for  
Programming Freedom, this mode of commercial software distribut ion is unlikely to  
recede much in the near future. But the present discussion is n ot about ordinary tools or  
application programs: it is about libraries of reusable softwar e components. In that case  
one can also find some arguments  in favor of source distributio n.
For the component producer, an a dvantage of source distribution  i s  t h a t  i t  e a s e s  
porting efforts. You stay away fr om the tedious and unrewarding  task of adapting software  
to the many incompatible platforms that exist in today’s comput er world, relying instead  
on the developers of object-orien ted compilers and environments  to do the job for you.  
(For the consumer  this is of course a counter-argument, as installation from sou rce will  
require more work and may cause unfores een errors.)
Some compilers for object-orien ted languages may let you retain  some of the portability  
benefit without committing to full source availability: if the compiler uses C as  
intermediate generated code, as is often the case today, you ca n usually substitute portable  
C code for binary code. It is then not difficult to devise a to ol that obscures the C form,  
making it almost as difficult to reverse-engineer as a binary f orm.
Also note that at various stages in the history of software, da ting back to UNCOL  
(UNiversal COmputing Language) in the late fifties, people have  been defining low-level  
instruction formats that could be interpreted on any platform, and hence could provide a  
portable target for compilers. The ACE consortium of hardware a nd software companies  
was formed in 1988 for that purpose. Together with the Java lan guage has come the  
notion of Java bytecode, for which interpreters are being devel oped on a number of  
platforms. But for the component  producer such efforts at first  represent more work, not  
less: until you have the double guarantee that the new format i s available on every  
platform of interest and that it executes target code as fast as platform-specific solu tions,  
you cannot forsake the old technology, and must simply add the new target code format  “Using assertions 
for documentation: the short form of a class”, page 389 .
T. B. Steel : “A First 
Version of UNCOL ”, 
Joint Computer Conf. , vol. 19 , Win-
ter 1961 , pages 
371-378 .
ISE’s compilers use 
both C generation and bytecode gen-eration .
APPROACHES TO REUSABILITY  §4.4 80
to those you already support. So a solution that is advertized as an end-all to all portability  
problems actually creates, in the short term, more portability problems.
Perhaps more significant, as an argument for source code distri bution, is the  
observation that attempts to pro tect invention and trade secret s by removing the source  
form of the implementation may b e of limited benefit anyway. Mu ch of the hard work in  
the construction of a good reusable library lies not in the imp lementation but in the design  
of the components’ interfaces; an d that is the part that you ar e bound to release anyway.  
This is particularly clear in th e world of data structures and algorithms, where most of the  
necessary techniq ues are available in the computing science lit erature. To design a  
successful library, you must embe d these techniques in modules whose interface will  
make them useful to the developers of many different applicatio ns. This interface design  
is part of what you must  release to the world.
Also note that, in the case of object-oriented modules, there a r e  t w o  f o r m s  o f  
c o m p o n e n t  r e u s e :  a s  a  c l i e n t  o r ,  a s  s t u d i e d  i n  l a t e r  c h a p t e r s ,  through inheritance. The  
second form combines reuse with a daptation. Interface descripti ons (short forms) are  
sufficient for client reuse, but not always for inheritance reu se. 
Finally, the educational side: distributing the source of libra ry modules is a good way  
to provide models of the produce r’s best engineering, useful to  encourage consumers to  
develop their own software in a consistent style. We saw earlie r that the resulting  
standardization is one of the benefits of reusability. Some of it will remain even if client  
developers only have access to t he interfaces; but nothing beat s having the full text. 
Be sure to note that even if source is available it should not serve as the primary  
documentation tool: for that role, we continue to use the modul e interface. 
This discussion has touched on s ome delicate economic issues, w hich condition in  
part the advent of an industry o f software components and, more  generally, the progress  
of the software field. How do we provide developers with a fair  reward for their efforts  
and an acceptabl e degree of protection for their inventions, wi thout hampering the  
legitimate interests  of users? Here are two opposite views: 
•A t  o n e  e n d  o f  t h e  s p e c t r u m  y o u  w i l l  f i n d  t h e  p o s i t i o n s  o f  t h e  L eague for  
Programming Freedom: all software  should be free and available in source form. 
• At the other end you have the idea of superdistribution , advocated by Brad Cox in  
several articles and a  book. Superdistribution would allow user s to duplicate  
software freely, charging them n ot for the purchase but instead  for each use. Imagine  
a little counter attached to each software component, which rin gs up a few pennies  
every time you make use of the component, and sends you a bill at the end of the  
month. This seems to preclude distribution in source form, sinc e it would be too easy  
to remove the c ounting instructions. Alt hough JEIDA, a Japanese  consortium of  
electronics companies, is said to be working on hardware and so ftware mechanisms  
to support the concept, and alt hough Cox has rec ently been emph asizing  
enforcement mechanisms built on regulations (like copyright) ra ther than  
technological devices, superdistr ibution still ra ises many tech nical, logistic,  
economic and psych ological questions.The chapter on 
teaching object technology devel-ops this point in “Apprenticeship”, page 944.
See the bibli-
ographical notes .
§4.5   THE TECHNICAL PROBLEM 81
An assessment 
Any comprehensive approach to re usability must, along with the technical aspects, deal  
with the organizational and econ omical issues: making reusabili ty part of the software  
development culture, finding the  right cost structure and the r ight format for component  
distribution, providing the approp riate tools for indexing and retrieving components. Not  
surprisingly, these issues have been the focus of some of the m ain reusability initiatives  
from governments and large corpor ations, such as the STARS prog ram of the US 
Department of Defense ( Software Technolo gy for Adaptable , Reliable Systems ) and the  
“software factories” installed by some large Japanese companies . 
Important as these questions are in the long term, they should not detract our  
attention from the main roadbloc ks, which are still technical. Success in reuse requires the  
right modular structures and the  construction of quality librar ies containing the tens of  
thousands of comp onents that the industry needs.
The rest of this chapt er concentrates on the  first of these que stions; it examines why  
common notions of  module are not appropriate for large-scale re usability, and defines the  
requirements that a better solution — developed in the followin g chapters — must satisfy.
4.5  THE TECHNICAL PROBLEM
What should a reusab le module look like?
Change and constancy 
Software development, it was men tioned above, in volves much rep etition. To understand  
the technical difficulties of re usability we must understand th e nature of that  repetition. 
Such an analysis reveals that al though programmers do tend to d o the same kinds of  
things time and time again, these are not exactly  the same things. If they were, the solution  
would be easy, at least on paper; but in practice so many detai ls may change as to defeat  
any simple-minded attempt at  capturing the commonality. 
A telling analogy is provided by t he works of the Norwegian pai nter Edvard Munch, the  
majority of which may be seen in the museum dedicated to him in  Oslo, the birthplace of  
Simula. Munch was obsessed with a small number of profound, ess ential themes: love,  
anguish, jealousy, dance, death … He drew and painted them endlessly, using the same  
pattern each time, but continually changing the technical mediu m, the colors, the  
emphasis, the size, the light, the mood. 
Such is the software engineer’s p light: time and again composin g a new variation  
that elaborates on the  same basic themes. 
Take the example menti oned at the beginni ng of this chapter: ta ble searching. True,  
the general form of a table searching algorithm is going to loo k similar each time: start at  
some position in the table t; then begin exploring the tabl e from that position, each time  
checking whether the e lement found at the current position is t he one being sought, and,  
if not, moving to another position. The process terminates when  it has either found the  
APPROACHES TO REUSABILITY  §4.5 82
element or probed all the candid ate positions unsuccessfully. S uch a general pattern is  
applicable to many possible cases of data representation and al gorithms for table  
searching, including arrays (sorted or not), linked lists (sort ed or not), sequential files,  
binary trees, B-trees and has h tables of various kinds.
It is not difficult to turn this informal description into an i ncompletely refined  
routine: 
has (t: TABLE , x: ELEMENT ): BOOLEAN
-- Is there an occurrence of x in t?
local
pos: POSITION
do
from
pos := INITIAL_POSITION (x, t)
until
EXHAUSTED ( pos, t) or else  FOUND (  pos, x, t)
loop
pos := NEXT (pos, x, t)
end
Result  := not EXHAUSTED (pos, t)
end
(A few clarifications on the notation: from  … until  … loop … end describes a loop,  
initialized in the from  clause, executing the loop clause zero or more times, and  
terminating as soon as the conditi on in the until clause is satisfied. Result  denotes the  
value to be returned by the func tion. If you are not familiar w ith the or else  operator, just  
accept it as if it were a boolean or.)
Although the above text  describes (through its lower-case eleme nts) a general  
pattern of algorithmic behavior,  it is not a directly executabl e routine since it contains (in  
upper case) some incompletely re fined parts, corresponding to a spects of the table  
searching problem that depend on the implementation chosen: the  type of table elements  
(ELEMENT ) ,  w ha t  pos i ti on  to  ex am i ne  f ir s t ( INITIAL_POSITION ) ,  h ow  t o g o f ro m  a  
candidate position to the next ( NEXT ), how to test for the presence of an element at a  
certain position ( FOUND ), how to determine that all i nteresting posit ions have been  
examined ( EXHAUSTED ).
Rather than a routine, then, the  above text is a routine patter n, which you can only  
turn into an actual routine by s upplying refineme nts for the up per-case parts.
The reuse-redo dilemma 
All this variation highlights th e problems raised by any attemp t to come up with general-
purpose modules in a given applic ation area: how can we take ad vantage of the common  
pattern while accommodating the n eed for so much variation? Thi s is not just an  or else  is explained 
in “Non-strict bool-ean operators”, page 454 .
§4.6   FIVE REQUIREMENTS ON MODULE STRUCTURES 83
implementation problem: it is almost as hard to specify  the module so tha t client modules  
can rely on it without kno wing its implementation. 
These observations point to the central problem of software reu sability, which  
dooms simplistic approa ches. Because of the versatility of soft ware — its very softness —  
candidate reusable modules will not suffice if they are inflexi ble. 
A frozen module forces you into the reuse or redo  dilemma: reuse the module  
exactly as it is, or redo the job completely. This is often too  limiting. In a typical situation,  
you discover a module that may pr ovide you with a solution for some part of your current  
j o b ,  b u t  n o t  n e c e s s a r i l y  t h e  e x a ct solution. You r specific need s may require some  
adaptation of the module’s original behavior. So what you will want to do in such a case  
is to reuse and redo: reuse some, redo some — o r, you hope, reuse a lot and re do a little.  
Without this ability t o combine reuse and adaptation, reusabili ty techniques cannot  
provide a solution that  satisfies the reali ties of practical so ftware development. 
So it is not by accident that almost every discussion of reusab ility in this book also  
considers extendibility (leading to the definition of the term “modularity”, which covers  
both notions and provided the top ic of the previous chapter). W henever you start looking  
for answers to one of these qual ity requirements, you quickly e ncounter the other. 
This duality between r euse and adaptation wa s also present in t he earlier discussion  
of the Open-Closed principle, wh ich pointed out that a successf ul software component  
must be usable as it stands (clo sed) while still  adaptable (ope n).
The search for the right notion of module, which occupies the r est of this chapter and  
the next few, may be characteriz ed as a constant attempt to rec oncile reusability and  
extendibility, closure and openness, constancy and change, sati sfying today’s needs and  
trying to guess what tom orrow holds in store. 
4.6  FIVE REQUIREMENTS  ON MODULE STRUCTURES 
How do we find module structures  that will yield directly reusa ble components while  
preserving the possibi lity of adaptation? 
The table searching issue and the has routine pattern obtained  for it on the previous  
page illustrate the stringent r equirements that any solution wi ll have to meet. We can use  
this example to analyze what it takes to go from a relatively v ague recognition of  
commonality between software vari ants to an actual set of reusa ble modules. Such a study  
will reveal five g eneral issues: 
• Type Variation. 
• Routine Grouping. 
• Implementation Variation. 
• Representation Independence. 
• Factoring Out Common Behaviors. “The Open-Closed 
principle”, page 57 .
APPROACHES TO REUSABILITY  §4.6 84
Type Variation
The has routine pattern assumes a table containing objects of a type ELEMENT . A 
particular refinement might use a specific type, such as INTEGER  or BANK_ACCOUNT , 
to apply the pattern to a table of integers or bank accounts. 
But this is not satisfactory. A reusable searching module shoul d be applicable to  
many different types of element, without requiring reusers to p erform manual changes to  
the software text. In other words, we need a facility for descr ibing type-parameterized  
modules, also known more concisely as generic  modules. Genericity (the ability for  
modules to be generic) will turn  out to be an important part of  the object-oriented method;  
an overview of the idea appe ars later in this chapter. 
Routine Grouping 
Even if it had been co mpletely refined and parameterized by typ es, the has routine pattern  
would not be quite satisfactory as a reusable component. How yo u search a table depends  
on how it was created, how elements are inserted, how they are deleted. So a searching  
routine is not e nough by itself as  a unit or reuse. A self-suff icient reusabl e module would  
need to include a set of routine s, one for each of the operatio ns cited — creation, insertion,  
deletion, searching. 
This idea forms the basis for a form of module, the “package”, found in what may be  
called the encapsulation language s: Ada, Modula-2 and relatives . More on this below. 
Implementation Variation 
The has pattern is very general; there i s in practice, as we have seen,  a wide variety of  
applicable data structures and a lgorithms. Such variety indeed that we cannot expect a  
single module to take care of all  possibilities; it would be en ormous. We will need a family  
of modules to cover all the different implementations. 
A general technique for produci ng and using reusable modules wi ll have to support  
this notion of module family. 
Representation Independence 
A general form of reusable modul e should enable clients to spec ify an operation without  
knowing how it is implemented. T his requirement is called Repre sentation Independence.
Assume that a client module C f r o m  a  c e r t a i n  a p p l i c a t i o n  s y s t e m  —  a n  a s s e t  
management program, a compiler, a geographical information syst em… —  n e e d s  t o  
determine whether a certain element x appears in a certain table t ( o f  i n v e s t m e n t s ,  o f  
language keywords, of cities). R epresentation in dependence mean s here the ability for C
to obtain this information through a call such as 
present  := has (t, x)“Genericity”, page 
96.
§4.6   FIVE REQUIREMENTS ON MODULE STRUCTURES 85
without knowing what kind of table  t is at the time of the call. C’s author shou ld only need  
to know that t is a table of elements of a certain type, and that x denotes an object of that  
type. Whether t is a binary search tree, a hash table or a linked list is irre levant for him; he  
should be able to limit his concerns to asset management, compi lation or geography.  
Selecting the appropriate search algorit hm based on t’s implementation is the business of  
the table manageme nt module, and of no one else. 
This requirement does not preclude letting clients choose a spe cific implementation  
when they create a data structur e. But only one client will hav e to make this initial choice;  
after that, none of the client s that perform searches on t should ever have to ask what exact  
kind of table it is. In particular, the client C containing the above call may have received t
from one of its own clients (as an argument to a routine call);  then for C the name t is just  
an abstract handle on a data stru cture whose details it may not  be able to access.
You may view Representation Inde pendence as an extension of the  r u l e  o f  
Information Hiding, essential for smooth development of large s ystems: implementation  
decisions will often change, and clients should be protected. B ut Representation  
Independence goes further. Taken to its full consequences, it m eans protecting a module’s  
clients against changes not only during the project lifecycle but also during execution  — 
a much smaller time frame! In the example, we want has to adapt itself automatically to  
the run-time form of table t, even if that form has cha nged since the  last call. 
Satisfying Representation Independence will also help us toward s a related principle  
encountered in the di scussion of modularity: Single Choice, whi ch directed us to stay  
away from multi-b ranch control structures that discriminate amo ng many variants, as in 
if “t is an array managed  by open hashing”  then
“Apply open hashing search algorithm”
elseif  “t is a binary search tree”  then
“Apply binary search tree traversal”
elseif
(etc.)
end
It would be equally unpleasant to have such a decision structur e in the module itself  
(we cannot reasonably expect a ta ble management module to know about all present and  
future variants) as to replicate it in every client. The soluti on is to hide the multi-branch  
choice completely from  software developers, and have it perform ed automatically by the  
underlying run-time system. This will be the role of dynamic binding , a key component  
of the object-oriented  approach, to be studi ed in the discussio n of inheritance. 
Factoring Out Common Behaviors
If Representation Independence r eflects the client’s view of re usability — the ability to  
ignore internal implementation details and variants –, the last  requirement, Factoring Out  
Common Behaviors, reflects the vi ew of the supplier and, more g enerally, the view of  
developers of reusable  classes. Their goal will be to take adva ntage of any commonality  
that may exist within a family o r sub-family of implementations . “Information Hid-
ing”, page 51 .
“Single Choice”, 
page 61 .
“DYNAMIC BIND-
ING”, 14.4, page 480.
APPROACHES TO REUSABILITY  §4.6 86
The variety of implementations a vailable in certain problem are as will usually  
demand, as noted, a solution bas ed on a family of modules. Ofte n the family is so large  
that it is natural to look for sub-families. In the table searc hing case a first attempt at  
classification might yield t hree broad sub-families: 
• Tables managed by some fo rm of hash-coding scheme. 
• Tables organized as trees of some kind. 
• Tables managed sequentially.
Each of these categories covers m any variants, but it is usuall y possible to find  
significant commonality between t hese variants. Consider for ex ample the family of  
sequential implementati ons — those in which items are kept and searched in the order of  
their original  insertion.
Possible representations for a s equential table include an arra y, a linked list and a file.  
But regardless of these differen ces, clients should be able, fo r any sequentially managed  
table, to examine the elements i n sequence by mo ving a (fictiti ous) cursor  indicating the  
position of the currently examin ed element. In this approach we  may rewrite the searching  
routine for sequen tial tables as: 
has (t: SEQUENTIAL_TABLE ; x: ELEMENT ): BOOLEAN
-- Is there an occurrence of x in t?
do
from start until
after or else  found (x)
loop
forth
end
Result  := not after
endSome possible 
table implementations
SEQUENTIAL_
TABLE
ARRAY_
TABLELINKED_
TABLEFILE_
TABLETABLE
HASH_
TABLETREE_
TABLE
“ACTIVE DATA 
STRUCTURES”, 23.4, page 774 , will 
explore details of the cursor technique .
§4.6   FIVE REQUIREMENTS ON MODULE STRUCTURES 87
This form relies on four routine s which any sequ ential table im plementation will be  
able to provide: 
•start, a command to move the cursor to the first ele ment if any. 
•forth , a command to advance the curso r by one positi on. (Support for  forth  is of  
course one of the prime characte ristics of a seq uential table i mplementation.) 
•after , a boolean-valued query to dete rmine if the cursor has moved p ast the last  
element; this will be true after a start if the table was empty. 
•found (x), a boolean-valued que ry to determine if the element at cursor position has  
value  x. 
At first sight, the routine text for has at the bottom of the pr eceding page resembles  
the general routine pattern used  at the beginning of this discu s s i o n ,  w h i c h  c o v e r e d  
searching in any table  (not just sequential). But the new form is not a routine pattern any  
more; it is a true routine, expre ssed in a directly executable notation (the no tation used to  
illustrate object-orie nted concepts in part C of this book). Given appropriate  
implementations for the four operations start, forth , after  and found  which it calls, you can  
compile and execute the latest form of has. 
For each possible sequential tabl e representation you will need  a representation for  
the cursor. Three example repres entations are by an array, a li nked list and a file.
The first uses an array of capacity  items, the table occupying positions 1 to count . 
Then you may represent the cursor simply as an integer index  ranging from 1 to count + 1 . 
(The last value is needed to represent a cursor that has moved “after ” the last item.) 
The second representation uses a linked list, where the first c ell is accessible through  
a reference first_cell  and each cell is linked to the next one through a reference right . Then  
you may represent the c ursor as a reference cursor . Sequential 
structure with 
cursorafteritem
index count 1
forthv1 v2 v3 v5 v4
The general routine 
pattern was on page 82 .
Array 
representation of  sequential 
table with 
cursor count 1 capacityv1 v2 v3 v5
index =3v4
APPROACHES TO REUSABILITY  §4.6 88
The third representation uses a sequential file, in which the c ursor simply represents  
the current reading position.
The implementation of the four low-level operations start, forth , after  and found  will 
be different for each variant. T he following table gives the im plementation in each case.  
(The notation  t @ i  denotes the i-th element of array t, which would be written t [i] in 
Pascal or C; Void denotes a void referenc e; the Pascal notation f ↑, for a file f, denotes the  
element at the cur rent file reading position.)
The challenge of reusability here  is to avoid unneeded duplicat ion of software by  
taking advantage of th e commonality between variants. If identi cal or near-identical  
fragments appear in different m odules, it will be difficult to guarantee their integrity and  
to ensure that changes or correc tions get propaga ted to all the  needed places; once again,  
configuration management  problems may follow.
All sequential table  variants share the has function, differing only by their  
implementation of the four lower-level operations. A satisfacto ry solution to the  
reusability problem must include the text of has in only one place, somehow associated  
with the general notion of seque ntial table independently of an y choice of representation.  
To describe a new variant, you s hould not have t o worry about has any more; all you will  
need to do is to provide t he appropriae versions of start, forth , after  and found . start forth after found (x)
Array i := 1 i := i + 1 i > count t @ i = x
Linked list c := first_
cellc := c   right c = Void c   item = x
File rewind read end_of_file f ↑ = xv1Void
cursor first_cellrightv2rightv3rightv5 v4right Linked list 
representation of sequential 
table with 
cursor
Sequential file 
representation 
of a sequential 
table with cursorv2 v3 v4 v5
File reading positionv1
In this table index is 
abbreviated as i 
and cursor  as c.
§4.7   TRADITIONAL MODULAR STRUCTURES 89
4.7  TRADITIONAL MODULAR STRUCTURES 
Together with the modularity re quirements of the  previous chapt er, the five requirements  
of Type Variation, Rou tine Grouping, Imple mentation Variation, Representation  
Independence and Factoring Out Co mmon Behaviors define what we may expect from our  
reusable components — abstracted modules.
Let us study the pre-O-O solutions to understand why they are n ot sufficient — but  
also what we should learn and ke ep from them in the object-orie nted world. 
Routines 
The classical approach to reusab ility is to build libraries of routines. Here the term routine  
denotes a software unit that other units may call to execute a certain algorithm, using  
certain inputs, produc ing certain outputs and possibly modifyin g  s o m e  o t h e r  d a t a  
elements. A calling unit will pas s its inputs (and sometimes ou tputs and modified  
elements) in the form of actual arguments . A routine may also return output in the form  
of a result ; in this case it is known as a function . 
The terms subroutine , subprogram  and procedure  are also used instead of routine . The 
first two will not appear in this book except in the discussion  of specific languages (the  
Ada literature talks about subprograms, and the Fortran literat ure about subroutines.)  
“Procedure” will be used in the sense of a routine which does n ot return a result, so that  
we have two disjoint categories of routine: procedures and func tions. (In discussions of  
the C language the term “function” itself is sometimes used for  the general notion of  
routine, but here it will always denote a routine that returns a result.) 
Routine libraries have been successful in several application d omains, in particular  
numerical computation, where exce llent libraries have created s ome of the earliest success  
stories of reusability. Decompos ition of systems into routines is also what one obtains  
through the method of top-down, funct ional decomposition. The r outine library approach  
i n d e e d  s e e m s  t o  w o r k  w e l l  w h e n  y o u  c a n  i d e n t i f y  a  ( p o s s i b l y  l a r ge) set of individual  
problems, subject to the following limitations: 
R1 • Each problem admits a simple specification. More precisely, it  i s  p o s s i b l e  t o  
characterize every problem instan ce by a small set of input and  output arguments. 
R2 • The problems are clearly distinct from each other, as the rout ine approach does not  
allow putting to good use any si gnificant commonality that migh t exist — except by  
reusing some o f the design. 
R3 • No complex data structures are involved: you would have to dis tribute them among  
the routines using the m, losing the conceptu al autonomy of each  module. 
The table searching problem prov i d e s  a  g o o d  e x a m p l e  o f  t h e  l i m i tations of  
subroutines. We saw earlier that a searching routine by itself does not have enough context  
to serve as a stand-alone reusab le module. Even if we dismissed  this objection, however,  
we would be faced with two equ ally unpleasant solutions: 
• A single searching routine, whi ch would try to cover so many d ifferent cases that it  
would require a long argument lis t and would be very complex in ternally. 
APPROACHES TO REUSABILITY  §4.7 90
• A large number of searching routines, each covering a specific  case and differing  
from some others by only a few d etails in violation of the Fact oring Out Common  
Behaviors requirement; candidate reusers could easily lose thei r way in such a maze.
More generally , routines are not flexible enough to satisfy the  needs of reuse. W e  
have seen the intimate connection  between reusability and exten dibility. A reusable  
module should be open to adaptat ion, but with a routine the onl y means of adaptation is to  
pass different arguments. This ma kes you a prisoner of the Reus e or Redo dilemma: either  
you like the routine as it i s, or you write your own. 
Packages 
In the nineteen-seventies, with the progress of ideas on inform ation hiding and data  
abstraction, a need emerged for a form of module more advanced than the routine. The  
result may be found in several d esign and programming languages  of the period; the best  
known are CLU, Modula-2 and Ada. T hey all offer a similar form of module, known in  
A d a  a s  t h e  p a c k a g e .  ( C L U  c a l l s  i t s  v a r i a n t  t h e  c l u s t e r ,  a n d  M o d ula the module. This  
discussion will reta in the Ada term.)
Packages are units of software d ecomposition with  the following  properties: 
P1 • In accordance with the Linguistic Modular Units principle, “pa ckage” is a construct  
of the language, so th at every package has a  name and a clear s yntactic scope. 
P2 • Each package definition contain s a number of declarations of r elated elements, such  
as routines and variable s, hereafter called the features  of the package. 
P3 • Every package can specify precise access rights governing the use of its features by  
other packages. In other words, the package mechanism supports information hiding. 
P4 • In a compilable language (one t hat can be used for implementat ion, not just  
specification and desi gn) it is possible to compile packages se parately. 
Thanks to P 3, packages deserve to be seen as  abstracted modules. Their majo r 
contribution is P 2, answering the Routine  Grouping requirement . A package may con tain 
any number of related operations, such as table creation, inser tion, searching and deletion.  
It is indeed not hard to see how a  package solution would work for our example problem.  
Here — in a notation adapted from the one used in the rest of t his book for object-oriented  
software — is the sketch of a package INTEGER_TABLE_HANDLING  describing a  
particular implementation of tables of integers, through binary  trees:
package INTEGER_TABLE_HANDLING  feature
type INTBINTREE
record  
-- Description of representation  of a binary tre e, for example:
info: INTEGER
left, right : INTBINTREE
endThis approach is 
studied in detail , 
through the Ada no-tion of package , in 
chapter 33 . Note 
again that by de-fault “Ada” means Ada 83. (Ada 95 re-
tains packages with a few additions. )
§4.7   TRADITIONAL MODULAR STRUCTURES 91
new: INTBINTREE is 
-- Return a new INTBINTREE , properly initialized.
do … end
has (t: INTBINTREE ; x: INTEGER ): BOOLEAN
-- Does x appear in t?
do … Implementation of searching operation … end
put (t: INTBINTREE ; x: INTEGER ) is 
-- Insert x into t.
do … end
remove (t: INTBINTREE ; x: INTEGER ) is 
-- Remove x from t.
do … end
end -- package  INTEGER_TABLE_HANDLING  
This package includes the declaration of a type ( INTBINTREE ), and a number of  
routines representing operations on objects of that type. In th is case there is no need for  
variable declara tions in the package (alt hough the routines may  have local variables). 
Client packages will now be able  to manipulate t ables by using the various features  
of INTEGER_TABLE_HANDLING . This assumes a syntactic convention allowing a client  
to use feature f from package P; let us borrow the CLU notation: P$f. Typical extracts from  
a client of INTEGER_TABLE_HANDLING  may be of the form:
-- Auxiliary declarations:
x: INTEGER ; b: BOOLEAN
-- Declaration of t using a type defined in INTEGER_TABLE_HANDLING :
t: INTEGER_TABLE_HANDLING $INTBINTREE
-- Initialize t as a new table, created by function new of the package: 
t := INTEGER_TABLE_HANDLING $new
-- Insert value of x into table, using procedure put from the package:
INTEGER_TABLE_HANDLING $put (t, x)
-- Assign True or False  to b, depending on wh ether or not x appears in t
-- for the searc h, use function has from the package:
b := INTEGER_TABLE_HANDLING $has (t, x)
Note the need to inven t two related names: one for the module, here INTEGER_
TABLE_HANDLING , and one for its main data type, here INTBINTREE . One of the key  
steps towards object orientation will be to merge the two notio ns. But let us not anticipate.
A less important problem is the tediousness of having to write the package name (here  
INTEGER_TABLE_HANDLING ) repeatedly. Languages supporting packages solve this  
problem by providing various syntac tic shortcuts, such as the f ollowing Ada-like form:
with  INTEGER_TABLE_HANDLING then
… Here  has means  INTEGER_TABLE_HANDLING $has, etc. …
end
APPROACHES TO REUSABILITY  §4.7 92
Another obvious limitation of pac kages of the above form is the ir failure to deal with  
the Type Variation issue: the mo dule as given is only useful fo r tables of integers. We will  
shortly see, however, how to corr ect this deficie ncy by making packages generic.
The package mechanism provides in formation hiding by limiting c lients’ rights on  
features. The client shown on the preceding page was able to de clare one of its own  
variables using the type INTBINTREE  from its supplier, and to call routines declared in  
that supplier; but it has access neither to the internals of th e type declaration (the record
structure defining the implementation of tables) nor to the rou tine bodies (their do 
c l a u s e s ) .  I n  a d d i t i o n ,  y o u  c a n  h i d e  s o m e  f e a t u r e s  o f  t h e  p a c k a g e (variables, types,  
routines) from clients, making th em usable only within the text  of the package.
Languages supporting the package notion differ somewhat in the details of their  
information hiding mechanism. In Ada, for example, the internal  properties of a type such  
as INTBINTREE  will be accessible to clients unless you declare the type as private . 
Often, to enforce information hi ding, encapsulation languages w ill invite you to  
declare a package in two parts, interface and implementation, r elegating such secret  
elements as the details of a typ e declaration or the body of a routine to the implementation  
part. Such a policy , however, results in extra work for the aut hors of supplier modules,  
forcing them to duplicate feature header declarations. With a b etter understanding of  
Information Hiding we do not need  any of this. Mo re in later ch apters. 
Packages: an assessment 
Compared to routines, the packag e mechanism brings a significan t improvement to the  
modularization of software system s into abstracted modules. The  possibility of gathering  
a number of features under one ro of is useful for both supplier  and client authors: 
• The author of a supplier module  can keep in one place and comp ile together all the  
software elements relating to a given concept. This facilitates  debugging and change.  
In contrast, with separate subrou tines there is always a risk o f forgetting to update  
some of the routines when you ma ke a design or implementation c hange; you might  
for example update new, put and has but forget remove . 
• For client authors, it is obviou sly easier to find and use a s et of related facilities if  
they are all in one place. 
The advantage of packages over routines is particularly clear i n cases such as our table  
example, where a package groups all the operations applying to a certain data structure. 
But packages still do not provide  a full solution to the issues  of reusability. As noted,  
they address the Routine Groupi ng requirement; but they leave t he others unanswered. In  
particular they offer no provisi on for factoring out commonalit y. You will have noted that  
INTEGER_TABLE_HANDLING , as sketched, relies on  one specific choice of  
implementation, binary search trees. True, clients do not need to be concerned with this  
choice, thanks to information hiding. But a library of reusable  components will need to  
provide modules for many differen t implementations. The resulti ng situation is easy to  
foresee: a typical package libra ry will offer do zens of similar  but never identical modules  “Supplier” is the in-
verse of “client” . 
Here the supplier is INTEGER_TABLE_HANDLING .
See “Using asser-
tions for documen-tation: the short form of a class”, page 389 and “Showing the inter-face”, page 804.
§4.8   OVERLOADING AND GENERICITY 93
in a given area such as table ma nagement, with no way to take a dvantage of the  
commonality. To provide reusabili ty to the clients, this techni que sacrifices reusability on  
the suppliers’ side. 
Even on the clients’ s ide, the situation is not completely sati sfactory. Every use of a  
table by a client req uires a declaration such as the above: 
t: INTEGER_TABLE_HANDLING $INTBINTREE 
forcing the client to choose a sp ecific implementation. This de feats the Representation  
Independence requirement: client authors will have to know more  about implementations  
of supplier notions than i s conceptually necessary. 
4.8  OVERLOADING AND GENERICITY
Two techniques, overloading and genericity, offer candidate sol utions in the effort to bring  
more flexibility to the mechanis ms just described. Let us study  what they can contribute. 
Syntactic overloading 
Overloading is the ability to at tach more than o ne meaning to a  name appearing in a  
program. 
The most common source of overloa ding is for variable names: in  a l m o s t  a l l  
languages, different variables may have the same name if they b elong to different modules  
(or, in the Algol style of languages, different blocks within a  module).
More relevant to this discussion is routine overloading , also known as operator  
overloading, which allows several routines to share the same na me. This possibility is  
almost always available for arit hmetic operators (hence the sec ond name): the same  
notation, a + b , denotes various forms of addit ion depending on the types of a and b
(integer, single-precision real, double-precision real). But mo st languages do not treat an  
operation such as "+" as a routine, and reserve it for predefined basic types — inte ger, real  
and the like. Starting with Algo l 68, which allowed overloading  t h e  b a s i c  o p e r a t o r s ,  
several languages have extended the overloading facility beyond  language built-ins to  
user-defined operations and ordinary routines. 
In Ada, for example, a package m ay contain several routines wit h the same name, as  
long as the signatures of these routines are different, where t he signature of a routine is  
defined here by the number and t ypes of its arguments. (The gen eral notion of signature  
also includes the type of the re sults, if any, but Ada resolves  overloading on the basis of  
the arguments only.) For example , a package could contain sever al square functions: 
square (x: INTEGER ): INTEGER do … end
square (x: REAL ): REAL do … end
square (x: DOUBLE ): DOUBLE do … end
square (x: COMPLEX ): COMPLEX do … end
Then, in a particular call of the form square (y), the type of y will determine which  
version of the routine you mean. The notation , compat-
ible with the one in the rest of this book , is 
Ada-like rather than exact Ada . The REAL  
type is called FLOAT  
in Ada; semicolons have been removed.
APPROACHES TO REUSABILITY  §4.8 94
A package could similarly declar e a number of search functions,  all of the form 
has (t: “SOME_TABLE_TYPE”;  x: ELEMENT  ) do … end
supporting various table implem entations and differing by the a ctual type used in lieu of  
“SOME_TABLE_TYPE” . The type of the first actual argument, in any client’s call t o has, 
suffices to determine whic h routine is intended. 
These observations suggest a gen eral characterization of routin e overloading, which  
will be useful when we later want  to contrast this facility wit h genericity:
What does routine overloading really bring to our quest for reu sability? Not much. It  
is a syntactic facility, relieving developers from having to in vent different names for various  
implementations of an operation and, in essence, placing that b urden on the compiler. But  
this does not solve any of the key issues of reusability. In pa rticular, overloading does  
nothing to address Representation Independence. When you write the call 
has (t, x)
you must have declared t and so (even if information hiding protects you from worrying  
about the details of each varian t of the search algorithm) you must know exact ly what kind  
of table t is! The only contribution of ov erloading is that you can use t he same name in all  
cases. Without overloading each implementation would require a different name, as in
has_binary_tree (t, x)
has_hash (t, x)
has_linked (t, x)
Is the possibility of avoiding di fferent names a benefit after all? Perhaps not. A basic  
rule of software construction, o bject-oriented or not, is the principle of non-deception : 
differences in semantics should be reflected by differences in the text of the software. This  
is essential to improve the understandability of software and m inimize the risk of errors.  
If the has routines are different, giving them the same name may mislead a reader of the  
software into believing that they are the same. Better force a little more wordiness on the  
client (as with the a bove specific names) an d remove any danger  of confusion. 
The further one looks into this s tyle of overloading, the more limited it appears. The  
criterion used to disambiguate calls — the signature of argumen t lists — has no particular  
merit. It works in the above examples, where the various overlo ads of square and has are 
all of different signatures, but  it is not difficult to think o f many cases where the signatures  
would be the same. One of the simplest examples for overloading  would seem t o be, in a  
graphics system, a set of functi ons used to create new points, for example under the form
p1 := new_  point (u, v)Role of overloading
Routine overloading is a facility for clients. It makes it poss ible to write the  
same client text when using diff erent implementations of a cert ain concept.See the correspond-
ing definition of ge-nericity on page 97 .
§4.8   OVERLOADING AND GENERICITY 95
There are two basic wa ys to specify a new point: through its ca rtesian coordinates x
and y (the projections on the horizon tal axis), and through its pola r coordinates ρ and θ
(the distance to the origin, and  the angle with the horizontal axis). But if we overload  
function new_point we are in trouble, since both ve rsions will have the signature
new_point (p, q: REAL ): POINT
T h i s  e x a m p l e  a n d  m a n y  s i m i l a r  o n es show that type signature, th e criterion for  
disambiguating overloaded versio ns, is irrelevant. But no bette r one has been proposed.
The recent Java language regretta bly includes the form of synta ctic overloading just  
described, in particular to provide alternative ways to create objects.
Semantic overloading (a preview)
The form of routine ove rloading described so far may be called syntactic overloading . 
The object-oriented met hod will bring a much more interesting t echnique, dynamic  
binding, which addresses the goal  of Representation Independenc e. Dynamic binding may  
be called semantic overloading . With this technique, you will be able to write the  
equivalent of has (t, x), under a suitably adap ted syntax, as a request to the machine that 
executes your software. The full  meaning of the request is some thing like this: 
Dear Hardware-Software Machine :
Please look at what t is; I know that it must be a table , but not what table  
implementation its original  creator chose — and to be  honest about it I’d much  
rather remain in the dark . After all , my job is not table management but  
investment  banking [or compiling , or computer-aided-design etc. ]. The chief  
table manager here  is someone else . So find out for yo urself about it and , once 
you have the answer , look up the prope r algorithm for has for that particular  
kind of table . Then apply that algor ithm to determine whether  x appears in t,
and tell me the result . I am eagerly waiting for your answer .
I regret to in form you that , beyond the in formation that t is a table of some kind  
and x a potential element , you will not get any more help from me .
With my sincerest wishes ,
Your friendly application developer .
Unlike syntactic overl oading, such semantic overloading is a di rect answer to the  
Representation Indepen dence requirement. It s t i l l  r a i s e s  t h e  s p ecter of violating the  
principle of non-deception; the answer will be to use assertions  to characterize the  
common semantics of a routine that has many different variants (for example, the common  
properties which characterize has under all possible ta ble implementations). 
Because semantic overloading, to  work properly, requires the fu ll baggage of object  
orientation, in particular inheri tance, it is understandable th at non-O-O languages such as  
Ada offer syntactic overloading as a partial substitute in spit e of the problems mentioned  
above. In an object-oriented langu age, however, pr oviding synta ctic overloading on top of  More on syntactic 
overloading in “Multiple creation and overloading”, page 239 and “O-O development and overloading”, page 564.
“DYNAMIC BIND-
ING”, 14.4, page 480.
How remarkably 
concise software languages are in comparison !
APPROACHES TO REUSABILITY  §4.8 96
dynamic binding can be confusing, as is illustrated by the case  of C++ and Java which both  
allow a class to introduce several routines with the same name,  leaving it to the compiler  
and the human reader t o disambiguate calls. 
Genericity
Genericity is a mechan ism for defining parameterized module pat terns, whose parameters  
represent types.
This facility is a direct answer to the Type Variation issue. I t avoids the need for  
many modules such as 
INTEGER_TABLE_HANDLING
ELECTRON_TABLE_HANDLING
ACCOUNT_TABLE_HANDLING
by enabling you instead to write  a single module  pattern of the  form 
TABLE_HANDLING [G]
where G is a name meant to represent an  arbitrary type and known as a formal generic  
parameter . (We may later encounter the need for two or more generic para meters, but for  
the present discussion we may limit ourselves to one.) 
Such a parameterized module pattern is known as a generic module , although it is  
not really a module, only a blue print for many possible modules . To obtain one of these  
a c tu al  m od ul es ,  y ou m u st  pr o vi de  a t yp e,  k no w n a s a n actual generic parameter , to 
replace G; the resulting (non-generic) modules are written for example 
TABLE_HANDLING [INTEGER ]
TABLE_HANDLING [ELECTRON ]
TABLE_HANDLING [ACCOUNT ]
using types INTEGER , ELECTRON  a n d  ACCOUNT  respectively as actual generic  
parameters. This process of obtaining an actual module from a g eneric module (that is to  
say, from a module pattern) by p roviding a type as actual gener ic parameter will be known  
as generic derivation ; the module itself will be sa id to be generically derived. 
Two small points of terminology. First, generic derivation is s ometimes called generic  
instantiation, a generically derived module then being called a  generic instance. This  
terminology can cause confusion in  an O-O context, since “insta nce” also denotes the  
run-time creation of objects ( instances ) from the corresponding types. So for genericity  
we will stick to the “derivation” terminology.
Another possible source of confusion is “parameter”. A routine may have formal  
arguments, representing values w hich the routine’s clients will  provide in each call. The  
literature commonly uses the term parameter (formal, actual) as  a synonym for argument  
(formal, actual). There is nothing wrong in principle with eith er term, but if we have both  
routines and genericity we need a clear convention to avoid any  misunderstanding. The  
convention will be to use “argument” for routines only, and “pa rameter” (usually in the  
form “generic parameter” for fur ther clarification) for generic  modules only. 
§4.8   OVERLOADING AND GENERICITY 97
Internally, the declaration of the generic module TABLE_HANDLING  will resemble  
that of INTEGER_TABLE_HANDLING  above, except that it uses G instead of INTEGER
wherever it refers to the type o f table elements. For example: 
package TABLE_HANDLING [G] feature
type BINARY_TREE
record
info: G
left, right : BINARY_TREE
end
has (t: BINARY_TREE ; x: G): BOOLEAN
-- Does x appear in t?
do … end
put (t: BINARY_TREE ; x: G)
-- Insert  x into t.
do … end
(Etc.)
end -- package  TABLE_HANDLING  
It is somewhat disturbing to s ee the type bein g declared as BINARY_TREE , and 
tempting to make it generic as well (something like BINARY_TREE [G]). There is no  
obvious way to achieve this in a package approach. Object techn ology, however, will  
merge the notions of module and type, so the temptation will be  automatically fulfilled.  
We will see this when we study how to integrate genericity into  the object-oriented world. 
It is interesting to define gene ricity in direct contrast with the definition given earlier  
for overloading:
W h a t  h e l p  d o e s  g e n e r i c i t y  b r i n g  u s  t o w a r d s  r e a l i z i n g  t h e  g o a l s  of this chapter?  
Unlike syntactic overloa ding, genericity has a real contributio n to make since as noted  
a b o v e  i t  s o l v e s  o n e  o f  t h e  m a i n  issues, Type Variation. The pre sentation of object  
technology in part C of  this book will indee d devote a signific ant role to genericity. 
Basic modularity techn iques: an assessment 
We have obtained two main resul ts. One is the idea of providing  a single syntactic home,  
such as the package construct, for a set of routines that all m anipulate similar objects. The  
other is genericity, which yield s a more flexible form of modul e. 
All this, however, onl y covers two of the reusability issues, R outine Grouping and  
Type Variation, and provides little help for the other three — Implementation Variation,  
Representation Indepen dence and Factoring Out Common Behaviors.  Genericity, in  
particular, does not suffice as a solution to the Factoring iss ue, since making a module  Role of genericity
Genericity is a facility for the authors of supplier modules. I t makes it  
possible to write the same supplier text when using the same im plementation  
of a certain concept , applied to differen t kinds of object. To be compared 
with INTEGER_
TABLE_HAN-DLING , page 90 .
Chapter 10 discuss-
es O-O genericity .
See the correspond-
ing definition of overloading on page 94 .
APPROACHES TO REUSABILITY  §4.9 98
generic defines two levels only: generic module patterns, param eterized and hence open  
to variation, but not directly us able; and individual generic d erivations, usab le directly but  
closed to further variation. Thi s does not allow us to capture the fine differences that may  
exist between competing represen tations of a giv en general conc ept. 
On Representation Independence, we have made almost no progress . None of the  
techniques seen so far — except for the short glimpse that we h ad of semantic overloading  
— will allow a client to use various implementations of a gener al notion wi thout knowing  
which implementation e ach case will select.
To answer these concerns, we will have to turn to the full powe r of object-
oriented concepts. 
4.9  KEY CONCEPTS INTRO DUCED IN THIS CHAPTER 
• Software development is a highl y repetitive acti vity, involvin g frequent use of  
common patterns. But there is considerable variation in how the se patterns are used  
and combined, defeating simplist ic attempts to work from off-th e-shelf components. 
• Putting reusability into practice raises economical, psycholog ical and organizational  
problems; the last category invo lves in particular building mec hanisms to index,  
store and retrieve large numbers o f reusable components. Even m ore important,  
however, are the underlying technical problems: commonly accept ed notions of  
module are not adequate to support serious reusability.
• T h e  m a j o r  d i f f i c u l t y  o f  r e u s e  i s  t h e  n e e d  t o  c o m b i n e  r e u s e  w i t h adaptation. The  
“reuse or redo” dilemma is not a cceptable: a goo d solution must  make it possible to  
retain some aspects of a reused module a nd adapt others. 
• Simple approaches, su ch as reuse of personn el, reuse of design s, source code reuse,  
and subroutine libraries, have e xperienced some degree of succe ss in specific  
contexts, but all fall short of providing th e full potential be nefits of reusability. 
• The appropriate unit of reuse i s some form of abstracted modul e, providing an  
encapsulation of a cer tain functionality t hrough a well-defined  interface. 
• Packages provide a better encap sulation technique than routine s, as they gather a  
data structure and the  associated operations. 
• Two techniques extend the flexi bility of packag es: routine ove rloading, or the reuse  
of the same name for more than one operation; genericity, or th e availability of  
modules paramete rized by types. 
• Routine overloading is a syntac tic facility which does not sol ve the important issues  
of reuse, and harms  the readability of software texts. 
• Genericity helps, but o nly deals with the i ssue of type variat ion. 
• What we need: techniques for cap turing commonalities within gr oups of related data  
structure implementations; and t echniques for isolating clients  from having to know  
the choice of supplier variants. 
§4.10   BIBLIOGRAPHICAL NOTES 99
4.10  BIBLIOGRAPHICAL NOTES
The first published discussion o f reusability in  software appea rs to have been McIlroy’s  
1968 Mass-Produced Software Components , mentioned at the begin ning of this chapter.  
His paper [McIlroy 1976]  w a s  p r e s e n t e d  i n  1 9 6 8  a t  t h e  first conference on software  
engineering, con vened by the NATO Scienc e Affairs Committee. (1 976 is the date of the  
proceedings, [Buxton 1976] , whose publication was delaye d by several years.) McIlroy  
advocated the development of an i ndustry of software components . Here is an extract: 
Software production today appears in the scale of in dustrialization somewhere  
below the more backward  construction industries . I think its pr oper place is  
considerab ly higher , and would like to investig ate the prospe cts for mass-
production techniques in software …
When we undertake to write a compiler , we begin by saying “What table  
mechanism shall we build  ?”. Not “What mechanism shall we use ?”…
My thesis is that the software industry is weakly founded [in part because of ]
the absence of a software  components subindustry … Such a components  
industry could be immensely successful .
One of the important points argu ed in the paper was the necessi ty of module families,  
discussed above as one of the re quirements on any comprehensive  solution to reuse.
Rather than the word “module”, McIlroy’s text used “routine”; in light of this chapter’s  
discussion, this is — with the hindsight of thirty years of fur ther software engineering  
development — too restrictive.
A special issue of the IEEE Transactions on Software Engineering  edited by  
Biggerstaff and Perlis [Biggerstaff 1984]  was influential in brin ging reusability to the  
attention of the software engine ering community; see in particu lar, from that issue,  
[Jones 1984] , [Horowitz 1984] , [Curry 1984] , [Standish 1984]  and [Goguen 1984] . The 
s a m e  e d i t o r s  i n c l u d e d  a l l  t h e s e  a r t i c l e s  ( e x c e p t  t h e  f i r s t  m e n t ioned) in an expanded  
two-volume collection [Biggerstaff 1989] . Another collection of articles on reuse is  
[Tracz 1988] . More recently Tracz col lected a number of his IEEE Computer  columns  
into a useful book [Tracz 1995]  emphasizing the management aspects.
One approach to reuse, based on concepts from artificial intell igence, is embodied in  
the MIT Programmer’s Apprentice project; see [Waters 1984]  a n d  [Rich 1989] ,
reproduced in the first and seco nd Biggerstaff-Perlis collectio ns respectively. Rather than  
actual reusable modules, this system uses patterns (called clichés  and plans ) representing  
common program design strategies.
Three “encapsulation languages” w ere cited in the discussion of  packages: Ada,  
Modula-2 and CLU. Ada is discussed in a later chapter, whose bi bliography section gives  
references to Modula-2, CLU, as w ell as Mesa and Alphard, two o ther encapsulation  
languages of the “modu lar generation” of the seventies and earl y eighties. The equivalent  
of a package in Alphar d was called a form.The most important characteristic of a software components  industry  is that  
it will offer families of [modules ] for a given job .
Ada is covered in 
chapter 33 ; see its 
“BIBLIOGRAPHI-CAL NOTES”, 33.9, page 1097 .
APPROACHES TO REUSABILITY  §4.10 100
An influential project of the ni neteen-eighties, the US Departm ent of Defense’s  
STARS, emphasized reusability with a special concern for the or ganizational aspects of  
the problem, and using Ada as the  language for software compone nts. A number of  
contributions on this a pproach may be found in the proceedings of the 1985 STARS DoD-
Industry conference [NSIA 1985] .
The two best-known books o n “design patterns” are [Gamma 1995]  and [Pree 1994] .
[Weiser 1987]  is a plea for the distribution of software in s ource form. Tha t article,  
however, downplays the need for a bstraction; as pointed out in this chapter, it is possible  
to keep the source form availabl e if needed but use a higher-le vel form as the default  
documentation for the users of a  module. For different reasons,  Richard Stallman, the  
creator of the League for Progra mming Freedom, has been arguing  that the source form  
should always be  available; see [Stallman 1992] .
[Cox 1992]  describes the idea of  superdistribution.
A form of overloading wa s present in Algol 68 [van Wijngaarden 1975] ; Ada (which  
extended it to routines), C++ an d Java, all discussed in later chapters, make extensive use  
of the mechanism.
Genericity appears in Ada and CLU and in an early version of th e Z specification  
language [Abrial 1980] ; in that version the Z syntax i s close to the one used for gen ericity  
in this book. The LPG language [Bert 1983]  was explicitly designed to explore genericity.  
(The initials sta nd for Language for Pro gramming Generically.)
T h e  w o r k  c i t e d  a t  t h e  b e g i n n i n g  o f  t h i s  c h a p t e r  a s  t h e  b a s i c  r e ference on table  
searching is [Knuth 1973] . Among the many algorithms and data structures textbooks  
which cover the question, see [Aho 1974] , [Aho 1983]  or [M 1978] .
Two books by the author of the present one explore further the question of reusability.  
Reusable Software  [M 1994a] , entirely devoted to the topic, provides design and  
implementation principles for building quality libraries, and t he complete specification of  
a set of fundamental libraries. Object Success [M 1995]  discusses management aspects,  
especially the areas in which a company interested in reuse sho uld exert its efforts, and  
areas in which efforts will probably be wasted (such as preachi ng reuse to application  
developers, or rewarding reuse) . See also a short article on th e topic, [M 1996] .
5  
Towards object technology
E xtendibility, reusability and reliability, our principal goals,  require a set of conditions  
defined in the preceding chapters .  T o  a c h i e v e  t h e se conditions,  w e  n e e d  a  s y s t e m a t i c  
method for decomposing systems into modules.
This chapter presents the basic elements of such a method, base d on a simple but far-
reaching idea: build every module  on the basis of some object t ype. It explains the idea,  
develops the rationale for it, and explores some of the immedia te consequences.
A word of warning. Given today’s  apparent prominence of object technology, some  
readers might think that the ba ttle has been won and that no fu rther rationale is necessary.  
This would be a mistake: we need  to understand the basis for th e method, if only to avoid  
common misuses and pitfalls. It is in fact frequent to see the word “object-ori ented” (like  
“structured” in an earlier era) used as mere veneer over the mo st conventional techniques.  
Only by carefully build ing the case for object technology can w e learn to detect improper  
uses of the buzzword, and stay a way from common mistakes review ed later in this chapter.
5.1  THE INGREDIENTS OF COMPUTATION
The crucial question in our searc h for proper software architec tures is modularization : 
what criteria should we use to find the modules of our software ?
To obtain the proper a nswer we must first ex amine the contendin g candidates.
The basic triangle
Three forces are at play when we use software to perform  some computations:
The three 
forces of 
computationAction Object
Processor
TOWARDS OBJECT TECHNOLOGY  §5.1 102
To execute a software system is to use certain processors  to apply certain actions  to 
certain objects .
T h e  p r o c e s s o r s  a r e  t h e  c o m p u t a t i o n  d e v i c e s ,  p h y s i c a l  o r  v i r t u a l , that execute  
instructions. A proces sor can be an actual processing unit (the  CP U of a computer),  a  
process on a conventio nal operating system, or a “thread” if th e OS is mult i-threaded.
The actions are the operations making up the computation. The e xact form of the  
actions that we consider will dep end on the level of granularit y of our analysis: at the  
hardware level, actions are mach ine language operations; at the  level of the hardware-
software machine, they are instr uctions of the programming lang uage; at the level of a  
software system, we ca n treat each major step of a complex algo rithm as a sin gle action. 
The objects are the data structu res to which the actions apply.  Some of these objects,  
the data structures built by a co mputation for it s own purposes , are internal and exist only  
while the computation proceeds; others (contained in the files,  databases and other  
persistent repositorie s) are external and may outlive individua l computations.
Processors will become imp ortant when we discuss concurrent  f o r m s  o f  
computation, in which several su b-computations can proceed in p arallel; then we will  
need to consider two or more processors, physical or virtual. B ut that is the topic of a later  
chapter; for the moment we can l imit our attenti on to non-concu rrent, or sequential
computations, relying on a single processor which will remain i mplicit.
This leaves us with ac tions and objects. The  duality between ac tions and objects —  
what a system does vs. what it does it to — is a perv asive theme in software enginee ring.
A note of terminology. Synonyms are available to denote each of  the two aspects: the  
word data will be used here as a synonym for objects ; for action  the discussion will often  
follow common practice and talk about the functions  of a system.
The term “function” is not without disadvantages, since softwar e discussions also use it  
in at least two other meanings: the mathematical sense, and the  programming sense of  
subprogram returning a result. But we can use it without ambigu ity in the phrase  the 
functions of a system , which is what we need here.
The reason for using this word rather than “action” is the mere  grammatical convenience  
of having an associated adjective, used in the phrase functional decomposition . “Action”  
has no comparable derivation. Another term whose meaning is equ ivalent to that of  
“action” for the purpose of this discussion is operation .
Any discussion of software issue s must account for both the obj ect and function  
aspects; so must the design of any software system. But there i s one question for which  
we must choose — the question of  this chapter: what is the appr opriate criterion for  
finding the modules of a system? Here we must decide whether mo dules will be built as  
units of functional decompositi on, or around major types of obj ects.
From the answer will follow the difference between the object-o riented approach  
and other methods. Traditional a pproaches build each module aro und some unit of  
functional decomposition — a certain piece of the action. The o bject-oriented method,  
instead, builds each module around some type of objects.Concurrency is the 
topic of chapter 30 .
§5.2   FUNCTIONAL DECOMPOSITION 103
This book, predictably, develops  the latter approach. But we sh ould not just embrace  
O-O decomposition because the tit le of the book so implies, or because it is the “in” thing  
to do. The next few sections wil l carefully examine the argumen ts that justify using object  
types as the basis for modularization — starting with an explor ation of the merits and  
limitations of traditi onal, non-O-O methods.  Then we will try t o get a clearer  
understanding of what the word “object” really means for softwa re development, although  
the full answer, requiring a lit tle theoretical detour, will on ly emerge in the next chapter.
W e  w i l l  a l s o  h a v e  t o  w a i t  u n t i l  t h e  n e x t  c h a p t e r  f o r  t h e  f i n a l  settlement of the  
formidable and ancient fight tha t provides the theme for the re st of the present discussion:  
the War of the Objects and the F unctions. As we prepare ourselv es for a campaign of  
slander against the functions as  a basis for system decompositi on, and of c orresponding  
praise for the objects, we must not forget the o bservation made  above: in the end, our  
solution to the software structuring problem must provide space  for both functions and  
objects — although not necessaril y on an equal basis. To discov er this new world order,  
we will need to define the respec tive roles of it s first-class and second-class citizens.
5.2  FUNCTIONAL DECOMPOSITION
We should first examine the merits and limitations of the tradi tional approach: using  
functions as a basis for the architecture of software systems. This will not only lead us to  
appreciate why we need something  else — object technology — but  also help us avoid,  
when we do move into the object w orld, certain methodological p itfalls such as premature  
operation ordering, whi ch have been known t o fool even experien ced O-O developers.
Continuity
A key element in answering the qu estion “should we structure sy stems around functions  
or around data?” is the problem of extendibility, and more prec isely the goal called  
continuity  in our earlier discuss ion s. As y ou w ill recall, a design  metho d satisfies this  
criterion if it yields stable ar chitectures, keeping the amount  of design change  
commensurate with the size of  the specification change.
Continuity is a crucial concern if we consider the real lifecyc le of software systems,  
including not just the productio n of an acceptable initial vers ion, but a system’s long-term  
evolution. Most system s undergo numerous changes after their fi rst delivery. Any model  
of software development that onl y considers the period leading to that delivery and  
ignores the subsequent era of cha nge and revision is as remote from real life as those  
novels which end when the hero ma rries the heroine — the time w hich, as everyone  
knows, marks the begin ning of the really interesting part.
To evaluate the quality of an ar chitecture (and of the method t hat produced it), we  
should not just consider how eas y it was to obtain this archite cture initially: it is just as  
important to ascertain how well the architecture will weather c hange.
The traditional answer to the qu estion of modularization has be en top-down  
functional decomposition, briefl y introduced in an earlier chap ter. How well does top-
down design respond to the requirements of modularity?“Modular continu-
ity”, page 44 .
Top-down design 
was sketched in “Modular decom-posability”, page 40 .
TOWARDS OBJECT TECHNOLOGY  §5.2 104
Top-down development
There was a most ingenious archit ect who had contrived a new method  
for buildi ng houses , by beginning at the roof , and working downwards  
to the foundation , which he justified to me by  the like practice of those  
two prudent insects , the bee and the spider . 
Jonathan Swift:  Gulliver’s Travels , Part III, A 
Voyage to Laputa , etc., Chapter 5.
The top-down approach builds a sy stem by stepwise refinement, s tarting with a definition  
of its abstract function. You start the process by expressing a  topmost statement of this  
function, such as
[C0]
“Translate a C progr am to machine code”
or:
[P0]
“Process a user command”
and continue with a sequence of refinement steps. Each step mus t decrease the level of  
abstraction of the elements obta ined; it decomposes every opera tion into a combination of  
one or more simpler operations. For example, the next step in t he first example (the C  
compiler) could produce the decomposition
[C1]
“Read program and produ ce sequence of tokens”
“Parse sequence of  tokens into abstra ct syntax tree”
“Decorate tree with semantic information”
“Generate code from decorated tree”
or, using an alternative structur e (and making the simplifying assumption that a C program  
is a sequence of fun ction definitions):
[C'1]
from
“Initialize da ta structures”
until
“All function definitions processed”
loop
“Read in next function definition”
“Generate partial code”
end
“Fill in cross references”
§5.2   FUNCTIONAL DECOMPOSITION 105
In either case, the de veloper must at each step examine the rem aining incompletely  
expanded elements (such as “Read program …” and “All function definitions processed” ) 
an d e xp an d t he m ,  u si ng  t he  sa m e  re f in em e nt  p ro ce ss ,  u nt i l e ve r y thing is at a level of  
abstraction low enough to al low direct implementation.
W e may picture the process of top-down refinement as the develo pment of a tree.  
Nodes represent elements of the decomposition; branches show th e relation “ B is part of  
the refinement of A”.
The top-down approach has a numb er of advantages. It is a logic al, well-organized  
thought discipline; it can be taught effectively; it encourages  orderly development of  
systems; it helps the designer f ind a way through the apparent complexity that systems  
often present at the initia l stages of their design.
The top-down approach can indeed  be useful for developing indiv idual algorithms.  
But it also suffers from limitat ions that make i t questionable as a tool for the design of  
entire systems:
• The very idea of characterizing  a system by just one function is subject to doubt.
• By using as a basis for modular  decomposition the properties t hat tend to change the  
most, the method fails  to account for the ev olutionary nature o f software systems.
Not just one function
In the evolution of a system, wha t may originally have been per ceived as the system’s  
main function may become l ess important over time.
Consider a typical payroll system . When stating his initial req uirement, the customer  
may have envisioned just what the name suggests: a system to pr oduce paychecks from  
the appropriate data. His view of the system, implicit or expli cit, may have been a more  
ambitious version of this:Top-down 
design : tree 
structure
(This figure first 
appeared on  
page 41 .)A
B D C
C1 I I1 C2 I2Sequence
Loop ConditionalTopmost functional abstraction
TOWARDS OBJECT TECHNOLOGY  §5.2 106
The system takes some inputs (su c h  a s  r e c o r d  o f  h o u r s  w o r k e d  a n d employee  
information) and produces some ou tputs (paychecks and so on). T his is a simple enough  
functional specification, in the strict sense of the word funct ional: it defines the program  
as a mechanism to perform one function — pay the employees. The  top-down f unctional  
method is meant precis ely for such well-defi ned problems, where  the task is to perform a  
single function — the “top” o f the system to be built.
Assume, however, that the develo pment of our payroll program is  a success: the  
program does the requisite job. Most likely , the development wi ll not stop there. Good  
systems have the detestable habi t of giving their users plenty of ideas about all the other  
things they could do. As the system’s develo per, you may initia lly have been told that all  
you had to do was to generate paychecks and a few auxiliary out puts. But now the requests  
for extensions start l anding on your desk: Could the program ga ther some statistics on the  
side? I did tell you that next q uarter we are going to start pa ying some employees monthly  
and others biweekly, did I not? And, by the way, I need a summa r y  e v e r y  m o n t h  f o r  
management, and one every quarte r for the shareholders. The acc ountants want their own  
output for tax preparation purpo ses. Also, you are keeping all this salary information,  
right? It would be really nifty t o let Personnel access it inte ractively. I cannot imagine why  
that would be a difficult functionality to add.
This phenomenon of having to add  unanticipated f unctions to suc cessful systems  
occurs in all application areas. A nuclear code that initially just applied some algorithm to  
produce tables of numbers from batch input will be extended to handle graphical input and  
output or to maintain a database of previous results. A compile r that just translated valid  
source into object code will after a while double up as a synta x verifier, a static analyzer,  
a pretty-printer, even a  programming environment.
This change process is often inc remental. The new requirements evolve from the  
initial ones in a continuous way . The new system is still, in m any respects, “the same  
system” as the old one: still a payroll system, a nuclear code,  a compiler. But the original  
“main function”, which may have seemed so important at first, o ften becomes just one of  
many functions; someti mes, it just vanishes, having outlived it s usefulness.
If analysis and design have used a decomposition method based o n the function, the  
system structure will follow fro m the designers’ original under standing of the system’s main  
function. As the system evolves, the designers may feel sorry ( or its maintainers, if different  
people, may feel angry) about th at original assessment. Each ad dition of a new function,  
however incremental it seems t o the customer, risks invalidatin g the entire structure.
It is crucial to find, as a crit erion for decomposition, proper ties less volatile than the  
system’s main function.Employee
 
HoursPaychecksProduce PaychecksInformation
Worked  Structure of a 
simple payroll 
program
§5.2   FUNCTIONAL DECOMPOSITION 107
Finding the top
Top-down methods assume that every system is characterized, at the most abstract level,  
by its main function. A lthough it is indeed easy to specify tex tbook examples of  
algorithmic problems —  the Tower of Hanoi, the Eight Queens and  the like — through  
their functional “tops”, a more useful description of practical  software systems considers  
each of them as offering a numbe r of services. Defining such a system by a single function  
is usually possible, but yield s a rather artificial view.
Take an operating system. It is best understood as a system tha t provides certain  
services: allocating CPU time, ma naging memory, handling input and output devices,  
decoding and carrying out users’ c ommands. The modules of a wel l-structured OS will  
tend to organize themselves arou n d  t h e s e  g r o u p s  o f  f u n c t i o n s .  B ut this is not the  
architecture that you will get f rom top-down functional decompo sition; the method forces  
you, as the designer, to answer the artificial question “what i s the topmost function?”, and  
then to use the successive refinements of the answer as a basis  for the structure. If hard  
pressed you could prob ably come up with an initial answer of th e form
“Process all user requests”
which you could then ref ine into something like
from
boot
until
halted  or crashed
loop
“Read in a user’s request and put it  into input queue”
“Get a request r from input queue”
“Process r”
“Put result into  output queue”
“Get a result o from output queue”
“Output o to its recipient”
end
Refinements can go on. From such premises, however, it is unlik ely that anyone can  
ever develop a reasonably str uctured operat ing system.
E v e n  s y s t e m s  w h i c h  m a y  a t  f i r s t  s e e m  t o  b e l o n g  t o  t h e  “ o n e  i n p u t, one abstract  
function, one output” category re veal, on closer examination, a  more diverse picture.  
Consider the earlier example of a compiler. Reduced to its bare  essentials, or to the view  
of older textbooks, a compiler i s the implementation of one inp ut-to-output function:  
transforming source te xt in some programming  language into mach ine code for a certain  
platform. But that is not a sufficient view of a modern compile r. Among its many services,  
a compiler will perform error de tection, program formating, som e configuration  
management, logging, r eport generation.
TOWARDS OBJECT TECHNOLOGY  §5.2 108
Another example is a typesetting program, taking input in some text processing  
format — T EX, Microsoft Word, FrameMaker … — and generating output in HTML,  
Postscript or Adobe Ac robat format. Again we may view it at fir st as just an input-to-
output filter. But most likely it will perform a number of othe r services as well, so it seems  
more interesting, when we are tr ying to characterize the system  in the most general way,  
to consider the various types of  data it manipulates: documents , chapters, sections,  
paragraphs, lines , words, charact ers, fonts, ru nning heads, tit les, figures and others.
The seemingly obvious starting point of top-down design — the v iew that each new  
development fulfills a  request for a specific function — is sub ject to doubt:
Functions and evolution
Not only is the main function of ten not the best criterion to c haracterize a system initially:  
it may also, as the system evolves, be among the first properti es to change, forcing the  
top-down designer into frequent re d e s i g n  a n d  d e f e a t i n g  o u r  a t t e mpts to satisfy the  
continuity requirement.
C o n s i d e r  t h e  e x a m p l e  o f  a  p r o g r a m  t h a t  h a s  t w o  v e r s i o n s ,  a  “ b a t ch” one which  
handles every session as a single big run over the problem, and  an interactive one in which  
a  s e s s i o n  i s  a  s e q u e n c e  o f  t r a n s a c t i o n s ,  w i t h  a  m u c h  f i n e r  g r a i n of user-system  
communication. This is typical of  large scientific programs, wh ich often have a “let it run  
a big chunk of computation for t he whole night” version and a “ let me try out a few things  
and see the results at once then  continue with something else” version.
The top-down refinement of the  batch version m ight begin as
[B0] -- Top-level abstraction
“Solve a complete inst ance of the problem”
[B1] -- First refinement
“Read input values”
“Compute results”
“Output results”
and so on. The top-down developme nt of the interactive version,  for its part, could proceed  
in the following style:Real systems have no top.
§5.2   FUNCTIONAL DECOMPOSITION 109
[I1]
“Process one transaction”
[I2]
if “New information pr ovided by the user” then
“Input information”
“Store it”
elseif  “Request for informa tion previously given” then  
“Retrieve request ed information”
“Output it”
elseif  “Request fo r result” then  
if “Necessary inform ation available” then  
“Retrieve reque sted result”
“Output it”
else
“Ask for confirmation of the request”
if Yes then
“Obtain required information”
“Compute requested result”
“Output result”
end
end
else
(Etc.)
Started this way, the developmen t will yield an entirely differ ent result. The top-
down approach fails to account fo r the property that the final programs are but two  
different versio n s  o f  t h e  s a m e  s o f t w a r e  s y s t e m  —  w h e t h e r  t h e y  a re developed  
concurrently or one has evolved from the other.
This example brings to light two of the most unpleasant consequ ences of the top-
down approach: its focus on the ex ternal interface (implying he re an early choice between  
batch and interactive) and its p remature binding of temporal re lations (the order in which  
actions will be executed).
Interfaces and software design
System architecture should be ba sed on substance, not form. But  top-down development  
tends to use the most superficial aspect of the system — its ex ternal interface — as a basis  
for its structure.
The focus on external interfaces is i nevitable in a method that  asks “What will the  
system do for the end user?” as the key question: the answer wi ll tend to emphasize the  
most external aspects.
TOWARDS OBJECT TECHNOLOGY  §5.2 110
The user interface is only one of  the components of a system. O ften, it is also among  
the most volatile, if only because of the difficulty of getting  it right the first time; initial  
versions may be of the mark, requiring experimentation and user  feedback to obtain a  
satisfactory solution. A healthy design method will try to sepa rate the interface from the  
rest of the system, using more st able properties as the basis f or system structuring.
It is in fact often possible to build the interface separately from the rest of the system,  
using one of the many tools avai lable nowadays t o produce elega nt and user-friendly  
interfaces, often based on object-oriented techniques. The user  interface then becomes  
almost irrelevant to the overall system design.
Premature ordering
The preceding examples illustrate another drawback of top-down functional  
decomposition: premature emphasi s on temporal constraints. Each  refinement expands a  
piece of the abstract structure into a more detailed control  architecture, specifying the  
order in which various functions  (various pieces of the action)  will be executed. Such  
ordering constraints become esse ntial properties of the system architecture; but they too  
are subject to change.
Recall the two alternative candid ate structures for the first r efinement of a compiler:
[C1]
“Read program and produ ce sequence of tokens”
“Parse sequence of  tokens into abstra ct syntax tree”
“Decorate tree with semantic information”
“Generate code from decorated tree”
[C'1]
from
“Initialize da ta structures”
until
“All function definitions processed”
loop
“Read in next function definition”
“Generate partial code”
end
“Fill in cross references”
As in the preceding example we start with two completely differ ent architectures.  
Each is defined by a control structure (a sequence of instructi ons in the first case, a loop  
followed by an instruction in th e second), implying strict orde ring constraints between the  
elements of the structure. But freezing such ordering relations  at the earliest stages of  
design is not reasonable. Issues such as the number of passes i n a compiler and the  
sequencing of various activities (lexical analysis, parsing, se mantic processing,  
optimization) have many possible solutions, which the designers  must devise by  
considering space-time tradeoffs  and other criteria which they do not necessarily master  Chapter 32 dis-
cusses techniques and tools for user interfaces .
§5.2   FUNCTIONAL DECOMPOSITION 111
at the beginning of a project. They can perform fruitful design  and implementation work  
on the components long before freezing thei r temporal ordering,  and will want to retain  
this sequencing freedom for as long as possible. Top-down funct ional design does not  
provide such flexibility: you mus t specify the order of executi ng operations before you  
have had a chance to understand properly what these operations will do.
Some design methods that attempt  to correct some of the deficie ncies of functional  
top-down design also suffer from this premature binding of temp oral relationships. This  
is the case, among others, with the dataflow-directed method kn own as structured analysis  
and with Merise (a met hod popular in some E uropean countries).
Object-oriented development, for  its part, stays away from prem ature ordering. The  
designer studies the v arious operations ap plicable to a certain  kind of data, and specifies  
the effect of each, but defers fo r as long as possible specifyi ng the operations’  order of  
execution. This ma y be called the shopping list approach: list needed operations — all the  
operations that you may need; ign ore their ordering constraints  until as late as possible in  
the software construction proces s. The result is much more exte ndible architectures.
Ordering and O-O development
The observations on the risks of premature ordering deserve a l ittle more amplification  
because even object-oriented des igners are not immune. The shop ping list approach is one  
of the least understood parts of  the method and it is not infre quent to see O-O projects fall  
into the old trap, with damaging  effects on quality. This can r esult in particular from  
misuse of the use case  idea, which we will encounter in  the study of O- O methodology.
The problem is that the order of  operations may seem so obvious  a property of a  
system that it will weasel itself into the earliest stages of i ts design, with di re consequences  
if it later turns out to be not so final after all. The alterna tive technique (under the  
“shopping list” a pproach), perhaps less n atural at first but mu ch more flexible, uses logical  
rather than temporal constraints. It relies on the assertion co ncept developed later in this  
book; we can get the basic idea no w through a simple non-softwa re example.
Consider the problem of buying a  house, reduced (as a gross fir st approximation) to  
three operations: finding a hous e that suits you; getting a loa n; signing the c ontract. With  
a method focusing on ordering we w ill describe the design as a simple sequence of steps:
[H]
find_house
get_loan
sign_contract
In the shopping list approach of O-O development we will initia lly refuse to attach  
too much importance to this orde ring property. But of course co nstraints exist between the  
operations: you cannot sign a con tract unless (let us just avoi d saying until for the time  
being!) you have a desired house  and a loan. We can express the se constraints in logical  
rather than temporal form:See the bibliogra-
phical notes for  
references on the methods cited .
Chapter 11 presents 
assertions.
TOWARDS OBJECT TECHNOLOGY  §5.2 112
[H'1]
find_property
ensure
property_found
get_loan
ensure
loan_approved
sign_contract
require
property_found and loan_approved
The notation will only be int roduced formally in chapter 11, but it should be clear  
enough here: require states a precondition, a logical property that an operation req uires 
for its execution; and ensure  states a postcondition, a logical property that will follow  
from an operation’s execution. W e have expressed that each of t he first two operations  
achieves a certain property, and that the last op eration requir es both of these properties.
Why is the logical form of stati ng the constraints, H'1, better  than the temporal form,  
H1? The answer is clear: H'1 expr esses the minimum requirements , avoiding the  
overspecification of H1. And indeed H1 is too strong, as it rul es out the scheme in which  
you get the loan first and then worry about the property — not at all absurd for a particular  
buyer whose main problem is fina ncing. Another buyer might pref er the reverse order; we  
should support both schemes as l ong as they obse rve the logical  constraint.
Now imagine that we turn this ex ample into a realistic model of  the process with the  
many tasks involved — title search, termite inspection, pre-qua lifying for the loan, finding  
a real estate agent, selling you r previous house if applicable,  inviting your f riends to the  
house-warming party … It may be possible to express th e ordering constra ints, but the  
result will be complicated and p robably fragile (you may have t o reconsider e verything if  
you later include another task). The logical constraint approac h scales up much more  
smoothly; each operation simply states what it needs and what i t guarantees, all in terms  
of abstract properties.
These observations are  particularly importa nt for the would-be object designer, who  
may still be influenced by functi onal ideas, and might be tempt ed to rely on early  
identification of system usage scenarios (“use cases”) as a bas is for analysis. This is  
incompatible with object-oriente d principles, and often leads t o top-down functional  
decomposition of the purest form — even when the team members a re convinced that they  
are using an object-oriented method.
We will examine, in our study of O-O methodological principles,  what role can be found  
for use cases in object-orient ed software construction.
Reusability
After this short advance incursi on into the fringes of object t erritory, let us resume our  
analysis of the top-down method,  considering it this time in re lation to one of our principal  
goals, reusability.Exercise E6.7, page 
162 (in the next chapter).
“Use cases”, page 
738.
§5.2   FUNCTIONAL DECOMPOSITION 113
W o r k i n g  t o p - d o w n  m e a n s  t h a t  y o u  d evelop software elements in re sponse to  
particular subspecific ations encountered in the tree-like devel opment of a system. At a  
given point of the development, corresponding to the refinement  of a certain node, you  
will detect the need for a speci fic function — such as analyzin g an input command line —  
and write down its specification, which you or someone else wil l then  implement.
The figure, which shows part of a  top-down refinement tree, ill ustrates this property:  
C2 is written to satisfy some sub-requirement of C;  b u t  t h e  c h a r a c t e r i s t i c s  o f  C2 a r e 
entirely determined by its immediate context — the needs of C. For example, C could be  
a module in charge of analyzing some user input, and C2 could be the module in charge  
of analyzing one line (p art of a longer input).
This approach is good at  ensuring that the d esign will meet the  initial specification,  
but it does not promote reusability. Modules are developed in r esponse to specific  
subproblems, and tend to be no more general than implied by the ir immediate context.  
Here if C is meant for input texts of a s pecific kind, it is unlikely th at C2, which analyzes  
one line of those texts , will be applicable to any other kind o f input.
One can in principle include the  concern for extendibility and generality in a top-
down design process, and encourag e developers to write modules that transcend the  
immediate needs which led to the ir development. But nothing in the method e ncourages  
generalization, and in practice it tends to produce modules wit h narrow specifications.
The very notion of top-down desi gn suggests the re verse of reus ability. Designing for  
reusability means building compon ents that are as general as po ssible, then combining them  
into systems. This is a bottom-up process, at the opposite of t he top-down idea of starting  
with the definition of  “the problem” and deriving a solution through successive  
refinements.
This discussion makes top-down d esign appear as a byproduct of what we can call  
the project culture  in software engineering: the view that the unit of discourse i s the 
individual project, i ndependently of earlier  and later projects . The reality is less simple:  
project n in a company is usually a variation on project n – 1 , and a preview of project  
n + 1. By focusing on just one projec t, top-down design ignores this  property of practical  
software construction,The context of 
a module in 
top-down design
C2 is written to satisfy a  
sub-requirement of C.A
C
C2
On the project and 
product culture see  
[M 1995] .
TOWARDS OBJECT TECHNOLOGY  §5.3 114
Production and description
One of the reasons for the origin al attraction of top-down idea s is that a top-down style  
may be convenient to explain a design once it is in place. But what is good to document  
an existing design is not necessa r i l y  t h e  b e s t  w a y  t o  p r o d u c e  d esigns. This point was  
eloquently argued by  Michael Jackson in System Development :
Top-down is a reasonable way of describing things which are already fully  
understood ... But top-down is not a re asonable way of developing , designing ,
or discovering anything . There is a close parallel with mathematics . A 
mathematical textbook desc ribes a branch of mathem atics in a logical order :
each theorem stated and proved is used  in the proofs of subsequent theorems .
But the theorems were not develo ped or discovered in this way , or in this order ...
When the develo per of a system , or of a program , already has a clear idea of  
the completed resu lt in his mind , he can use top-down to  describe on paper what  
is in his head . This is why people can believe that they are performing top-down  
design or development , and doing so successfully : they confuse the method of  
description with the method of development ... When the top-do wn phase begins ,
the problem is already solved , and only details remain to be solved .
Top-down design: an assessment
This discussion of top-down funct ional design sho ws the method to be poorly adapted to  
the development of significant systems. It remains a useful par adigm for small programs  
and individual algorithms; it is certainly a helpful technique to describe  well-understood  
algorithms, especially  in programming cours es. But it does not scale up to large practical  
software. By developing a system  top-down you trade short-term convenience for long-
term inflexibility; you unduly privilege one function over the others; you may be led to  
devoting your attention to interface characteristics at the exp ense of more fundamental  
properties; you lose si ght of the data aspect; and you risk sac rificing reusability.
5.3  OBJECT-BASED DECOMPOSITION
The case for using objects (or more precisely, as seen below, o bject types) as the key to  
system modularization is based o n the quality aims defined in c hapter 1, in particular  
extendibility, reusability and compatibility.
The plea for using objects will be fairly short , since the case  has already been made  
at least in part: many of the arguments against top-down, funct ion-based desi gn reappear  
naturally as evidence in favor o f bottom-up, object-based desig n.
This evidence should not, however, lead us to dismiss the funct ions entirely. As noted  
at the beginning of this chapter,  no approach to software const ruction can be complete  
unless it accounts for both the function and object parts. So w e will need to retain a clear  
role for functions in the object- oriented method, even if they must submit to the objects in  
the resulting system architectur es. The notion of abstract data  type will provide us with a  
definition of objects which rese rves a proper place for the fun ctions.Quotation from 
[Jackson 1983],  
pages 370-371 .
§5.3   OBJECT-BASED DECOMPOSITION 115
Extendibility
If the functions of a system, as discussed above,  tend to chang e often over the system’s  
life, can we find a more stable characterization of its essenti al properties, so as to guide  
our choice of modul es and meet the goal of continuity?
The types of objects manipulated by the system are more promisi ng candidates.  
Whatever happens to the payroll processing system used earlier as an example, it likely  
will still manipulate objects re presenting employees, salary sc ales, company regulations,  
hours worked, pay checks. Whatever happens to a compiler or oth er language processing  
tool, it likely will still manip ulate source texts, token seque nces, parse trees, abstract  
syntax trees, target code. Whate ver happens to a finite element  system, it likely will still  
manipulate matri ces, finite elements and grids. 
This argument is based on pragma tic observation, not on a proof  that object types are  
more stable than functions. But e xperience seems to support it overwhelmingly.
The argument only holds if we ta ke a high-level enough view of objects. If we  
understood objects in terms of th eir physical representations, we would not be much better  
off than with functions — as a m atter of fact probably worse, s ince a top-down functional  
decomposition at least encourag es abstraction. So the question of finding a suitably  
abstract description of objects is crucial; it will occupy all of the next chapter. 
Reusability
The discussion of reusability poi nted out that a routine (a uni t of functional decomposition)  
was usually not sufficient  as a unit of reusability.
The presentation used a typical e xample: table s earching. Start ing with a seemingly  
natural candidate for reuse, a s earching routine , it noted that  we cannot eas ily reuse such  
a routine separately from the ot her operations t hat apply to a table, such as creation,  
insertion and de letion; hence the idea that a satisfactory reus able module for such a  
problem should be a collection of  such operations. But if we tr y to understand the  
conceptual thread that  unites all these operations, we find the  type of objects to which they  
apply — tables.
Such examples suggest that objec t types, fully equipped with th e associated  
operations, will provide stable units of reuse.
Compatibility
A n o t h e r  s o f t w a r e  q u a l i t y  f a c t o r ,  c o m p a t i b i l i t y ,  w a s  d e f i n e d  a s  the ease with which  
software products (for this discu ssion, modules) can be combine d with each other.
It is difficult to combine actio ns if the data structures they access are not designed  
for that purpose. Why not instead try to co mbine entire data st ructures?See “Factoring Out 
Common Behav-iors”, page 85 .
TOWARDS OBJECT TECHNOLOGY  §5.4 116
5.4  OBJECT-ORIENTED SOFTWARE CONSTRUCTION
We have by now accumulated enough  background to consider a tent ative definition of  
object-oriented software construction. This will only be a firs t attempt; a more concrete  
definition will follow from the d iscussion of abstract data typ es in the next chapter.
An informal characterization of this approach may serve as a mo tto for the object-
oriented designer: 
To get a working implementation, you will of course, sooner or later, have to find out  
what it does. Hence the word first. Better later than sooner, says object-oriented wisdom.  
In this approach, the choice of main function is  one of the ver y last steps to be taken in the  
process of system construction.
The developers will stay away , as long as possible, from the ne ed to describe and  
implement the topmost function of  the system. Instead, they wil l analyze the types of  
objects of the system. System de sign will progre ss through the successive improvements  
of their understanding of these object classes. It is a bottom- up process of bu ilding robust  
and extendible solutions to part s of the problem, and combining  them into more and more  
powerful assemblies — until the final assembly which yields a s olution of the original  
problem but, everyone  h o p e s ,  i s  n o t  t h e  only possible one: the same components,  
assembled differently and probab ly combined with others, should  be general enough to  
yield as a byproduct, if you have applied the method well and e njoyed your share of good  
luck, solutions to futu re problems as well.
For many software people this ch ange in viewpoint is as much of  a shock as may  
have been for others, in an ear lier time, the idea of the earth  orbiting around the sun rather  
than the reverse. It is also con trary to much of the establishe d software engineering  
wisdom, which tends to present sy stem construction as the fulfi llment of a system’s  
function as expressed in a narro w, binding requirements documen t. Yet this simple idea —  
look at the data first, forget the immediate purpose of the sys tem — may hold the key to  
reusability and extendibility.Object-oriented software construction (definition 1)
Object-oriented softwar e construction is the software developme nt method  
which bases the architecture of a ny software system on modules deduced  
from the types of objects it man ipulates (rather than the funct ion or functions  
that the system is i ntended to ensure). 
OBJECT MOTTO
Ask not first what the system does :
Ask what it does it to !See page 147 for 
the final definition .
§5.5   ISSUES 117
5.5  ISSUES
The above definition provides a s tarting point to  discuss the o bject-oriented method. But  
besides providing comp onents of the answer it also raises many new questions, such as: 
• How to find the relevant object types.
• How to describe the object types.
• How to describe the relations a nd commonalities between object  types.
• How to use object types  to structure software.
The rest of this book will address these issues. Let us preview  a few answers.
Finding the object types
The question “how shall we find t he objects?” can seem formidab le at first. A later chapter  
will examine it in some detail ( in its more accurate version, w hich deals with object types
rather than individual  objects) but it is u seful here to dispel  some of the possible fears. The  
question does not necessarily occu py much of the time of experi enced O-O developers,  
thanks in part to the availabili ty of three sources of answers:
• Many objects are there just for  the picking. They directly mod el objects of the  
p h y s ic al  re al i ty  t o  w h i c h  th e so ft w a re  ap p l ie s.  O n e o f  th e p a rt icular strengths of  
object technology is indeed its power as a model ing tool, using  software object types  
(classes) to model physical obje ct types, and the method’s inte r-object-type relations  
(client, inheritance) to model th e relations that exist between  physical object types,  
such as aggregation an d specialization. It d oes not take a trea tise on object-oriented  
analysis to convince a software developer that a call monitorin g system, in a  
telecommunications application, will have a class CALL  and a class LINE , or that a  
document processing system will have a class DOCUMENT , a class P ARAGRAPH
and a class FONT .
• A source of object types is reuse: classes previously develope d by others. This  
technique, although not always pr ominent in the O-O analysis li terature, is often  
among the most useful in practic e. We should resist the impulse  to invent something  
if the problem has alr eady been solved satisfactorily by others .
• Finally, experience an d imitation also play a role. As you bec ome familiar with  
successful object-oriented desig ns and design patterns (such as  some of those  
described in this book and the re st of the O-O literature), eve n those which are not  
directly reusable in your partic ular application, you will be a ble to gain inspiration  
from these earlier efforts.
We will be in a much better posi tion to understand these object -finding techniques  
and others once we have gained a  better technical insight into the software no tion of object  
— not to be confused with the e veryday meanin g of the word.See chapter 22 .
TOWARDS OBJECT TECHNOLOGY  §5.5 118
Describing types and objects
A question of more immediate concern, assuming we know how to o btain the proper  
object types to serve as a basis for modularizing our systems, is how to describe these  
types and their objects.
Two criteria must guide us i n answering this question:
• The need to provide representat ion-independ ent descriptions, f or fear of losing (as  
noted) the principal be nefit of top-down functional design: abs traction.
• T h e  n e e d  t o  r e - i n s e r t  t h e  f u n c t ions, giving them their proper place in software  
architectures whose decompositi on is primarily based on the ana lysis of object types  
since (as also noted) we must in  the end accommodate both aspec ts of the object-
function duality.
The next chapter develops an o bject description technique achie ving these goals.
Describing the relations a nd structuring software
Another question is what kind of relation we should permit betw een object types; since  
the modules will be based on object types, the answer also dete rmines the structuring  
techniques that will be available to make up software systems f rom components.
I n  t h e  p u r e s t  f o r m  o f  o b j e c t  t e c h n o l o g y ,  o n l y  t w o  r e l a t i o n s  e x i st: client and  
inheritance. They correspond to d ifferent kinds of possible dep endency between two  
object types A and B:
•B is a client of A if every object of type B may contain information about one or more  
objects of type A.
•B is an heir of A if B denotes a special ized version of A.
S o m e  w i d e l y  u s e d  a p p r o a c h e s  t o  a nalysis, in particular informat ion modeling  
approaches such as entity-relationship m odeling, have introduce d rich sets of relations to  
describe the many poss ible connections that may exist between t he element of a system.  
T o people used to such approaches, having to do with just two k inds of relation often  
seems restrictive at first. But this impression is not necessar ily justified:
• The client relation is broad en ough to cover many different fo rms of dependency.  
Examples include what is often c alled aggregatio n (the presence  in every object of  
type B of a subobject of type  A), reference dependency,  and generic dependency.
• The inheritance relation covers  specialization in its many dif ferent forms.
• Many properties of dependencies will be expressed in a more ge neral form through  
other techniques. For example, to describe a 1-to- n dependency (every  object of type  
B is connected to at least one and at most n objects of type A) we will express that B
is a client of A, and include a class invariant  specifying the exact nature of the client  
relation. The class invariant, b eing expressed in the language of logic, covers many  
more cases than the finite set o f primitive relations offered b y entity-relationship  
modeling or similar approaches.
§5.6   KEY CONCEPTS INTRODUCED IN THIS CHAPTER 119
5.6  KEY CONCEPTS INTR ODUCED IN THIS CHAPTER
• Computation involves three kind s of ingredient: processors (or  threads of control),  
actions (or functions), and data (or objects). 
• A system’s architecture may be obtained from th e functions or from the object types.
• A description based on  object types tends to provide better st ability over time and  
better reusability than one base d on an analysis of the system’ s functions.
• It is usually artificial to vie w a system as consisting of jus t one function. A realistic  
system usually has more than one “top” and is better described as providing a set  
of services.
• It is preferable not to pay too  much attention to ordering con straints during the early  
stages of system analysis and de sign. Many temporal constraints  can be described  
more abstractly  as logical constraints.
• Top-down functional design is n ot appropriate for the long-ter m view of software  
systems, which involv es change and reuse.
• Object-oriented software construction bases the structure of s ystems on the types of  
objects they manipulate. 
• In object-oriented design, the primary design issue is not wha t the system does, but  
what types of objects it does it to. The design process defers to the last steps the  
decision as to what is  the topmost function , if any, of the sys tem.
• To satisfy the requirements of extendibility and reusability, object-oriented software  
construction needs to deduce the  architecture fr om sufficiently  abstract descriptions  
of objects.
• Two kinds of relation may exist between object types: client a nd inheritance.
5.7  BIBLIOGRAPHICAL NOTES
The case for object-based decompos ition is made, using various arguments, in [Cox 1990] 
(original 1986), [Goldberg 1981] , [Goldberg 1985] , [Page-Jones 1995]  an d [M 1978] , 
[M 1979] , [M 1983] , [M 1987] , [M 1988] .
The top-down method has been advocated in many books and articl es. [Wirth 1971] 
developed the notion of stepwise refinement. 
TOWARDS OBJECT TECHNOLOGY  §5.7 120
Of other methods whose rationales start with some of the same a rguments that have  
led this discussion to object-oriented concepts, the closest is  probably Jackson’s JSD  
[Jackson 1983] , a higher-level extension of JSP [Jackson 1975] . See also Warnier’s data-
directed design method [Orr 1977] . For a look at the methods that object technology is  
meant to replace, see books on: Constantine’s and Yourdon’s str uctured design  
[Yourdon  1979] ; structured analysis [DeMarco 1978] , [Page-Jones 1980] , 
[McMenamin  1984] , [Yourdon 1989] ; Merise [Tardieu 1984] , [Tabourier 1986] .
Entity-relations hip modeling was introduced by [Chen 1976] .
6  
Abstract data types
This opened my mind , I started to grasp what it means to use the tool known as algebra . I’ll 
be damned if anyone had ever told me before : over and again Mr . Dupuy [the mathematics  
teacher ] was making pompous sentences on the subject , but not once would he say this  
simple word : it is a division of labor , which like any division of labor produces miracles ,
and allows the mind to concentrate all of its forces on just one side of objects , on just one  
of their qualities .
What a difference it would have made for us if Mr . Dupuy had told us : This cheese is soft or  
it is hard ; it is white , it is blue ; it is old , it is young ; it is yours , it is mine , it is light or it is  
heavy . Of so many qualities let us consider only the weight . Whatever that weight may be ,
let us call it A . Now , without thinking of the weight any more , let us apply to A everything  
that we know of quantities . 
Such a simple thing ; yet no one was saying it to us in that faraway province …
Stendhal, The Life of Henry Brulard , 1836.
For abstraction consists only in separa ting the perceptible qualities of bodies , either from  
other qualities , or from the bodies to which they apply . Errors arise when this separation is  
poorly done or wrongly applied : poorly done in philosophical questions , and wrongly  
applied in physical and mathematical questions . An almost sure way to err in philosophy is  
to fail to simplify enough the objects under study ; and an infallible way to obtain defective  
results in physics and mathematics is to view  the objects as less composite than they are . 
Denis Diderot, A Letter on the Blind for the Benefit of Those Who Can See , 1749.
L etting objects play the lead role in our software architectures  requires that we describe  
them adequately. Thi s chapter shows how.
You are perhaps impatient to div e into the depths of object tec hnology and explore  
the details of multiple inheritance, dynamic binding and other joys; then you may at first  
look at this chapter as an undue delay since it is mostly devot ed to the study of some  
mathematical concepts (although all the mathematics involved is  elementary).
But in the same way that even the most gifted musician will ben efit from learning a  
little music theory, k nowing about abstract data types will hel p you understand and enjoy  
the practice of object-oriented analysis, design and programmin g, however attractive the  
concepts might already appear wi thout the help of the theory. S ince abstract data types  
ABSTRACT DATA TYPES  §6.1 122
establish the theoretical basis for the entire method, the cons equences of the ideas  
introduced in this chapter will be felt througho ut the rest of this book. 
There is more. As we will see at chapter end, these consequence s actually extend  
beyond the study of software proper, yielding a few principles of intellectual investigation  
which one may perhaps appl y to other disciplines. 
6.1  CRITERIA
To obtain proper descr iptions of objects, w e need a method sati sfying three conditions:
• The descriptions should b e precise and unambiguous.
• They should be complete — or at least as complete as we want t hem in each case (we  
may decide to leave some details out). 
• They should not be overspecifying .
The last point is what  makes the answer non -trivial. It is afte r all easy to be precise,  
unambiguous and complete if we “spill the beans” by giving out all the details of the  
objects’ representation. But this is usually too much  information for the authors of  
software elements that need to access the objects.
T h i s  o b s e r v a t i o n  i s  c l o s e  t o  t h e  c o m m e n t s  t h a t  l e d  t o  t h e  n o t i o n of information  
hiding. The concern there was tha t by providing a module’s sour c e  c o d e  ( o r ,  m o r e  
generally, implementation-related elements) as the primary sour ce of information for the  
authors of software elements tha t rely on that module, we may d rown them in a flood of  
details, prevent them from concentrating on their own job, and hamper prospects of  
smooth evolution. Here the danger is the same if we let modules  u s e  a  c e r t a i n  d a t a  
structure on the basis of information that pertains to the stru cture’s representation rather  
than to its essential properties.
6.2  IMPLEMENTATION V ARIATIONS
To understand better why the need  for abstract data description s is so crucial, let us explore  
further the potential consequenc es of using physical representa tion as the basis for  
describing objects.
A well-known and convenient exampl e is the description of stack  objects. A  stack  
object serves to pile up and retrieve other objects in a last-i n, first-out (“LIFO”) manner,  
the latest inserted element being the first one to be retrieved . The stack is a ubiquitous  
structure in computing science a nd in many software systems; th e typical compiler or  
interpreter, for example, is pepp ered with stacks of many kinds . 
Stacks, it must be said, are also ubiquitous in didactic presen tations of abstract data types,  
so much so that Edsger Dijkstra is said to have once quipped th at “abstract data types are  
a remarkable theory, whose purpose is to describe stacks”. Fair  enough. But the notion of  
abstract data type applies to so many more advanced cases in th e rest of this book that I  
do not feel ashamed of starting with this staple example. It is  the simplest I know which  
includes about every important i dea about abstract data types.“Information Hid-
ing”, page 51 .
§6.2   IMPLEMENTATION V ARIATIONS 123
Stack representations 
Several possible  physical representati ons exist for  stacks: 
The figure illustrates three of t he most common representations . Each has been given  
a name for ease of reference:
•ARRAY _UP: represent a stack through an array representation  and an integer count
whose value ranges from 0 ( for an empty stack) to capacity , the size of the array  
representation ; stack elements are stored in  the array at ind ices 1 up to count . 
•ARRAY _DOWN : like ARRAY _UP, but with elements stored  from the end of the array  
rather than from the beginning.  Here the integer is called free (it is the index of the  
h i g h e s t  f r e e  a r r a y  p o s i t i o n ,  o r  0  i f  a l l  p o s i t i o n s  a r e  o c c u p i e d ) and ranges from  
capacity for an empty stack down to 0. Th e stack elements are stored in the array at  
indices capacity down to  free + 1 . 
•LINKED : a linked representation which stores each stack element in a cell with two  
fields: item representing the element, and previous  containing a pointer to the cell  
containing the previously pushed element. The representation al so needs last, a 
pointer to the cell representing the top.Three possible 
representations 
for a stack
representation(ARRAY _UP)“Push” operation:
count := count + 1
representation [count ] := x countcapacity
1
representation(ARRAY _DOWN )“Push” operation:
representation [free] := x
free := free – 1
freecapacity
1
(LINKED )“Push” operation:
new (n)
n  item := x
n  previous := last
last := nitem
itemitem
itemprevious
previous
previous
previouslast
ABSTRACT DATA TYPES  §6.2 124
Next to each representation, the  figure shows a program extract  (in Pascal-like  
notation) giving the corresponding  implementation for a basic s tack operation: pushing an  
element x onto the top. 
For the array representations, ARRAY _UP a n d  ARRAY _DOWN , the instructions  
increase or decrease the top indicator ( count  or free) and assign x to the corresponding  
array element. Since these representations support stacks of at  most capacity  elements,  
robust implementations should in clude guards of the respective forms 
if count < capacity  then …
if free > 0 then …
which the figure omi ts for simplicity. 
For LINKED , the linked representa tion, pushing an ele ment requires four o perations:  
create a new cell n (done here with Pascal’s new procedure, which allocates space for a  
new object); assign x to the new cell’s item field; chain the new cell to the earlier stack top  
by assigning to its previous  field the current value of last; and update last so that it will  
now be attached to the  newly created cell. 
Although these are the most frequ ently used stack representatio ns, many others exist.  
For example if you need two stacks of elements of the same type, and have only limited  
space available, you may rely on a single array with two intege r top markers, count  as in 
ARRAY _UP and free as in ARRAY _DOWN ; one of the stacks will grow up and the other will  
grow down. The representation is full if and only  if count = free. 
The advantage, of course, is to lessen the risk of running out of space: with two  
arrays of capacity n representing stacks under ARRAY _UP or ARRAY _DOWN , you exhaust  
the available space whenever either  stack reaches n elements; with a single array of size  
2n holding two head-to-head st acks, you run out when the combined  size reaches 2n, a less  
likely occurrence if the two stack s grow independently. (For an y variable values p and q, 
max ( p + q) ≤ max ( p) + max (q).) 
Each of these and other possible  representations is useful in s ome cases. Choosing  
one of them as “the” definition of stacks would be a typical ca se of overspecification. Why  
should we consider ARRAY _UP, for example, more r epresentative than LINKED ? The most  
visible properties of ARRAY _UP — the array , the integer count , the upper bound — are  
irrelevant to an understanding of the underlying structure. Head-to-head 
representation for two stacks
representationcount
1capacity
freeStack 2
Stack 1
§6.2   IMPLEMENTATION V ARIATIONS 125
The danger of overspecification 
Why is it so bad to use a particu lar representation as specific ation? 
The results of the Lientz and Sw anson maintenance study, which you may recall,  
give a hint. More than 17% of software costs was found to come from the need to take into  
account changes of dat a formats. As was noted in the discussion , too many programs are  
closely tied to the physical stru cture of the data they manipul ate. A method relying on the  
physical representation of data structures to guide analysis an d design would not be likely  
to yield flexible software.
So if we are to use objects or object types as the basis of our  system architectures,  
we should find a better description criterion than the physical  representation. 
How long is a middle initial?
Lest stacks make us forget that,  beyond the examples favored by  computer scientists, data  
structures are ultimately connec ted with real-life objects, her e is an amusing example,  
taken from a posting o n the Risks forum ( comp.risks  Usenet newsgroup)  of the dangers of  
a view of data that is  too closely dependent  on concrete proper ties:
My dear mother blessed (or perhaps cursed ) all of her children with two middle initials ,
in my case “D” and “E” . This has caused me a good deal of trouble .
It seems that TRW sells certain parts of your credit information , such as your name and  
a demographic profile . I recently got a new credit card from Gottchalks and found to my  
chagrin that my name had been truncated to “Darrell D . Long” . I went to the credit  
manager and was assured that things would be fixed . Well , two things happened : I got a  
new credit card , this time as “Darrell E . Long” , and TRW now has an annotation in my  
file to the effect “File variation : middle initial is E” . Soon after this I start getting mail  
for “Darrell E . Long” (along with the usual “Darrell Long” and “Darrell D . Long” and  
the occasional “ Darrell D . E. Long” ).
I called up the credit bureau and it seems that the programmer who coded up the TRW  
database decided that all good Americans are entitled to only one middle initial . As the  
woman on the phone patiently told me “They only allocated enough megabytes (sic) in 
the system for one middle initial , and it would probably be awfully hard to change” .
A s i d e  f r o m  t h e  t y p i c a l  e x a m p l e  o f technobabble justification (“ megabytes”), the  
lesson here is the need to avoid tying software to the exact ph ysical properties of data.  
TRW’s system seems similar to those programs, mentioned in an e arlier discussion, which  
“knew” that postal codes consist of exactly five digits.
The author of the message repro duced above was mainly concerned  about junk mail,  
an unpleasant but not life-threat ening event; the  archives of t he Risks forum are full of  
computer-originated name confusions with more serious consequen ces. The “millenium  
problem”, mentioned in the discussion of software maintenance, is another example of the  
dangers of accessing data based o n physical representation, thi s one with hundreds of  
millions of dollars’ w orth of consequences.“ABOUT SOFT-
WARE MAINTE-
NANCE”, 1.3, page 17.
Risks forum , 10.74, 
3 Jan . 1993 . Post-
ing by Darrell D .E. 
Long : ``Dehuman-
ization by old 
Cobol programs'' . 
Abbreviated .
See exercise E6.5, 
page 161.
See page 18 .
ABSTRACT DATA TYPES  §6.3 126
6.3  TOWARDS AN ABSTRACT VIEW OF OBJECTS 
How do we retain completeness, precision and non-ambiguity with out paying the price of  
overspecification? 
Using the operations 
I n  t h e  s t a c k  e x a m p l e ,  w h a t  u n i t e s the various re presentations i n spite of all their  
differences is that they describ e a “container” structure (a st ructure used to contain other  
objects), where certain operatio ns are applicable and enjoy cer tain properties . By focusing  
not on a particular choice of rep resentation but on these opera tions and properties, we may  
be able to obtain an abstract ye t useful charact erization of th e notion of stack. 
The operations typically availab le on a stack are the following : 
• A command to push an element on  top of a stack. Let us call th at operation put. 
• A command to remove the stack’s top element, if the stack is n ot empty. Let us call  
it remove . 
• A query to find out what the to p element is, if the stack is n ot empty. Let us call it item. 
• A query to determine whether th e stack is empty. (This will en able clients to  
determine beforehand  if they can use remove  and item.) 
In addition we may need a creator operation giving us a stack, initially empty. Let us  
call it make . 
Two points may have caught your attention and will deserve more  explanation later in  
this chapter. First, the operation names may seem surprising; f or the moment, just think  
of put as meaning push , remove  as meaning pop, and item as meaning top. Details  
shortly (on the facing page, actually). Second, the operations have been divided into  
three categories: creat ors, which yield objects; queries, which  return information about  
objects; and commands, which can modify objects. This classific ation will also require  
some more comments. 
In a traditional view of data structures, we would consider tha t the notion of stack is  
given by some data declaration co rresponding to one of the abov e representations, for  
example (representation ARRAY _UP, Pascal-like syntax): 
count : INTEGER
representation : array [1      capacity ] of STACK_ELEMENT_TYPE
where capacity , a constant integer, is the maximum number of elements on the stack. Then  
put, remove , item, empty  and make  would be routines (subpr ograms) that work on the  
object structures defined by these declarations. 
The key step towards data abstra ction is to reverse the viewpoi nt: forget for the  
moment about the repre sentation; take the operations themselves  as defining the data  
structure. In othe r words, a stack is any structure to which clients may apply the operations  
listed above. 
§6.3   TOWARDS AN ABSTRACT VIEW OF OBJECTS 127
A laissez-faire policy for the society of modules
The method just outlined for desc ribing data structures shows a  rather selfish approach to  
the world of data struc t u r e s :  l i k e  a n  e c o n o m i s t  o f  t h e  m o s t  p a s sionate supply-side,  
invisible-hand, let-the-free-market-decide school, we are inter ested in individual agents  
not so much fo r what they are internally as for what they have  to offer to each other. The  
world of objects (and hence of software architecture) will be a  world of interacting agents,  
communicating on the basis of pr ecisely defined protocols. 
The economic analogy will indeed  accompany us throughout this p resentation; the  
agents — the software modules — are called suppliers  and clients ; the protocols will be  
called contracts , and much of object-ori ented design is indeed Design by Contract , the 
title of a later chapter. 
As always with analogies, we sh ould not get too carried away: t his work is not a  
textbook on economics, and conta ins no hint of its author’s vie ws in that field. It will  
suffice for the moment to note t he remarkable an alogies of the abstract data type approach  
to some theories of how human ag ents should work together. Late r in this chap ter we will  
again explore what abstract data types can tell us beyond their  original area of application. 
Name consistency 
For the moment, let us get back to more immediate concerns, and  make sure you are  
comfortable with the above examp le specification in all its det ails. If you have  
encountered stacks before, the o peration names chosen for the d iscussion of stacks may  
have surprised or even shocked yo u. Any self-respecting compute r scientist will know  
stack operations under other names:
Why use anything else than the traditional terminology? The rea son is a desire to  
take a high-level view of data structures — especially “contain ers”, those data structures  
used to keep objects. 
Stacks are just one brand of con tainer; more precisely, they be long to a category of  
containers which we may call dispensers .  A  d i s p e n s e r  p r o v i d e s  i t s  c l i e n t s  w i t h  a  
mechanism for storing ( put), retrieving ( item) and removing ( remove ) objects, but without  
giving them any control over the  choice of object to be stored,  retrieved or removed. For  
example, the LIFO policy of stac ks implies that you may only re trieve or remove the  
element that was stored last. Another brand of dispenser is the  queue, which has a first-in,  
first-out (FIFO) policy: you stor e at one end, retrieve and rem ove at the other; the element  Common stack operation name Name used here
push put
pop remove
top item
new makeSee “BEYOND 
SOFTWARE”, 6.6, 
page 147 .
ABSTRACT DATA TYPES  §6.3 128
that you retrieve or remove is th e oldest one stored but not ye t removed. An example of a  
container which is not a dispenser is an array, where you choose, thro ugh integer ind ices, 
the positions where you sto re and retrieve objects. 
Because the similarities between various kinds of container (di spensers, arrays and  
others) are more impor tant than the differ ences between their i ndividual storage, retrieval  
and removal properties, this bo ok constantly adheres to a stand ardized terminology which  
downplays the differences betwee n data structure variants and i nstead emphasizes the  
commonality. So the bas ic operation to retrieve an element will  always be called item, the 
basic operation to remove an e lement will always be called remove  and so on. 
These naming issues may appear superficial at first — “cosmetic ”, as programmers  
sometimes say. But do not forget  that one of our eventual aims is to provide the basis for  
powerful, professional libraries of reusable software component s. Such libraries will  
contain tens of thousands of ava ilable operations. Without a sy stematic and clear  
nomenclature, both the developer s and the users of these librar ies would quickly be  
s w a m p e d  i n  a  f l o o d  o f  s p e c i f i c  a nd incompatible names, providin g a strong (and  
unjustifiable) obstacle to large-sca le reuse. 
Naming, then, is not cosmetic. Good reusab le software is software that provides the  
right functionality and provide s it under the right names. 
The names used here for stack op erations are part of a systemat ic set of naming  
conventions used throug hout this book. A later chapter will int roduce them in more detail. 
How not to handle abstractions 
In software engineering as in other scientific and technical di sciplines, a seminal idea may  
seem obvious once you have been exposed to it, even though it m ay have taken a long time  
to emerge. The bad ideas and the  complicated ones (they are oft en the same) often appear  
first; it takes time for the simp le and the elegant to take ove r. 
This observation is true of abst ract data types. Although good software developers  
have always (as a result of educ ation or mere instinct) made go od use of abstraction, many  
of the systems in existence today were designed without much co nsideration of this goal. 
I once did a little involuntary experiment which  provided a goo d illustration of this  
state of affairs. While setting u p  t h e  p r o j e c t  p a r t  o f  a  c o u r s e  w h i c h  I  w a s  t e a c h i n g ,  I  
decided to provide students with a sort of anonymous marketplac e, where they could place  
mock “for sale” announcements of software modules , without sayi ng who was the source  
of the advertisement. (The idea, which may or may not have been  a good one, was to favor  
a selection process based only o n a precise specification of th e modules’ advertized  
facilities.) The mail facility o f a famous operating system com monly favored by  
universities seemed to provide the right base mechanism (why wr ite a new mail system  
just for a course project?); but naturally that mail facility s hows the sender’s name when  
it delivers a message to  its recipients. I had access to the so urce of the corresponding code  
— a huge C program — and decided, perhaps foolishly , to take th at code, remove all  
references to the sender’s name in delivered messages, and reco mpile. Chapter 26 , in par-
ticular “CHOOS-
ING THE RIGHT NAMES”, 26.2, 
page 879.
§6.4   FORMALIZING THE SPECIFICATION 129
Aided by a teaching assistant, I thus embarked on a task which seemed obvious  
enough although not commonly tau ght in software e ngineering cou rses: systematic  
program deconstruction. Sure enough, we quickly found the first place whe re the program  
accessed the sender’s name, and we removed the corresponding co de. This, we naïvely  
thought, would have done the job,  so we recompiled and sent a t est mail messa ge; but the  
sender’s name was still there! T hus began a long and surreal pr ocess: time and again,  
believing we had finally found th e last reference to the sender ’s name, we would remove  
it, recompile, and mail a test m essage, only to find the name d uly recorded once again in  
its habitual field. Like the Hydra in its famous fight, the mai ler kept growing a new head  
every time we thought we  had cut the last neck.
Finally, repeating for the modern era the earlier feat of Hercu les, we slew the beast  
for good; by then we ha d removed more than twenty code extracts  which all accessed, in  
some way or other, information about the message sender. 
Although the previous sections have only got us barely started on our road to abstract  
data types, it should be clear by now that any program written in accordance with even the  
most elementary concepts of da ta abstraction would treat MAIL_MESSAGE  as a carefully  
defined abstract notion, suppor ting a query operation, perhaps called sender , which  
returns information about the me ssage sender. Any portion of th e mail program that needs  
this information would obta in it solely through the sender  query. Had the mail program  
been designed according to this s eemingly obvious principle, it  would have been  
sufficient, for the purpose of m y little exercise, to modify th e code of the sender  query.  
Most likely, the software would also then have provided an asso ciated command operation  
set_sender  to update sender inf ormation, making the job even easier. 
What is the real moral of that little story (besides lowering t he reader’s guard in  
preparation for the surprise mat hematical offensive of the next  section)? After all, the mail  
program in question is successfu l, at least judging by its wide spread use. But it typifies the  
current quality standard in the industry. Until we move signifi cantly beyond that standard,  
the phrase “software engineering ” will remain a case of wishful  thinking. 
Oh yes, one more note. Some time  after my brief encounter with the mail program,  
I read that certain network hackers had intruded into the compu ter systems of highly  
guarded government laboratories,  using a security hole of that very mail program — a hole  
which was familiar, so the press reported, to all  those in the know. I was not in the know;  
but, when I learned the ne ws, I was not surprised. 
6.4  FORMALIZING THE SPECIFICATION 
The glimpse of data abstraction presented so far  is too informa l to be of durable use.  
Consider again our staple exampl e: a stack, as we now understan d it, is defined in terms  
of the applicable operations; but then we need to define these operations! 
Informal descriptions as above ( put pushes an element “on top of  ” the stack, remove
pops the element “last pushed” and so on) do not suffice. We ne ed to know precisely how  
these operations can be used by clients, and what they will do for them.  Writing MAIL_
MESSAGE  is the 
topic of exercise E6.4, page 161 .
ABSTRACT DATA TYPES  §6.4 130
An abstract data type specificatio n will provide this informati on. It consists of four  
paragraphs, expla ined in the next sections: 
•T Y P E S .  
• FUNCTIONS. 
• AXIOMS. 
• PRECONDITIONS. 
These paragraphs will rely on a simple mathematical notation fo r specifying the  
properties of an abstract data type (ADT for short).
The notation — a mathematical formalism, not to be confused wit h the software  
notation of the rest of this book even though for consistency i t uses a similar syntactic  
style — has no name and is not a programming language; it could  serve as the starting  
point for a formal specification  language, but we shall not pursue this avenue here,  
being content enough to use self-explanatory conventions for th e unambiguous  
specification of abstract data types.
Specifying types 
The TYPES paragraph in dicates the types bein g specified. In gen eral, it may be  
convenient to specify several ADT s together, although our examp le has only one, STACK . 
By the way, what is a type? The answer to this question will co mbine all the ideas  
developed in the rest of this ch apter; a type is a collection o f objects characterized by  
functions, axioms and preconditions. If for the moment you just  view a type as a set of  
o b j e c t s ,  i n  t h e  m a t h e m a t i c a l  s e n s e  o f  t h e  w o r d  “ s e t ”  —  t y p e  STACK  as the set of all  
possible stacks, type INTEGER  as the set of all possible integer values and so on — you  
are not guilty of any terrible misunderstanding. As you read th is discussion you will be  
able to refine this view. In the  meantime the dis cussion will n ot be too fussy about using  
“set” for “type” and conversely. 
On one point, however,  you should make sure to avoid any confus ion: an abstract  
data type such as STACK  is not an object (one particular  stack) but a collection of ob jects 
(the set of all stacks). Rememb er what our real goal is: findin g a good basis for the  
modules of our software systems.  As was noted in the previous c hapter, basing a module  
on one particular obje ct — one stack, one airplane, one bank ac count — would not make  
sense. O-O design will enable us  to build modules covering the properties of all stacks, all  
airplanes, all bank acc ounts — or at least of some stacks, airp lanes or accounts. 
An object belonging to the set o f objects described by an ADT s pecification is called  
an instance  of the ADT. For example, a specific stack which satisfies the properties of the  
STACK  abstract data type will be an instance of STACK . The notion of instance will carry  
over to object-oriented design a nd programming, where it will p lay an important role in  
explaining the run-time behavior of programs. 
§6.4   FORMALIZING THE SPECIFICATION 131
The TYPES paragraph simply lists  the types introduced in the sp ecification. Here:
Our specification is about a  single abstract data type STACK , describing stacks of  
objects of an arbitrary type G. 
Genericity 
In STACK [G], G denotes an arbitrary, unspecified type. G is called a formal generic  
parameter  of the abstract data type STACK , and STACK  itself is said to be a generic ADT.  
The mechanism permitting such pa rameterized speci fications is k nown as genericity; we  
already encountered a similar co ncept in our rev iew of package constructs.
It is possible to write ADT spec ifications without genericity, but at the price of  
unjustified repetition. Why have separate specifications for th e types “stack of bank  
accounts”, “stack of integers” a nd so on? These specifications would be identical except  
where they explicitly refer to the type of the stack elements —  bank accounts or integers.  
Writing them, and then performing the type substitutions manual ly, would be tedious.  
Reusability is desirable for sp ecifications too — not just prog rams! Thanks to genericity,  
we can make the type parameterization explicit by choosing some  arbitrary name, here  G, 
to represent the variable type of stack elements. 
As a result, an ADT such as STACK  is not quite a type, but rather a type pattern; to  
obtain a directly usable stack t ype, you must obtain some eleme nt type, for example  
ACCOUNT , and provide it as actual generic parameter  corresponding to the formal  
parameter G. So although STACK  is by itself just a typ e pattern, t he notation 
STACK [ACCOUNT ]
is a fully defined type. Such a type, obtained by providing act ual generic parameters to a  
generic type, is said to be generically derived . 
The notions just seen are applic able recursively : every type sh o u l d ,  a t  l e a s t  i n  
principle, have an ADT speci fication, so you may view ACCOUNT  as being itself an  
abstract data type; also, a type  that you use as actual generic  parameter to STACK  (to 
produce a generically derived typ e) may itself be generically d erived, so it is perfectly all  
right to use
STACK [STACK [ACCOUNT ]]
s p e c i f y i n g  a  c e r t a i n  a b s t r a c t  d a t a  t y p e :  t h e  i n s t a n c e s  o f  t h a t  t y p e  a r e  s t a c k s ,  w h o s e  
elements are themselves stacks; t he elements of these latter st acks are bank accounts. 
As this example shows, the prece ding definition of “instance” n eeds some  
qualification. Strictly speaking, a particular stack is an inst ance not of STACK  (which, as  
noted, is a type pattern rather than a type) but of some type g enerically derived from  
STACK , for example STACK [ACCOUNT ]. It is convenient, howev er, to continue talking  TYPES 
• STACK [G] 
See “Genericity”, 
page 96 .
ABSTRACT DATA TYPES  §6.4 132
about instances of STACK  a n d  s i m i l a r  t y p e  p a t t e r n s ,  w i th the understanding that this  
actually means instances of t heir generic derivations. 
Similarly, it is not quite accurate to talk about STACK  being an ADT: the correct term  
is “ADT pattern”. For simplicity,  this discussion  will continue  omitting the word “pattern”  
when there is no r isk of confusion. 
The distinction will carry over to object-oriented design and p rogramming, but there we  
will need to keep two separate terms:
•The basic notion will be the class ; a class may have generic parameters. 
•Describing actual data requires types . A non-generic class is also a type, but a generic class  
is only a type pattern. To obtain an actual type from a generic  class, we will need to  
provide actual generic parameters, exactly as we derive the ADT  STACK  [ACCOUNT ]
from the ADT pattern STACK . 
Later chapters will explore the notion of genericity as applied  to classes, and how to  
combine it with the inheritance m echanism.
Listing the functions 
After the TYPES paragraph comes the FUNCTIONS paragraph, which lists the operations  
applicable to instances of the A DT. As announced, these operati ons will be the prime  
component of the type definition — describing its instances not  by what they are but by  
what they have to offer. 
Below is the FUNCTIO NS paragraph for the STACK  abstract data type. If you are a  
software developer, you will fin d the style familiar: the lines  of such a paragraph evoke  
the declarations  found in typed programming lang uages such as Pascal or Ada. Th e line 
for new resembles a variable declaratio n; the others resemble routine headers.
Each line introduces a mathemati cal function modeling one of th e operations on  
stacks. For example function put represents the operation that  pushes an element onto the  
top of a stack. 
Why functions? Most software people will not naturally think of  an operation such  
as put as a function. When the execution of a software system applies  a put operation to  
a stack, it will usually modify that stack by adding an element  to it. As a result, in the  
above informal classification of commands, put was a “command” — an operation which  
may modify objects. (The other two categories of operations wer e creators and queries).FUNCTIONS 
• put: STACK [G] × G → STACK [G] 
• remove : STACK [G]  STACK [G] 
• item: STACK [G]  G 
• empty : STACK [G] → BOOLEAN 
• new: STACK [G]  Chapter 10 and 
appendix B .
→
→
§6.4   FORMALIZING THE SPECIFICATION 133
An ADT specification, however, is  a mathematical model, and mus t rely on well-
understood mathematical technique s. In mathematics the notion o f command, or more  
generally of changing something, does not exist as such; comput ing the square root of the  
number 2 does not modify the val ue of that number. A mathematic al expression simply  
defines certain mathematical obj ects in terms of certain other mathematical objects: unlike  
the execution of software on a c omputer, it never changes any m athematical object. 
Yet we need a mathematical concep t to model computer operations , and here the  
notion of function yields the cl osest approximation. A function  is a mechanism for  
obtaining a certain result, belonging to a certain target set, from any possible input  
belonging to a certain source set. For example, if R denotes the set of real numbers, the  
function definition 
square_  plus_one : R → R
square_  plus_one (x) = x2 + 1            (for any x in R)
introduces a function square_  plus_one  h a v i n g  R as both source and target sets, and  
yielding as result, for  any input, the squar e of the input plus  one. 
The specification of abstract data types uses exactly the same notion. Operation put, 
for example, is specified as 
put: STACK [G] × G → STACK [G]
which means that put will take two arguments, a STACK  of instances of G and an instance  
of G, and yield as a result a new STACK [G]. (More formally, the source set of function put
is the set STACK [G] × G, known as the cartesian product  of STACK [G] and G; this is  
the set of pairs <s, x> whose first element s is in STACK [G] and whose second element  x
is in G.) Here is an informal illustration: 
With abstract data types, we only have functions in the mathema tical sense of the  
term; they will produce neither side effects nor in fact change s of any kind. This is the  
condition that w e must observe to enjoy the benefits of mathema tical reasoning. 
When we leave the ethereal realm of specification for the rough -and-tumble of  
software design and im plementation, we will need to reintroduce  the notion of change;  
because of the perform ance overhead, few people would accept a software execution  
environment where every “push” o peration on a st ack begins by d uplicating the stack.  
Later we will examine the details of the transition from the ch ange-free world of ADTs to  
the change-full world of softwar e development. For the moment, since we are studying  
how best to specify types, the m athematical view is the appropr iate one. See also “The im-
perative and the ap-
plicative”, page 
351.
Applying the 
put function
 (,  )put =
(stack )( stack ) (element )
ABSTRACT DATA TYPES  §6.4 134
The role of the operations modele d by each of the functions in the specification of  
STACK  is clear from the pr evious dis cussion: 
• Function put yields a new stack with one extr a element pushed on top. The f igure on  
the preceding page illustrates put (s, x) for a stack s and an element x.
• Function remove  yields a new stack with the top  element, if any, popped; like put, 
this function should yield a co mmand (an object-changing operat ion, typically  
implemented as a procedure) at de sign and implementation time. We will see below  
how to take into account the case  of an empty stack, which has no top to be popped. 
• Function item yields the top element, if any. 
• Function empty  indicates whether a stack is empty; its result is a boolean va lue (true  
or false); the ADT BOOLEAN  is assumed to have been defined separately. 
• Function new yields an empty stack. 
The FUNCTIONS paragraph does not  fully define these functions; it only introduces  
their signatures  — the list of their a rgument and result typ es. The signature o f put is 
STACK [G] × G → STACK [G]
indicating that put accepts as arguments pairs of the form < s, x> where s is an instance of  
STACK [G] and x is an instance of G, and yields as a result an instance of STACK [G]. In 
principle the target set of a function (the type that appears t o the right of the arrow in  
signature, here STACK [G]) may itself be a cartesian product; this can be used to descri be 
operations that return two or more results. For simplicity, how ever, this book will only use  
single-result  functions. 
The signature of functions remove  and item includes a crossed arrow  instead of  
the standard arrow used by put and empty . This notation expresse s that the functions are  
not applicable to all members of the source set; it will be exp lained in detail below. 
The declaration for function new appears as just 
new: STACK
with no arrow in the signature. This is in fact an abbreviation  for 
new: → STACK
introducing a function with no a rguments. There is no need for arguments since new must  
always return the same result, a n empty stack. So we just remov e the arrow for simplicity.  
The result of applying the funct ion (that is to say, the empty stack) will also be written new, 
an abbreviation for new ( ), meaning the result of applying new to an empty argument list. 
Function categories
The operations on a type were classified informally at the begi nning of this chapter into  
creators, queries and commands. W ith an ADT specification for a  new type T, such as  
STACK [G] i n  t h e  e x a m p l e ,  w e  c a n  d e f i n e  t h e corresponding classification i n  a  m o r e  
rigorous way. The classifica tion simply examines where T appears, relative to the arrow,  
in the signa ture of each function: →
§6.4   FORMALIZING THE SPECIFICATION 135
• A function such as new for which T appears only to the right of the arrow is a creator  
function . It models an operation wh ich produces instances of T from instances of  
other types — or, as in the case of a constant creator function  such as new, from no  
argument at all. (Remember that the signature of new is considered to contain an  
implicit arrow.) 
• A function such as item and empty  for which T appears only on the  left of the arrow  
is a query function . It models an operation which yi elds properties of instances o f 
T, expressed in terms of instances of other types ( BOOLEAN  a n d  t h e  g e n e r i c  
parameter G in the examples). 
• A function such as put or remove  for which T appears on both sides of the arrow is a  
command function . It models an operation which yields new instances of T from 
existing instances of T (and possibly instanc es of other types).
An alternative terminology calls  the three categories “construc tor”, “accessor” and  
“modifier”. The terms retained here are more directly related t o the interpretation of ADT  
functions as models of operations on software objects, and will  c a r r y  o v e r  t o  c l a s s  
features, the software count erparts of our mathem atical functions.
The AXIOMS paragraph 
We have seen how to describe a data type such as STACK  through the list of functions  
applicable to its instances. The  functions are k nown only throu gh their signatures. 
To indicate that we have a stack, and not some other data struc ture, the ADT  
specification as given so far is  not enough. Any  “dispenser” st ructure, such as a first-in-
first-out queue, will also satisf y it. The choice of names for the operations makes this  
particularly clear: we do not ev en have stack-specific names su ch as push , pop or top to 
fool ourselves into be lieving that we have d efined stacks and o nly stacks. 
This is not surprising, of course , since the FUNCTIONS paragrap h declared the  
functions (in the same way that a program unit may declare a va riable) but did not fully  
define them. In a mathematical d efinition such a s the earlier e xample 
square_  plus_one : R → R
square_  plus_one (x) = x2 + 1       (for any  x in R)
the first line plays the role of the signature declaration, but  there is also a second line which  
defines the function’s value. How  do we achieve t he same for th e functions of an ADT? 
H e r e  w e  s h o u l d  n o t  u s e  a n  e x p l i c i t  d e f i n i t i o n  i n  t h e  s t y l e  o f  t he second line of  
square_  plus_one ’s definition, because it would force us to choose a representa tion — and  
this whole discussion i s intended to protec t us from representa tion choices. 
Just to make sure we understand what an explicit definition wou ld look like, let us  
write one for the stack representation ARRAY _UP as sketched above. In mathematical  
terms, choosing ARRAY _UP means that we consider any instance of STACK  a s  a  p a i r  
<count , representation >, where representation  is the array and count  is the number of  
pushed elements. Then an explicit definition of put is (for any instance x of G): 
ABSTRACT DATA TYPES  §6.4 136
put (<count , representation >, x)  =  <count + 1 , representation [count+1 : x]>
where the notation  a [n: v] denotes the array obtained from a by changing the value of the  
element at index n so that it is now v, and keeping all other elements, if any, as they are. 
This definition of function put is just a mathematical version of the implementation  
of the put operation sketched in Pascal no tation, next to representation ARRAY _UP, in the  
picture of possible stack represe ntations at the beginning of t his chapter.
But this is not what we want; “Free us from the yoke of represe ntations!”, the motto  
of the Object Liberation Front a nd its military branch (the ADT  brigade), is also ours. 
Because any explicit definition w ould force us to select a repr esentation, we must  
turn to implicit  definitions. We will refrain fro m giving the values of the fun ctions of an  
ADT specification; instead we will state properties of these va lues — all the properties  
that matter, but tho se properties only. 
The AXIOMS paragraph state s these properties. For STACK  it will be:
The first two axioms express the  basic LIFO (last-in, first-out ) property of stacks. To  
understand them, ass ume we have a stack s and an instance  x, and define  s' to be put (s, x), 
that is to say the  result of pushing x onto s. Adapting an ea rlier figure:AXIOMS
     For any x: G, s: STACK [G],
A1  • item (put (s, x)) = x
A2 • remove  (put (s, x)) = s
A3 • empty  (new)
A4 • not empty  (put (s, x))Figure page 123.
The political branch 
specializes in class-
action suits .
Applying the 
put function(,  )= put
 s'  s  x
§6.4   FORMALIZING THE SPECIFICATION 137
Here axiom A1 tells us that the top of s' is x, the last element that we pushed; and  
axiom A2 tells us that if we remove the top element from s', we get back the stack s that 
we had before pushing x. These two axioms provide a  concise description of the  
fundamental property o f stacks in pure mat hematical terms, with out any recourse to  
imperative reasoning or representation properties. 
Axioms A3 and A4 tell us when a stack is empty and when it is n ot: a stack resulting  
from the creator function new is empty; any stack resulti ng from pushing an element on  
an existing stack (empty  or not) is non-empty. 
These axioms, like the others, are predicates (in the sense of logic), expressing that  
a certain property is always true for every possible value of s and x. Some people prefer  
to read A3 and A4 in  the equivalent form
under which you may also view th em, informally at least, as def ining function empty  by 
induction on the size of stacks.
Two or three things we know about stacks 
ADT specifications are implicit . We have encountered two forms of implicitness: 
• The ADT method defines a set of  objects implicitly, through th e applicable  
functions. This was described a bove as defining objects by what  they have, not what  
they are. More precisely, the definition never implies that the  operations listed are  
the only ones; when it comes to a representation, you will ofte n add other operations. 
• The functions themselv es are also defined implicitly: instead of explicit definitions  
(such as was used for square_  plus_one , and for the early attempt to define put by 
reference to a mathematical repr esentation), we use axioms desc ribing the functions’  
properties. Here too there is no claim of exhaustiveness: when you eventually  
implement the functions, they will  certainly acquire more prope rties. 
This implicitness is a key aspec t of abstract data types and, b y implication, of their  
future counterparts in object-oriented soft ware construction — classes. When we define  
an abstract data type or a class, we always talk about  the type or class: we simply list the  
properties we know, and take the se as the defini tion. Never do we imply that these are the  
only applicable  properties. 
Implicitness implies o penness: it should alw ays be possible to add new properties to  
an ADT or a class. The basic mechanism for performing such exte nsions without  
damaging existing  uses of the original form is inheritance. 
The consequences of this implici t approach are far-reaching. Th e “supplementary  
topics” section at the end of th is chapter will include more co mments about implicitness.      For any x: G, s: STACK [G]
A3' •  empty  (new) = true
A4' •  empty  (put (s, x)) = false
“More on implicit-
ness”, page 149.
ABSTRACT DATA TYPES  §6.4 138
Partial functions 
The specification of any realistic example, even one as basic a s stacks, is bound to  
encounter the problems of undefin ed operations: some operations  are not applicable to  
every possible element  of their source sets. Here this is the c ase with remove  and item: you 
cannot pop an element f rom an empty stack; and an empty stack h as no top. 
The solution used in the precedi ng specification is to describe  these functions as  
partial. A function from a source set X to a target set Y is partial if it is not defined for all  
members of X. A function which is not partial is total . A simple example of partial  
function in standard mathematics is inv, the inverse function on real numbers, whose value  
for any appropriate real number x is
inv (x) = 
Because inv is not defined for x = 0, we may specify it as a partial function on R, the 
set of all real numbers: 
inv: R  R
To indicate that a function may be partial, the notation uses t he crossed arrow ; the 
normal arrow → will be reserved for functions which are guaranteed to be tota l. 
The domain  of a partial function in X  Y is the subset of X containing those  
elements for which the function yields a value. Here the domain  of inv is R – {0}, the set  
of real numbers other than zero. 
The specification of the STACK  ADT applied these ideas  to stacks by declaring put
and item as partial functions in the FUNCT IONS paragraph, as indicated by the crossed  
arrow in their signatures. This raises a new problem, discussed  in the next section: how to  
specify the domains o f these functions. 
In some cases it may be desirable to describe put as a partial function too; this is  
necessary to model implementations such as ARRAY _UP and ARRAY _DOWN , which only  
support a finite number of consecutive put operations on any given stack. It is indeed a  
good exercise to adapt the specification of STACK  so that it will des cribe bounded stacks  
w i t h  a  f i n i t e  c a p a c i t y ,  w h e r e a s  t h e  a b o v e  f o r m  d o e s  n o t  i n c l u d e  any such capacity  
restriction. This is a new use for partial functions: to reflec t implementation  constraints.  
In contrast, the need to declare item and remove  as partial functions reflected an abstract  
property of the underlying oper ations, applicable  to all repres entations. 
Preconditions 
Partial functions are an inescap able fact of software developme nt life, merely reflecting  
the observation that not every o peration is applicable to every  object. But they are also a  
potential source of errors: if f is a partial function from X to Y, we are not sure any more  
that the expression  f (e) makes sense even if the value of e is in X: we must be able to  
guarantee that the value belongs to the domain of f. 
For this to be possible, any ADT specification which includes p artial functions must  
specify the domain of each of them. This is the role of the PRE CONDITIONS paragraph. 
For STACK , the paragraph will appear as:1
x---
→
→
→
Exercise E6.9, 
page 162.
§6.4   FORMALIZING THE SPECIFICATION 139
w h e r e ,  f o r  e a c h  f u n c t i o n ,  t h e  require  clause indicates what c onditions th e function’s  
arguments must satisfy to belo ng to the functi on’s domain. 
The boolean expression which defines the domain is called the precondition  of the  
corresponding partial function. Here the precondition of both remove  and item expresses  
that the stack argument must be non-empty. Before the require  clause comes the name of  
the function with dummy names for arguments ( s for the stack argumen t in the example),  
so that the preconditio n can refer to them. 
Mathematically, the precondition of a function f is the characteristic function  of the  
domain of f. The characteristic function of a subset A o f a  s e t X is the total function  
ch: X → BOOLEAN  such that ch (x) is true if x belongs to A, fals e otherwise. 
The complete specification 
The PRECONDITIONS paragraph conc ludes this simple specification  o f  t h e  STACK
abstract data type. For ease of reference it is useful to piece  together the various  
components of the spec ification, seen sepa rately above. Here is  the full specification:PRECONDITIONS 
• remove (s: STACK [G]) require  not empty (s)
• item (s: STACK [G]) require  not empty (s) 
ADT specification of stacks
TYPES 
• STACK [G] 
FUNCTIONS 
• put: STACK [G] × G → STACK [G] 
• remove : STACK [G]  STACK [G] 
• item: STACK [G]  G 
• empty : STACK [G] → BOOLEAN  
• new: STACK [G] 
AXIOMS
     For any x: G, s: STACK [G]
A1  • item (put (s, x)) = x
A2 • remove  (put (s, x)) = s
A3 • empty  (new)
A4 • not empty  (put (s, x))
PRECONDITIONS 
• remove (s: STACK [G]) require  not empty (s) 
• item (s: STACK [G]) require  not empty (s) →
→
ABSTRACT DATA TYPES  §6.4 140
Nothing but the truth 
The power of abstract data type s pecifications comes from their  ability to capture the  
essential properties of data structures without overspecifying.  The stack specification  
collected on the preceding page e xpresses all there is to know about the notion of stack in  
general, excluding anything that only applies to some particula r representations of stacks.  
All the truth about stacks; yet nothing but the truth. 
This provides a general model of computation with data structur es. We may describe  
complex sequences of op erations by mathematical expressions enj oying the usual  
properties of algebra; and we may  view the process of carrying out the computation  
(executing the program ) as a case of algebra ic simplification. 
In elementary mathematics we hav e been taught to take an expres sion such as
cos2 (a – b ) + sin2 (a + b – 2 × b)
and apply the rules of algebra a nd trigonometry to simplify it.  A rule of algebra tells us  
that we may simplify a + b – 2 × b into a – b  for any  a and b; and a rule of trigonometry  
tells us that we can simplify cos2 (x) + sin2 (x) into 1 f o r  a n y  x. Such rules may be  
combined; for example the combin ation of the two preceding rule s allow us to simplify  
the above expression into just 1.
In a similar way, the functions defined in an abstract data typ e specification allow us  
to construct possibly complex ex pressions; and the axioms of th e  A D T  a l l o w  u s  t o  
simplify such expressions to yie ld a simpler result. A  complex stack expression is the  
mathematical equivalent of a program; the simplification proces s is the mathematical  
equivalent of a computation, tha t is to say, of executing such a program.
Here is an example. With the specification of the STACK  abstract data type as given  
above, we can writ e the expression
item (remove (put (remove (put (put (
remove (put (put (put (new, x1), x2), x3)),
item (remove (put (put (new, x4), x5)))), x6)), x7)))
Let us call this expression stackexp  for future reference. I t is perhaps easier to  
understand stackexp  if we define it in terms of a s equence of auxiliary expression s:
s1 = new
s2 = put (put (put (s1, x1), x2), x3)
s3 = remove (s2)
s4 = new
s5 = put (put (s4, x4), x5)
s6 = remove (s5)
y1 = item (s6)
s7 = put (s3, y1)
s8 = put (s7, x6)
s9 = remove (s8)
§6.4   FORMALIZING THE SPECIFICATION 141
s10 = put (s9, x7)
s11 = remove (s10)
stackexp = item (s11)
Whichever variant of the definition you choose, it is not hard to follow the  
computation of which stackexp is a mathematical model: create a new stack; push elements  
x1, x2, x3, in this order, on top of it; remove the last pushed element ( x3), calling s3 the 
resulting stack; create another empty stack; and so on. Or you can think of it graphically:
You can easily find the value of  such an ADT expression by draw ing figures such as  
the above. (Here you would find x4. )  B ut  t he  th eo ry  en ab le s  you to obtain this result  
formally, without any need for pictures: just apply the axioms repeatedly to simplify the  
expression until you cannot simp lify any further . For example:
• Applying A2 to simplify s3, that is to say remove (put (put (put (s1, x1 ), x2), x3)), 
yields put (put (s1, x1), x2)). (With A2, any consecutive remove -put pair cancels out.)
• The same axiom indicates that s6 is put (s4, x4); then we can use axiom A1 to deduce  
that y1, that is to say item (put (s4, x4)), is in fact x4, showing that (as illustrated by  
the arrow on the above figure) s7 is obtained by pushing x4 on top of s3. 
And so on. A sequence of such si mplifications, carried out as s imply and  
mechanically as the simplificati o n s  o f  e l e m e n t a r y  a r i t h m e t i c ,  y ields the value of the  
expression stackexp , which (as you are invited to check for yourself by performing  the 
simplification pr ocess rigorous ly) is indeed x4.
This example gives a glimpse of one of the main theoretical rol es of abstract data  
types: providing a formal model for the notion of program and p rogram execution. This  
model is purely mathematical: it  has none of the imperative not ions of program state,  
variables whose values may chang e in time, or execution sequenc ing. It relies on the  
standard expression ev aluation techniques of  ordinary mathemati cs.Stack 
manipulations
 s2  s3  s1
 x4 x5 x1 x2 x3
 s5  s6 x1 x2
 x4s7 = put (s3, y1) (empty) s7 x1 x2 x4
(also:  s9, s11)
ABSTRACT DATA TYPES  §6.5 142
6.5  FROM ABSTRACT DATA TYPES TO CLASSES 
We have the starting point of an  elegant mathematical theory fo r modeling data structures  
and in fact, as we just saw, programs in general. But our subje ct is software architecture,  
not mathematics or even theoretical computing science! Have we strayed from our path?
Not by much. In the search for a good modular structure based o n object types,  
abstract data types provide a hi gh-level description mechanism,  free of implementation  
concerns. They will lead us to t he fundamental structures of ob ject technology.
Classes 
ADTs will serve as the direct basis for the modules that we nee d in the search begun in  
chapter 3. More precisely, an object-oriented system will be built (at t he level of analysis,  
design or implementation) as a collection of interacting ADTs, partially or totally  
implemented. The basic notion here is class :
So to obtain a class we must pro vide an ADT and decide on an im plementation. The  
ADT is a mathematical concept; t he implementation is its comput er-oriented version. The  
definition, however, states that the implementation may be part ial; the following  
terminology separates this case from that of a fully implemente d class:
To obtain an effective class, you  must provide all the implemen tation details. For a  
deferred class, you may choose a certain style of implementatio n but leave some aspects  
of the implementation open. In th e most extreme case of “partia l” implementation you  
may refrain from making any impl ementation decis ion at all; the  resulting class will be  
fully deferred, and e quivalent to an ADT. Definition: class
A class is an abstract data type  equipped with a possibly parti al 
implementation.
Definition: deferred, effective class
A class which is fully imp lemented is said to be effective . A class which is  
implemented only par tially, or not at all, is said to be deferred . Any class is  
either deferred or effective.
§6.5   FROM ABSTRACT DATA TYPES TO CLASSES 143
How to produce an effective class
Consider first the case of effect ive classes. What does it take  to implement an ADT? Three  
kinds of element will make up the resulting effective class: 
E1 •  An ADT specification (a set of functions with the associated a xioms and  
preconditions, describing th e functions’ properties). 
E2 •  A choice of representation.
E3 •  A mapping from the functions ( E1) to the representation ( E2) in the form of a set  
of mechanisms, or features , each implementing one of the functions in terms of  
the representation, so as to sati sfy the axioms and preconditio ns. Many of these  
features will be routines (subpr ograms) in the usual sense, alt hough some may  
also appear as data fi elds, or “attributes”, as explained in th e next chapters. 
For example, if the ADT is STACK , we may choose as r epresentation (step E2) the 
solution called ARRAY _UP above, which implemen ts any stack by a pair 
<representation , count >
where representation  is an array and count  an integer. For the function implementations ( E3) 
we will have features corresponding to put, remove , item, empty  and new, which achieve the  
corresponding effects; for example we may implement put by a routine of the form
put (x: G)
-- Push x onto stack.
-- (No check for possible stack overflow.)
do
count  := count + 1
representation [count ] := x
end
The combination of elements obtained under E1, E2 and E3 will yield a class, the  
modular structure of object technology. 
The role of deferred classes 
For an effective class, all of the implementation information ( E2, E3 above) must be  
present. If any of it is mis sing, the class  is deferred. 
The more deferred a class, the closer it is to an ADT, gussied up in the kind of  
syntactic dress that will help s educe software developers rathe r than mathematicians.  
Deferred classes are p articularly useful fo r analysis and for d esign: 
• In object-oriented analysis, no implementation details are nee ded or desired: the  
method uses classes only for  their descriptive power. 
• In object-oriented design, many aspects of the implementation w i l l  b e  l e f t  o u t ;  
instead, a design shoul d concentrate on high-level architectura l properties of the  
system — what functi onalities each module provides, not how it provides them. 
• As you move your design gradually closer to a full implementat ion, you will add  
more and more implementation prop erties until you get effective  classes. 
ABSTRACT DATA TYPES  §6.5 144
But the role of deferred classes  does not stop there, and even in a fully implemented  
system you will often find many of them. Some of that role foll ows from their previous  
applications: if you started fro m deferred classes to obtain ef fective ones, you may be well  
inspired to keep the former as ancestors (in the sense of inher itance) to the latter, to serve  
as a living memory of the analysis and design process.
Too often, in software produced with non-object-oriented approa ches, the final form  
of a system contains no record o f the considerable effort that led to it. For someone who  
is asked to perform maintenance — extensions, ports, debugging — on the system, trying  
to understand it without that rec ord is as difficult as it woul d be, for a geologist, to  
understand a landscape without ha ving access to the sedimentary  layers. Keeping the  
deferred classes in the final sy stem is one of the best ways to  maintain the needed record.
Deferred classes also h ave purely implementation-related uses. They serve to  
classify groups of related types of objects, provide some of th e most important high-level  
reusable modules, capt ure common behaviors among a set of varia nts, and play a key role  
(in connection with pol ymorphism and dynamic binding) in guaran teeing that the software  
architecture remains decen tralized and extendible. 
The next few chapters, which int roduce the basic  object-oriente d techniques, will at  
first concentrate on effective classes. But keep in mind the no tion of deferred class, whose  
importance will grow as we penetrate the full power of the obje ct-oriented method. 
Abstract data types and information hiding
A particularly interesting conse quence of the object-oriented p olicy of basing all modules  
on ADT implementations (classes)  is that it provides a clear an swer to a question that was  
left pending in the discussion of  information hiding: how do we  select the public and 
private features of a module — t he visible and i nvisible parts of the iceberg?See the mention of 
vagueness in the middle of page 52 . 
The ADT view 
of a module under 
information 
hiding
Secret part:
• Choice of representation (E2)
• Implementation  of functions
by features (E3)Public part:
ADT specification (E1)
§6.5   FROM ABSTRACT DATA TYPES TO CLASSES 145
If the module is a class coming from an ADT as outlined above, the answer is clear:  
of the three parts invol ved in the transition, E1, the ADT specification, is public; E2 and 
E3, the choice of representation and the implementation of the AD T functions in terms  
of this representation, should b e secret. (As we start building  classes we will encounter  
a fourth part, also secret: auxi liary features needed only for the internal purposes of  
these routines.)
So the use of abstract data type s as the source of our modules gives us a practical,  
unambiguous guideline for applyi ng information hiding in our de signs. 
Introducing a more imperative view
The transition from abstract dat a types to classes involves an important stylistic  
difference: the introd uction of change and imperative reasoning . 
As you will remember, the specification of abstract data types is change-free, or, to  
use a term from theoretical computing science, applicative . All features of an ADT are  
modeled as mathematical functions ; this applies to creators, qu eries and commands. For  
example the push operation on st acks is modeled by the command function 
put: STACK [G] × G → STACK [G]
specifying an operation that returns a new s tack, rather than c hanging an existing stack. 
Classes, which are closer to the world of design and implementa tion, abandon this  
applicative-only view and reintroduce comma nds as operations th at may change objects. 
For example, put will appear as a routine whic h takes an argument of type G (the 
formal generic parameter), and m odifies a stack by pushing a ne w element on top —  
instead of produci ng a new stack. 
This change of style reflects th e imperative mood that prevails  in software  
construction. (The word “operati onal” is also used as synonym f or “imperative”.) It will  
require the corresponding change  in the axioms of ADT s. Axioms A1 and A4 of stacks,  
which appeared above as  
will yield, in the imperative form, a clause known as a routine postcondition , introduced  
by the keyword ensure  in A1  • item (put (s, x)) = x
A4 •  not empty  (put (s, x))
ABSTRACT DATA TYPES  §6.5 146
put (x: G)
-- Push x on top of stack
require
… The precondition, if any …
do
… The appropriate implementation, if known …
ensure
item = x
not empty
end
Here the postcondition expresses that on return from a call to routine put, the value  
of item will be x (the element pushed) and the value of empty  will be false. 
Other axioms of the ADT specific ation will yield a clause known  a s  t h e  class 
invariant . Postconditions, class invarian t s  a n d  o t h e r  n o n - a p p l i c a t i v e  a v atars of an  
ADT’s preconditions and axioms will be studied as part of the d iscussion of assertions  
and Design by Contract.
Back to square one? 
If you followed carefully, starti ng with the chapter on modular ity, the line of reasoning that  
led to abstract data types and t hen classes, you may be a littl e puzzled here. We started with  
the goal of obtaining the best po ssible modular structures; var ious arguments led to the  
suggestion that objects, or mor e precisely object types, would provide a better basis than  
their traditional competitors — functions. This raised the next  question: how to describe  
these object types. But when the answer came, in the form of ab stract data types (and their  
practical substitutes, classes), i t meant that we must base the  description of data on … the 
applicable functions! Have we then come full circle? 
No. Object types, as represented by ADTs and classes, remain th e undisputed basis  
for modularization. 
It is not surprising that both th e object and function aspects should appear in the final  
system architecture: as noted in the previous chapter, no descr iption of softwa re issues can  
be complete if it misses one of these two components. What fund amentally distinguishes  
object-oriented methods from old er approaches is the distributi on of roles: object types are  
the undisputed winners when it c omes to selecting the criteria for building modules.  
Functions remain their servants. 
In object-oriented decomposition, no function ever exists just by itself: every  
function is attached to some obj ect type. This carries over to the design and  
implementation levels: no feature ever exists just by itself; e very feature is attached to  
some class. “THE ADT CON-
NECTION”, 11.10, 
page 373 . 
§6.6   BEYOND SOFTWARE 147
Object-oriented software construction
The study of abstract data types has given us the answer to the  question asked at the  
beginning of this chapter: how t o describe the object types tha t will serve as the backbone  
of our software architecture.
We already had a definition of obj ect-oriented software constru ction: remaining at a  
high level of generality, it pre sented the method as “basing th e architecture of any software  
system on modules dedu ced from the types of objects it manipula tes”. Keeping that first  
definition as the framework, we can now complement it with a mo re technical one:
This will be our worki ng definition. Its var ious components are  all important:
• The basis is the notion of abstract data type .
• For our software we need not the  ADTs themselves, a mathematic al notion, but ADT  
implementations , a software notion.
• These implementations, howeve r ,  n e e d  n o t  b e  c o m p l e t e ;  t h e  “ possibly partial  ” 
qualification covers deferred cl asses — including the extreme c ase of a fully  
deferred class, where none of t he features is implemented.
• A system is a collection  of classes, with no one particularly in charge — no top or  
main program.
• The collection is structured  thanks to two inter-class relations: client and inheritance.
6.6  BEYOND SOFTWARE
As we are completing our study of abstract data types it is wor th taking a moment to reflect  
on the significance of this noti on outside of its immediate int ended application area. 
What the ADT approach tells us is that a suc cessful intellectua l investigation should  
renounce as futile any attempt a t knowing things from the insid e, and concentrate instead  
on their usable properties. Do not tell me what you are; tell m e what you have — what I  
can get out of you. If we need a name for this epistemological discipline, we should call it  
the principle of selfishness . 
If I am thirsty, an orange is so mething I can squeeze; if I am a painter, it is color  
which might inspire my palette; if I am a farmer, it is produce  that I can sell at the market;  
if I am an architect, it is slic es that tell me how to design m y new opera house, overlooking  
the harbor; but if I am none of these, and have no other use fo r the orange, then I should  
not talk about it, as the concept of orange does not for me eve n exist. Object-oriented software construction (definition 2)
Object-oriented software construc tion is the building of softwa re systems as  
structured collections of possibl y partial abstract data type i mplementations.See page 116 for the 
original definition .
ABSTRACT DATA TYPES  §6.7 148
The principle of selfishness — you are but what you have — is a n extreme form of  
an idea that has played a centra l role in the development of sc ience: abstraction, or the  
importance of separating concern s. The two quotations at the be ginning of this chapter,  
each in its own remarkable way, e xpress the importance of this idea. Their authors, D iderot  
and Stendhal, were writers rather  than scientists, although bot h obviously had a good  
understanding of the scientific method (Diderot was the living fire behind the Great  
Encyclopedia, and Stendhal prepa red for admission into the Écol e Polytechnique,  
although in the end he decided that he coul d do better things w ith his life). It is striking to  
see how both quotations are appli cable to the use of abstractio n in software development. 
Yet there is more than abstracti on to the principle of selfishn ess: the idea, almost  
shocking at first, that a property is not worth talking about u nless it is useful in some direct  
way to the talker. 
This suggests a more g eneral observation as to the intellectual  value of our field.
Over the years many articles and talks have claimed to examine how software  
engineers could benefit from study ing philosophy, general syste m s  t h e o r y ,  “ c o g n i t i v e  
science”, psychology. But to a practicing software developer th e results are disappointing.  
If we exclude from the discussion  the generally applicable laws  of rational investigation,  
which enlightened minds have know n for centuries (at least sinc e Descartes) and which of  
course apply to software science as to anything else, it someti mes seems that experts in the  
disciplines mentioned may have more to learn from experts in so ftware than the reverse. 
Software builders have tackled — with various degrees of succes s — some of the  
most challenging intellectual endeavors ever undertaken. Few en gineering projects, for  
example, match in complexity the  multi-million l ine software pr ojects commonly being  
launched nowadays. Through its m ore ambitious efforts the softw are community has  
gained precious insig hts on such issues and concepts as size, c omplexity, structure,  
abstraction, taxonomy, concurrenc y, recursive reasoning, the di fference between  
description and prescription, la nguage, change and invariants. All this is so recent and so  
tentative that the profession it self has not fully realized the  epistemological implications  
of its own work.
Eventually someone will come and explain what les sons the exper ience of software  
construction holds for the intel lectual world at large. No doub t abstract data types will  
figure prominently in the list. 
6.7  SUPPLEMENTARY TOPICS 
The view of abstract data types presented so far will suffice f or the uses of ADTs in the  
r e s t  o f  t h i s  b o o k .  ( T o  c o m p l e m e n t  i t ,  d o i n g  t h e  e x e r c i s e s  w i l l  help you sharpen your  
understanding of the concept.) 
If, as I hope, you have been conq uered by the elegance, simplic ity and power of  
ADTs, you may want to explore a few more of their properties, e ven though the discussion  
of object-oriented methods will not use them directly. These su pplementary topics, which  
may be skipped on first reading, a re presented in the next few pages: 
§6.7   SUPPLEMENTARY TOPICS 149
• Implicitness and its relationship to the software construction  process.
• The difference between sp ecification and design.
• The differences  between classes  and records.
• Potential alternatives to the use of partial functions. 
• Deciding whether a specification is complete or not. 
The bibliographical re ferences to this chapt er point to more ad vanced literature on  
abstract data types. 
More on implicitness 
The implicit nature of abstract d a t a  t y p e s  a n d  c l a s s e s ,  d i s c u s s ed above, reflects an  
important problem of so ftware construction. 
One may legitimately ask what di fference there is between a sim plified ADT  
specification, using the  function declarations 
x: POINT → REAL
y: POINT → REAL
and the record type declaration which we may express in a tradi tional programming  
language such as Pas cal under the form
type
POINT =
record
x, y: real
end
At first sight, the two definiti ons appear equivalent: both sta te that any instance of  
type POINT  has two associated values x and y, of type REAL . But there is a crucial if  
subtle difference:
• The Pascal form is closed and explicit: it indicates that a POINT  object is made of  
the two given fields, and no other.
• The ADT function declarations carry no such connotation. They indicate that one  
may query a poi nt about its x and its y, but do not prec lude other queries — such as  
a point’s mass and velocity in  a kinematics application. 
From a simplified mathematical perspective, you may consider th at the above Pascal  
declaration is a definition of the mathematical set POINT  as a cartesia n product: 
POINT  REAL × REAL
where  m e a n s  “ i s  d e f i n e d  a s ” :  t h i s  d e f i n e s  POINT  fully. In contrast, the ADT  
specification does no t explicitly define POINT  through a mathematical model such as the  
cartesian product; it just characterizes POINT  implicitly by listing two of the queries  
applicable to obje cts of this type.=Δ
=Δ
ABSTRACT DATA TYPES  §6.7 150
If at some stage you think you ar e done with the specification of a certain notion, you  
may want to move it from the implicit world to the explicit wor ld by identifying it with  
the cartesian product of the appl icable simple queries; for exa mple you will identify points  
with <x, y> pairs. W e may view this identification process as the very def inition of the  
transition from analysis and sp ecification to design and implem entation.
Specification versus design
The last observation helps clarif y a central issue in the study  of software: the difference  
between the initial activities o f software development — specif ication, also called analysis  
— and later stages such as design and implementation.
The software engineering literatur e usually defines this as the  difference between  
“defining the problem” and “buil ding a solution”.  Although corr ect in principle, this  
definition is not always directly useful in practice, and it is  sometimes hard to determine  
where specification stops and de s i g n  b e g i n s .  E v e n  i n  t h e  r e s e a r ch community, people  
routinely criticize each other on  the theme “you advertize nota tion x as a specification  
language, but what it really exp resses is designs”. The supreme  insult is to accuse the  
notation of catering to implementation ; more on this in a later chapter.
The above definition yields a mo re precise criterion: to cross the Rubicon between  
specification and design is to m ove from the implicit to the ex plicit; in other words:
The subsequent transition — from design to implementation — is simply the move  
f r o m  o n e  e x p l i c i t  f o r m  t o  a n o t h e r :  t h e  d e s i g n  f o r m  i s  m o r e  a b s t ract and closer to  
mathematical con cepts, the implementati on form is more concrete  and computer-oriented,  
but they are both explicit. This transition is less dramatic th an the preceding one; indeed,  
it will become increasingly clear  in the pages that follow that  object techno logy all but  
removes the distinction between design and implementation. With  good object-oriented  
notations, what our computers directly execute (with the help o f our compilers) is what to  
the non-O-O world would often appear as designs.
Classes versus records
Another remarkable pro perty of object techno logy, also a result  of the focus on implicit  
definition, is that you can keep your descriptions implicit for  a much longer  period than  
with any other approach. The foll owing chapters will introduce a notation enabling us to  
define a class under the form 
class  POINT  feature
x, y: REAL
endDefinition: transition from analy sis (specification) to design
To go from specification to design is to identify each abstract ion with the  
cartesian product of its simple queries.See “The clouds 
and the precipice”, page 905.
§6.7   SUPPLEMENTARY TOPICS 151
This looks suspiciously close to  the above Pascal record type d efinition. But in spite  
of appearances the class definition is different: it is implici t! The implicitness comes from  
inheritance; the author of the class or (even more interestingl y) someone else may at any  
time define a new class such as 
class MOVING_POINT  inherit
POINT
feature
mass : REAL
velocity : VECTOR [REAL ]
end
which extends the original class  in ways totally unplanned for by the initial design. Then  
a variable (or entity, to use th e terminology in troduced later)  of type POINT , declared as 
p1: POINT
may become attached to objects which are not just of type POINT  but also of any  
descendant type such as MOVING_POINT . This occurs in particular through  
“polymorphic assignme nts” of the form 
p1 := mp1
where mp1 is of type MOVING_POINT . 
These possibilities illustrate t he implicitness and openness of  the class definition: the  
corresponding entities represent  not just points in the narrow sense of direct instances of  
class POINT  as initially defined, but, more generally, instances of any ev entual class that  
describes a concept deri ved from the original. 
The ability to define software elements (classes) that are dire ctly usable while  
remaining implicit (through inhe ritance) is one of the major in novations of object  
technology, directly answering t he Open-Closed requirement. Its  full implications will  
unfold progressi vely in the foll owing chapters. 
Not surprisingly for such a revo lutionary concept, the realm of  new possibilities that  
it opens still scares many peopl e, and in fact many object-orie nted languages restrict the  
openness in some way . Later chapters will mention examples. 
Alternatives to partial functions 
Among the techniques of this chapter that may have caused you t o raise your eyebrows is  
its use of partial functions. Th e problem that it addresses is inescapable: any specification  
needs to deal with ope rations that are not always defined; for example, it is impossible to  
pop an empty stack. But  is the use of parti al functions the bes t solution?
It is certainly not the only possible one. Another technique th at comes to mind, and  
is indeed used by some of the AD T literature, is to make the fu nction total but introduce  
special error values to denote t he results of operations applie d to impossible cases. 
For every type T, this method introduces a speci al “error” value ; let us write it ωT. 
Then for any function f of signature 
f: … Input types … → TSee “The Open-
Closed principle”, page 57.
ABSTRACT DATA TYPES  §6.7 152
it specifies that any application of f to an object for which the corresponding computer  
operation may not be execute d will produce  the value ωT. 
Although usable, this method lead s to mathematical and practica l unpleasantness.  
The problem is that the special values are rather bizarre anima ls, which may unduly  
disturb the lives of innocent mathematical creatures. 
Assume for example that we consider stacks of integers — instan ces of the generic  
derivation STACK [INTEGER ], where INTEGER  is the ADT whose instances are integers.  
Although we do not need to write the specification of INTEGER  completely for this  
discussion, it is clear that the  functions defining this ADT sh ould model the basic  
operations (addition, subtraction, “less than” and the like) de fined on the mathematical set  
of integers. The axioms of the ADT should be consistent with or dinary properties of  
integers; typical among  these properties is that, for any integ er n: 
[Z1]
n + 1 ≠ n
Now let n be the result of requesting the top of an empty stack, that is  to say, the value  
of item (new), where new is an empty stack of integers. With the “special error element ” 
approach, n must be the special value ωINTEGER . What then is the val ue of the expression  
n + 1? If the only values at our disposal are normal integers and ωINTEGER , then we ought  
to choose ωINTEGER  as the answer: 
ωINTEGER  + 1 = ωINTEGER
This is the only acceptable choice: any other value for ωINTEGER  + 1, that is to say,  
any “normal” integer q, would mean in practical terms t hat after we att empt to access  the 
top of an empty stack, and get a n error value as a result, we c an miraculously remove any  
trace of the error, simply by adding one to the result! This mi ght have passed when all it  
took to erase the memory of a crime was a pilgrimage to Santiag o de Compostela and the  
purchase of a few indu lgences; modern mores and computers are n ot so lenient. 
But choosing ωINTEGER  as the value of n + 1  when n is ωINTEGER  violates the above  
Z1 property. More generally, ωINTEGER  + p will be ωINTEGER  for any p. This means we  
must develop a new axiom system for the updated abstract data t ype ( INTEGER  enriched  
with an error element) , to specify that ever y integer operation  yields ωINTEGER  whenever  
any one of its arguments is ωINTEGER . Similar changes will be  needed for every type.
The resulting complication seems unjustifiable. We cannot chang e the specification  
of integers just for the purpose of modeling a specific data st ructure such as the stack. 
With partial functions, the situation is simpler. You must of c ourse verify, for every  
expression involving partial fun ctions, that the arguments sati sfy the corresponding  
preconditions. This am ounts to performing a sanity check — reas suring yourself that the  
result of the computation will b e meaningful. Having completed this check, you may  
apply the axioms witho ut further ado. You need not change any e xisting axiom systems. 
§6.7   SUPPLEMENTARY TOPICS 153
Is my specification complete? 
Another question may have crossed your mind as you were reading  the above example of  
abstract data type specification:  is there is any way to be sur e that such a specification  
describes all the relevant prope rties of the objects it is inte nded to cover? Students who are  
asked to write their first specifications (for example when doi ng the exercises at the end  
of this chapter) often come back  with the same question: when d o I know that I have  
specified enough and that I can stop? 
In more general terms: does a method exist to find out whether an ADT specification  
is complete? 
If the question is asked in this simple form, the answer is a p lain no. This is true of  
formal specifications i n general: to say that a specification i s complete is to claim that it  
covers all the needed properties ; but this is only meaningful w ith respect to some  
document listing these properties and used as a reference. Then  we face one of two equally  
disappointing situations: 
• If the reference document is in formal (a natural-language “req uirements document”  
for a project, or perhaps just the text of an exercise), this l ack of formality precludes  
any attempt to check systematica lly that the specification meet s all the requirements  
described in that document. 
• If the reference document is it self formal, and we are able to  check the completeness  
of our specification against it, this merely pushes the problem  further: how do we  
ascertain the completeness of the reference document itself  ? 
In its trivial form, then, the c ompleteness question is uninter esting. But there is a  
more useful notion of completene ss, derived from the meaning of  t h i s  w o r d  i n  
mathematical logic. For a mathem atician, a theory is complete i f its axioms and rules of  
inference are powerful enough to prove the truth or falsity of any formula that can be  
expressed in the language of the theory. This meaning of comple teness, although more  
limited, is intellectually satis fying, since it indicates that whenever the t heory lets us  
express a property it also enables us to det ermine whether the property holds. 
How do we transpose this idea to an ADT specification? Here the  “language of the  
theory” is the set of all the well-formed expressions , those expressions which we may  
build using the ADT’s functions,  applied to arguments of the ap propriate types. For  
example, using the specification of STACK  and assuming a valid expression x of type G, 
the following expressions are well-formed:
new
put (new, x)
item (new) -- If this seems strange, see  comments on the next page.
empty (put (new, x))
stackexp -- The complex expressi on defined on page 140.
ABSTRACT DATA TYPES  §6.7 154
The expressions  put (x) and put (x, new ), however, are not well-formed, since they  
do not abide by the rules: put always requires two arguments, the first of type  STACK [G]
and the seco nd of type G; so put (x) is missing an argument, and put (x, new) has the wrong  
argument types.
The third example in the preceding box, item (new), does not desc ribe a meaningful  
computation since new does not satisfy the precondition of item. Such an expression,  
although well-f ormed, is not correct . Here is the precise de finition of this notion:
D o  n o t  c o n f u s e  “ c o r r e c t ”  w i t h  “ w ell-formed”. Well-formedness is  a  s t r u c t u r a l  
property, indicating whether all the functions in  an expression  have the right number and  
types of arguments; correctness, w h i c h  i s  o n l y  d e f i n e d  f o r  a  w e ll-formed expression,  
indicates whethe r the expression defines  a meaningful computati on. As we have seen, the  
expression put (x) is not well-formed (and so it is  pointless to ask whether it i s correct),  
whereas the expression item (new) is well-formed but not correct.
An expression well-formed but not correct, such as item (new), is similar to a  
program that compiles ( because it is built according to the pro per syntax and satisfies all  
typing constraints of the progra mming language) but will crash at run time by performing  
an impossible operation such as division by zero or popping an empty stack.
Of particular interest for compl eteness, among well-formed expr essions, are query  
expressions , those whose outerm ost function is a qu ery. Examples are: 
empty (put (put (new, x1), x2))
item (put (put (new, x1), x2))
stackexp -- See page  140
A query expression denotes a value which (if defined) belongs n ot to the ADT under  
definition, but to another, prev iously defined type. So the fir st query express ion above has  
a value of type BOOLEAN ; the second and third  have values of type G, the formal generic  
parameter — for example INTEGER  if we use the generic derivation STACK  [INTEGER ]. 
Query expressions represent exte rnal observations that we may m ake about the  
r e s u l t s  o f  a  c e r t a i n  c o m p u t a t i o n  involving instances of the new  A D T .  I f  t h e  A D T  
specification is useful, it shoul d always enable us to find out  whether such results are  
defined and, if so, what they ar e. The stack spe cification appe ars to satisfy this property,  
at least for the three example e xpressions above , since it enab les us to determine that the  
three expressions are defined and, by applyi ng the axioms, to d etermine their values: 
empty (put (put (new, x1), x2)) = False
item (put (put (new, x1), x2)) = x2
stackexp = x4Definition: correct ADT expression
Let f (x1, …, xn ) be a well-formed expression involving one or more functions  
o n  a  c e r t a i n  A D T .  T h i s  e x p r e s s i o n  i s  c o r r e c t  i f  a n d  o n l y  i f  a l l  t h e  xi a r e 
(recursively) co rrect, and their values s atisfy the preconditio n of f, if any. 
The “queries” in 
our example, return-ing a result of type other than STACK , 
are item and empty . 
See “Function cate-gories”, page 134.
§6.7   SUPPLEMENTARY TOPICS 155
Transposed to the case of arbitra ry ADT specifications, these o bservations suggest a  
pragmatic notion of co mpleteness, known as sufficient  completeness, which expresses that  
the specification contains axioms powerful enough to enable us to find the result of any  
query expression , in the form of a simple value.
Here is the precise definition o f sufficient completeness. (Non -mathematically  
inclined readers sh ould skip the rest of this section.)
In S2, expression e is of the form f (x1, …, xn) where f is a query function, such as  
empty  and item for stacks. S 1 tells us that e has a value, but this is n ot enough; in this case  
we also want to know what the va lue is, expressed only in terms  of values of other types (in  
the STACK  example, valu es of types BOOLEAN  and G). If the axioms are strong enough to  
answer this question in  all possible cases , then the specificat ion is sufficiently complete. 
Sufficient completeness is a use ful practical guideline to chec k that no important  
property has been left out of a specification, answering the qu estion raised above: when  
do I know I can stop looking for new properties to describe in the specification? It is good  
practice to apply this check, at least informally, to any ADT s pecification that you write  
— starting with your answers to t he exercises of this chapter. Often, a formal proof of  
sufficient correctness is possible; the proof given below for t he STACK  specification  
defines a model which can be followed in many cases. 
As you may have noted, S 2 is optimistic in talkin g about “the” value of e: what if the  
axioms yield two or more? This w ould make the specification use less. To avoid such a  
situation we need a further condi tion, known from mathematical logic as consistency:
The two properties are complemen tary. For any query expression we want to be  
able to deduce exactly one value: at least one (sufficient comp leteness), but no more  
than one (consistency). Definition: sufficient completeness
An ADT specification for a type T is sufficiently comple te if and only if the  
axioms of the theory make it possible to solve the following pr oblems for any  
well-formed expression e: 
S1 • Determine whether  e is correct.
S2 • If e is a query expression and has been shown to be correct under S 1, 
express e’s value under a f orm not involving any value of type T. 
Definition: ADT consistency
An ADT specification is consisten t if and only if, for any well -formed query  
expression e, the axioms make it possible to infer at most one value for e. 
ABSTRACT DATA TYPES  §6.7 156
Proving sufficient completeness 
(This section and the rest of this  chapter are supplementary mat erial and its results are not  
needed in the rest of the book.)
The sufficient completeness of a n abstract data type specificat ion is, in general, an  
undecidable problem. In other words, no general proof method ex ists which, given an  
arbitrary ADT specification, would tell us in finite time wheth er or not the specification is  
sufficiently complete. Consistency, too, is undecidable in the general case.
It is often possible, however, to prove the sufficient complete ness and the consistency  
of a particular specification. T o satisfy the curiosity of math ematically inclined readers, it  
is interesting to prove, as a conclusion to this chapter, that the specification of STACK  is 
indeed sufficiently complete. The  proof of consistency will be left as an exercise. 
Proving the sufficient complete ness of the stack specification means devising a valid  
rule addressing problems S1 and S2 above; in other words the rule must enable us, for an  
arbitrary stack expression e: 
S1 • To determine whether e is correct. 
S2 • If e is correct under S1 and its outermost function is item or empty  (one of the two  
query functions), to express its value in terms of BOOLEAN  and G values only,  
without any reference to values of type STACK [G] or to the functions of STACK ’s 
specification. 
It is convenient for a start to consider only well-formed expre ssions which do not  
involve any of the tw o query functions item and empty — so that we only have to deal with  
expressions built out of the functions new, put and remove . This means that only problem  
S1 (determining whether an expression is defined) is relevant at this stage. Query functions  
and S2 will be brought in later. 
The following property, which we  must prove, yields a rule addr essing S1:
H e r e  t h e  “ w e i g h t ”  o f  a n  e x p r e s s i o n  r e p r e s e n t s  t h e  n u m b e r  o f  e l e ments in the  
corresponding stack; it is also the difference between the numb er of nested occurrences of  
put and remove . Here is the pre cise definition of this notion: Weight Consistency rule 
A well-formed stack expression e, involving neither item nor empty , is 
correct if and only if its weight  is non-negative, and any sube xpression of e
is (recursively) correct. Non-mathematically 
inclined readers may 
skip to “KEY CON-
CEPTS INTRO-
DUCED IN THIS 
CHAPTER”, 6.8, page 159
§6.7   SUPPLEMENTARY TOPICS 157
Informally, the Weight Consistency rule tells us that a stack e xpression is correct if  
and only if the expression and every one of its subexpressions,  direct or indirect, has at  
least as many put operations (pushing an element on top) as it has remove  operations  
(removing the top element); if we view the expression as repres enting a stack computation,  
this means that we never try to pop more than we have pushed. R emember that at this stage  
we are only concentrating on put and remove , ignoring the queries item and empty .
This intuitively seems right but of course we must prove that t he Weight Consistency  
rule indeed holds. It will be con venient to intro duce a compani on rule and prove the two  
rules simultaneously:
The proof uses induction on the nesting level (maximum number o f nested  
parentheses pairs) of the expres sion. Here again, for ease of r eference, are the earlier  
axioms applying to function empty : 
An expression e with nesting level 0 (no parent heses) may only be of the form new; 
so its weight is 0, and it is correct since new has no precondition. Axiom A3 indicates that  
empty (e) is true. This takes care of the  base step for both the Weight Consistency rule and  
the Zero Weight rule. 
For the induction step, assume that the two rules are applicabl e to all expressions of  
nesting level n or smaller. We must prove that they apply to an arbitrary expr ession e of 
nesting level n + 1 . Since for the time being we ha ve excluded the query functions  from 
our expressions, one o f the following two forms must apply to e:Definition: weight
The weight of a well-formed sta ck expression not involving item or empty  is 
defined inductively as follows: 
W1 •  The weight of the expression new is 0. 
W2 •  The weight of the expression  put (s, x) is ws + 1 , where ws is the  
weight of s. 
W3 •  The weight of the expression  remove (s) is ws — 1 , where ws is the  
weight of s. 
Zero Weight rule
Let e be a well-formed and correct st ack expression not involving item or 
empty . Then empty (e) is true if and only if e has weight 0. 
STACK AXIOMS
For any x: G, s: STACK [G]
A3 •empty  (new)
A4 •not empty  (put (s, x))
ABSTRACT DATA TYPES  §6.7 158
E1 • e = put  (s, x) 
E2 • e = remove  (s) 
where x is of type G, and s has nesting level n. Let ws be the weight of s. 
In case E1, since put is a total function, e is correct if and only if s is correct, that is  
to say (by the induction h ypothesis) if and only if s and all its subexpr essions have non-
negative weights. This is the same as saying that e and all its subexpr essions have non-
negative weights, and so proves that the Weight Consistency rul e holds in this case. In  
addition, e has the positive weight ws + 1 , and (by axiom A4) is not empty, proving that  
the Zero Weight ru le also holds. 
In case E2, expression e is correct if and only if both of the following conditions hol d: 
EB1 • s and all its subexpr essions are correct. 
EB2 • not empty (s) (this is the pr econdition of remove ). 
Because of the induction hypothesis, condition EB2 means that ws, the weight of s, is 
positive, or, equivalently, that ws – 1 , the weight of e, is non-negative. So  e satisfies the  
Weight Consistency rule. To prove that it also satisfies the Ze ro Weight rule, we must prove  
that e is empty if and only if its weight is zero. Since the weight o f s is positive, s must  
contain at least one occurrence of put, which also appears in e. Consider the outermost  
occurrence of put in e; this occurrence is enclosed in a remove  (since e has a remove  at the  
outermost level). This means that a subexpression of e, or e itself, is of the form 
remove (put (stack_expression , g_expression ))
which axiom A2 indicates may be reduced to just stack_expression . Performing this  
replacement reduces the weight of e by 2; the resulting expres sion, which has the same  
value as e, satisfies the Zero Weight rule by the induction hypothesis. T his proves the  
induction hypothesis for case E2. 
The proof has shown in passing that in any well-formed and corr ect expression  
which does not involve  t h e  q u e r y  f u n c t i o n s  item a n d  empty  we may “remove every  
remove ”, that is to say, obtain a canon ical form that involves only put and new, by applying  
axiom A2 wherever po ssible. For example , the expression 
put (remove  (remove (put (put (remove (put (put (new, x1), x2)), x3), x4))), x5)
has the same value a s the canonical form
put (put (new, x1), x5)
For the record, let us  give this mechanism a name and a definit ion:
This takes care of the proof of sufficient completeness but onl y for expressions that  
do not involve any of the query functions, and consequently for  property S1 only (checking  Canonical Reduction rule
A n y  w e l l - f o r m e d  a n d  c o r r e c t  s t a c k  expression involving neither item n o r 
empty has an equivalent “canonical” form that does not involve remove (that 
is to say, may only involve new and put). The canonical form is obtained by  
applying the stack axiom A2 as many times as possible.
§6.8   KEY CONCEPTS INTRODUCED IN THIS CHAPTER 159
the correctness of an expression). To finish the proof, we must  now take into account  
expressions that involve the query functions, and deal with pro blem S2 (finding the values  
of these query expressions). This means we need a rule to deter mine the correctness and  
value of any well-formed expression of the form  f (s), where s is a well-form ed expression  
and f is either empty  or item. 
The rule and the proof of its va lidity use induction on the nes ting level, as defined  
above. Let n be the nesting level of s. If n is 0, s can only be new since all the other  
functions require arguments, and so would have at least one par enthesis pair. Then the  
situation is clear  for both of the query functions: 
•empty (new) is correct and has value true (axiom A3). 
•item (new) is incorrect since th e precondition of item is not empty (s). 
For the induction step, assume that s has a nesting depth n of one or more. If any  
subexpression u of s has item or empty  as its outermost function, then u has a depth of at  
most n – 1 , so the induction hypothesis indicates that we can determine w hether u i s 
correct and, if it is, obtain the value of u by applying the axioms. By performing all such  
possible subexpression rep lacements, we obtain for s a form which involves no stack  
function other than put, remove  and new.
Next we may apply the idea of ca nonical form introduced above t o get rid of all  
occurrences of remove , so that the resulting form of s may only involve put and new. The 
case in which s is just new has already been dealt with; i t remains the case for which s is 
of the form put (s', x). Then for the two express ions under consideration: 
•empty (s) is correct, and axiom A3 indicates that the value of this expr ession is false . 
•item (s) is correct, since the precondition of item is precisely not empty (s); axiom  
A1 indicates that the value  of this expression is x. 
This concludes the proof of sufficient completeness since we ha ve now proved the  
validity of a set of rules — the Weight Consistency rule and th e Canonical Reduction rule  
— enabling us to ascertain whether  an arbitrary st ack expressio n is correct and, for a  
correct query expression, to de termine its value in terms of BOOLEAN  and G values only. 
6.8  KEY CONCEPTS INTRODUCED IN THIS CHAPTER
• The theory of abstract data types (ADT) reconciles the need fo r precision and  
completeness in specifications w ith the desire to avoid overspe cification. 
• An abstract data type specification is a formal, mathematical description rather than  
a software text. It is applicative , that is to say change-free. 
• An abstract data type may be ge neric and is defined by functio ns, axioms and  
preconditions. The axioms and pre conditions express the semanti cs of a type and are  
essential to a full, unambiguous description. 
• To describe operations which are  not always defined, partial f unctions provide a  
convenient mathematica l model. Every partial function has a pre condition, stating  
the condition under which it will  yield a result for any partic ular candidate argument. 
• An object-oriented system is a collection of classes. Every cl ass is based on an  
abstract data type and provides a partial or full implementatio n for that ADT. 
ABSTRACT DATA TYPES  §6.9 160
• A class is effective if it is f ully implemented, deferred othe rwise. 
• Classes should be designed to b e as general and reusable as po ssible; the process of  
combining them into syst ems is often bottom-up. 
• Abstract data types are implicit rather than explicit descript ions. This implicitness,  
which also means openn ess, carries over to t he entire object-or iented method.
• No formal definition exists for the intuitively clear concept of an abstract data type  
specification being “complete” . A rigorously defined notion, sufficient
completeness, usually provides the answer. A lthough no method i s possible to  
ascertain the sufficient complet eness of an arbitrary specifica tion, proofs are often  
possible for specific cases; the proof given in th is chapter fo r the stack specification  
may serve as a guide f or other examples. 
6.9  BIBLIOGRAPHICAL NOTES
A few articles published in the early nineteen-seventies made t he discovery of abstract  
data types possible. Notable amo ng these are Hoare’s paper on t he “proof of correctness  
of data representations” [Hoare 1972a] , which introduced the concept of abstraction  
function, and Pa rnas’s work on informati on hiding mentioned in the bibliographical notes  
to chapter 3. 
Abstract data types, of course, go beyond informa tion hiding, a lthough many  
elementary presentations of the concept stop there. ADTs proper  were introduced by  
Liskov and Zilles [Liskov 1974] ; more algebraic present ations were given in [M 1976]
and [Guttag 1977] . The so-called ADJ group (Gogue n, Thatcher, Wagner) explored t he 
algebraic basis of abstract data  types, using category theory. See in particular their  
influential article [Goguen 1978] , published as a chapter in a collective book. 
Several specification languages have been based on abstract dat a types. Two resulting  
from the work of the ADJ group are CLEAR [Burstall 1977]  [Burstall 1981]  and OBJ-2 
[Futatsugi 1985] . See also Larch by Guttag, Horning and Wing [Guttag 1985] . ADT ideas  
have influenced formal specification languages such as Z in its  successive incarnations 
[Abrial 1980]  [Abrial 1980a]  [Spivey 1988]  [Spivey 1992]  and VDM [Jones 1986] . The 
notion of abstraction function pla ys a central role in VDM. Rec ent extensions to Z have  
established a closer link to object-oriented ideas; see in part icular Object Z [Duke 1991] 
and further references in chapter 11.
The phrase “separation of concerns” is central in the work of D ijkstra; see in  
particular his “Discipline of Programming” [Dijkstra 1976] . 
The notion of sufficient complet eness was first published by Gu ttag and Horning  
(based on Guttag’s  1975 thesis) in [Guttag 1978] . 
The idea that going from specification to design means switchin g from the implicit  
to the explicit by identifying an  ADT with the cartesian produc t of its simple queries was  
suggested in [M 1982]  as part of a theory for describing data structures at three se parate  
levels (physical, str uctural, implicit).
§E6.1   EXERCISES 161
EXERCISES
E6.1  Points
Write a specification describing the abstract data type POINT , modeling points in plane  
geometry. The specific ation should cover th e following aspects:  c a r t e s i a n  a n d  p o l a r  
coordinates; rotation;  translation; distance of a point to the center; distance to another point. 
E6.2  Boxers
Members of the Association Dijon naise des Tapeventres, a boxing  league, regularly  
compete in games to ascertain their comparative strength. A gam e involves two boxers; it  
either results in a winner and a loser or is declared a tie. If  not a tie, the outcome of a game  
is used to update the ranking of  players in the league: the win ner is declared better than  
the loser and than any boxer b such that the loser was previously better than b. Other  
comparative rankings a re left unchanged. 
Specify this problem as a se t of abstract data types: ADT_LEAGUE , BOXER , GAME . 
(Hint : do not introduce the notion of  “ranking” explicitly, but mode l it by a function better
expressing whether a player is b etter than anoth er in the leagu e.) 
E6.3  Bank accounts
Write an ADT specification for a “bank account” type with opera tions such as “deposit”,  
“withdraw”, “current balance”, “holder”, “change holder”. 
How would you add functions repr esenting the opening and closin g of an account? ( Hint : 
these are actually funct ions on another ADT.) 
E6.4  Messages
Consider an electronic mail sys tem with which y ou are familiar.  In light of this chapter’s  
discussion, define MAIL_MESSAGE  as an abstract data type. Be sure to include not just  
query functions but also commands and creators. 
E6.5  Names 
Devise a NAME  abstract data type taking into a ccount the different component s of a  
person’s name. 
E6.6  Text 
Consider the notion of text, as handled by a text editor. Speci fy this notion as an abstract  
data type. (This statement of th e exercise leaves much freedom to the specifier; make sure  
to include an informal  description of the properties of text th at you have chosen to model  
in the ADT.) See “How long is a 
middle initial?”, page 125.
ABSTRACT DATA TYPES  §E6.7 162
E6.7  Buying a house
Write an abstract data type specification for the problem of bu ying a house, sketched in the  
preceding chapter. Pay particular attention to the definition o f logical constraints, expressed  
as preconditions and axioms in the ADT specification.
E6.8  More stack operations
Modify the ADT specification of stacks to account for operation s count  (returning the  
number of elements on a stack), change_top  (replacing the top of the stack by a given  
element) and wipe_out  ( r e m o v e  a l l  e l e m e n t s ) .  M a k e  s u r e  t o  i n c l u d e  n e w  a x i o m s  a n d  
preconditions as needed. 
E6.9  Bounded stacks 
Adapt the specification of the s tack ADT presented in this chap ter so that it will describe  
stacks of bounded capacity. (Hin t: introduce the capacity as an  explicit quer y function;  
make put partial.) 
E6.10  Queues
Describe queues (first-in, first-o ut) as an abstract data type,  in the style used for STACK . 
Examine closely the similarities and differences. ( Hint : the axioms for item and remove
must distinguish , to deal with put (s, x), the cases in which s is empty and non-empty.)
E6.11  Dispensers
(This exercise assumes that you have answered the previous one. )
Specify a general ADT DISPENSER  covering both stack an d queue structures. 
Discuss a mechanism fo r expressing more sp ecialized ADT specifi cations such as those  
of stacks and queues by referenc e to more general specification s, such as the specification  
of dispensers. ( Hint : look at the inheritance mechan ism studied in later chapters.)
E6.12  Booleans
Define BOOLEAN  as an abstract data type in a wa y that supports its use in the  ADT 
definitions of this chapter. You  may assume that equality and i nequality operations  
(= and ≠) are automatically def ined on every ADT. 
E6.13  Sufficient completeness
(This exercise assumes that you have answered one or more of th e preceding ones.)  
Examine an ADT specification wri tten in response to one of the preceding exercises, and  
try to prove that it is sufficien tly complete. If it is not suf ficiently complete, explain why,  
and show how to correct or exten d the specification to satisfy sufficient completeness. 
E6.14  Consistency
Prove that the s pecification of stacks gi ven in this chapter is  consistent.“Ordering and O-
O development”, page 111.
Part C: 
Object-oriented techniques
“But” , I said , “when you discovered the ma rks on the snow and on the  
branches , you did not yet know [the horse]  Brownie . In a certain way these  
marks were telling us about all horses , or at least about al l horses of that kind .
Should we not say then that the book of  nature talks to us only in terms of  
essences , as taught by some very  distinguished theologians ?”
“Not at all , my Dear Adso” , replied the master . […] “The imprint in that place  
and at that time of day to ld me that at least one among all possible horses had  
passed there . So that I found myse lf half-way between the study of the concept  
of horse and the knowledge of one individual horse . And in any ca se what I knew  
of the universal horse was given to me by the mark , which was singular . You 
could say that at that time I was held prisoner between the singularity of that  
mark and my ignorance , which took the very hazy  form of a universal idea . If 
you see something afar , and do not understand what it is , you will satisfy  
yourself by definin g it as a large body . Once you have come  closer you will  
define it as being an animal , even if you do not yet know whether it is a horse  
or an ass . And finally , when it is closer , you will be able to say that it is a horse  
even if you do not know yet whether it is Brownie or Fanny . And only when you  
are at the right distance will  you see that it is Brownie (in other words that horse  
and not another , however you decide to call it ). And that will be the full  
knowledge , the intuition of the singular .” […]
“Thus the ideas , which I had used be fore to imagine a horse which I had not  
seen yet , were pure signs , as were pure signs of the horse idea the imprint on the  
snow : and we use signs , and signs of signs , only when we lack the things .”
Umberto Eco, The Name of the Rose , Day One, Terce.See the comments on 
this text on pages 
168 and 169 .
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
Part C will cover in detail the set of concepts an d techniques that form the basis of  
object technology .
7  
The static structure: classes 
Examining the software engineerin g background of our discussion,  you have seen the  
reasons for demanding a better a pproach to modular design: reus ability and extendibility.  
You have realized the limitations  of traditional approaches: ce ntralized architectures  
limiting flexibility. You have d iscovered the theory behind the  object-oriented approach:  
abstract data types. Y ou have heard enough about the problems. On to the solution! 
This chapter and the others in p art C introduce the fundamental  techniques of object-
oriented analysis, design and pr o g r a m m i n g .  A s  w e  g o  a l o n g ,  w e  w ill develop the  
necessary notation. 
Our first task is to e xamine the basic build ing blocks: classes . 
7.1  OBJECTS ARE NOT THE SUBJECT 
What is the centra l concept of object technology? 
Think twice before you answer “o bject”. Objects are useful, but  they are not new.  
Ever since Cobol has had structures; ever since Pascal has had records; ever since the first  
C programmer wrote the first C st ructure definiti on, humanity h as had objects. 
Objects remain important to describe the execution of an O-O sy stem. But the basic  
notion, from which everything in  object technology derives, is class , previewed in the  
preceding chapter. Here again is the definition:
Abstract data types are a mathem atical notion, suitable for the  specification stage  
(also called analysis). Because it introduces implementations, partial or total, the notion  
of class establishes the necessa ry link with software construct ion — design and  
implementation. Remember that a class is said to be effective i f the implementation is  
total, deferred otherwise. Definition: class
A class is an abstract data type  equipped with a possibly parti al 
implementation. Objects are stud-
ied in detail in the next chapter . 
THE STATIC STRUCTURE: CLASSES  §7.2 166
Like an ADT, a class is a type: it describes a set of possible data structure s, called the  
instances  of the class. Abstract data types too have instances; the diff erence is that an  
instance of an ADT is a purely m athematical element (a member o f some mathematical  
set), whereas an instance of a c lass is a data structure that m ay be represented in the  
memory of a computer and manipu lated by a software system. 
For example if we have defined a class STACK  by taking the ADT specification of  
the previous chapter and adding adequate representation informa tion, the instances of that  
class will be data structures re presenting individual stacks. A nother example, developed  
in the rest of this chapter, is a class POINT  modeling the notion of point in a two-
dimensional space, und er some appropriate representation; an in stance of that class is a  
data structure representing a point. Under one of the represent ations studied below, the  
cartesian representation, each instance of POINT  is a record with tw o fields representing  
the horizontal and v ertical coordinates, x and y, of a point. 
The definition of “class” yields  as a byproduct a definition of  “object”. An object is  
simply an instance of some class . For example an instance of cl ass STACK  —  a  d a t a  
structure representing  a particular stack — is an object; so is  an instance of class POINT , 
representing a particular poin t in two-dimen sional space. 
The software texts that serve to produce systems are classes. O bjects are a run-time  
notion only: they are cr eated and manipulated by the software d uring its execution.
The present chapter is devoted to the basic mechanisms for writ ing software  
elements and combining them into systems; as a consequence, its  focus is on classes. In  
the next chapter, we will explore the run-time structures gener ated by an object-oriented  
system; this will require us to s tudy some implementation issue s and to take a closer look  
at the nature of objects.            
7.2  A VOIDING THE STANDARD CONFUSION
A class is a model, and an objec t is an instance of such a mode l. This property is so obvious  
that it would normally  deserve no comments beyond the preceding  definitions; but is has  
been the victim of so much confusion in the more careless segme nt of the literature that  
we must take some time to clarify the obvious. (If you feel tha t you are immune to such a  
danger, and have avoided exposure  to sloppy object-oriented tea ching, you may wish to  
skip this section alto gether as it e ssentially belabors the obv ious.) 
What would you think of this?
Among the countries in Europe we may identify the Italian . The Italian has a  
mountain chain running through him No rth-South and he li kes good cooking ,
often using olive oil . His climate is of the Mediterranean type , and he speaks  
a beautifully musical language .The next section , for 
readers who do not like the belaboring of the obvious , is 
“THE ROLE OF CLASSES”, 7.3, page 169 .
§7.2   A VOIDING THE STANDARD CONFUSION 167
If someone in a sober state talk ed or wrote to you in this fash ion, you might suspect a new  
neurological disease, the inabili ty to distinguis h between cate gories (such as the Italian  
nation) and individuals members of these categories (such as in dividual Italians), reason  
enough to give to the ambulance driver the address of Dr. Sacks ’s New York clinic. 
Yet in the object-oriented softwar e literature similar confusio ns are common.  
Consider the following extract f rom a popular book on O-O analy sis, which uses the  
example of an interactive system  to discuss how to identify abs tractions:
In the same breath this text uses the word objects , user and thing in two meanings  
belonging to entir ely different levels of abstraction:
•A typical user of the interact ive system under discussion. 
•T h e  concept  of user in general. 
Although this is probably a slip  of terminology (a peccadillo w hich few people can  
claim never to have committed) rather than a true confusion on the authors’ part, it is  
unfortunately representative of how some of the literature deal s with the model-instance  
distinction. If you start the stu dy of a new method with this k ind of elementary mix-up,  
real or apparent, you are not lik ely to obtain a rational appro ach to software c onstruction. 
The mold and the instance 
Take this book — the copy which you are currently  reading. Cons ider it as an object in the  
common sense of the term. It has its own individual features: t he copy may be brand new,  
or already thumbed by previous re aders; perhaps you wrote your name on the first page;  
or it belongs to a library and h as a local identification code impressed on its spine. 
The basic properties of the book , however, such as its title, p ublisher, author and  
contents, are determined by a ge neral description which applies  to every individual copy:  
the book is entitled Object-Oriented Soft ware Construction , it is published by Prentice  
Hall, it talks about the object- oriented method, and so on. Thi s set of properties defines  
not an object but a class of obj ects (also calle d, in this case , the type of these objects; for  
the time being the notions of ty pe and class may be considered synonymous). 
Call the class OOSC . It defines a certain mold. Obj ects built from this mold, such  as 
your copy of  the book, are called instances  of the class. Another  example of mold would  
be the plaster cast that a sculptor makes to obtain an inverted  version of the design for a  
set of identical statues; any st atue derived fro m the cast is a n instance of the mold. [W]e might identify a “User” Object in a problem space where the system  
does not need to keep an y information about the user . In this case , the system  
does not need the usual identification number , name , access privilege , and 
the like . However , the system does need to monitor the user , responding to  
requests and providing timely information . And so , because of required  
Services on behalf of  the real world thing (in this case , User ), we need to add  
a corresponding Object to the model of the problem space .See e .g. Oliver 
Sacks , ``The Man 
Who Mistook His Wife for a Hat and Other Clinical Tales'' , Harper 
Perennials , 1991 .
[Coad 1990],  3.3.3, 
page 67 .
Exercise E7.1, page 
216, asks you to 
clarify each use of “Object” in this text . 
THE STATIC STRUCTURE: CLASSES  §7.2 168
In the quotation from The Name of the Rose  which opens part C, the Master is explaining  
how he was able to determine, from traces of the snow, that Bro wnie, the Abbot’s horse,  
earlier walked here. Brownie is an instance of the class of all  horses. The sign on the  
snow, although imprinted by one particular instance, includes o nly enough information to  
determine the class (horse), not its identity (Brownie). Since the class, like the sign,  
identifies all horses rather t han a particular horse, the extra ct calls it a sign too. 
Exactly the same concepts apply to software objects. What you w ill write in your  
software systems is the description of classes, such as a class  LINKED_STACK describing  
properties of stacks in a certain  representation. Any particula r execution of your system  
may use the classes to create ob jects (data structures); each s uch object is derived from a  
class, and is called an instance  of that class. For example the execution may create a  
linked stack object, derived from the description given in clas s LINKED_STACK ; such an  
object is an instance of class LINKED_STACK . 
The class is a software text. It is static; in other words, it exists independently of any  
execution. In contrast, an object derived from that class is a dynamically created data  
structure, exist ing only in the memory of  a computer during the  execution of a system.
This, of course, is in line with  the earlier discussion of abst ract data types: when  
specifying STACK  as an ADT, we did not describe any particular stack, but the g eneral  
notion of stack, a mold from which one can d erive individual in stances ad libitum. 
The statements “ x is an instance of T ” and “ x i s  a n  o b j e c t  o f  t y p e  T ” will be  
considered synonymous f or this discussion. 
With the introduction of inheritance we will need to distinguis h between the direct  
instances  of a class (built from the exact pattern defined by the class)  and its instances  in 
the more general sense (direct i nstances of the class or any of  its specializations).
Metaclasses 
Why would so many books and articles confuse two so clearly dif ferent notions as class  
and object? One reason — although not an excuse — is the appeal  of the word “object”, a  
simple term from everyday language. But it is misleading. As we  already saw in the  
discussion of seamlessness, although some of the objects (class  instances) which O-O  
systems manipulate are the computer representations of objects in the usual sense of the  
term, such as documents, bank accounts or airplanes, many other s have no existence  
outside of the software; they include in particular the objects  introduced for design and  
implementation purposes — ins tances of classes such as STATE  or LINKED_LIST . 
Another possible source of confu sion between objects and classe s is that in some  
cases we may need to treat classe s themselves as objects. This need arises only in special  
contexts, and is mainly relevant to developers of object-orient ed development  
environments. For example a comp iler or interpreter for an O-O language will manipulate  
data structures representing cla sses written in that language. The same would hold of other  
tools such as a browser (a tool u sed to locate classes and find  out about their properties)  
or a configuration management sys tem. If you produce such tools , you will create objects  
that represent classes. Page 163 .
See “Instances”, 
page 475 .
§7.3   THE ROLE OF CLASSES 169
Pursuing an analogy used earlier, we may compare this situation  to that of a Prentice Hall  
employee who is in charge of prep aring the catalog of software engineering titles. For the  
catalog writer, OOSC, the concept behind this book, is an objec t — an instance of a class  
“catalog entry”. In contrast, for the reader of the book, that concept is a class, of which  
the reader’s particular copy is an instance. 
Some object-oriented l anguages, notably Smalltalk, have introdu ced a notion of  
metaclass  to handle this kind of situation. A metaclass is a class whose  i n s t a n c e s  a r e  
themselves classes — what the Name of the Rose  extract called “s igns of signs”. 
We will avoid metaclasses in thi s presentation, however, since t h e y  b r i n g  m o r e  
problems than benefits. In particular, the addition of metaclas ses makes it difficult to have  
static type checking, a required condition of the production of  reliable software. The main  
applications of metacl asses are better obtai ned through other m echanisms anyway: 
•You can use metaclasses to make a set of features available to many or all classes.  
We will achieve the same result by arranging the inheritance st ructure so that all  
classes are descendants of a gen eral-purpose, customizable clas s ANY, containing the  
declarations of universal features. 
•A few operations may be viewed a s characterizing a class rather  than its instances,  
justifying their inclusion as features of  a metaclass. But thes e operations are few and  
known; the most obvious one is object cr eation — sufficiently i mportant to deserve  
a special language construct, the  creation instru ction. (Other such operations, such  
as object duplication, will be  covered by features of class ANY.) 
• There remains the use of metacl asses to obtain information abo ut a class, such as a  
browser may need: name of the class, list of features, list of parents, list of suppliers  
etc. But we do not nee d metaclasses for that . It will suffice t o devise a library class,  
E_CLASS , so that each instance of E_CLASS  represents a class and its properties.  
When we create such an instance, we pass to the creation instru ction an argument  
representing a certain class C; then by applying the various features of E_CLASS  to 
that instance, we can  learn all about C. 
In practice, then, we can do wit hout a separate concept of meta class. But even in a  
method, language or env ironment that would support this notion,  the presence of  
metaclasses is no excu se for confusing molds and their instance s — classes and objects. 
7.3  THE ROLE OF CLASSES 
Having taken the time to remove an absurd but common and damagi ng confusion, we may  
now come back to the central properties of classes, and in part icular study why they are so  
important to object technology. 
To understand the object-oriente d approach, it is essential to realize that classes play  
two roles which pre-O-O approach es had always tr eated as separa te: module and type. “Universal classes”, 
page 580 . 
See “The creation 
instruction”, page 232.
THE STATIC STRUCTURE: CLASSES  §7.3 170
Modules and types 
Programming languages and other notations used in software deve lopment (design  
languages, specification languag es, graphical notations for ana lysis) always include both  
some module facility a nd some type system. 
A module is a unit of software d ecomposition. Various forms of module, such as  
routines and packages, were studied in an earlier chapter. Rega rdless of the exact choice  
of module structure, w e may call the notion of module a syntactic  concept, since the  
decomposition into modules only affects the form of software te xts, not what the software  
can do; it is indeed possible in principle to write any Ada pro gram as a single package, or  
any Pascal program as a single main program. Such an approach i s not recommended, of  
course, and any competent software developer will use the modul e facilities of the  
language at hand to decompose hi s software into manageable piec es. But if we take an  
existing program, for example in Pascal, we can always merge al l the modules into a single  
one, and still get a working system with equivalent semantics. (The presence of recursive  
routines makes the conversion pr ocess less trivial, but does no t fundamentally affect this  
discussion.) So the practice of d ecomposing into modules is dic tated by sound engineering  
and project management principles rather than intrinsic necessi ty. 
Types, at first sight, are a quite  different concept. A type is  the static description of  
certain dynamic objects: the various data elements that will be  processed during the  
execution of a software system. T he set of types usually includ es predefined types such as  
INTEGER  a n d  CHARACTER  as well as developer-define d types: record types (also  
known as structure types), point er types, set types (as in Pasc al), array types and others.  
The notion of type is a semantic  concept, since every type  directly influences the  
execution of a software system by  defining the form of the obje cts that the system will  
create and manipulate at run time. 
The class as module and type 
In non-O-O approaches, the module and type concepts remain dist inct. The most  
remarkable property of the noti on of class is that it subsumes these two concepts, merging  
them into a single linguistic construct. A class is a module, o r unit of software  
decomposition; but it is also a type (or, in cases involving ge nericity, a type pattern). 
Much of the power of the object-oriented method derives from th is identification.  
Inheritance, in particular, can only be understood fully if we look at it as providing both  
module extensi on and type specialization. 
What is not clear yet is how it is possible in practice to unify two concepts which  
appear at first so distant. The discussion and examples in the re st  of  t hi s c ha pt e r w il l  
answer this question. See chapter 3 .
§7.4   A UNIFORM TYPE SYSTEM 171
7.4  A UNIFORM TYPE SYSTEM 
A n  i m p o r t a n t  a s p e c t  o f  t h e  O - O  a p p r o a c h  a s  w e  w i l l  d e v e l o p  i t  i s the simplicity and  
uniformity of the type system, d eriving from a fundamental prop erty:
The Object rule will apply not j ust to composite, developer-def ined objects (such as  
data structures with se veral fields) but al so to basic objects such as integers, real numbers,  
boolean values and char acters, which will all be considered to be instances o f predefined  
library classes ( INTEGER , REAL , DOUBLE , BOOLEAN , CHARACTER ). 
This zeal to make every possible value, however simple, an inst ance of some class  
may at first appear exaggerated or even extravagant. After all,  mathematicians and  
engineers have used integers and reals successfully for a long time, without knowing they  
were manipulating class instances. But insisting on uniformity pays off for several reasons: 
• It is always desirable to have a simple and uniform framework rather than many  
special cases. Here the type sys tem will be entirely based on t he notion of class. 
•Describing basic types as ADTs and hence as classes is simple a nd natural. It is not  
hard, for example, to see how to define the class INTEGER  with features covering  
arithmetic operations such as "+", comparison operations such as "<=" , and the  
associated properties, derived f rom the corresponding mathemati cal axioms.
• By defining the basic types as c lasses, we allow them to take part in all the O-O  
games, especially inheritance a nd genericity. If we did not tre at the basic types as  
classes, we would have to introdu ce severe limitations and many  special cases. 
As an example of inheritance, classes INTEGER , REAL  and DOUBLE  will be heirs to more  
general classes: NUMERIC , introducing the basic arithmetic operations such as "+", "–"
and "", and COMP ARABLE , introducing comparison operations such as "<". As an  
example of genericity, we can define a generic class MATRIX  whose generic parameter  
represents the type of matrix elements, so that instances of MATRIX  [INTEGER ] represent  
matrices of intege rs, instances of MATRIX [REAL ] represent matrices of reals and so on. As  
an example of combining genericity with inheritance, the preced ing definitions also allow  
us to use the type MATRIX  [NUMERIC ], whose instances represent matrices containing  
objects of type INTEGER  as well as objects of type REAL  and objects of any new type T
defined by a software developer so as to inherit from NUMERIC . 
With a good implementation, we do not need to fear any negative  consequence from  
the decision to define all types from classes. Nothing prevents  a compiler from having  
special knowledge about the basic  classes; the code it generate s for operations on values  
of types such as INTEGER and BOOLEAN  can then be just as efficient as if these were  
built-in types in the language. Object rule
Every object is an ins tance of some class.
The mathematical 
axioms defining integers are known as Peano’s axioms .
THE STATIC STRUCTURE: CLASSES  §7.5 172
Reaching the goal of a fully cons i s t e n t  a n d  u n i f o r m  t y p e  s y s t e m  requires the  
combination of several important  O-O techniques, to be seen onl y later: expanded classes,  
to ensure proper representation of simple values ; infix and pre fix operators, to enable  
usual arithmetic syntax (such as a < b or –a rather than the more cumbersome  a  less_
than (b) or a  negated  ); constrained genericity, neede d to define classes which may b e 
adapted to various types with specific operations, for example a class MATRIX that can  
represent matrices of integers as  well as matrices of elements of other numeric types. 
7.5  A SIMPLE CLASS 
Let us now see what classes look  like by studying  a simple but typical example, which  
shows some of the fund amental properties applicable to almost a ll classes. 
The features 
The example is the notion of point, as it could appear in a two -dimensional graphics system.
To characterize type POINT  as an abstract data type, we would need the four query  
functions x, y, ρ, θ. (The names of the last two will be spelled out as rho and theta  in 
s o f t w a r e  t e x t s . )  F u n c t i o n  x gives the abscissa of a poi nt (horizontal coordinate), y i t s 
ordinate (verti cal coordinate), ρ its distance to the origin, θ the angle to the horizontal axis.  
The values of x and y for a point are called its cartesian coordinates, those of ρ and θ its 
polar coordinates. Another useful query function is distance , which will yield the distance  
between two points. 
Then the ADT specification would list commands such as translate  (to move a point  
by a given horizontal and vertical displacement), rotate  (to rotate the point by a certain  
angle, around the origin) and scale  (to bring the point closer to or further from the origin  
by a certain factor). 
It is not difficult to write the full ADT specification includi ng these functions and  
some of the associated  axioms. For example , two of the function  signatures will be 
x: POINT → REAL
translate : POINT  × REAL  × REAL  → POINT
and one of the axioms will be (for any point p and any reals a, b): 
x (translate ( p1, a, b)) = x ( p1) + a 
expressing that trans lating a point by <a, b> increases its abscissa by a.A point and its 
coordinates
θρp1
xy
The name translate  
refers to the “trans-lation” operation of geometry.
§7.5   A SIMPLE CLASS 173
You may wish to complete this AD T specification by yourself. Th e rest of this  
discussion will assume that you have understood the ADT, whethe r or not you have  
written it formally in full, so that we can focus on its implem entation — the class. 
Attributes and routines 
Any abstract dat a type such as POINT  is characterized by a set of functions, describing the  
operations applicable to instanc es of the ADT. In classes (ADT implementations),  
functions will yield features — the operations applicable to in stances of the class. 
We have seen that ADT functions are of three kinds: queries, co mmands and  
creators. For features, we need a  complementary c lassification,  based on how each feature  
is implemented: by s pace or by time. 
The example of point coordinates  s h o w s  t h e  d i f f e r e n c e  c l e a r l y .  Two common  
representations are available for points: cartesian and polar. If we choose cartesian  
representation, each i nstance of the class will contain two fie lds representing the x and y
of the corre sponding point:
If p1 i s  t h e  p o i n t  s h o w n ,  g e t t i n g  i t s  x o r  i t s  y simply requires looking up the  
corresponding field in th is structure. Getting ρ or θ, however, requires a computation: for  
ρ we must compute , and for θ we must compute arctg  (y / x) with non-zero x. 
If we use polar representation , the situation is reversed: ρ and θ are now accessible  
by simple field lookup, x and y require small c omputations (of ρ cos θ and ρ sin θ).
This example shows the need for two kinds of feature: 
• Some features will be represent ed by space, that is to say by associating a certain  
piece of information with every instance of the class. They wil l be called attributes . 
For points, x and y are attributes in carte sian representation; rho a n d  theta  a r e 
attributes in pola r representation. Exercise E7.2, page 
216.
“Function catego-
ries”, page 134 .
Representing a 
point in 
cartesian 
coordinatesx
y
(CARTESIAN_POINT )
x2y2+
Representing a 
point in polar 
coordinatesrho
theta
(POLAR_POINT )
THE STATIC STRUCTURE: CLASSES  §7.5 174
• S o m e  f e a t u r e s  w i l l  b e  r e p r e s e n t e d  b y  t i m e ,  t h a t  i s  t o  s a y  b y  d efining a certain  
computation (an algorithm) appli c a b l e  t o  a l l  i n s t a n c e s  o f  t h e  c lass. They will be  
called routines . For points, rho and theta  are routines in cartesian representation; x
and y are routines in pol ar representation. 
A further distinction affects routines (the second of these cat egories). Some routines  
will return a result; they are called functions . Here x and y in polar representation, as well  
as rho and theta  in cartesian representation, ar e functions since they return a  result, of type  
REAL . Routines which do not return a  result correspond to the comma nds of an ADT  
specification and are called procedures . For example the class POINT  will include  
procedures translate , rotate  and scale . 
Be sure not to confuse the use of “function” to denote result-r eturning routines in classes  
with the earlier use of this word  to denote the mathematical sp ecifications of operations  
in abstract data types. This c onflict is unfortunate, but follo ws from well-established  
usage of the word in both the mathematics and software fields.
The following tree hel ps visualize this classification of featu res:
This is an external classificatio n, in which the principal ques tion is how a feature will  
look to its client s (its users).
We can also take a more internal view, using as primary criteri on how each feature  
is implemented in the class, and  leading to a different classif ication:Feature 
classification , 
by role
Procedure
Function
Function AttributeReturns result: Query No result:  Command
No argument Arguments
Computation MemoryFeature
ROUTINE
§7.5   A SIMPLE CLASS 175
Uniform  access 
One aspect of the preceding clas sifications may at first appear  disturbing and has perhaps  
caught your attention. In many c ases, we should be able to mani pulate objects, for  
example a point p1, without having to worry about wh ether the intern al representa tion of  
p1 is cartesian, polar or other . Is it appropriate, then, to dist inguish explicitly between  
attributes and functions? 
The answer depends on whose view we consider: the supplier’s vi ew (as seen by the  
author of the clas s itself, here POINT ) or the client’s view (as s een by the author of a class  
that uses POINT ). For the supplier, the distinction between attributes and fun ctions is  
meaningful and n ecessary, since in some cases you will want to implement a feature by  
storage and in others by computa tion, and the decision must be reflected somewhere.  
W h a t  w o u l d  b e  w r o n g ,  h o w e v er, would be to force the clients  t o  b e  a w a r e  o f  t h e  
difference. If I am accessing p1, I want to be able to find out its x or its ρ without having  
to know how such querie s are implemented. 
The Uniform Access principle, in troduced in the discussion of m odularity, answers  
this concern. The principle stat es that a client  should be able  to access a property of an  
object using a single notation, whether the property is impleme nted by memory or by  
computation (space or time, attr ibute or routine). We shall fol low this important principle  
in devising a notation for featur e call below: the expression d enoting the value of the x
feature for p1 will always be 
p1  x
whether its effect is to access a  field of an object or to exec ute a routine.
As you will have noted, the uncertainty can only exist for quer ies without arguments,  
which may be implemented as functions or as attributes. A comma nd must be a procedure;  
a query with arguments must be a f unction, since attributes can not have arguments. ProcedureRoutine
FunctionAttribute
Returns result No resultComputation MemoryFeature
Feature 
classification , 
by 
implementation
See “Uniform 
Access”, page 55 .
THE STATIC STRUCTURE: CLASSES  §7.5 176
The Uniform Access principle is e s s e n t i a l  t o  g u a r a n t e e  t h e  a u t o nomy of the  
components of a system. It preserves the class designer’s freed om to experiment with  
various implementation  techniques wi thout disturbing the client s. 
Pascal, C and Ada violate the principle by providing a differen t notation for a function  
call and for an attribute access. For such non-object-oriented languages this is  
understandable (although we have seen that Algol W, a 1966 pred ecessor to Pascal,  
satisfied uniform access). More recent languages such as C++ an d Java also do not  
enforce the principle. Departin g from Uniform Access may cause any internal  
representation change (such as th e switch from polar to cartesi a n  o r  s o m e  o t h e r  
representation) to cause upheaval in many client classes. This is a primary source of  
instability in software development. 
The Uniform Access principle also yields a requirement on docum entation  
techniques. If we are to apply the principle consistently, we m ust ensure that it is not  
possible to determine, from the official documentation on a cla ss, whether a query without  
arguments is a function or an attribute. This will be one of th e properties of the standard  
mechanism for documenting a cl ass, known as the short form. 
The class 
Here is a version of the class text for POINT . (Any occurrence of consecutive dashes --
introduces a comment, which exte nds to the end of the line; com ments are explanations  
intended for the reader of the c lass text and do not affect the  semantics of the class.)
note
description : "Two-dimensional points "
class  POINT feature  
x, y: REAL
-- Abscissa and ordinate
rho: REAL
-- Distance to origin (0, 0) 
do
Result := sqrt (x ^ 2 + y ^ 2 )
end
theta : REAL is 
-- Angle to  horizontal axis
do
…Left to reader (exercise E7.3, page 216 ) º
end“Using assertions 
for documentation: the short form of a class”, page 389 .
§7.6   BASIC CONVENTIONS 177
distance (p: POINT ): REAL
-- Distance to p
do
Result := sqrt ((x – p   x) ^ 2 + (y – p   y) ^ 2)
end
translate (a, b: REAL )
-- Move by a horizontally, b vertically.
do
x := x + a
y := y + b
end
scale (factor : REAL )
-- Scale by factor .
do
x := factor ∗ x
y := factor ∗ y
end
rotate (p: POINT; angle : REAL )
-- Rotate around p by angle .
do
…Left to reader (exercise E7.3, page 216 ) …
end
end
The next few sections e xplain in detail the  non-obvious aspects  of this class text. 
The class mainly consists of a c lause listing the various featu res and intr oduced by  
the keyword feature . There is also a note clause giving general description  information,  
useful to readers of the class but with no effect on its execut ion semantics. Later on we  
will learn three optional clauses: inherit  for inheritance, creation  for non-default creation  
and invariant  for introducing class invariants ; we will also see how to incl ude two or  
more feature  clauses in one class.
7.6  BASIC CONVENTIONS 
Class POINT  shows a number of techniques wh ich will be used throughout lat er examples.  
Let us first look at t he basic conventions. 
Recognizing feature kinds
Features x and y are just declared as being of type REAL , with no associated algorithm; so  
they can only be attributes. All  other features have a clause o f the form 
do
… Instructions …
end
THE STATIC STRUCTURE: CLASSES  §7.6 178
which defines an algorithm; this  indicates the feature is a rou tine. Routines rho, theta  and 
distance  ar e  de cl ar e d a s r et ur n in g a  re su lt ,  o f t yp e REAL  in all cases, as indicated by  
declarations of the form
rho: REAL = …
This defines them as functions. The other two, translate  and scale , do not return a  
result (since they do not have a result decl aration of the form  :T for some type T ), and so  
they are procedures. 
Since x and y are attributes, while rho and theta  are functions, th e representation  
chosen in this parti cular class for poin ts is cartesian. 
Routine bodies and header comments
The body of a routine (the do clause) is a sequence of instructions. You can use  
semicolons, in the Algol-Pascal tradition, to separate successi ve instructions and  
declarations, but the semicolons  are optional. We will omit the m for simplicity between  
elements on separate lines, but will always include them to del imit instructions or  
declarations appearing on the same line.
All the instructions in the routines of class POINT  are assignments; for assignment,  
the notation uses the := symbol (again borrowed from the  Algol-Pascal conventions). Thi s 
s y m b o l  s h o u l d  o f  c o u r s e  n o t  b e  c o nfused with the equality symbo l =, used, as in  
mathematics, as a co mparison operator. 
Another convention of the notati on is the use of header comment s. As already noted,  
comments are introduced by  two consecutive dashes --. They may appear at any place in  
a class text where the class aut hor feels that readers will ben efit from an explanation. A  
special role is played by the header comment  which, as a general style rule, should appear  
at the beginning of every routine, after the keyword is, indented as shown by the examples  
in class POINT . Such a header comment should te rsely express the purpose of t he routine.
Attributes should also have a he ader comment immediately follow ing their  
declaration, aligned with routin e’s header comments, as illustr ated here with x and y.
The note clause
At the beginning of the class comes a clause starting with the keyw ord note. It contains a  
single entry, labeled description . The note clause has no effec t on software execution, but  
serves to associate information with the class. In its general form it contains zero or more  
entries of the form
index_word : index_value , index_value , …
where the index_word  i s  a n  a r b i t r a r y  i d e n t i f i e r ,  a n d  e a c h  index_value  is an arbitrary  
language element (iden tifier, integer, string …).For details see “The 
War of the Semico-lons”, page 897 .
See “A note about 
component index-ing”, page 78 .
§7.6   BASIC CONVENTIONS 179
The benefit is twofold:
• Readers of the class get a summa ry of its properties, without having to see the details.
•In a software development envir onment supporting reuse, query t ools (often known  
as browsers ) can use the indexing informati on to help potential users find  out about  
available classes; the tools can let the users enter various se arch words and match  
them with the index words and values.
The example has a single indexing entry, with description as index word and, as  
index value, a string describing the purpose of the class. All classes in this book, save for  
short examples, will include a description entry. You are strongly encouraged to follow  
this example and begin e very class text with a note clause providing a concise overview  
of the class, in the sa me way that every routine begins with a header comment.
Both indexing ( note) clauses and header c omments are faithful applications of the  
Self-Documentation principle: as much as possible of a module’s  documentation should  
appear in the text o f the module itself.
Denoting a function’s result 
We need another convention to und erstand the texts of the funct ions in class POINT : rho, 
theta  and distance . 
Any language that supports functi ons (value-return ing routines)  must offer a  
notation allowing the body of a f unction to set the value which  will be returned by any  
particular call. The convention used here is simple: it relies on a predefined entity name,  
Result , denoting the value th at the call will return. For example, th e body of rho contains  
an assignment to Result : 
Result := sqrt (x ^ 2 + y ^ 2 )
Result  is a reserved word, and may onl y appear in func tions. In a fun ction declared  
as having a result of type T, Result  is treated in the same way as other entities, and may be  
assigned values through assignme nt instructions such as the abo ve. 
Any call to the function will return, as its result, the final value assigned to Result
during the call’s execution. Tha t value always e xists since lan guage rules (to be seen in  
detail later) require every exec ution of the routine, when it s tarts, to initialize Result  to a 
preset value. For a REAL the initialization value is ze ro; so a function of the form 
non_negative_value (x: REAL ): REAL
-- The value of x if positive; ze ro otherwise.
do
if x > 0.0 then
Result := x
end
end
will always return a well-define d value (as desc ribed by the he ader comment) even though  
the conditional in struction has no else part. Chapter 36 
describes a general O-O browsing mechanism. 
“Self-Documenta-
tion”, page 54.
An “entity” is a 
name denoting a value. Full defini-tion on page 213.
Initialization rules 
will be given in “The creation instruc-tion”, page 232.
THE STATIC STRUCTURE: CLASSES  §7.6 180
The discussion section of this c hapter examines the rationale b ehind the Result
convention and compares it with other techniques such as return  instructions. Although  
this convention addresses an issue that arises in all design an d programming languages, it  
blends particularly well with th e rest of the ob ject-oriented a pproach. 
Style rules
The class texts in this book fol low precise style conventions r egarding indentation, fonts  
(for typeset output), choice of names for features and classes,  use of lower and upper case.
The discussion will point out th ese conventions, under the head ing “style rules”, as  
we go along. They should not be di smissed as mere cosmetics: qu ality software requires  
consistency and attent ion to all details, of form as well as of  content. The re usability goal  
makes these observations even mo re important, since it implies that software texts will  
have a long life, duri ng which many people will need to underst and and improve them.
Y ou should apply the style rules right from the time you start writing a class. For  
example you should never write a routine without immediately in cluding its header  
comment. This does not take long,  and is not wasted time; in fa ct it is time saved for all  
future work on the class, whether by you or by others, whether after half an hour or after  
half a decade. Using regular indentation, proper spelling for c omments and identifiers,  
adequate lexical conventions — a space before each opening pare nthesis but not after, and  
so on — does not make your task any longer than ignoring these rules, but compounded  
over months of work and heaps of software produce s a tremendous  difference. Attention  
to such details, although not su fficient, is a necessary condit ion for quality software (and  
quality, the general theme of th is book, is what defines softwa re engineering).
The elementary style rules are c lear from the preceding class e xample. Since our  
immediate goal is to explore the basic mechanisms of object tec hnology, their precise  
description will only app ear in a later chapter.
Inheriting general- purpose facilities 
Another aspect of class POINT  which requires clarification is the presence of calls to the  
sqrt function (in rho and distance ). This function should clear ly return the square root of  
a real number, but where does it come from? 
Since it does not seem appropria te to encumber a general-purpos e language with  
specialized arithmetic operations ,  t h e  b e s t  t e c h n i q u e  i s  t o  d e f ine such operations as  
features of some specialized class — say ARITHMETIC  — and then simply require any  
class that needs these facilities to inherit from the specializ ed class. As will be seen in  
detail in a later chapter, i t suffices then to write POINT  as 
class  POINT inherit
ARITHMETIC
feature
… The rest as before …
endSee “Denoting the 
result of a function”, page 210 .
Chapter 26 is 
devoted to style rules .
§7.7   THE OBJECT-ORIENTED STYLE OF COMPUTATION 181
This technique of inheriting general-purpose facilities is some what controversial; one can  
argue that O-O principles suggest making a function such as sqrt a feature of the class  
representing the object to which it applies, for example REAL . But there are many  
operations on real numbers, not all of which can be included in  the class. Square root may  
be sufficiently fundamental to justify making it a feature of c lass REAL ; then we would  
write a  sqrt rather than  sqrt (x). We will return, in the discussion of design principles, to  
the question of whether “ facilities” classes such as ARITHMETIC  are desirable.
7.7  THE OBJECT-ORIENTED STYLE OF COMPUTATION
Let us now move to the funda mental properties of class POINT  by trying to understand a  
typical routine body a nd its instructions, then studying how th e class and its features may  
be used by other c lasses — clients. 
The current instance 
Here again is the text of one of  our example routines, procedur e translate : 
translate (a, b: REAL )
-- Move by a horizontally, b vertically
do
x := x + a
y := y + b
end
At first sight this text appears clear enough: to translate a p oint by a horizontally, b
vertically, we add a to its x and b to its y. But if you look at it mo re carefully, it may not  
be so obvious anymore! Nowhere in the text have we stated what point we were talking  
about. To whose x and whose y are we adding a and b? In the answer to this question will  
lie one of the most distinctive aspects of the object-oriented development style. Before we  
are ready to discover that answe r we must understand a few inte rmediate topics.
A class text describes the prope rties and behavior of objects o f a certain type, points  
in this example. It does so by d escribing the properties and be havior of a t ypical instance  
of that type — what we could call the “point in the street” in the way newspapers report  
the opinion of the “man or woman in the street”. We will settle  for a more formal name:  
the current instance of the class.
Once in a while, we may need to refer to the current instance e xplicitly. The  
reserved word 
Current
will serve that purpose. In a class text, Current  denotes the current ins tance of the enclosing  
class. As an example of when Current  is needed, assume we rewrite distance  so that it  
checks first whether the argument p is the same point as the current instance, in which case  
the result is 0 with no need f or further computation. Then distance  will appear as See “F ACILITY 
INHERITANCE”, 24.9, page 847 .
THE STATIC STRUCTURE: CLASSES  §7.7 182
distance (p: POINT): REAL
-- Distance to  p
do
if p /= Current then
Result := sqrt ((x — p   x) ^ 2 + (y — p   y) ^ 2)
end
end
(/= is the inequality operator. Bec ause of the initialization rule  mentioned above, the  
conditional instructi on does not need an else part: if p = Current the result is zero.) 
In most circumstances, however, t he current instance is implici t and we will not need  
to refer to Current  by its name. For example, references to x in the body of translate  and 
the other routines simply mean, if not further q ualified: “the x of the current instance”. 
This only pushes back the mystery, of course: “who” really is Current ? The answer  
will come with the study of routine calls below. As long as we only look at the routine text,  
it will suffice to know that all operations are relative, by de fault, to an implicitly defined  
object, the curre nt instance. 
Clients and suppliers 
Ignoring for a few moments the enigma of Current ’s identity, we know how to define  
simple classes. We must now stu dy how to use their definitions.  Such uses will be in other  
classes — since in a pure object -oriented approach every softwa re element is part of some  
class text. 
There are only two ways to use a class such as POINT . One is to inherit from it; this  
is studied in detail i n later chapters. The other one is to bec ome a client  of POINT . 
The simplest and most common way to become a client of a class is to declare an  
entity of the corresponding type:
In this definition, a may be an attribute or function of C, or a local entity or argument  
of a routine of C. 
For example, the declarations of x, y, rho, theta  and distance  above make class POINT
a client of REAL . Other classes may in turn become clients of POINT . Here is an example: Definition: client, supplier
Let S be a class. A class C which contains a declaration of the form a: S is 
said to be a client of  S. S is then said to be a supplier of C. Chapters 14 to 16 
study inheritance . 
§7.7   THE OBJECT-ORIENTED STYLE OF COMPUTATION 183
class  GRAPHICS feature
p1: POINT
…
some_routine
-- Perform some actions with p1.
do
… Create an i nstance of POINT and attach it to p1 …
p1  translate (4.0, –1.5) -- …
end
…
end
Before the instruction marked -- gets executed, the attribute p1 will have a value  
denoting a certain instance of class POINT . Assume that this instance represents the origin,  
of coordinates x = 0, y = 0: 
Entity p1 is said to be attached  to this object. We do not worry at this point about  
how the object has been created (by the unexplai ned line that r eads “ …Create object …”) 
and initialized; such topics will be discussed as part of the o bject model in the next chapter.  
Let us just assume that the object exists and that p1 is attached to it. 
Feature call 
The starred instruction, 
p1  translate (4.0, –1.5)
deserves careful examination sinc e it is our first complete exa mple of what may be called  
the basic mechanism of objec t-oriented computation : feature call. In the execution of  
an object-oriented software syst em, all computation is achieved  by calling certain features  
on certain objects. 
This particular feature call means: apply to p1 the feature translate  of class POINT , 
with arguments 4.0 and –1.5, corresponding to a and b in the declaration of translate  as it 
appears in the class. More genera lly, a feature call appears in  its basic form as one of 
x  f
x  f (u, v, …)The originx
y
(POINT )0.0
0.0
THE STATIC STRUCTURE: CLASSES  §7.7 184
In such a call, x, called the target  of the call, is an entity or  expression (which at run  
time will be attached to a certai n object). As any other entity  or expression, x has a certain  
type, given by a class C; then f must be one of the features of C. More precisely, in the first  
form, f must be an attribute or a routi ne without arguments; in the se cond form, f must be  
a routine with arguments, and u, v, …, called the actual arguments  for the call, must be  
expressions matching in type and  number the formal arguments de clared for f in C. 
In addition, f must be available (exported) to  the client containing this cal l. This is  
the default; a later section will show how to restrict export r ights. For the moment, all  
features are availab le to all clients. 
The effect of the above call whe n executed at run time is defin ed as follows:
The Single Target principle
What is so special about feature call? After all, every softwar e developer knows how to  
write a procedure translate  which moves a point by a certain displacement, and is called  
in the traditional form (availab le, with minor variants, in all  programming languages): 
translate (p1, 4.0, –1.5)
Unlike the object-oriented style of feature call, however, this  call treats all arguments  
on an equal basis. The O-O form has no such symmetry: we choose  a certain object (here  
the point  p1) as target, relegating the othe r arguments, here the real numb ers 4.0 and –1.5, 
to the role of supporting cast. This way of making every call r elative to a single target  
object is a central part of the object-oriented s tyle of comput ing:
To novices, this is of ten the most disconcerting aspect of the method. In object-
oriented software cons truction, we never rea lly ask: “Apply thi s operation to these objects”.  
Instead we say: “Apply this operation to this object here.” And perhaps (in the second  
form): “Oh, by the way, I almost forgot, you will need those va lues there as arguments”. 
What we have seen so far does no t really suffice  to justify thi s convention; in fact its  
negative consequences will, for a while, ove rshadow its advanta ges. An example of  
counter-intuitive effect appears with the function distance  of class POINT , declared above  
as distance (p: POINT ): REAL , implying that a typical  call will be written 
p1  distance (p2)
which runs against t he perception of distance  as a symmetric operati on on two arguments.  
Only with the introduction of inh eritance will the Single Targe t principle be fully vindicated. Effect of calling a feature f on a target x 
Apply feature f to the object attached to x, after having initialized each formal  
argument of f (if any) to the value of the corresponding actual argument.
Single Target principle
Every operation of object-orient ed computation is relative to a  certain object,  
the current instance at the time  of the operatio n’s execution.“SELECTIVE EX-
PORTS AND INFOR-MATION HIDING”, 7.8, page 191.
§7.7   THE OBJECT-ORIENTED STYLE OF COMPUTATION 185
The module-type identification 
The Single Target principle is a direct consequence of the modu le-type merge, presented  
earlier as the starting point of object-oriented decomposition:  if every module is a type,  
then every operation in the modul e is relative to a certain ins tance of that type (the current  
instance). Up to now, however, the details of that merge remain ed a little mysterious. A  
class, it was said above, is bot h a module and a type; but how can we reconcile the  
syntactic notion of module (a gr ouping of related facilities, f orming a part of a software  
system) with the semantic notion of type (the static descriptio n of certain possible run-
time objects)? The example of POINT  makes the answer clear:
This identification between the o perations on instances of a ty pe and the services  
provided by a module lies at the  heart of the structuring disci pline enforced by the object-
oriented method. 
The role of Current  
With the help of the same example, we are now also in a positio n to clear the remaining  
mystery: what does the current  instance really represent? 
The form of calls indicates why the text of a routine (such as translate  in POINT ) 
does not need to specify “who” Current  is: since every call to the routine will be relative  
to a certain target, specified explicitly in the call, the exec ution will treat every feature  
name appearing in the text of  the routine (for example x in the text of translate ) as applying  
to that particular target. So for the execution of the call 
p1  translate (4.0, –1.5)
every occurrence of x in the body of translate , such as those in the instruction 
x := x + a
means: “the x of p1”. 
The exact meaning of Current  follows from these observations. Current  means: “the  
target of the current call”. For example, for the duration of t he above call, Current  will 
denote the objec t attached to p1. In a subsequent call, Current  will denote the target of that  
new call. That this al l makes sense follows from the extreme si mplicity of the object-
oriented computation model, based  on feature calls and on the S ingle Target principle:How the module-type merge works
The facilities provided by class  POINT , viewed as a module, are precisely the  
operations available o n instances of class POINT , viewed as a type.“The class as mod-
ule and type”, page 170.
THE STATIC STRUCTURE: CLASSES  §7.7 186
Qualified a nd unqualified calls 
It was said above that all objec t-oriented comput ation relies o n feature calls. A  
consequence of this rule is that  software texts actually contai n more calls than meet the  
eye at first. The calls seen so f ar were of one of the two form s introduced above: 
x  f
x  f (u, v, …)
Such calls use so-called dot notation (with the “   ” symbol) and are said to be  
qualified  because the target of the ca ll is explicitly identified: it is  the entity or expression  
(x in both cases above) that  appears before the dot. 
Other calls, however, will be unqualified because their targets  are implicit. As an  
example, assume that we want to add to class POINT  a procedure transform  that will both  
translate and scale a point. The procedure’s text may rely on translate  and scale : 
transform (a, b, factor : REAL )
-- Move by a horizontally, b vertically, then scale by factor .
do
translate (a, b)
scale ( factor )
end
The routine body contains calls to translate  and scale . Unlike the earlier examples,  
these calls do not show  an explicit target,  and do not use dot notation. Such calls are said  
to be unqualified . 
Unqualified calls do not violate the  property called F 2 in the Feature Call principle:  
like qualified calls, they have a target. As you have certainly  guessed, the target in this case  
is the current instance. When procedure transform  is called on a certain target, its body  
calls translate  and scale  on the same target. It coul d in fact have been written
do
Current   translate (a, b)
Current   scale ( factor )
More generally, you may rewrite any unqualified c all as a quali fied call with Current
as its target. The unqualified f orm is of course simpler and ju st as clear. 
The unqualified calls that we have just examined were calls to routines. The same  
discussion applies to attributes, although the presence of call s is perhaps less obvious in  
this case. It was noted above that, in the body of translate , the occurrence of x in the  
expression x + a  denotes the x field of the current instance. Another way  of expressing this  Feature Call principle
F1 • No software element ever gets executed except as part of a rout ine call. 
F2 • Every call has a target.
Strictly speaking, the 
equivalence only applies if the feature is exported.
§7.7   THE OBJECT-ORIENTED STYLE OF COMPUTATION 187
property is that x is actually a feature call, so that the expression as a whole could have  
been written as Current   x + a . 
More generally, any ins truction or expressi on of one of the for ms 
f
f (u, v, …)
is in fact an unqualified call, and you may also write it in qu alified form as (respectively) 
Current   f
Current   f (u, v, …)
although the unqualified forms are more convenient. If you use such a notation as an  
instruction, f must be a procedure (with no argu ment in the first form, and w ith the  
appropriate number and types of a rguments in the second). If it  is an expression, f may be  
an attribute (in the f irst form only, since  attributes have no arguments) or a function.
Be sure to note that this syntactical equivalence only applies to a feature used as an  
instruction or an expression. So in the following assignment fr om procedure translate  
x := x + a
only the occurrence of x on the right-hand side is an unqualified call: a i s  a  f o r m a l  
argument, not a feature; and the occurrence of x on the left is not an expression (one cannot  
assign a value to an e xpression), so it woul d be meaningless to  replace it by Current   x.
Operator features 
A further look at the expression x + a  leads to a useful notion:  operator features. This  
notion (and the present section)  may be viewed as pure “cosmeti cs”, that is to say,  
covering only a syntactical fac ility without bringing anything really new to the object-
oriented method. But such syntac tical properties can be importa nt to make developers’ life  
easier if they are present — or miserable if they are absent. O perator features also provide  
a good example of how successful the object-oriented paradigm c an be at integrating  
earlier approaches smoothly.
Here is the idea. Although you ma y not have guessed it, the exp ression x + a  contains  
not just one call — the call to x, as just seen — but two. In non-O-O computation, we  
would consider + as an operator, applied here to two values x and a, both declared of type  
REAL . In a pure O-O model, as noted, the only computational mechani sm is feature call;  
so you may consider the addition itself, at least in theory, to  be a call to an addition feature. 
To understand this better, consi der how we could define the typ e REAL . The Object  
rule stated earlier implied that every type is based on some cl ass. This applies to  
predefined types such as REAL  a s  w e l l  a s  d e v e l o p e r - defined types such as POINT . 
Assume you are requested to write REAL  as a class. It is not hard to identify the relevant  
features: arithmetic operations (addition, subtraction, negatio n…), comparison operations  
(less than, greater than …). So a first sket ch could appear as:The Object rule was 
given on page 171 .
THE STATIC STRUCTURE: CLASSES  §7.7 188
note
description: "Real numbers (not final version !)"
class  REAL feature  
 plus (other : REAL ): REAL
-- Sum of current value and other
do
…
end
minus (other : REAL ) REAL
-- Difference of current value and other
do
…
end
negated : REAL
-- Current value but with opposite sign
do
…
end
less_than (other : REAL ): BOOLEAN
-- Is current value s trictly less than other ?
do
…
end
… Other features … 
end
With such a form of the class, you could not write an arithmeti c expression such as
x + a  any more; instead, you wou ld use a call of the form 
x  plus (a)
Similarly, you wou ld have to write x  negated  instead of the usual –x. 
One might try to justi fy such a departure from usual mathematic al notation on the  
grounds of consistency with the object-oriented model, and invo ke the example of Lisp to  
suggest that it is sometimes pos sible to convince a subset of t he software development  
community to renounce standard no tation. But this argument cont ains it owns limitations:  
usage of Lisp has always remaine d marginal. It is rather danger ous to go against notations  
which have been in existence for centuries, and which people ha ve been using since  
elementary school, especially wh en there is nothing wrong with these notations.
A simple syntactical device reco nciles the desire for consisten cy (requiring here a  
single computational me chanism based on feature call) and the n eed for compatibility with  
traditional notations. I t suffices to consider that an expressi on of the form 
x + a
is in fact a call to the addition feature of class REAL ; the only difference with the plus
feature suggeste d  a b o v e  i s  t h a t  w e  m u s t  r e w r i t e  t h e  d e c l a r a t i o n  of the corresponding  
feature to specify tha t calls will use operator notation rather  than dot notation. 
§7.7   THE OBJECT-ORIENTED STYLE OF COMPUTATION 189
Here is the form of a class that achieves this goal: 
note
description: "Real numbers "
class  REAL feature
infix  "+" (other : REAL ): REAL
-- Sum of current value and other
do
…
end
infix  "–" (other: REAL) REAL
-- Difference of c urrent value and other
do
…
end
prefix  "–": REAL
-- Current value but  with opposite sign
do
…
end
infix  "<" (other : REAL ): BOOLEAN
-- Is current value strictly less than other ?
do
…
end
… Other features …
end
Two new keywords have been introduced: infix  and prefix . The only syntactical  
extension is that from now on we  may choose feature names which , instead of identifiers  
(such as distance  or plus), are of one of the two forms 
infix  "§"
prefix  "§"
where § stands for an operator symbol c hosen from a list which include s +, –, , <, <= and 
a few other possibilities listed below. A feature may have a na me of the infix  form only if  
it is a function with one argument, such a s the functions calle d plus, minus  and less_than
in the original version of class REAL ; it may have a name of the prefix  form only if it is a  
function with no argum ent, or an attribute. 
Infix and prefix features, collectively called operator features , are treated exactly  
like other features (called identifier features ) with the exception of the two syntactical  
properties already seen: 
• The name of an operator feature  as it appears in the feature’s  declaration is of the  
form infix  "§" or prefix  "§", rather than an identifier. 
• Calls to operator features are of the form u § v (in the infix case) or § u (in the prefix  
case) rather than using dot notation. The next chapter 
will show how to declare this class as “expanded” . See 
“The role of expanded types”, page 256 .
THE STATIC STRUCTURE: CLASSES  §7.7 190
As a consequence of the second property, operator features only  support qualified  
calls. If a routine of class REAL  contained, in the first versi on given earlier, an unqualified  
call of the form plus (y), yielding the sum of the current number and y, the corresponding  
call will have to be written Current + y  in the second version. Wit h an identifier feature,  
the correspond ing notation, Current   plus (y), is possible but we wou ld not normally use it  
in practice since it is uselessl y wordy. With an operator featu re we do not have a choice.
Other than the two synt actical differences noted, operator feat ures are fully  
equivalent to identifier features ; for example they are inherit ed in the same way. Any class,  
not just the basic  classes such as REAL , can use operator features ; for example, it may be  
convenient in a class VECTOR  to have a vector addi tion function called infix  "+". 
The following rule will apply to the operators us ed in operator  features. An operator  
is a sequence of one or more printable characters, containing n o space or newline, and  
beginning with one of
+  –  ∗  /  <  >  =  \  ^  @  #  |  &
In addition, the following keywords, used for compatibility wit h usual boolean  
notation, are permi tted as operators:
not  and  or  xor  and then   or else   implies
In the non-keyword case, the rea son for restricting the first c haracter is to preserve  
t h e c la ri t y of  so f tw a r e t ex ts  by  en sur i ng  t h at  an y us e o f a n i n fix or prefix operator is  
immediately recogniz able as such from its first character.
Basic classes ( INTEGER  etc.) use the following, kno wn as standard operators:
• Prefix: +  –  not. 
•I n f i x :  +  –  ∗  /  <  >  <=  >=  //  \\  ^  and  or  xor  and then   or else   implies . 
The semantics is the usual one. // is used for integer division, \\ for integer remainder, ^
as the power operation, xor as exclusive or. In class BOOLEAN , and then  and or else  are 
variants of and and or, the difference being explained in a later chapter, and implies  is 
the implication operator, such that a implies  b is the same as (not a) or else  b.
Operators not in the “ standard” list are called free operators.  Here are two examples  
of possible operator featur es using free operators: 
• When we later introduce an ARRAY  class, we will use the operator feature infix  "@"
for the function that returns an  array element given by its ind ex, so that the i-th 
element of an array a may be written simply as a @ i . 
•I n  c l a s s  POINT , we could have used the name  infix  "|–|" instead of distance , so that  
the distance between p1 and p2 is written p1 |–| p2 instead of p1  p2. 
The precedence of all operators is fixed; standard operators ha ve their usual  
precedence, and all free operators  bind tighter th an standard o perators. 
The use of operator features is a convenient way  to maintain co mpatibility with well-
accepted expression notation whil e ensuring the goal of a fully  uniform type system (as  
stated by the Object Rule) and of  a single fundamental mechanis m for computation. In the  
same way that treating INTEGER  and other basic types as cla sses does not need to cause  
any performance problem, treating arithmetic and boolean operat ions as features does not  See “Non-strict 
boolean opera-tors”, page 454.
§7.8   SELECTIVE EXPORTS AND INFORMATION HIDING 191
need to affect efficie ncy. Conceptually, a + x  is a feature call; but any good compiler will  
know about the basic t ypes and their features, and will be able  to handle such a call so as  
to generate code at least as g ood as the code generated for a + x  in C, Pascal, Ada or any  
other language in which + is a special hard-wired  language co nstruct. 
When using operators such as +, < and others in expressions, we may forget, most  
of the time, that they actually stand for feature calls; the ef fect of these operators is the one  
we would expect in traditional approaches. But it is pleasant t o know that, thanks to the  
theoretical conte xt of their definition, t hey do not cause any departure fro m object-
oriented principles, and fit in perfectly with th e rest of the method. 
7.8  SELECTIVE EXPORTS AND INFORMATION HIDING
In the examples seen so far all the features of a class were ex ported to all possible clients.  
This is of course not always acceptable; we know from earlier d iscussion how important  
information hiding is to the des ign of coherent and flexible ar chitectures. 
Let us take a look at how we can indeed restrict features to no  clients, or to some  
clients only. This section only introduces the n otation; the ch apter on the design of class  
interfaces will discuss its proper use.
Full disclosure
By default, as noted, features d eclared without any particular precaution are available to  
all clients. In a class of the form 
class  S1 feature
f …
g …
…
end
features f, g, … are available to all clients of S1. This means that in a class C, for an entity  
x declared of type S1, a call
x  f …
is valid, provided the call sati sfies the other validity condit ions on calls to f, regarding the  
number and types of arguments if  any. (For simplicity the discu ssion will use identifier  
features as examples, but it applies in exactly the same way to  operator features, for which  
the clients will use calls in in fix or prefix for m rather than dot notation.)
Restricting client access
To restrict the set of clients t hat can call a certain feature h, we will use the possibility for  
a class to have two or more feature  clauses. The cl ass will then be of the form See “Information 
Hiding”, page 51 .
“SELECTIVE 
EXPORTS”, 23.5, page 796 .
THE STATIC STRUCTURE: CLASSES  §7.8 192
class  S2 feature
f …
g …
feature  {A, B}
h …
…
end
Features f and g have the same status as before:  available to all  clients. Feat ure h is 
available only to A and B, and to their descendants (the classes that inherit directly o r 
indirectly from A or B). This means that with x declared of type S2 a call of the form 
x  h …
is invalid unless it appears in the text of A, B, or one of their  descendants. 
As a special case, if you want to hide a feature i from all clients, you may declare it  
as exported to an empty list of clients: 
class  S3 feature  { }
i …
end
In this case a call of the form x  i (…) is always invalid. The only permitted calls to  
i are unqualified calls of the form 
i (…)
appearing in the text of a routine of S3 itself, or one of its des cendants. This mechanism  
ensures full information hiding. 
The possibility of hiding a feat ure from all clients, as illust rated by i, is present in  
many O-O languages. But most do not offer the selective mechani sm illustrated by h: 
exporting a feature to certain designated clients and their pro per descendants. This is  
regrettable since many applications will ne ed this degree of fi ne control. 
 The discussion section of the p resent chapter explains why sel ective exports are a  
critical part of the architectur al mechanisms of the object-ori ented approach, avoiding the  
need for “super-modules” that wo uld hamper the simplicity of th e method.
We will encounter various exampl es of selective exports in subs equent chapters, and  
will study their method ological role in the design of good modu lar interfaces.
Style for declarin g secret features
A small point of style. A feature declared in the form used abo ve for i is secret, but perhaps  
this property does not  stand out strongly enough from the synta x. In particular, the  
difference with a public feature may not be visible enough, as in This is not the rec-
ommended style ; see 
S5 below .
“The architectural 
role of selective exports”, page 209 .
“SELECTIVE 
EXPORTS”, 23.5, page 796 .
§7.8   SELECTIVE EXPORTS AND INFORMATION HIDING 193
class  S4 feature
exported …
feature  { }
secret …
end
where feature exported  is available to all clients whereas secret  is available to no client.  
The difference between feature  { }, with an empty list in braces, and feature , with no  
braces, is a little weak. For th at reason, the recommended nota tion uses not an empty list  
but a list consisting of the single class NONE , as in 
class  S5 feature
… Exported …
feature  {NONE }
… Secret  …
end
Class NONE , which will be studied in a late r chapter in connection with i nheritance,  
is a Base library class which is  so defined as to have no insta nces and no descendants. So  
exporting a feature to NONE  only is, for all practical pu rposes, the same as keeping it  
secret. As a result there is no meaningful difference between t he forms illustrated by S4
and S5; for reasons of clarity and readability, however, the second f orm is preferred, and  
will be employed in the rest of this book whenever we need to i ntroduce a secret feature. 
Exporting to yourself
A consequence of the rules seen so far is that a class may have  to export a secret feature.  
Assume the declaration
note
note: "Invalid as it stands (see explanations below )"
class  S6 feature
x: S6
my_routine do … print (x  secret ) … end
feature {NONE }
secret : INTEGER
end
By declaring x of type S6 and making the call x  secret , the class becomes its own  
client. But this cal l is invalid, since secret  is exported to no class! That the unauthorized  
client is S6 itself does not make any difference: the {NONE } export status of secret  makes  
any call x  secret  invalid. Permitting exceptions w ould damage the simplicity of the rule.
The solution is simple: instead of feature {NONE } the header of the second feature
clause should read feature {S6}, exporting the feature to the class itself and its descendants .
Be sure to note that this is onl y needed if you want to use the  feature in a qualified  
call such as appears in print (x  secret ). If you are simply using secret  by itself, as in the  Not the recom-
mended style ; see S5 
next.
The recommended 
style.
“The bottom of the 
pit”, page 582 .
THE STATIC STRUCTURE: CLASSES  §7.9 194
instruction print (secret ), you of course do not need to e xport it at all.  Features decla red in 
a class must be usable by the ro utines of the class and its des cendants; othe rwise we could  
never do anything with a secret feature! Only if you use the fe ature indirectly in a qualified  
call do you need to e xport it to yourself.
7.9  PUTTING EVERYTHING TOGETHER 
The previous discussions have in troduced the basic mechanisms o f object-oriented  
computation, but we are still mi ssing the big picture: how does  anything ever get executed? 
Answering this q uestion will help us piece everything together and understand how  
to build executable systems from individua l classes. 
General relativity 
What is a little mind-boggling is that every description given so far of what happens at run  
time has been relative. The effect of a routine such as translate  is relative to the current  
instance; within the class text, as noted, the current instance  is not known. So we can only  
try to understand the effect of a  call with respect to a specif ic target, such as p1 in
p1  translate (u, v)
But this brings the next question: what does p1 actually denote? Here again the  
answer is relative. The above cal l  m u s t  a p p e a r  i n  t h e  t e x t  o f  s ome class such as  
GRAPHICS . Assume that p1 is an attribute of class GRAPHICS . Then the occurrence of  
p1 in the call, as noted above, may be viewed as a call: p1 stands for Current   p1. So we  
have only pushed the problem fur ther, as we must know what obje ct Current  stood for at  
the time of the above call! In o ther words, we must look at the  client that called the routine  
of class GRAPHICS  containing that call. 
So this attempt at understanding  a feature call starts off a ch ain of reaso ning, which  
we will not be able to follow to  the end unless we know where e xecution started. 
The Big Bang
To understand what is going on l et us generalize the above exam ple to an arbitrary call. If  
we do understand that arbitrary call, we will indeed understand  all of O-O computation,  
thanks to the Feature Call p rinciple which stated that
Any call will be of one of the following two forms (the argumen t list may be absent  
in either case): 
• Unqualified: f (a, b, …)
• Qualified: x  g (u, v, …)F1 • No software element ever gets executed except as part of a rou tine call. 
F2 • Every call has a target.See page 186 .
§7.9   PUTTING EVERYTHING TOGETHER 195
The call appears in th e body of a routine r. It can only get executed as part of a call  
to r. Assume we know the target of that call, some object OBJ. Then  the target t is easy to  
determine in each case: 
T1 • For the unqualified form, t is simply OBJ. Cases T 2, T3 and T 4 will apply to the  
qualified form. 
T2 • If x is an attribute, the x field of OBJ has a value which must be attached to some  
object; t is that object.
T3 • If x is a function, we must  first execute the ( unqualified) call to  x; the result gives  
us t. 
T4 • If x is a local entity of r, earlier instructions  will have given x a value, which at the  
time of the call must be atta ched to a certain object; t is that object. 
The only problem with these answer s is of course that they are relative: they only  
help us if we know the current i nstance OBJ. What is OBJ? Why, the target of the current  
call, of course! As in the traditional song (the kid was eaten by the cat, the cat was bitten  
by the dog, the dog was  beaten by the stick …), we do not see the  end of the chain. 
T o transform these relative answ ers into absolute ones, then, w e must know what  
happened when everything started  — at Big Bang time. Here is th e rule:
At Big Bang time, an object get s created, and a creation proced ure gets started. The  
root object is an instance of a certain class, the system’s root class ; the creation procedure  
is one of the procedures of the root class. In all but trivial systems, the creation procedure  
will itself create new objects and call routines on them, trigg ering more object creations  
and more routine calls. System execution as a whole is the succ essive deployment of all  
the pieces in a giant and complex firework, all resulting direc tly or indirectly from the  
initial lighting of a minuscule spark. 
Once we know where everything st arts, it is not difficult to tr ace the fate of Current
throughout this chain reaction. The first current object, at th e start of everything (Big Bang  
time, when the root’s creation pr ocedure is called), is the roo t object. Then at any stage  
during system execution let r be the latest routine to have been called; if OBJ was the  
current object at the time of the call to r, here is what becomes of Current  during the  
execution of r: 
C1 • If r executes an instruction which does not call a routine (for exa mple an  
assignment), we keep the sam e object as cu rrent object.
C2 • Starting an unqualifie d call also keeps the  same object as curr ent object. Definition: system execution
Execution of an object-oriented software system consists of the  following  
two steps: 
• Create a certain object, called the root object  for the execution. 
• Apply a certain pro cedure, called a creation procedure , to that object.
THE STATIC STRUCTURE: CLASSES  §7.9 196
C3 • Starting a qualified call x  f … causes the target object o f that call, which is the  
object attached to x (determined from OBJ through the rules called T 1 to T4 at the  
top of the previous page), to be c o m e  t h e  n e w  c u r r e n t  o b j e c t .  W h e n  t h e  c a l l  
terminates, OBJ resumes its  role as current object. 
In cases C 2 and C 3 the call may be to a routine that itself includes further call s, 
qualified or not; so this rule m ust be understood recursively. 
There is nothing mysterious or confusing, then, in the rule for  determining the target  
of any call, even though that rule is relative and in fact recu rsive. What is mind-boggling  
is the power of computers, the p ower we use to p lay sorcerer’s apprentice by writing a  
deceptively small software text and then executing it to create  o b j e c t s  a n d  p e r f o r m  
computations on them in numbers so large — number of objects, n umber of computations  
— as to appear almost infinite w hen measured on the scale of hu man understanding. 
Systems 
The emphasis in this chapter is o n classes: the individual comp onents of object-oriented  
software construction. To obtain  executable code, we must assem ble classes into systems. 
The definition of a system follo ws from the prev ious discussion . To make up a  
system we need three things: 
•A  s e t  CS of classes, calle d the system’s class set .
• The indication of which class in CS is the root class . 
• The indication of which proce dure of the root class is the root creation procedure . 
To yield a meaningful system, these elements  must satisfy a con sistency condition,  
system closure : any class needed directly or i ndirectly by the root class mus t be part of CS. 
Let us be a little more precise:
•A  c l a s s  C needs directly  a class D if the text of C refers to D. There are two basic  
ways in which C may need directly D: C may be a client of D, as defined earlier in  
this chapter, and C may inherit from D, according to the inheritance relation which  
we will study later. 
•A  c l a s s  C needs  a class E, with no further q ualification, if C is E or C needs directly  
a class D which (recursively) needs E. 
With these definitions we may st ate the closure requirement as follows:
If the system is closed, a language-processing tool, such as a compiler, will be able  
to process all its classes, starting with the root class, and r ecursively han dling needed  Definition: system closure
A system is closed if and only i f its class set contains all cl asses needed by  
the root class. 
§7.9   PUTTING EVERYTHING TOGETHER 197
classes as it encounters their names. If the tool is a compiler , it will then produce the  
executable code corresponding to the entire system. 
This act of tying together the set of classes of a system, to g enerate an executable  
result, is called assembly  and is the last step in the s oftware construc tion process. 
Not a main program 
The discussions in the previous c hapters repeated ly emphasized that systems developed  
w i t h  t h e  o b j e c t - o r i e n t ed method have no no tion of main program.  By introducing the  
notion of root class, and requi ring the system specification to  indicate a particular creation  
procedure, have we not brought m ain programs back through a sid e door? 
Not quite. What is wrong with the  traditional not ion of main pr ogram is that it  
merges two unrelated concepts: 
• The place where execution begins. 
• The top, or fundamental componen t of the system’s architecture . 
T h e  f i r s t  o f  t h e s e  i s  obviously necessary: e very system will be gin its execution  
somewhere, so we must have a way to let developers specify the starting point; here they  
will do so by specifyi ng a root class and a  creation procedure.  (In the case of concurrent  
rather than sequential computation we may have to specify sever al starting points, one per  
independent thread  of computation.)
On the concept of top, enough ab use has been heaped in earlier chapters to make  
further comments unnecessary.
But regardless of the intrinsic merit of each of the two notion s, there is no reason to  
m e r g e  t h e m :  n o  r e a s o n  t o  a s s u m e  t h a t  t h e  s t a r t i n g  p o i n t  o f  a  c o mputation will play a  
particularly important role in the architecture of the correspo nding system. Initialization  
is just one of many aspects of a system. To take a typical exam ple, the initial ization of an  
o p e r a t i n g  s y s t e m  i s  i t s  b o o t i n g  p r o c e d u r e ,  u s u a l l y  a  s m a l l  a n d  relatively marginal  
component of the OS; using it as the top of the system’s design  would not lead to an  
elegant or useful architecture. The notion of sy stem, and objec t technology in general, rely  
in fact on the reverse assumptio n: that the most important prop erty of a system is the set  
of classes that it cont ains, the individual capabilities of the se classes, and their  
relationships. In this view the c hoice of a root class is a sec ondary property, and should be  
easy to change as th e system evolves. 
A s  d i s c u s s e d  e x t e n s i v e l y  i n  a n  e arlier chapter, the quest for e xtendibility and  
reusability requires that we she d the practice of asking “what is the main function?” at an  
early stage of the system’s design and of organizing the archit ecture around the answer.  
Instead, the approach promotes t he development of reusable soft ware components, built  
as abstract data type implementat ions — classes. Systems are th en built as reconfigurable  
assemblies of such components. 
I n  f a c t ,  y o u  w i l l  n o t  a l w a y s  b u i l d  s y s t e m s  i n  t h e  p r a c t i c e  o f  O -O software  
development. An important applic ation of the method is to devel op libraries  of reusable  For a critique of 
function-based decomposition see “FUNCTIONAL DECOMPOSI-TION”, 5.2, page 103
THE STATIC STRUCTURE: CLASSES  §7.9 198
components — classes. A library is not a system, and has no roo t class. When developing  
a library, you may of course nee d to produce, compile and execu te one or more systems  
along the way, but such systems are a means, not an end: they h elp test the components,  
and will usually not be part of the library as finally delivere d. The actual delivered product  
is the set of classes making up the library, which other develo pers will then use to produce  
their own systems — or again their own libraries. 
Assembling a system
The process of putting together a  number of classes (one of whi ch is designated as root)  
to produce an executabl e system was called “assembly” above. Ho w in practice do we  
assemble a system? 
Let us assume an operating system of the usual form, where we w ill keep our class  
texts stored in files. The langu age processing tool in charge o f this task (compiler,  
interpreter) will need the following information: 
A1 • The name of th e root class. 
A2 • A universe , or set of files which may contain the text of classes needed by the root  
(in the above precise s ense of “needed”). 
This information shoul d not be included in the class texts them selves. Identifying a  
class as root in its own text (A 1) would violate the “no main  program” principle. Letting  
a class text include i nformation about the files where the need ed classes reside would tie  
the class to a particular locati on in the file system of a give n installation; this would  
prevent use of the class by another installation and is clearly  inappropriate. 
These observations suggest that the system assembly process wil l need to rely on  
some information stored outside of the text of the classes them selves. To provide this  
information we will rely on a little control language called La c e .  L e t  u s  o b s e r v e  t h e  
process, but not until we have noted that the details of Lace a re not essential  to the method;  
Lace is just an example of a con trol language, allowing us to k eep the O-O components  
(the classes) autonomous and reusable, and to rely on a separat e mechanism for their  
actual assembly into systems.
A typical Lace document, known as an Ace file , might appear as follows: 
system  painting root
GRAPHICS ("painti ng_application")
cluster
base_library : " \ library  \ base";
graphical_library : " \ library  \ graphics ";
painting_application : " \ user \ application "
end -- system painting
The cluster  clause defines the universe (th e set of files containing class  texts). It is  
organized as a list of clusters; a cluster is a group of relate d classes, representing a  
subsystem or a library.Chapter 28 dis-
cusses the cluster model .
§7.9   PUTTING EVERYTHING TOGETHER 199
In practice, an operating system such as Windows, VMS or Unix p rovides a  
convenient mechanism to support the notion of cluster: director i e s .  I t s  f i l e  s y s t e m  i s  
structured as a tree, where only  the terminal nodes (leaves), c alled “plain files”, contain  
directly usable information; the internal nodes, called directo ries, are sets of files (plain  
files or again  directories).
We may associate each cluster wi th a directory. This convention  is used in Lace as  
illustrated above: every cluster, with a Lace name such as base_library , has an associated  
directory, whose name is given a s a string in double quotes, su ch as "  \ library  \ base". This  
file name assumes Windows conventions (names of the form  \ dir1 \ dir2 \ …), but this is  
j u s t  f o r  t h e  s a k e  o f  t h e  e x a m p l e .  Y o u  c a n  o b t a i n  t h e  c o r r e s p o n d ing Unix names by  
replacing the back slash characters \ by slashes /.
Although by default you may use the hierarchical structure of d irectories to represent cluster  
nesting, Lace has a notion of subcluster through which you can define the logical structure  
of the cluster hierarchy, regardless of the clusters’ physical locations in the file system.
The directories listed in the cluster  clause may contain files of all kinds. To  
determine the universe, the system assembly process will need t o know which ones of  
these files may contain class te xts. A simple convention is to require the text of any class  
of name NAME  to be stored in a file of name name   e (lower case). Let us assume this  
convention (which can easily be extended for more flexibility) for the rest of this  
discussion. Then the universe is the set of files having names of the form name   e in the  
list of directories appearing in the cluster  clause. 
The root clause of Lace serves to designate the root class of the syste m. Here the root  
class is GRAPHICS  and, as indicated in parent heses, it appears in the painting_a pplication
cluster. If there is only one class called GRAPHICS  in the universe, it is not necessary to  
specify the cluster. 
Assume that you start a language processing tool, for example a  compiler, to process  
the system described by the abov e Ace. Assume further that none  of the classes in the  
system has been compiled yet. The  compiler finds the text of th e root class, GRAPHICS , 
in the file graphics   e of the cluster painting_application ; that file appears in the directory  Root directory
Subdirectory
Non-directory
filed3 d2 d1
d4
f3A directory 
structure
THE STATIC STRUCTURE: CLASSES  §7.9 200
 \ user \ application . By analyzing the text of class GRAPHICS , the compiler will find the  
names of the classes needed by GRAPHICS  and will look for files with the corresponding  
  e names in the three cluster directories. It will then apply the  same search to the classes  
needed by these new classes, repeating th e process until it has  located all the classes  
needed directly or indi rectly by the root. 
An important property of this process is that it should be automatic . As a software  
developer, you should not have to  write lists of dependencies b etween modules (known as  
“Make files”), or to indicate in  each file the names of the fil es that will be needed for its  
compilation (through what is know n in C and C++ as “Include dir ectives”). Not only is it  
tedious to have to create and ma intain such dependency informat ion manually; this  
process also raises the possibil ity of errors when the software  evolves. All that the Ace  
requires you to provide is the i nformation that no tool can fin d by itself: the name of the  
root class, and the list of loca tions in the file system where needed classes — what earlier  
was called the class set  of the system — may appear. 
To simplify the work of developers further, a good compiler wil l, when called in a  
directory where no Ace is presen t, construct a template Ace who se cluster  clause includes  
the basic libraries (kernel, fu ndamental data structures and al gorithms, graphics etc.) and  
the current directory, so that yo u will only have to fill in th e name of the system and of its  
root class, avoiding the need to  remember the syntax of Lace. 
The end result of the compilati on process is an executable file , whose name is the  
one given after system in the Ace — painting  in the example. 
The Lace language includes a few other simple constructs, used to control the actions  
of language processing tools, in particular compiler options an d assertion monitoring  
levels. W e will encounter some of them as we explore further O- O techniques. Lace, as  
noted, also supports the notion of logical subcluster, so that you can use it to describe  
complex system structures, inclu ding the notions of subsystem a nd multi-lev el libraries.
Using a system description langu age such as Lace, separate from  the development  
language, allows classes to rema in independent f rom the system or systems in which they  
intervene. Classes are software components, similar to chips in  electronic design; a system  
is one particular assembly of cl asses, similar to a board or a computer made by assembling  
a certain set of chips. 
Printing your name 
Reusable software components are  great, but sometimes all you w ant to do is just a simple  
task, such as printing a string. Y ou may have been wondering ho w to write a “program”  
that will do it. Having introduc ed the notion of system, we can  answer this burning  
question. (Some people tend to b e nervous about the whole appro ach until they see how  
to do this, hen ce this little digression.) 
The following little c lass has a procedure w hich will print a s tring: 
§7.9   PUTTING EVERYTHING TOGETHER 201
class SIMPLE  creation
make
feature
make
-- Print an example string.
do
print_line ("Hello Sarah !")
end
end
The procedure print_line  c a n  t a k e  a n  a r g u m e n t  o f  a n y  t y p e ;  i t  p r i n t s  a  d e f a u l t  
representation of the correspond ing object, here a string, on a  line. Also available is print
which does not go to a new line a fter printing. Both procedures  are available to all classes,  
coming from a universal ancestor, GENERAL , as explained in a  later chapter.
To obtain a system that will prin t the given string, do the fol lowing: 
E1 • Put the above class text in a file called simple   e in some directory. 
E2 • Start the compiler.
E3 • If you have not provided an Ace, you will be prompted to edit a  n e w  o n e ,  
automatically generated from a te mplate; just fill in the name of the root class,  
SIMPLE , the name of the system — say my_ first — and the cluster directory.
E4 • Exit from the editor; the compile r will assemble the system and  p r o d u c e  a n  
executable file called my_ first. 
E5 • Execute the result. On platforms  such as Unix with a notion of command-line  
execution a command will have been generated, of name my_ first; simply type that  
name. On graphical platforms such as Windows and OS/2, a new ic on will have  
appeared, labeled my_ first; just double-click on that icon.
The result of the last step will  be, as desired, to print on yo ur console the message
Structure and order: the sof tware developer as arsonist 
We now have an overall picture o f the software construction pro cess in the object-oriented  
method — assembling clas ses into systems. We also know how to r econstruct the chain of  
events that will lead to the exe cution of a particular operatio n. Assume this operation is
[A]
x  g (u, v, …)
appearing in the text of a routine r of a class C, of which we assume x to be an attribute.  
How does it ever get executed? Le t us recapitulate. You must ha ve included C in a system,  
and assembled that system with t he help of an appropriate Ace. Then you must have  
started an execution of that sys tem by creating an instance of its root class. The root’s  Hello Sarah !On GENERAL see 
“Universal classes”, page 580 .
THE STATIC STRUCTURE: CLASSES  §7.9 202
creation procedure must have exe cuted one or more operations wh ich, directly or  
indirectly, caused the creation of an instance C_OBJ  of C, and the execution of a call of  
the form 
[B]
a  r (…)
where a was at the time attached to C_OBJ . Then the call shown as [A] will execute g, 
with the arguments given, using a s target the obj ect attached t o the x field of C_OBJ . 
So by now we know (as well we should) how to find out the exact  sequence of events  
that will occur during the execution of a system. But this assu mes we look at the entire  
system. In general we will not be able, just by examining the t ext of a given class, to  
determine the order in which clients will call its various rout ines. The only ordering  
property that is immediately visible is the order in which a gi ven routine executes the  
instructions o f its body. 
Even at the system level, the st ructure is so de centralized tha t the task of predicting  
the precise order of operations,  although possible in principle , is often difficult. More  
importantly, it is usually not very interesting. Remember that we treat the root class as a  
s o m e w h a t  s u p e r f i c i a l  p r o p e r t y  o f  t h e  s y s t e m  —  a  p a r t i c u l a r  c h o i ce, made late in the  
development process, of how we are going to combine a set of in dividual components and  
schedule their available operations. 
This downplaying of ordering con straints is part  of object tech nology’s constant  
push for decentralization in sys tem architectures. The emphasis  is not on “the” execution  
of “the” program (as in Pascal o r C programming a nd many design  methods) but on the  
services provided by a set of classes through their features. T he order  in which the services  
will be exercised, during the ex ecution of a particular system built from these classes, is a  
secondary property. 
The method goes in fact fur ther by prescribing that even if you know  the order of  
execution you should not base any serious system design decisio n on it. The reason for  
this rule was explored in earlie r chapters: it i s a consequence  of the concern for  
extendibility and reusability. It is much easier to add or chan ge services in a decentralized  
structure than to change the order of operations if that order was one of the properties used  
to build the architecture. This reluctance of the object-orient ed method to consider the  
order of operations as a fundamen tal property of software syste m s  —  w h a t  a n  e a r l i e r  
discussion called the shopping list approach  — is one of its ma jor differences with most  
of the other popular so ftware design methods.
These observations once again evoke the picture of the software  developer as  
firework expert or perhaps arsoni st. He prepares a giant confla gration, maki ng sure that  
all the needed components are re ady for assembly and all the ne eded connections present.  
He then lights up a match and watc hes the blaze. But if the str ucture has been properly set  
up and every component is proper ly attached to its neighbors, t here is no need to follow  
or even try to predict the exact  sequence of lightings; it suff ices to know that every part  
that must burn will burn, and wi ll not do so before its time ha s come. See “Premature 
ordering”, page 110.
§7.10   DISCUSSION 203
7.10  DISCUSSION
As a conclusion to this chapter,  let us consider the rationale behind some of the decisions  
made in the design of the method  and notation, exploring along the way a few alternative  
paths. Similar discussion sections will appear at the end of mo st chapters introducing new  
constructs; their aim is to spur  the reader’s own thinking by p resenting a candid,  
uncensored view of a f ew delicate issues.
Form of declarations 
To hone our critical skills on something that is not too life-t hreatening, let us start with a  
syntactical property. One point worth noting is the notation fo r feature declarations. For  
routines, there are none of the keywords procedure  or function  such as they appear in  
many languages; the form of a fea ture determines whether it is an attribute, a procedure or  
a function. The beginning of a f eature declarati on is just the feature name, say 
f …
W h e n  y o u  h a v e  r e a d  t h i s ,  y o u  m u s t  s t i l l  k e e p  a l l  p o s s i b i l i t i e s  open. If a list of  
arguments comes next, as in 
g (a1: A; b1: B; …) …
then you know g is a routine; it could still be either a function or a procedur e. Next a type  
may come: 
f: T …
g (a1: A; b1: B; …): T …
In the first example, f can still be either an attribut e or a function without argumen ts; 
in the second, however, the suspense stops, as g can only be a function. Coming back to f, 
the ambiguity will be resol ved by what appears after T: if nothing, f is an attribute, as in
my_ file: FILE
But if an is is present, followed by a routine body ( do or the variants once  an d 
external  to be seen later), as in 
f: T
-- …
do … end
f is a function. Yet another variant is: 
f: T is some_value
which defines f as a constant attribute  of value some_value . 
The syntax is designed to allow easy recognition of the various  kinds of feature,  
while emphasizing the fundamental similarities. The very notion  o f  f e a t u r e ,  c o v e r i n g  
routines as well as attributes, is in line with the Uniform Acc ess principle — the goal of  
providing clients with abstract facilities and downplaying thei r representation differences.  
The similarity between feature d eclarations follows from the sa me ideas. Chapter 18 dis-
cusses constant attributes.
THE STATIC STRUCTURE: CLASSES  §7.10 204
Attributes vs. functions 
Let us explore further the conse quences of the Uniform Access p rinciple and of grouping  
attributes and routi nes under a common heading — features.
The principle stated that client s of a module should be able to  u s e  a n y  s e r v i c e  
provided by the module in a unifo rm way, regardless of how the service is implemented  
— through storage or through com putation. Here the services are  the features of the class;  
what is meaningful for clients i s the availability of certain f eatures and their properties.  
Whether a given feature is imple mented by storing appropriate d ata or by computing the  
result on demand is, for most purposes, irrelevant. 
Assume for example a class PERSON  containing a feature age of type INTEGER , 
with no arguments. If the author  of a client cla ss writes the e xpression 
Isabelle   age
the only important i nformation is that age will return an integer, the age field of an  
instance of PERSON  attached, at run-time, to the entity Isabelle . Internally, age may be  
either an attribute, stored with each object, or a function, co mputed by subtracting the  
value of a birth_date  attribute from the current year . But the author of the client class does  
not need to know which one of the se solutions was chosen by the  author of PERSON . 
The notation for accessing  an attribute, then, i s the same as for calling a routine; and  
the notations for declaring  these two kinds of feature are as similar as conceptually poss ible. 
Then if the author of a supplier  class reverses an implementati on decision (implementing  
as a function a feature that was  initially an attribute, or con versely), clients will not be  
affected; they will require neith er change, possibly not even r ecompilation.
The contrast between the supplier’s and client’s view of the fe atures of a module was  
apparent in the two figures whic h helped introduce the notion o f feature earlier in this  
chapter. The first used as its primary criterion the distinctio n between routines and  
attributes, reflecting the internal (implementation) view, whic h is also the supplier’s view.  
In the second figure, the primar y distinction wa s between comma nds and queries, the  
latter further subdivided into q ueries with and without argumen ts. This is the external view  
— the client’s view. 
The decision to treat attributes  and functions without argument s as equivalent for  
clients has two important consequences, which later chapters wi ll develop:
•The first consequence affects so ftware documentation. The stand ard client  
documentation for a class, known as the short form  of the class, will be devised so  
as not to reveal whether a given feature is an attribute or a f unction (in cases for  
which it could be either).
•The second consequence affects i nheritance, the m ajor technique  for adapting  
software components to new circu mstances without  disrupting exi sting software. If  
a certain class introduces a feat ure as a function without argu ments, descendant  
classes will be permitted to redefine  the feature as an attri bute, substituting memory  
for computation. “Uniform Access”, 
page 55 ; see also , in 
the present chapter , 
“Uniform access”, page 175 .
The figures 
appeared on pages 174 and 175 .
“Using assertions 
for documentation: the short form of a class”, page 389 .
“Redeclaring a func-
tion into an attribute”,page 491.
§7.10   DISCUSSION 205
Exporting attributes 
A consequence of the preceding o bservations is that classes may  export attributes. For  
example, class POINT , in the cartesian implementatio n introduced earlier, has attri butes x
and y, and exports them to clients in  exactly the same way as the fu nctions rho and theta . 
To obtain the value of an attrib ute for a certain object, you s imply use feature call notation,  
as in my_ point   x or my_ point   theta .
This ability to export attributes  differs from th e conventions that exist in many O-O  
languages. Typical of these is S malltalk, where only routines ( called “methods”) may be  
exported by a class; attributes ( “instance variables”) are not directly accessible to clients. 
A consequence of the S malltalk approach is that if you want to obtain the effect of  
exporting an attribute  you have to write a small exported funct ion whose only purpose is  
to return the attribut e’s value. So in the POINT  example we could call the attributes  
internal_  x and internal_  y, and write the class as follows  (using the notation of this bo ok 
rather than the exact Smalltalk syntax, and calling the functio ns abscissa  and ordinate
rather than x and y to avoid any confusion): 
class POINT feature  -- Public features:
abscissa : REAL
-- Horizontal coordinate
do Result := internal_  x end
ordinate : REAL
-- Vertical coordinate
do Result := internal_  y end
… Other features as in the earlier version …
feature {NONE } -- Features inaccessible to clients: 
internal_  x, internal_  y: REAL
end
This approach has two drawbacks: 
• It forces authors of supplier c lasses to write many small func tions such as abscissa  
and ordinate . Although in practice such functions will be short (since the syntax of  
Smalltalk is terse, and makes it possible to give the same name  to an attribute and a  
function, avoiding the need to de vise special attribute names s uch as internal_  x and 
internal_  y), writing them is still a waste of effort on the part of the c lass author, and  
reading them is a us eless distraction for the class reader. 
• The method entails a significan t performance penalty: every ac cess to a field of an  
object now requires a routine cal l. No wonder object technology  has developed a  
reputation for inefficiency in s ome circles. (It is possible to  develop an optimizing  
compiler which will expand calls to abscissa -style functions in-li ne, but then what is  
the role of these functions?)
The technique discussed in this chapter seems preferable. It av oids the need for  
cluttering class texts with nume rous little extra functions, an d instead lets the class  
designers export attributes as n eeded. Contrary to what a super ficial examination might  The class text was on 
page 176.
THE STATIC STRUCTURE: CLASSES  §7.10 206
suggest, this policy does not vio late information hiding; it is  in fact a direct  
implementation of this  principle and of the associated principl e of Uniform Access. To  
satisfy these requirements it suffices to make sure that attrib utes, as seen by clients, are  
indistinguishable from  functions without arg uments, and that th ey have the same  
properties for inheritance and class documentation. 
This technique reconciles the goals of Uniform Access (essentia l for the clients), ease  
of writing class texts (essential for the suppliers), and effic iency (essential for everyone). 
The client’s privileges on an attribute
Exporting an attribute, using th e techniques just discussed, al lows clients to access the  
value of an attribute for a certain object, as in my_ point   x It does not allow clients to  
modify that value. You may not a ssign to an attri bute; the assi gnment
my_ point   x := 3.7
is syntactically illegal. Th e syntax rule is simple: a  attrib , if attrib  is an attribute (or for  
that matter a function) is an expression, not an entity, so you  cannot assign to it, any more  
than you can assign to the expression a + b .
To make attrib  accessible in modification mode , you must write and export an  
appropriate procedure, of the form: 
set_attrib (v: G)
-- Set to v the value of attrib .
do
attrib := v
end
Instead of this convention, one c ould imagine a syntax for spec ifying access rights,  
such as
class C feature [AM]
…
feature  [A] {D, E}
…
where A would mean access and M modification. (Specifying A could be optional: if you  
export something you must at least allow clients to access it i n read mode). This would  
avoid the frequent n eed for writing proc edures similar to set_attrib .
Besides not justifying the extra  language complication, this so lution is not flexible  
enough. In many cases, you will want to export specific  ways of modifying an attribute.  
For example, the following class  exports a counter, and the rig ht to modify it not arbitrarily  
but only by increments of +1 or –1: Warning : illegal 
construct — for illustration only .
Warning : not a 
retained notation . 
For discussion only .
§7.10   DISCUSSION 207
class COUNTING  feature
counter : INTEGER
increment
-- Increment counter
do
count := count + 1
end
decrement
-- Decrement counter
do
count := count — 1
end
end
Similarly, class POINT  as developed in this chapter do es not let its clients set the x
and y of a point directly; clients can change the values of these att ributes, but only by going  
through the specific m echanisms that have be en exported for tha t purpose, procedures  
translate and scale .
When we study assertions we will  s e e  a n o t h e r  f u n d a m e n t a l  r e a s o n  why it is  
inappropriate to let clients perform direct assignments of the a  attrib := some_value  form:  
not all some_value  are acceptable. You may d efine a procedure such as
set_polygon_size (new_size : INTEGER )
-- Set the number of p olygon vertices to new_size .
require
new_size >= 3
do
size := new_size
end
requiring any actual argument to b e  3  o r  m o r e .  D i r e c t  a s s i g n m e n ts would make it  
impossible to enforce this constr aint; a call could then produc e an incorrect object.
These considerations show that a class writer must have at his disposal, for each  
attribute, five possible level s for granting acc ess privileges to clients:
Level 0 is total  protection: clients have no way of accessing t he attribute. At level 1  
and above, you make the attribut e available for access, but at level 1 you do not grant any  
modification right. At level 2, you let clients modify the attr ibute through specific  
algorithms. At level 3, you let them set the value, but only if  it satisfies certa in constraints,  
as in the polygon size  example. Level 4 rem oves the constraints .Possible client 
privileges on 
an attributeNo access Read only Restricted write Protected write
(0) (1) (2) (3)Unrestricted  
(4)
THE STATIC STRUCTURE: CLASSES  §7.10 208
The solution described in this ch apter is a consequence of this  analysis. Exporting an  
attribute only gives clients acc ess permission (level 1); permi ssion to modify is specified  
by writing and exporting appropr iate procedures, which give cli ents restricted rights as in  
the counter and point examples ( level 2), direct modification r ights under some constraints  
(3) or unrestricted rights (4).
This solution is an improvement o ver the ones commonly found in  O-O languages:
• In Smalltalk, as noted, you hav e to write special encapsulatio n functions, such as the  
earlier abscissa  and ordinate , just to let clients access an attribute at level 1; this may  
mean both extra work for the dev eloper and a performance overhe ad. Here there is  
no need to write routines for attribute access; only for attrib ute modifications (levels  
2 and above) do we require writing a routine, since it is conce ptually necessary for  
the reasons just seen.
• C++ and Java are the other extr eme: if you export an attribute  then it is up for grabs  
at level 4: clients can set it through direct assignments in th e my_ point   x := 3.7
style as well as access its valu e. The only way to achieve leve l 2 (not 3 in the  
absence of an O-O assertion mech anism in these languages) is to  hide the attribute  
altogether, and then write exported routines, both procedures f or modification  
(levels 2 or 4) and functions fo r access (level 1). But then yo u get the same  
behavior as with the Smalltalk approach.
T h i s  d i s c u s s i o n  o f  a  f a i r l y  s p e c ific language trait illustrates  t w o  o f  t h e  g e n e r a l  
principles of language design: do not needlessly bother the pro grammer; know when to  
stop introducing new la nguage constructs at  the point of dimini shing returns. 
Optimizing calls
At levels 2 and 3 of the preceding discussion, the use of expli cit procedure calls such as  
my_ polygon   set_size (5) to change an attribute value is inevitable. At level 4, one cou ld 
fear the effect on performance of using the set_attrib -style. The compiler, however, can  
generate the same code for my_ point   set_ x (3.7) as it would for my_ point   x := 3.7 had this  
last phrasing been legal.
ISE’s compiler achieves this through a general in-line expansio n mechanism, which  
eliminates certain routine calls  by inserting the routine body directly, with appropriate  
argument substitutions, into the caller’s code.
In-line expansion is i ndeed one of the trans formations that we may expect from an  
optimizing compiler for an objec t-oriented language. The modula r style of development  
fostered by object tec hnology produces many small routines. It would be unacceptable for  
developers to have to worry about  the effect of the correspondi ng calls on performance.  
They should just use the clearest  and most robust architecture they can devise, according  
to the modularity principles stu died in this book, and expect t he compiler to get rid of any  
calls which may be re levant to the design but not necessary for  the execution.
§7.10   DISCUSSION 209
In some programming languages, no tably Ada and C+ +, developers specify what  
routines they want expanded in-li ne. I find it preferable to tr eat this task as an automatic  
optimization, for several reasons:
• It is not always correct to expand a call in-line; since the c ompiler must, for  
correctness, check that the opti mization applies, it may just a s well spare developers  
the trouble of requestin g it in the first place.
• With changes in the software, i n particular through inheritanc e, a routine which was  
inlinable may become non-inlinable. A softw are tool is better t han a human at  
detecting such cases.
• On a large system, compilers will always be more effective. Th ey are better equipped  
to apply the proper heuristics —  based on routine size and numb er of calls — to  
decide what routines should be i nlined. This is again especiall y critical as the  
software changes; we cannot expec t a human to track the evoluti on of every piece.
• Software developers have better  things to do wi th their time.
The modern software engineering view is that such tedious, auto matable and delicate  
optimizations should b e handled by software  tools, not people. The policy of leaving them  
to the responsibility of develop ers is one of the principal cri ticisms that have been leveled  
a t  C + +  a n d  A d a .  W e  w i l l  e n c o u n t e r this debate ag ain in studying  t w o  o t h e r  k e y  
mechanisms of object technology: memory management, and dynamic  binding.
The architectural role  of selective exports
The selective export facility is not just a convenience; it is essential to object-oriented  
architecture. It enables a set of  conceptually related classes to make some of their features  
accessible to each other without releasing them to the rest of the world, that is to say,  
without violating the rule of In formation Hiding. It also helps  us understand a frequently  
debated issue: whether we need m odules above the level of class es.
Without selective exports, the on ly solution (other than renoun cing Information  
Hiding altogether) would be to i ntroduce a new m odular structur e to group classes. Such  
super-modules, similar to Ada’s or Java’s packages, would have their own rules for hiding  
and exporting. By adding a compl etely new and partly incompatib le module level to the  
elegant framework defined by clas ses, they would yield a bigger , hard-to-learn language.
Rather than using a separate package construct, the super-modul es could themselves  
be classes; this is the approach  of Simula, which permits class  nesting. It too brings its  
share of extra complexity , for no clear benefit.
We have seen that the simplicity  of object technology relies fo r a good part on the  
use of a single modular concept,  the class; its support for reu sability relies  on our ability  
to extract a class from its context, keeping only its logical d ependencies. With a super-
module concept we run the risk of losing these advantages. In p articular, if a class belongs  
to a package or an enclosing clas s we will not be able to reuse  it by itself; if we want to  
include it in another super-modul e we will need either to impor t the entire original super-
module, or to make a copy of the class — not an attractive form  of reuse.“Garbage collector 
requirements”, page 305, and “The C++ 
approach to binding”,page 513 .
THE STATIC STRUCTURE: CLASSES  §7.10 210
The need will remain to group cl asses in structured collections . This will be  
addressed in a later chapter through the notion of cluster . But the cluster is a management  
and organizational notion; making  it a language construct would  jeopardize th e simplicity  
of the object-oriented  approach and its s upport for modularity.
When we want to let a group of c lasses grant each other special  privileges, we do not  
need a super-module; selective e xports, a modest extension to b asic information hiding,  
provide a straightforward solutio n, allowing classes to retain their status of free-standing  
software components. This is, in  my opinion, a typical case of how a simple, low-tech idea  
can outperform the heavy artill ery of a “powerful” mechanism.
Listing imports 
Each class lists, in the headers of its feature  clauses, the features t hat it makes available  
to others. Why not, one might as k, also list fea tures obtained from other classes? The  
encapsulation langu age Modula-2 indeed provides an import  clause.
In a typed approach to O-O softw are construction, however, such  a clause would not  
serve any purpose other than doc umentation. To use a feature f from another class C, you 
must be a client or (through inh eritance) a descendant of that class. In the first case, the  
only one seen so far, this means that every use of f is of the form 
a  f
where, since our n otation is typed, a must have been declared: 
a: C
showing without any ambiguity that f came from the C. In the descendant case the  
information will be available fr om the official class documenta tion, its “flat-short form”.
So there is no need to bother de velopers with import clauses.
There is a need, however , to help developers with import  documentation. A good  
graphical development environmen t should include mechanisms tha t enable you, by  
clicking a button, to see the s uppliers and ancestors of a clas s, and follow the import chain  
further by exploring their ow n suppliers and ancestors.
Denoting the result of a function 
An interesting language issue broached earlier in this chapter is how to denote function  
results. It is worth exploring f urther although it applies to n on-O-O languages as well. 
Consider a function — a value-returning routine. Since the purp ose of any call to the  
function is to compute a certain  result and return it to the ca ller, the question arises of how  
to denote that result in the tex t of the function itself, in pa rticular in the instructions which  
initialize and update the result. 
The convention introduced in thi s chapter uses a special entity , Result , treated as a  
local entity and initialized to the appropriate default value; the result retur ned by a call is  Chapter 28 .
“The flat-short 
form”, page 543.
See chapter 36.
§7.10   DISCUSSION 211
the final value of Result . Because of the initialization rules, that value is always def ined 
even if the routine body contains no assignment to Result . For example, the function 
f: INTEGER
do
if some_condition then Result := 10 end
end
will return the value 10 if some_condition  is satisfied at the time of the call, and 0 (the  
default initialization value for INTEGER ) otherwise. 
The technique using Result  originated, as far as I know, with the notation developed  
in this book. (Since the first edition it has found its way int o at least one other language,  
Borland’s Delphi.) Note that it w ould not work in a language al lowing functions to be  
declared within functions, as the name Result  would then be ambiguous. Among the  
techniques used in earlier la nguages, the most common are: 
A • Explicit return instructions ( C, C++/Java, Ada, Modula-2). 
B • Treating the function name as a variable (Fortran, Algol 60, S imula, Algol 68,  
Pascal). 
Convention A relies on an instruction of the form return  e whose execution  
terminates the current execution  of the enclosin g function, ret urning e as the result. This  
technique has the benefit of cla rity, since it makes the return ed value stand out clearly from  
the function text. But it suff ers from several drawbacks: 
A1 • Often, the result must in practice be obtained through some co mputation: an  
initialization and a few subseque nt updates. This means you mus t introduce and  
declare an extraneous variable (an entity in the terminology of  this chapter) just for  
the purpose of holding the inter mediate results of the computat ion. 
A2 • The technique tends to promote multiple-exit modules, which ar e contrary to the  
principles of good program structuring. 
A3 • The language definition must specify what will happen if the l ast instruction  
executed by a call to the function is not a return . The Ada result in this case is to  
raise … a run-time exception! (This may be viewed as the ultimate in b uck-
passing, the language designers having transferred the responsi bility for language  
design issues not just to software developers, but finally to t he end-users of the  
programs developed in the language!) 
Note that it is possible to solve the last two problems by trea ting return  not as an  
instruction, but as a syntactic clause which would be a require d part of any function text: 
function  name (arguments ): TYPE
do
…
return
expression
end
THE STATIC STRUCTURE: CLASSES  §7.10 212
This solution remains compatible in spirit with the idea of a return  instruction while  
addressing its most serious defi ciencies. No co mmon language, h owever, uses it, and of  
course it still leaves problem A 1 open. 
The second common technique, B, t reats a function’s name as a v ariable within the  
text of the function. The value returned by a call is the final  value of that variable. (This  
avoids introducing a special variable as mentioned under  A1.) 
The above three problems do not ar ise in this approach. But it raises other  difficulties  
because the same name now ambiguou sly denotes both a function a nd a variable. This is  
particularly confusing in a langu age allowing recursion, where a function body may use  
the function’s name to denote a recursive call. Because an occu rrence of the function’s  
name now has two possible meanings, the language must define pr ecise conventions as to  
when it denotes the variable, a nd when it denotes a function ca ll. Usually, in the body of  
a function f, an occurrence of the name f as the target of an assignment (or other contexts  
implying a value to be modified)  denotes the variable, as in 
f := x
and an occurrence of f  in an expression (or other contexts implying a value to be acce ssed) 
denotes a recursive fu nction call, as in 
x := f
which is valid only if f  has no arguments. But then a n assignment of the form 
f := f + 1
will be either rejected by the compiler (if  f has arguments) or, worse, understood as  
containing a recursive call who se result gets assigned to f (the variable). The latter  
interpretation is almost certainl y not what the developer had i n mind: if f h a d  b e e n  a  
normal variable, the instruction would simply have increased it s value by one. Here the  
assignment will usually cause a non-terminating computation. To  obtain the desired effect,  
the developer will have to intro duce an extra variable; this ta kes us back to problem  A1
above and defeats the whole pu rpose of using technique B. 
The convention introduced in this chapter, relying on the prede fined entity Result , 
avoids the drawbacks of both A an d B. An extra advantage, in a language providing for  
default initialization of all entities including Result , is that it simplifies the writing of  
functions: if, as often happens, you want the result to be the default value except in specific  
cases, you can use the scheme
do
if some_condition then Result := “Some specific value” end
end
without worrying about an else clause. The language definiti on must, of co urse, specify  
all default values in an unambiguous and platform-independent w ay; the next chapter will  
introduce such convent ions for our notation.
A final benefit of the Result  convention will become clear when we study Design by  
C o n t r a c t :  w e  c a n  u s e  Result t o  e x p r e s s  a n  a b s t r a c t  p r o p e rty of a function’s result,  Page 233.
Chapter 11 .
§7.11   KEY CONCEPTS INTR ODUCED IN THIS CHAPTER 213
independent of its implementatio n, in the routine’s postconditi on. None of the other  
conventions would allow us to write
prefix "|_": INTEGER
-- Integer part
do
… Implementation omitted …
ensure
no_greater: Result <= Current
smallest_possible: Result + 1 > Current
end
The postcondition is the ensure clause, stating two properties of the result: that it is  
no greater than the value to whi ch the function is applied; and  that adding 1 to it yields a  
result greater than that value.
Complement: a precise definition of entities 
It will be useful, while we are considering notational problems , to clarify a notion that has  
repeatedly been used above, but not yet defined precisely: enti ties. Rather than a critical  
concept of object technology, th is is simply a technical notion , generalizing the traditional  
notion of variable; we ne ed a precise definition.
Entities as used in this book c over names that denote run-time values, themselves  
attached to possible objects. We  have now seen all three possib le case s:
Case E 2 indicates that  the entity Result  is treated, for all purposes, as a local entity;  
other local entities a re introduced in the local  clause. Result and other local entities of a  
routine are initialized anew eac h time the routine is called. 
All entities except formal arguments (E 3) are writable, that is to say may appear as  
the target x of an assignment x := some_value .
7.11  KEY CONCEPTS INTRODUCED IN THIS CHAPTER 
• The fundamental concept of object technology is the notion of class. A class is an  
abstract data type, partia lly or fully implemented. 
• A class may hav e instances, called objects. 
• Do not confuse objects (dynamic items) with classes (the stati c description of the  
properties common to a set  of run-time objects). 
• In a consistent approach to obj ect technology, every object is  an instance of a class. Definition: entity
An entity is one of the following:
E1 • An attribute of a class. 
E2 • A routine’s local ent ity, including the predefined entity Result  for a function.
E3 • A formal argument of a routine.
THE STATIC STRUCTURE: CLASSES  §7.11 214
• The class serves as both a module and a type. The originality and power of the O-O  
model come in part from the fusion of these two notions. 
• A class is characterized by feat ures, including attributes (re presenting fields of the  
instances of the class) and rout ines (representing computations  on these instances).  
A routine may be a function, which returns a result, or a proce dure, which does not. 
• The basic mechanism of object-o riented computation is feature call. A feature call  
applies a feature of a  class to an instance of that class, poss ibly with arguments. 
• Feature call uses either dot no tation (for identifier features ) or operator notation,  
prefix or infix (for operator features). 
• Every operation is relative to a “current instance” of a class . 
• For clients of a class (other c l a s s e s  w h i c h  u s e  i t s  f e a t u r e s ) ,  a n  a t t r i b u t e  i s  
indistinguishable from a functio n without arguments, in accorda nce with the  
Uniform Access principle. 
• An executable assembly of classes is called a system. A system  contains a root class  
and all the classes which the ro ot needs directly or indirectly  (through the client and  
inheritance relations). To execu te the system is to create an i nstance of the root class  
and to call a creation pro cedure on that instance. 
• Systems should have a decentralized architecture. Ordering rel ations between the  
operations are inessen tial to the design. 
• A small system description langu age, Lace, makes it possible t o specify how a  
system should be assembled. A Lace specification, or Ace, indic ates the root class  
and the set of directories where  the system’s cl usters reside. 
• The system assembly process sho uld be automatic , with no need for Make files or  
Include directives. 
• The Information Hiding mechanis m needs flexibility: besides be ing hidden or  
generally available, a feature m ay need to be exported to some clients only; and an  
attribute may need to be exporte d for access only, access and r estricted modification,  
or full modification.
• Exporting an attribute gives clients the right to access it. M odifying it requires  
calling the appropriat e exported procedure.
• Selective exports are necessary to enable groups of closely re lated classes to gain  
special access to each other’s features.
• There is no need for a super-mo dule construct above classes. C lasses should remain  
independent soft ware components.
• The modular style promoted by o bject-oriented development lead s to many small  
routines. Inlining, a compiler optimization, removes any potent ial efficiency  
consequence. Detecting inlinable  calls should be the responsibi lity of the compiler,  
not software developers.
§7.12   BIBLIOGRAPHICAL NOTES 215
7.12  BIBLIOGRAPHICAL NOTES 
The notion of class comes from th e Simula 67 language; see the bibliographical references  
of the corresponding chapter. A Simula class is both a module a nd a type, although this  
p r o p e r t y  w a s  n o t  e m p h a s i z e d  i n  t h e  S i m u l a  l i t e r a t u r e ,  a n d  w a s  d ropped by some  
successors of Simula.
The Single Target principle may be viewed as a software equival ent of a technique  
that is well known in mathematical logic and theoretical comput ing science: currying . To 
curry a two-argument function f  is to replace it by a one-argument function g yielding a  
one-argument function as a resul t, such that for any applicable  x and y: 
(g (x)) (y) = f (x, y)
To curry a function, in other words, is to specialize it on its  first argument. This is  
similar to the transformation de scribed in this chapter to repl ace a traditional two-
argument routine rotate , called under the form 
rotate (some_point , some_angle )
by a one-argument function with a target, called under the form  
some_point   rotate (some_angle )
[M 1990] describes currying and some of i ts applications to computing sc ience, in  
particular the formal study of p rogramming language syntax and semantics. We will  
encounter currying again in the discussion of graphical user in terfaces.
A few language designs have used the concept of object as a sof tware construct  
rather than just a run-time noti on as described in this chapter . In such appr oaches, meant  
for exploratory programming, ther e may be no need for a notion of class. The most notable  
representative of this school of  thought is the Self language [Chambers 1991] , which uses  
“prototypes” rathe r than classes. 
The detail of the conventions fo r infix and prefix operators, i n particular the  
precedence table, is given in [M 1992] .
James McKim brought to my attention the final argument for the Result  convention  
(its use for pos tconditions).Chapter 35 , bibliog-
raphy on page 1138 .
Chapter 32 (discus-
sion on the CD).
THE STATIC STRUCTURE: CLASSES  §E7.1 216
EXERCISES
E7.1  Clarifying the terminology 
[This exercise requires two well-sharpened  pencils, one blue and the other red.]
Study the textbook extract used earlier in this chapter to illu strate the confusion between  
objects and classes; for each us e of the word “object”, “thing”  or “user” in that extract,  
underline the word in blue if you think that the authors r eally meant object; underline t he 
word in red if you think that they really meant class. 
E7.2  POINT  as an abstract data type
Write an abstract data type specification for the notion of two -dimensional point, as  
suggested in the informal in troduction of that notion. 
E7.3  Completing POINT  
Complete the text of class POINT  by filling in the missing details and adding a procedure  
rotate  (to rotate a point around the o rigin) as well as any other fea ture that you feel is  
necessary. 
E7.4  Polar coordinates
Write the text of class POINT  so as to use a polar, rather th an cartesian, representation. See “What would 
you think of this?”, page 166 .
Page 176 .
8  
The run-time structure: objects
In the previous chapter we saw th at classes may have instances, called objects. We must  
now turn our attention to these o bjects and, more generally, to  the run-time model of  
object-oriented  computation. 
Where the previous chapters were  mostly concerne d with conceptu al and structural  
issues, the present one will, for the first time in this book, include implementation aspects.  
In particular it will describe how the execution of object-orie nted software uses memory  
— a discussion continued by the study of garbage collection in the next chapter. As  
already noted, one of the benefit s of object technology is to r estore implementation issues  
to their full status; so even if your interest is mostly in ana lysis and design topics you  
should not be afraid of this exc ursion into implementation terr itory. It is impossible to  
understand the method unless you hav e some idea of its influenc e on run-time structures.
The study of object structures in this chapter indeed provides a particularly good  
example of how wrong it is to se parate implementation aspects f rom supposedly higher-
level issues. Throughout the disc ussion, whenever we realize th e need for a new O-O  
technique or mechanism, initially introduced for some implement ation-related purpose,  
the real reason will almost alwa ys turn out to be deeper: we ne ed the facility just as much  
for purely descriptive, abstract  p u r p o s e s .  A  t y p i c a l  e x a m p l e  w i ll be the distinction  
between references and expanded values, which might initially a ppear to be an obscure  
programming technique, but in rea lity provides a general answer  to the question of sharing  
in whole-to-parts relations, an i ssue that figures prominently in many discussions of  
object-oriented analysis.
This contribution of implementation is sometimes hard to accept  for people who have  
been influenced by the view, still prevalent in the software li terature, that all that counts is  
analysis. But it should not be so surprising. To develop softwa re is to develop models. A  
good implementation technique is often a good modeling techniqu e as well; it may be  
applicable, beyond software systems, to systems from various fi elds, natural and artificial. 
More than implementation in the strict sense of the term, then,  the theme of this  
chapter is modeling: how to use object structure s to construct realistic and useful  
operational descriptions o f systems of many kinds. 
THE RUN-TIME STRUCTURE: OBJECTS  §8.1 218
8.1  OBJECTS 
At any time during its execution,  an O-O system will have creat ed a certain number of  
objects. The run-time structure is the organization of these ob jects and of their relations.  
Let us explore its properties. 
What is an object? 
First we should recall what the word “object” means for this di scussion. There is nothing  
vague in this notion; a precise t echnical definition was given in the previous chapter:  
A software system that includes a class C may at various points of its execution  
create (through creation and clon ing operations, whose details appear later in this chapter)  
instances of C; such an instance is a data structure built according to the p attern defined  
by C; for example an instance of the class POINT  introduced in the previous chapter is a  
data structure consisting of two fields, associated with the tw o attributes x and y declared  
in the class. The inst ances of all possible classes constitute the set of objects.
The above definition is the offic ial one for object-oriented so ftware. But “object”  
also has a more general meaning,  coming from everyday language.  Any software system  
is related to some external syst em, which may contain “objects” : points, lines, angles,  
surfaces and solids in a graphics  system: employees, pay checks  and salary scales in a  
payroll system; and so on. Some of the objects created by the s oftware will be in direct  
correspondence with such external objects, as in a payroll syst em that includes a class  
EMPLOYEE , whose run-time instances are computer models of employees. 
This dual use of the word “objec t” has some good consequences, which follow from  
the power of the object-oriented  method as a mod eling tool. Bet ter than any other method,  
object technology highlights and supports the modeling componen t of software  
development. This explains in pa r t  t h e  i m p r e s s i o n of naturalnes s which it exudes, the  
attraction it exerts on so many people, and its early successes  — still among the most  
visible — in such areas as simulation and user interfaces. The method here enjoys the  
direct mapping  property which an earlier chapter described as a principal req uirement of  
good modular design. With software systems considered to be dir ect or indirect models of  
real systems, it is not surprisin g that some classes will be mo dels of extern al object types  
from the problem domai n, so that the softwar e objects (the inst ances of these classes) are  
themselves models of the corre sponding external objects. 
But we should not let ourselves get too carried away by the wor d “object”. As always  
in science and technology, it is a bit risky to borrow words fr om everyday language and  
give them technical meanings. (Th e only discipline which seems to succeed in this delicate  
art is mathematics, which routin ely hijacks such innocent words  as “neighborhood”,  
“variety” or “barrel” and uses t hem with completely unexpected meanings — perhaps the  Definition: object
An object is a run-time instance of some class.The definition 
appeared on page 166. See also the 
Object rule , page 
171. 
“Direct Mapping”, 
page 47 . 
§8.1   OBJECTS 219
reason why no one seems to have any trouble.) The term “object”  is so overloaded with  
everyday meanings that in spite of the benefits just mentioned i t s  u s e  i n  a  t e c h n i c a l  
software sense has caused its sh are of confusion. In particular : 
• As pointed out in the discussio n of direct mapping, not all cl asses correspond to  
object types of the problem doma in. The classes introduced for design and  
implementation have no immediate counterparts in the modeled sy stem. They are  
often among the most important i n practice, and the most diffic ult to find. 
•Some concepts from the problem dom ain may yield classes in the software (and  
objects in the software’s execut ion) even though they would not  necessarily be  
classified as objects in the usual sense of the term if we insi st on a concrete view of  
o b j e c t s .  A  c l a s s  s u c h  a s  STATE  in the discussion of the form-based interactive  
system, or COMMAND  (to be studied in a later chapter in connection with undo-redo  
mechanisms) fall in this category. 
When the word “object” is used i n this book, the context will c learly indicate whether  
the usual meaning or (more commo nly) the technical software mea ning is intended. When  
there is a need to disting uish, one may talk about external objects  and software objects . 
Basic form 
A software object is a  rather simple animal once you know what class it comes from.
Let O be an object. The definition on  the previous page indicates th at it is an instance  
of some class. More precisely, it is a direct instance  of just one  class, say C. 
Because of inheritance, O will then be an instance, direct or not, of other classes, the  
ancestors of C; but that is a matter for a future chapter, and for the presen t discussion we  
only need the notion of direct instance. The word “direct” will  be dropped when there is  
no possible confusion. 
C is called the generating class, or just generator , of O. C is a software text; O is a 
run-time data structur e, produced by one of the object creation  mechanisms studied below. 
Among its features, C has a certain number of attribut es. These attributes entirely  
determine the form of the object: O is simply a collection of components, or fields , one 
for each attribute. 
Consider class POINT  from the previous chapter. Th e class text was of the form: 
class POINT  feature
x, y: REAL
… Routine declarations …
end
The routines have been omitted, and for good rea son: the form o f the corresponding  
objects (the direct instances of the class) is solely determine d by the attributes, although  
the operations  applicable to the objects depen d on the routines. Here the cla ss has two  
attributes, x and y, both of type REAL , so a direct instance of POINT  is an object with two  
fields containing values of that type, for example: See chapter 20 about 
the form-based sys-tem. About the 
notion of command , 
see chapter 21 . 
For the text of class 
POINT  see page 
176.
THE RUN-TIME STRUCTURE: OBJECTS  §8.1 220
Notice the conventions used here and in the rest of this book f or representing an object as  
a set of fields, shown as adjacent rectangles containing the as sociated values. Below the  
object the name of the generating class, here POINT , appears in parentheses and in italics;  
next to each field, also in italics, there appears the name of the corresponding attribute,  
here x and y. Sometimes a name in roman (here P_OBJ) will appear above the object; it  
has no counterpart in the software but identifies the object in  the discussion.
In diagrams used to show the structure of an object-oriented sy stem, or more commonly  
of some part of such a system, c lasses appear as ellipses. This  convention, already used  
in the figures of the previous chapter, avoids any confusion be tween classes and objects.
Simple fields 
Both attributes of class POINT  a r e  o f  t y p e  REAL . As a consequence, each of the  
corresponding fields of a direct instance of POINT  contains a real value. 
This is an example of a field corresponding to an attribute of one of the “basic types”.  
Although these types are formally defined as classes, their ins tances take their values from  
predefined sets implemented effi ciently on computers. They incl ude:
•BOOLEAN , which has exactly two instances , representing the boolean val ues true  
and false.
•CHARACTER , whose instances rep resent characters.
•INTEGER , whose instances re present integers. 
•REAL and DOUBLE , whose instances represent single-precision and double-
precision floating-point numbers. 
Another type which for the time being will be treated as a basi c type, although we  
will later see that it is actuall y  i n  a  d i f f e r e n t  c a t e g o r y ,  i s  STRING , whose instances  
represent finite seque nces of characters. 
For each of the basic types we w ill need the ability to denote the corresponding  
values in software texts and on figures. The conventions are st raightforward: 
•F o r  BOOLEAN , the two instanc es are written True and False . 
• To denote an instance of CHARACTER  you will write a character enclosed in single  
quotes, such as 'A'.3.4
–8.09x
y
(POINT )P_OBJ
See “Graphical con-
ventions”, page 271 .
“STRINGS”, 13.5, 
page 456 .
§8.1   OBJECTS 221
• To denote an instance of STRING , write a sequence of characters in double quotes,  
as in "A STRING ". 
• To denote an instance of INTEGER , write a number in an o rdinary decimal notation  
with an optional sign, as in 34, –675  and +4. 
• You can also write an instance of REAL  or DOUBLE in ordinary notation, as in  
3.5 or –0.05. Use the letter e to introduce a decimal exponent, as in –5.e–2
which denotes the same value  as the preceding example.
A simple notion of book
Here is a class with attribute t ypes taken from the preceding s et: 
class BOOK1  feature
title: STRING
date, page_count : INTEGER
end
A typical instance of class BOOK1  may appear as follows:
Since for the moment we are only interested in the structure of  objects, all the  
features in this class  and the next few examples are attributes  — none are routines.
This means that our ob jects are similar at this stage to the re cords or structure types  
of non-object-oriented languages such as Pa scal and C. But unli ke the situation in these  
languages there is little we can  do with such a class in a good  O-O language: because of  
the information hiding  mechanisms, a client class has no way of  assigning v alues to the  
fields of such objects. In Pascal, or in C with a slightly diff erent syntax, a record type with  
a similar structure wo uld allow a client to include the declara tion and instruction 
b1: BOOK1
…
b1  page_count := 355
which at run time will assign value 355 to the page_count  field of the object attached to  
b1. With classes, however, we shou ld not provide any such facilit y: letting clients change  
object fields as they please wou ld make a mockery of the rule o f information hiding, which  An object 
representing a book"The Red and the Black"
1830title
date
(BOOK1 )341 page_count
Warning : not per-
mitted in the O-O notation ! For dis-
cussion only .
THE RUN-TIME STRUCTURE: OBJECTS  §8.1 222
implies that the author of each class controls the precise set of operations that clients may  
execute on its instances. No such  direct field assignment is po ssible in an O-O context;  
clients will perform field modifications through procedures of the class. Later in this  
chapter we will add to BOOK1  a procedure that gives clie nts the effect of the above  
assignment, if the author of the class indeed wishes to grant t hem such privileges.
We have already seen that C++ and Java actually permit assignme nts of the form  
b1  page_count := 355. But this simply reflects the inherent limits of attempts to i ntegrate  
object technology in a C context.
As the designers of Java themselves write in their book about t he language: “ A 
programmer could still mess up the object by setting [a public ] field , because the field [is]
subject to change” through direct assignment instructions. Too many languages requ ire 
such “don’t do this” warnings. Rather than propose a language a nd then explain at length  
how not to use it, it is desirable to define hand in hand the m ethod and a notation that will  
support it.
In proper O-O development, cla sses without routines, such as BOOK1 , have little  
practical use (except as ancesto rs in an inheritance hierarchy,  where descendants will  
inherit the attributes and provide their own routines; or to re present external objects which  
the O-O part can acces s but not modify, for example sensor data  in a real-time system).  
But they will help us go through the basic concepts; then we wi ll add routines.
Writers
Using the types mentioned above , we can also define a class WRITER  describing a simple  
notion of book author: 
class WRITER  feature
name , real_name : STRING
birth_   year, death_   year: INTEGER
end
References 
Objects whose fields are all of basic types will not take us ve ry far. We need objects with  
fields that represent other objec ts. For example we will want t o represent the property that  
a book has an author — denot ed by an instance of class WRITER . [Arnold 1996],  
page 40 .
See also “If it is 
baroque, fix it”, page 670 .
A “writer” 
object"Stendhal"
"Henri Beyle"name
real_name
1783 birth_year
1842 death_year
(WRITER )
§8.1   OBJECTS 223
A possibility is to int roduce a notion of s ubobject. For exampl e we might think of a  
book object, in a new version BOOK2  of the book class, as having a field author  which is  
itself an object, as infor mally suggested by the following picture:
Such a notion of subobject is indeed useful and we will see, la ter in this chapter, how  
to write the corre sponding classes.
But here it is not exactly what we need. The example represents  two books with the  
same author; we ended up duplicating the au thor information, wh ich now appears as two  
subobjects, one in each instance of BOOK2 . This duplication is p robably not acceptable:
• It wastes memory space. Other e xamples would make this waste e ven more  
unacceptable: imagine for exampl e a set of objects representing  people, each one  
with a subobject representing the country of citizenship, where  the number of people  
represented is large but the n umber of countries is small. 
• Even more importantly , this technique fails to account for the  n e e d  t o  e x p r e s s  
sharing . Regardless of repres entation choices, the author  fields of the two objects  
refer to the same instance of WRITER ; if you update the WRITER  object (for example  
to record an author’s death), you will want the change to affec t all book objects  
associated with the given author. 
Here then is a better picture of  the desired situation, assumin g yet another version of  
the book class, BOOK3 : Two “book” 
objects with 
“writer” subobjects"Life of Rossini"
1823title
date
(BOOK2 )307 page_
"Stendhal"
"Henri Beyle"name
real_name
1783 birth_ year
1842 death_ year
(WRITER )count"The Red and the Black”
1830title
date
(BOOK2 )341 page_
"Stendhal"
"Henri Beyle"name
real_name
1783 birth_ year
1842 death_ year
(WRITER )count
THE RUN-TIME STRUCTURE: OBJECTS  §8.1 224
The author  field of each instance of BOOK3  contains what is known as a reference
to a possible ob ject of type WRITER . It is not difficult to defi ne this notion precisely:
I n  t h e  l a s t  f i g u r e ,  t h e  author  r e f e r e n c e  f i e l d s  o f  t h e  BOOK3  instances are both  
attached to the WRITER  instance, as shown by the arrow s, which are conventionally use d 
on such diagrams to re present a reference attached to an object . The following figure has  
a void reference (perhaps to indi cate an unknown author), showi ng the graphical  
representation of void references: Definition: reference 
A reference is a run-tim e value which is either void or attached . 
If attached, a reference identifies a single object. (It is the n said to be attached  
to that particular object.)"The Charterhouse of Parma"
1839title
date
(BOOK3 )307count"The Red and the Black"
1830title
date
(BOOK3 )341 page_
count
(WRITER )"Stendhal"
"Henri Beyle"name
real_name
1783 birth_ year
1842 death_ yearauthor authorpage_Two “book” 
objects with 
references to the same 
“writer” object
An object with 
a void 
reference field
(“Candide” was 
published anony-mously .)"Candide, or Optimism"
1759title
date
(BOOK3 )120 page_count
author
§8.1   OBJECTS 225
The definition of references make s no mention of implementation  properties. A  
reference, if not void, is a way to identify an o bject; an abst ract name  for the object. This  
is similar to a social security number that uniquely identifies  a person, or an area code that  
identifies a phone ar ea. Nothing implementation-specific or com puter-specific here.
The reference concept of course has a counterpart in computer i mplementations. In  
machine-level pr ogramming it is possible to manipulate addresse s; many programming  
languages offer a notion of point er. The notion of reference is  more abstract. Although a  
reference may end up being represented as an address, it does n ot have to; and even when  
the representation of a reference includes an address, it may i nclude other information.
Another property sets references  apart from addr esses, although  pointers in typed  
languages such as Pascal and Ada  (not C) also enjoy it: as will  be explained below, a  
reference in the approach described here is typed. This means t hat a given reference may  
only become attached to objects of  a specific set of types, det ermined by a de claration in  
the software text. This idea again has counterparts in the non- computer world: a social  
security number is only meant fo r persons, and area codes are o nly meant for phone areas.  
(They may look like normal i ntegers, but you would not add two area codes.)
Object identity 
The notion of reference brings ab out the concept of object iden tity. Every object created  
during the execution of an object-oriented system has a unique identity, independent of the  
object’s value as defined by  its fields. In particular: 
I1 •  Two objects with different ident ities may have i dentical field s. 
I2 •  Conversely , the fields of a certain object may change during t he execution of a  
system; but this does not af fect the object’s identity.
These observations indicate  that a phrase such as “ a denotes the same object as b” 
may be ambiguous: are we talking  about objects with different i dentities but the same  
contents (I 1)? Or about the states of an obj ect before and after some chang e is applied to  
its fields (I 2)? W e will use the second interpretation: a given object may ta ke on new  
values for its constituent field s during an execution, while re maining “the same object”.  
Whenever confusion is p ossible the di scussion will be more expl icit. For case I 1 we may  
talk of equal (but dis tinct) objects; equali ty will be defined more precisely below. 
A point of terminology may have caught your attention. It is no t a mistake to say (as in  
the definition of I 2) that the fields of an object may change. The term “field” as defined  
above denotes one of the values that make up an object, not the  corresponding field  
identifier, which is the name o f one of the attributes of the o bject’s generating class.
For each attribute of the class, for example date in class BOOK3 , the object has a field,  
for example 1832  in the object of the last figure. During execution the attribu tes will  
never change, so each object’s d ivision into fields will remain  the same; but the fields  
themselves may change. For example an instance of BOOK3  will always have four fields,  
corresponding to attributes title, date, page_count , author ; these fields — the four values  
that make up a given object of type BOOK3  — may change. 
The study of how to make objects persistent  will lead us to explo re further properties  
of object identity.“Object identity”, 
page 1052 .
THE RUN-TIME STRUCTURE: OBJECTS  §8.1 226
Declaring references 
Let us see how to extend t he initial book class, BOOK1 , which only had a ttributes of basic  
types, to the new variant BOOK3  which has an attribute representing references to  
p o t e n t i a l  a u t h o r s .  H e r e  i s  t h e  c l a s s  t e x t ,  a g a i n  j u s t  s h o w i n g  t he attributes; the only  
difference is an extra attribu te declaration at the end: 
class BOOK3  feature
title: STRING
date, page_count : INTEGER
author : WRITER -- This is the new attribute.
end
The type used to declare author  is simply the name of the corresponding class:  
WRITER . This will be a general rule: w henever a class is declared in the standard form 
class  C feature  … end
then any entity declared of type C through a declara tion of the form 
x: C
denotes values that are references  to potential objects of type C. The reason for this  
convention is that using referenc es provides more flexibility, and so are appropriate in the  
vast majority of cases. You will  find further examination of th is rule (and of the other  
possible conventions) in the dis cussion section of this chapter . 
Self-reference 
Nothing in the preceding discussi on precludes an object O1 from  containing a reference  
field which (at some point of a sy stem’s execution) is attached  to O1 itself. This kind of  
self-reference can also be indire ct. In the situation pictured b e l o w ,  t h e  o b j e c t  w i t h  
"Almaviva" in its name field is its own landlo rd (direct reference cycle); the object  
"Figaro" loves "Susanna" which l oves "Figaro" (indirect referen ce cycle).  See page 272 .
Direct and 
indirect self-reference
(PERSON1 )"Almaviva" name
landlord
loved_one
(PERSON1 )"Figaro" name
landlord
loved_one
(PERSON1 )"Susanna" name
landlord
loved_one
§8.1   OBJECTS 227
Such cycles in the dynamic struc ture can only exist if the clie nt relation among the  
corresponding classes also has d irect or indirect cycles. In th e above example, the class  
declaration is of the form 
class PERSON1  feature
name : STRING
loved_one , landlord : PERSON1
end
showing a direct cycle ( PERSON1  is a client of PERSON1 ).
The reverse property is not true: the presence of a cycle in th e client relation does not  
imply that the run-tim e structure will have cycles. For example  you may declare a class 
class PERSON2  feature
mother , father : PERSON2
end
which is a client of itself; but if this models the relations b etween people suggested by the  
attributes’ names, there can be no reference cycle in the run-t ime structure, as it would  
imply that a certain person is h is own parent or indirect ances tor. 
A look at the run-time object structure 
From what we have seen so far em erges a first picture of the st ructure of an object-oriented  
system during its execution. 
A possible run-
time object 
structure
"Raphaël"27
"Sarah"3.5
– 62
"Caroline"root
True
'Z'(TYPE1 )
(TYPE4 )
(TYPE2 ) (TYPE1 )(TYPE3 )897
(TYPE5 )
THE RUN-TIME STRUCTURE: OBJECTS  §8.2 228
The system is made of a certain number of objects, with various  fields. Some of these  
fields are values of basic ty pes (integer fields such as 27, character fields such as 'Z ' and 
so on); others are references, some void, others attached to ob jects. Each object is an  
instance of some type, always based on a class and indicated be low the object in the figure.  
Some types may be represented by  just one instance, but more co mmonly there will be  
many instances of a given type; here TYPE1 has two instances, the others only one. An  
object may have reference fields  only; this is the case here wi th the TYPE4  instance, or  
basic fields only, as with the TYPE5  instance. There may be sel f-references: direct, as with  
the top field of the TYPE2 instance, or indirect, as with t he clock-wise reference cycle  
starting from and coming back to the TYPE1 instance at the top.
This kind of structure may look unduly complicated at first — a n impression  
reinforced by the last figure, which is meant to show many of t he available facilities and  
does not purport to model any real  system. The expression “spag hetti bowl” comes to mind. 
But this impression is not just ified. The concern for simplicit y applies to the software  
text and not necessarily to the run-time object structure. The text of a soft ware system  
embodies certain relatio ns (such as “is child of   ”, “loves”, “has as la ndlord”); a particular  
run-time object structure embodie s what we may call an instance  of these relations — how  
the relations hold between membe rs of a certain set of objects.  The relations modeled by  
the software may be simple even if their instances for a partic u l a r  s e t  o f  o b j e c t s  a r e  
complex. Someone who considers the basic idea behind the relati on “loves” fairly simple  
might find the instance of the r elation for a particular group of people — the record of who  
loves whom — hopelessly entangled. 
So it is often impossible to pre vent the run-tim e object struct ures of our O-O systems  
from becoming big (involving larg e numbers of objects) and comp lex (involving many  
references with a convoluted str ucture). A good software develo pment environment will  
provide tools tha t help explore object st ructures for testing a nd debugging.
Such run-time complexity does no t have to affect the static pic ture. We should try to  
keep the software itse lf — the set of classe s and their relatio ns — as simple as possible. 
The observation that simple mode ls can have complex instances i s in part a reflection  
o n  t h e  p o w e r  o f  c o m p u t e r s .  A  s m a l l  s o f t w a r e  t e x t  c a n  d e s c r i b e  h uge computations; a  
simple O-O system can at execution time yield millions of objec ts connected by many  
references. A cardinal goal of software engineering is to keep the software simple even  
when its instances are not. 
8.2  OBJECTS AS A MODELING TOOL 
We can use the techniques introduced so far to improve our unde rstanding of the method’s  
modeling power. It is important in particular two clarify two a spects: the various worlds  
touched by software de velopment; and the relationship of our so ftware to external reality. 
§8.2   OBJECTS AS A MODELING TOOL 229
The four worlds of software development 
From the preceding dis cussions it appears th at when talking abo ut object-oriented  
software development w e should distinguish b etween four separat e worlds: 
• The modeled system, also known as the external system (as oppo sed to the software  
system) and described through obj ect types and their abstract r elations. 
• A particular instantiation of t he external system, made of obj ects between which  
relations may hold. 
• The software system, made of cl asses connected by the relation s of the object-
oriented method (clien t and inheritance). 
• An object structure, as may exi st during the execution of the software system, made  
of software objects connec ted through references. 
The following picture suggests the mappings that exist between these  worlds.  
On both the software level (lower  part of the picture) and the external level (higher  
part) it is important to distingu ish between the general notion s (classes and abstract  
relations, appearing on  the left) and their specific instances (objects and relation instances,  
appearing on the right). This point has already been emphasized  in the previous chapter’s  
discussion of the comparative ro le of classes and objects. It a lso applies to relations: we  
must distinguish between the abstract relation loved_one and the set of loved_one links 
that exist between the elements of a certain set  of objects. 
This distinction is emphasized n either by the st andard mathemat ical definitions of  
relations nor, in the software fi eld, by the theory of relation al databases. Limiting  
ourselves to binary re lations, a relation is defined in both ma thematics and relational  
databases as a set of pairs, all of the form <x, y> where every x is a member a given set TXMolds and 
their instancesMOLD INSTANCE
ABSTRACT
CONCRETEAbstract
Data
TypeModel
Object
Class (Software)
Object
Implements
Is an instance of
THE RUN-TIME STRUCTURE: OBJECTS  §8.2 230
and every y is a member of a given set TY. (In software terminology: all x are of type TX
and all y are of type TY.) Appropriate as such definitio ns may be mathematically, they are 
not satisfactory for system mode ling, as they fail to make the distinction between an  
abstract relation and one of its particular instan c e s .  F o r  s y s t em modeling, if not for  
mathematics and relati onal databases, the loves  relation has its own general and abstract  
properties, quite independent of the record of who loves whom i n a particular group of  
people at a particular time.
This discussion will be extended in a later chapter when we loo k at transformations  on 
both abstract and concrete objects and give a name to the verti cal arrows of the preceding  
figure: the abstraction function .
Reality: a cousin twice removed 
You may have noted how the above discussion (and previous ones on neighboring topics)  
stayed clear of any reference to the “real world”. Instead, the  expression used above in  
reference to what the software represents is  simply “the modele d system”.
This distinction is not commonly made. Many of the discussions in information  
modeling talk about “modeling th e real world”, and similar expr essions abound in books  
about O-O analysis. So we should take a moment to reflect on th is notion. Talking about  
the “reality” behind a software system is decept ive for at leas t four reasons. 
First, reality is in the eyes of the beholder. Without being ac cused of undue chauvinism  
for his profession, a software engineer may with some justifica tion ask his customers why  
their systems are more real than his. Take a program that performs ma thematical  
computations — proving the four-c olor conjecture in graph theor y, integrating some  
differential equations, or solvi ng geometrical problems in a fo ur-dimensional Riemann  
surface. Are we, the software d evelopers, to quarrel with our m athematician friends (and  
customers) as to whose artefacts are more real: a piece of soft ware written in some  
programming language, or a complete subspace with negative curv ature? 
Second, the notion of real world collapses in the not infrequen t case of software that  
solves software problems — reflex ive applications, as they are sometimes called. Take a  
C compiler written in Pascal. Th e “real” objects that it proces ses are C programs. Why  
s h o u l d  w e  c o n s i d e r  t h e s e  p r o g r a m s  m o r e  r e a l  t h a n  t h e  c o m p i l e r  i tself? The same  
observation applies to other systems handling objects that only  exist in a computer: an  
editor, a CASE tool, even a docum ent processing system (since t he documents it  
manipulates are computer objects , the printed ver sion being onl y their final form). 
The third reason is a generali zation of the second. In the earl y days of co mputers, it  
may have been legitimate to thin k of software systems as being superimposed on a pre-
existing, indepe ndent reality. But today the computers and thei r software are more and  
more a part of that reality. Lik e a quantum physicist finding h imself unable to separate the  
measure from the measu rement, we can seldom treat “the real wor ld” and “the software”  
as independent entities. The MIS  field (Management Information Systems, that is to say,  
business data processing) provide s some of the most vivid evide nce: although it may have  
been the case with the first MIS  a p p l i c a t i o n s ,  a  f e w  d e c a d e s  a g o, that companies  “The abstraction 
function”, page 375 .
See also “DISCUS-
SION”, 20.6, page 693 on the dangers 
of staying too close 
to reality .
§8.3   MANIPULATING OBJECTS AND REFERENCES 231
introduced computers and the associated software simply with th e aim of automating  
existing procedures, the situatio n today is radically different , as many existing procedures  
already involve computers and th eir software. To describe the o perations of a modern bank  
is to describe mechanisms of whi ch software is a fundamental co mponent. The same is  
true of most other app lication areas; many of the activities of  physicists and other natural  
scientists, for example, rely on  computers and software not as auxiliary tools but as a  
fundamental part of the operatio nal process. One may reflect he re about the expression  
“virtual reality”, and its implication that  what soft ware produ ces is no less r eal than what  
comes from the outside world. In  all such cases the software is  not disjoint from the reality,  
as if we had a feedback loop in which operating the software in jects some new and  
important inputs into the model. 
The last reason is even more fu ndamental. A software system is not a model of  
reality; it is at best a model of a model of some part of some reality. A hospital’s patient  
monitoring system is not a model of the hospital, but the imple mentation of someone’s  
view of how certain aspects of t he hospital management should b e handled — a model  of 
a model  of a subset  of the hospital’s reality. An astronomy program is not a model  of the  
universe; it is a software model  of someone’s model of some pro perties of some part of  
the universe. A financ ial information system is not a model of the stock exchange; it is a  
software transposition of a mode l devised by a certain company to describe those aspects  
of the stock exchange which are rele vant to the co mpany’s goals .
The general theme of the object- oriented method, abstract data types, helps  
understand why we do not need to delude ourselves with the flat tering but illusory notion  
that we deal with the real world. The first step to object orie ntation, as expressed by the  
ADT theory, is to toss out realit y in favor of something less g randiose but more palatable:  
a set of abstractions characteri zed by the operations available  to clients, and their formal  
properties. (This gave the ADT m odeler’s motto — tell me not wh at you are but what you  
have.) Never do we make any pret ense that these are the only po ssible operations and  
properties: we choose the ones th at serve our purposes of the m oment, and reject the  
others. To model is to discard .
To a software system, the reality that it addresses is, at best , a cousin twice removed. 
8.3  MANIPULATING OBJECTS AND REFERENCES 
Let us come back to more mundane matters and see how our softwa re systems are going  
to deal with obj ects so as to create and  use flexible data stru ctures. 
Dynamic creation and reattachment 
What the description of the run- time object structure has not y et shown is the highly  
dynamic nature of a true object-oriented model. As opposed to s tatic and stack-oriented  
policies of object management, il lustrated at the programming l anguage level by Fortran  
and Pascal respectively, the policy in a proper O-O environment  is to let systems create  
objects as needed at run time, a ccording to a pattern which is usually impossible to predict  
by a mere static examinati on of the software text. See “BEYOND 
SOFTWARE”, 6.6, page 147 .
THE RUN-TIME STRUCTURE: OBJECTS  §8.3 232
From an initial state in which ( as described in the previous ch apter) only one object  
has been created — the root object — a system will repetitively  perform such operations  
on the object structure as creating a new object, attach a prev iously void reference to an  
object, make a reference void, or reattach a previously attache d reference to a different  
object. The dynamic a nd unpredictable nature of these operation s is part of the reason for  
the flexibility of the approach, and its ability to support the  dynamic data structures that  
are necessary if we are to use ad vanced algorithm s and model th e fast-changing properties  
of many external systems. 
The next sections explore the m echanisms needed to create objec ts and manipulate  
their fields, in par ticular references. 
The creation instruction 
Let us see how to cr eate an instance o f a class such as BOOK3 . This can only be done by  
a routine of a class w hich is a client of BOOK3 , such as 
class QUOTATION  feature
source : BOOK3
page : INTEGER
make_book
-- Create a BOOK3  object and attach source  to it.
do
… See below …
end
end
which might serve to describe a quotation of a book, appearing in another publication and  
identified by two fields: a refe rence to the quoted book and th e number of the page which  
quotes the book. 
The (soon to be explained) mechanism that creates an instance o f type QUOTATION
will also by default initialize a ll its fields. An important pa rt of the default initialization  
rule is that any reference field, such as the one associated wi th attribute source , will be  
initialized to a void reference.  In other words, creating an ob ject of type QUOTATION
does not by itself crea te an object of type BOOK3 . 
The general rule is indeed that, unless you do something to it,  a reference remains  
void. To change this, you may create a new object through a cre ation instruc tion. This can  
be done by procedure make_book , which should then read as follows: 
§8.3   MANIPULATING OBJECTS AND REFERENCES 233
make_book
-- Create a BOOK3  object and attach source  to it.
do
create  source
end
This illustrates the simplest for m of the creation instruction:  create  x, where x is an 
attribute of the enclosing class or (as will be seen later) a l ocal entity of the enclosing  
routine. We will see a few exten sions to this basic notation la ter.
The entity x named in the instruction ( source  in the above example) is called the  
target  of the creation instruction. 
T h i s  f o r m  o f  t h e  c r e a t i o n  i n s t r u c t i o n  i s  k n o w n  a s  a  “ b a s i c  c r e a tion instruction”.  
(Another form, involving a call to a procedure of the class, wi ll appear shortly.) Here is  
the precise effect of a basic creation instruction: 
Step C 1 will create an instance of C. Step C 2 will set the values of each field to a  
predetermined value, which depen ds on the type of the correspon ding attribute. Here are  
these values:Effect of a basic creation instruction
The effect of a creation instruction of the form create  x, where the type of  
the target x is a reference type based on a class C, is to execute the following  
three steps: 
C1 • Create a new instance of C (made of a collection of fields, one for  
each attribute of C). Let OC be the new instance. 
C2 •Initialize each field of OC according to the stan dard default values. 
C3 • Attach the value of x (a reference) to OC. 
Default initialization values
For a reference, the default  value is a void reference. 
For a BOOLEAN , the default value is False . 
For a CHARACTER , the default v alue is the null character. 
For a number (of type INTEGER , REAL  or DOUBLE ), the default value is  
zero (that is to say, the zero va lue of the appropriate type). The “standard 
default values” mentioned in step C2 appear in the next box . 
THE RUN-TIME STRUCTURE: OBJECTS  §8.3 234
So for a target source  of type BOOK3 , where the above clas s declaration read 
class BOOK3  feature
title: STRING
date, page_count : INTEGER
author : WRITER
end
the creation instruction create  source , executed as part of a call to procedure make_book
of class QUOTATION , will yield an object of the following form: 
The integer fields have been ini tialized to zero . The reference  field for author  has 
been initialized to a void reference. The field for title, a STRING ,  a l s o  s h o w s  a  v o i d  
reference. This is because type STRING  (of which the above initialization rules said  
nothing) is in fact a reference type too, althoug h as noted we may for most practical  
purposes treat it as a basic type. 
The global picture 
It is important not to lose track of the order in which things happen. For the above instance  
of BOOK3  to be created, the  following two eve nts must occur: 
B1 • An instance of QUOTATION  gets created. Let Q_OBJ b e that instance and let a be 
an entity whose value is a r eference attached to Q_OBJ. 
B2 • Some time after step B 1, a call of the form a  make_book  executes procedure make_
book  with Q_OBJ as  its target.
It is legitimate of course to as k how we ever get to step B1 — how Q_OBJ itself will  
be created. This only pushes the problem further. But by now yo u know the answer to this  
question: it all comes back to the Big Bang. To execute a syste m, you must provide a root  
class and the name of a procedure of that class, the creation p rocedure. At the start of the  
execution, you are automatically p rovided with one  object, the root object — an instance  
of the root class. The root object is the only one that does no t need to be created by the  
software text itself; it comes from the outside, as an objectus ex machina . Starting with  
that one providential object, the software can now create other  objects in the normal way,  
through routines that execute cre ation instructions. The first routine to be executed is the  
creation procedure, automatically  applied to the root object; i n all but the most trivial cases  
it will include at leas t one creation instruction so as to star t what the previous chapter  
compared to a giant firework: th e process of producing as many new objects as a particular  
execution will need.A newly 
created and 
initialized object0title
date
(BOOK3 )0 page_count
author
“STRINGS”, 13.5, 
page 456 .
See “PUTTING 
EVERYTHING TOGETHER”, 7.9, page 194 .
§8.3   MANIPULATING OBJECTS AND REFERENCES 235
Why explicit creation? 
Object creation is explicit . Declaring an entity such as 
b: BOOK3
does not cause an object to be c reated at run time: creation wi ll only occur when some  
element of the system executes an operation 
create  b
You may have wondered why this w a s  s o .  S h o u l d  t h e  d e c l a r a t i o n  o f b not be  
sufficient if we need an object at run time? What good is it to  declare an entity if we do  
not create an object? 
A moment’s reflection, however, shows that the distinction betw een declaration and  
creation is actuall y the only reason able solution. 
The first argument is by reductio ad absurdum . Assume that somehow we start  
processing the declaration of b and immediately create the corresponding book object. But  
this object is an instance of class BOOK3 , which has an attribute author , itself of a  
reference type WRITER , so that the author  field is a reference, for which we must create  
an object right away. Now this o bject has reference fields (rem ember that STRING  is in 
fact a reference type) and they w ill require the same treatment : we are starting on a long  
path of recursive object creatio n before we have even begun any  useful processing! 
This argument would be even more  obvious with a self-referentia l class, such as  
PERSON1  seen above: 
class PERSON1  feature
name : STRING
loved_one , landlord : PERSON1
end
Treating every declaration as yielding an object would mean tha t every creation of  
an instance of PERSON1  would cause creation of two more such objects (corresponding  
to loved_one  and landlord ), entering into an infinite loop . Yet we have seen that such s elf-
referential definitions, either direct as here o r indirect, are  common and necessary.
Another argument simply follows from a theme that runs through this chapter: the  
use of object technolog y as a powerful modeling technique. If e very reference field were  
initialized to a newly created obj ect, we would have room neith er for void references nor  
for multiple references attached  to a single object. Both are n eeded for rea listic modeling  
of practical systems: 
• In some cases the model may req uire that a certain reference b e left not attached to  
any object. We used this t echnique when leaving the author  field void to indicate that  
a book is by an unknown author. 
•In other cases two references sho uld be attached, again for con ceptual reasons  
coming from the model, to the sa me object. In the self-referenc e example we saw the  
loved_one fields of two PERSON1  instances attached to the same object. It would  See the figure on 
page 226 .
THE RUN-TIME STRUCTURE: OBJECTS  §8.4 236
not make sense in that case to c reate an object for each field on creation; what you  
need is, rather than a creation instruction, an assignment oper ation (studied later in  
this chapter) that attaches a re ference to an already existing object. This observation  
applies even more clearly to the  self-referential field from th e same example (field  
landlord  for the top object). 
The object management mechanism never attaches a reference impl icitly. It creates  
objects through creati on instructions (or clone  operations, seen below and explicit too),  
initializing their reference fields to void references; only th rough explicit instructions will  
these fields, in turn, become attached to objects.
In the discussion of inheritance we will see that a creation in struction may use the syntax  
create  {T} x to create an object whose type T is a descendant of the type declared for x.
8.4  CREATION PROCEDURES
All the creation instructions see n so far relied on default ini tializations. In some cases, you  
may be unhappy with the language- defined initializations, wanti ng instead to provide  
specific information to initializ e the created object. Creation  procedures address this need.
Overriding the default initializations
T o  u s e  a n  i n i t i a l i z a t i o n  o t h e r  t han the default, give the class  one or more creation  
procedures. A creation  procedure is a procedure of the class, w hich is listed in a clause  
starting with the keyword creation  at the beginning of the class, before the first feature  
clause. The scheme is this:
note
…
class C creation
p1, p2, …
feature
… Feature declarations, including  declarations for procedures p1, p2, …
end
A style suggestion: the recommended name for creation procedure s in simple cases is  
make , for a class that has only one c reation procedure; for a class  that has two or more  
creation procedures it is generally desirable to give them a na me starting with make_  and 
continuing with some qualifying word, as in the POINT  example that follows.
The corresponding creation instruction is not just create  x any more, but of the form
create  x  p (…)
where p is one of the creation pr ocedures lis ted in the creation  clause, and (…) is a valid  
actual argument list for p. The effect of such an instruct ion is to create the object usi ng the  
default values as in the earlier form, and to apply p, with the given arguments, to the result.  
The instruction is called a creation call ; it is a combination of creation instruction and  
procedure call.“Polymorphic cre-
ation”, page 479.
“CHOOSING THE 
RIGHT NAMES”, 26.2, page 879 .
§8.4   CREATION PROCEDURES 237
We can for example add creat ion procedures to the class POINT  to enable clients to  
specify initial coordinates, either cartesian or polar, when th ey create a point object. We  
will have two creation procedures, make_cartesian and make_  polar . Here is the scheme:
class POINT1 creation
make_cartesian , make_  polar
feature
… The features studied in the preceding version of the class:
    x, y, ro, theta , translate , scale , …
feature {NONE } -- See explanations below a bout this export status.
make_cartesian (a, b: REAL )
-- Initialize point with cartesian coordinates a and b.
do
x := a; y := b
end
make_  polar (r, t: REAL )
-- Initialize point wit h polar coordinates r and t.
do
x := r ∗ cos (t); y := r ∗ sin (t)
end
end
With this class text, a  client will create a point through such  instructions as
create  my_  point   make_cartesian (0, 1)
create  my_  point   make_  polar (1, Pi/2)
both having the same effect if Pi has the value suggested by its name.
Here is the rule defining the effect of such creation calls. Th e first three steps are the  
same as for the basic form seen earlier:
Effect of a creation call
The effect of a creati on call of the form create  x  p (…), where the type of the  
target x is a reference type based on a class C, p is a creation procedure of  
class C, and (…) represents a valid list of actua l arguments for t his procedure  
if necessary, is to execute the following four steps: 
C1 • Create a new instance of C (made of a collection of fields, one for  
each attribute of C). Let OC be the new instance. 
C2 • Initialize each field of OC according to standa rd default  values. 
C3 • Attach the value of x (a reference) to OC. 
C4 • Call procedure p, with the argum ents given, on OC.Original version of 
POINT in “The 
class”, page 176.
The new step
THE RUN-TIME STRUCTURE: OBJECTS  §8.4 238
The export status of creation procedures
In POINT1 the two creation procedures have  been declared in a feature cla use starting  
with feature {NONE }. This means they are secret, bu t only for normal calls, not fo r 
creation calls. So the two example creation calls just seen are  valid; normal calls of the  
form my_ point   make_cartesian (0, 1) or my_ point   make_  polar (1, Pi/2) are invalid since  
the features have not been made available for calling by any cl ient.
The decision to make the two pro cedures secret m eans we do not want clients, once  
a point object exists, to set their coordinates directly, altho ugh they may set them indirectly  
through the other procedures of the class such as translate and scale . Of course this is only  
one possible policy; you may very well decide to export make_cartesian  and make_  polar
in addition to m aking them creation procedures.
It is possible to give a procedu re a selective creation status as well by including a set  
of classes in braces in its creation  clause, as in 
class C creation {A, B, …}
p1, p2, 
…
although this is less frequent than limiting the export status of a feature through the similar  
syntax feature {A, B, …} or feature {NONE }. Remember in any case that the creation  
status of a procedure is indepen dent of its call export status.
Rules on creation procedures
The two forms of creation in structions, the basic form create  x and the creation call  
create  x  p (…), are mutually exclusive. As soon as a class has a creation  clause, then only the  
creation call is permitted; the basic form will be considered i nvalid and rejected by the compiler.
This convention may see m strange at first, but is justified by considerations of object  
consistency. An object is not just a collection of fields; it i s the implementation of an  
abstract data type, which may im p o s e  c o n s i s t e n c y  c o n s t r a i n t s  o n  t h e  f i e l d s .  H e r e  i s  a  
typical example. Assume an object representing a person, with a  field for the birth year  
and another for the age. Then yo u cannot set these two fields i ndependently to arbitrary  
values, but must ensure a consis tency constraint: the sum of th e age field and the birth year  
field must equal either  the current year or  the one b efore. (In  a later chapter we will learn  
how to express such constraints, often reflecting axioms from t he underlying ADT, as  
class invariants .) A creation instruction must always  yield a consistent object. The basic  
form of the creation instruction — create  x with no call — is only ac ceptable if setting all  
the fields to the default values  yields a consistent object. If  this is not the case, you will  
need creation procedures, and should disallow the basic form of  the creation instruction.
In some infrequent cases you may want to accept the default ini tializations (as they  
satisfy the class invariant) while also defining one or more cr eation procedures. The  
technique to apply in this case is to list nothing  among the creation procedures. Feature  
nothing is a procedure without arguments,  inherited from the universal class ANY, which  
has an empty body (the feature declaration is simply: nothing do end) so that it does  
exactly what the name indic ates. Then you can write:On the {NONE } 
construct see “Style for declaring secret features”, page 192 .
See “CLASS 
INVARIANTS”, 11.8, page 363 , in 
particular “The role of creation proce-dures”, page 371 .
§8.4   CREATION PROCEDURES 239
class C creation
nothing , some_creation_  procedure , some_other_creation_  procedure …
feature
…
Although the form create  x is still invalid in this case, clients can achieve the  
intended effect by writi ng the instruction as create  x  nothing
Finally, note that as a special case the rule on creation instr uctions gives a way to define  
a class that no client  will be permitted to instantiat e. A class decla ration of the f orm
class C creation
-- There is nothing here!
feature
… Rest of c lass text …
end
has a creation clause — an empty one. The above rule states tha t if there is a creation
clause the only permitted creatio n instructions are creation ca lls using a creation  
procedure; here, since  there are no creation  procedures, no cre ation call is permitted.
Being able to disallow class ins tantiation is of little interes t if we limit ourselves to  
the object-oriented me chanisms seen so far. But when we move on  to inheritance this little  
facility may prove ha ndy if we want to speci fy that a certain c lass should on ly be used as  
ancestor to other classes, nev er directly to c reate objects.
Another way to achieve this is to make the class deferred , but a deferred class must have  
at least one deferred feature, and we will not always have a ro le for such a feature.
Multiple creation and overloading
In advance of the discussion sect ion, it is illuminating to com pare the mechanism of  
multiple creation procedures with  the C++/Java approach. The ne ed is universal:  
providing several ways to initial ize an object on creation. C++  and Java, however, rely on  
a different techniqu e, name overloading.
In these languages all the creat ion procedures of a class (its “constructors”) have the  
same name, which is in fact the class name; if a class POINT contains a constructor with  
two real arguments  corresponding to make_cartesian , the expression new POINT (0, 1)
will create a new instance. To differentiate between two constr uctors, the languages rely  
on the signatures (the t ypes of the arguments).
T h e  p r o b l e m  i s  o f  c o u r s e ,  a s  w e  s a w  i n  t h e  d i s c u s s i o n  o f  o v e r l o ading, that the  
argument signature is not the ap propriate criterion: if we also  want a constructor providing  
the equivalent of make_  polar  we are stuck, since the arguments would be the same, two  
real numbers. This is the general problem of overloading: using  t h e  s a m e  n a m e  f o r  
different operations, thereby c ausing potential ambiguity — com pounded here by the use  
of that name as a cl ass name as well as a procedure name.
The technique developed earlier seems preferable in all respect s: minimum hassle (no  
creation procedure) if default initializations suffice; prevent  creation, if desired, through an  
empty creation clause; to provide several forms of creation, define as many cr eation  
procedures as needed; do not introduce any confusion between cl ass names and feature  
names; let the effect of every operation stand out clearly from  its names, as with make_  polar .See “What to do 
with deferred classes”, page 487 and exercise E14.5, page 518 .
See “Syntactic over-
loading”, page 93 .
THE RUN-TIME STRUCTURE: OBJECTS  §8.5 240
8.5  MORE ON REFERENCES 
The run-time model gives an impo rtant role to re ferences. Let u s examine some of their  
properties, in particular the no tion of void reference, and som e of the issues they raise.
States of a reference 
A reference may be in either of two states: void and attached. We have seen that a  
reference is always void initially and can be come attached thr ough creation. Here is a  
more complete picture.  
Other than creation, a reference  may change state through assig nment, as will be  
studied shortly. For the moment, please make sure you understan d the difference between  
the three notions — object, refer ence and entity — which recur through this chapter: 
• “Object” is a run-time notion; a ny object is an instance of a certain class, created at  
execution time and made of a number of fields. 
• “Reference” is also a run-time notion: a reference is a value that is either void or  
attached to an object. We have s een a precise definition of “at tached”: a reference is  
attached to an object if it iden tifies that objec t unambiguousl y. 
•In contrast, “entity” is a stati c notion — that is to say, appl ying to the software text.  
An entity is an identifier appear ing in the text of a class, an d representing a run-time  
value or a set of successive run -time values. (Readers used to traditional forms of  
software development m ay think of the notion of entity as cover ing variables,  
symbolic constants, routine ar guments and function results.)
If b is an entity of reference type, its run-time value is a refere nce, which may be  
attached to an object O. By an abuse of language we can say tha t b itself is attached to O.
Void references and calls 
In most situations we expect a r eference to be attached to an o bject, but the rules also  
permit a reference to be void. V oid references play an importan t role — if only by making  
a nuisance of themselves — in th e object-oriented model of comp utation. As discussed  
extensively in the previous chap ter, the fundamental operation in that model is feature call:  
apply to an instance of a class a feature of that class. This i s written VOID
STATEATTACHED
STATE
b := Void
b := c (where c is void)create  b
b := c (where c is attached)The possible 
states of a reference
Full definition of 
“entity”: page 213.
§8.5   MORE ON REFERENCES 241
some_entity   some_  feature (arg1, …)
where some_entity  is attached to the desired target object. For the call to work , some_entity
must indeed be attached to an object. If some_entity  is of a reference type and happens to  
have a void value at the time of the call, the call cannot proc eed, as some_  feature  needs a  
target object. 
To be correct, an obje ct-oriented system mu st never attempt at run time to execute a  
feature call whose target is void. The effect will be an exception ; the notion of exception,  
and the description of how it is  possible to recover from an ex ception, will be discussed in  
a later chapter. 
It would be desirable to let compilers check the text of a syst em to guarantee that no  
such event will occur at run time, in the same way that they ca n check the absence of type  
incompatibilities by en forcing type rules. Unfortunately such a  general goal is currently  
beyond the reach of compilers (u nless we place unacceptable res trictions on th e language).  
So it remains the software devel oper’s responsibility to ensure  that the execution will  
never attempt a feature call on a void target. There is of cour se an easy way to do so:  
always write x  f (…) as 
if “x is not void”  then
x  f (…)
else
…
end
but this is too unwieldy to be acceptable as a universal requir ement. Sometimes (as when  
a call x  f immediately follows a creation create  x) it is clear from the context that x is not  
void, and you do no t want to test.
The question of non-vacuity of re ferences is part of the larger  question of software  
correctness. To prove a system c orrect, it is necessary to prov e that no call is ever applied  
to a void reference, and that all the software’s assertions (as  studied in a later chapter) are  
satisfied at the appropriate run -time instants. For non-vacuity  as well as for assertion  
correctness, it would be desirable to have an automatic mechani sm (a program prover,  
either integrated with the compiler or designed as a separate s oftware tool) to ascertain that  
a software system is correct. In  the absence of such tools, the  result of a violation is a run-
time error — an exception. Developers may protect their softwar e against such situations  
in two ways: 
• When writing the software, tryi ng to prevent the erroneous sit uations from arising at  
run time, using all means possib le: systematic and careful deve lopment, class  
inspections, use of tools that p erform at least partial checks.  
• If any doubt remains and run-tim e failures are unacceptable, e quipping the software  
with provisions for handling exceptions. See chapter 12 , in 
particular “Sources of exceptions”, page 412.
The test  “x is not 
void”  may be  
written simply as  
x /= Void . See below .
THE RUN-TIME STRUCTURE: OBJECTS  §8.6 242
8.6  OPERATIONS ON REFERENCES 
We have seen one way of changing the value of a reference x: using a creation instruction  
of the form create  x, which creates a new object and attaches x to it. A number of other  
interesting operations are  available on references. 
Attaching a reference to an object 
So far the classes of this chapter have had attributes but no r outines. As noted, this makes  
them essentially useless: it is not possible to change any fiel d in an existing object. We  
need ways to modify the value of references, without resorting to instructions of the  
Pascal-C-Java-C++ form my_beloved   loved_one := me (to set the loved_one field of an  
object directly), which violates information hiding and is synt actically illegal in our  
notation.
To modify fields of foreign obje cts, a routine will need to cal l other routines that the  
authors of the corresponding cla sses have specifically designed  for that purpose. Let us  
adapt class PERSON1  to include such a procedu re, which will change the loved_one field 
to attach it to a new objec t. Here is the result: 
class PERSON2  feature
name : STRING
loved_one , landlord : PERSON2
set_loved (l: PERSON2 )
-- Attach the loved_one  field of current object to l.
do
loved_one := l
end
end
Procedure set_loved  a s s i g n s  t o  t h e  loved_one  field of the curr ent instance of  
PERSON2 , a reference field, the value of another reference, l. Reference assignments (like  
assignments of simple values such as integers) rely on the := symbol, with the  
assignment’s source on the right and the target on the left. In  this case, sinc e both source  
and target are of refe rence types, the assignment is said to be  a reference assignment. 
The effect of a reference assign ment is exactly what the name s uggests: the target  
reference gets reattached to the object to which the source ref erence is attached — or  
becomes void if the source was void. Ass ume for example that we  start with t he situation  
shown at the top of the facing page; to avoid cluttering the pi cture, the landlord fields and  
the irrelevant loved_one fields have been left blank. 
Assume that we execute  the proce dure call 
a  set_loved (r)
§8.6   OPERATIONS ON REFERENCES 243
where a is attached to the top object (O1) and r to the bottom-right object (O3). From the  
way set_loved  has been written, this will  execute the assignment 
loved_one := l
with O1 as the current object and  l having the same value as r, a reference to O3. The result  
is to reattach the loved_one  field of O1:  (PERSON2 )"Almaviva" name
loved_onelandlordO1ar
(PERSON2 )"Susanna" name
loved_onelandlord
(PERSON2 )"Rosina" name
loved_onelandlordO3 O2Before 
reference 
assignment
After reference 
assignment
(PERSON2 )"Almaviva" name
loved_onelandlordO1ar
(PERSON2 )"Susanna" name
loved_onelandlord
(PERSON2 )"Rosina" name
loved_onelandlordO3 O2
THE RUN-TIME STRUCTURE: OBJECTS  §8.6 244
If r had been a void reference, the assignment would have made the loved_one  field 
of O1 void too.
A natural question at this stage is: what happens to the object  to which the modified field  
was initially attached — O2 in the figure? Will the space it oc cupies be automatically  
recycled for use by future creation instructions?
This question turns out to be so important as to deserve a chap ter of its own — the next  
chapter, on memory management and garbage collection. So please  hold your breath until  
then. But it is not too early for a basic observation: regardle ss of the final answer, a policy  
that would always recycle the object’s space would be incorrect . In the absence of further  
information about the system from which the above run-time stru cture is extracted, we do  
not know whether some other reference is still attached to O2. So a reference assignment  
by itself does not tell us what to do with the previously attac hed object; any mechanism  
for recycling objects will need more context. 
Reference comparison 
In the same way that we have an operation (the := assignment) to attac h a reference to an  
object, we need a way to test whether two references are attach ed to the same object. This  
is simply provided by the usual equali ty operator =. 
If x and y are entities of referen ce types, the expression 
x = y
is true if and only if the corresponding references are either both void or both attached to  
the same objects. The opposite o perator, “not equal”, is writte n /= (a notation borrowed  
from Ada). 
For example, the expression 
r = a  loved_one
has value true on th e last figure, where both sides of the = sign denote references attached  
to the object O3, but not on th e next-to-last figure, where a  loved_one  is attached to O2
and r is attached to O3.
In the same way that an assignmen t to a reference is a referenc e operation, not an  
operation on objects,  the expressions x = y and x /= y compare references, not objects. So  
if x and y are attached to two  distinct objects, x = y has value false even if these objects are  
field-by-field identical . Operations which compare objects rath er than reference will be  
introduced later. 
The void value 
Although it is easy to get a void reference — since all referen ce fields are by default  
initialized to Void –, we will find it convenient to have a name for a reference v alue 
accessible in all  contexts and known alway s to be void. The pre defined feature
Void
will play that role.
§8.6   OPERATIONS ON REFERENCES 245
Two common uses of Void are to test whether a certain reference is void, as in 
if x = Void then  …
and to make a reference void, using the assignment 
x := Void
This last assignment has the effect of putting the reference ba ck to the void state, and  
so of de-attaching it from t he attached object, if any:
The comment made in the general  discussion of reference assignm ent is worth repeating  
here: the assignment of Void to x has no immediate effect on the attached object (O1 in  
the figure); it simply cuts the link between the reference and the object. It would be  
incorrect to understand it as freeing the memory associated wit h O1, since some other  
reference may still be attached to O1 even after x has been de-attached from it. See the  
discussion of memory management in the next chapter.
Objec t cloning and equality 
Reference assignments may cause two or more refe rences to becom e attached to a single  
object. Sometimes you will need a different form of assignment,  which works on the  
object itself: rather than attach ing a reference to an existing  object, you will want to create  
a new copy of an existing object. 
This goal is achieved through a call to a function called clone . If y is attached to an  
object OY, the expression 
clone (y)O1
O1x
xBEFORE
AFTERDe-attaching a 
reference from 
an object
THE RUN-TIME STRUCTURE: OBJECTS  §8.6 246
denotes a new object OX, such th at OX has the same number of fi elds as OY , each field  
of OX being identical to the c orresponding field of OY . If y is void, the value of clone (y)
is also void. 
To duplicate the object attached to y and attach the resulting object to x (or make x 
void if y is void), you may use a call to clone  in an assignment: 
[1]
x := clone (y)
Here is an illustrati on of this mechanism.
We similarly need a mechanism to  compare two objects. The expre ssion  x = y, as 
noted, fulfills another purpose: comparing references. For obje cts, we will use function  
equal . The call 
equal (x, y)
returns a boolean value, true if and only if x and y are either both void,  or attached to two  
objects whose corresponding field s have the same values. If a s ystem executes the clone  
assignment [1], the state immediately following that assignment  will satisfy equal (x, y).
You may wonder why function clone  has an argument, and equal  two arguments treated  
symmetrically, rather than being called under forms closer to t he usual object-oriented  
style, for example y  twin and x  is_equal (y). The answer appears in the discussion  
section, but it is not too early to try  to guess it. OYyBEFORE
AFTER'A'
783
OY
'A'
783OX
'A'
783y xCloning an 
object
“The form of clone 
and equality opera-tions”, page 274 .
§8.6   OPERATIONS ON REFERENCES 247
Object copying 
Function clone  creates a new object as a carbon copy of an existing one. Some times the  
target object already exists; al l we want to do is to overwrite  its fields. Procedure copy
achieves this. It is called through the instruction
x  copy (y)
for x and y of the same type; its effect is to copy the fields of the obje ct attached to y onto 
the corresponding ones of  the object attached to x. 
As with all feature calls, any call to copy  requires the target x to be non-void. In  
addition, y must also be non-void. This inab ility to deal with void values distinguishes  
copy  from clone . 
The requirement that y must be non-void is so important that we should have a way to  
express it formally. The problem is in fact more general: how a  routine can state the  
preconditions  on the arguments passed by its callers. Such preconditions, a case of the  
more general notion of assertion, will be discussed in detail i n a later chapter. Similarly,  
we will learn to express as postconditions  such fundamental semantic properties as the  
observation made above that the result of a clone  will satisfy equal .
Procedure copy  may be considered more fundamental than function clone  i n  t h e  
sense that we can, at least for a class with no creation proced ure, express clone  in terms of  
copy  through the following  equivalent function: 
clone (y: SOME_TYPE )
-- V oid if  y is void; otherwise duplic ate of object attached to y
do
if y /= Void then
create  Result -- Valid only in the absen ce of creation procedures
Result   copy (y)
end
end
On execution of a function call, Result  is automatically initialized using the same  
rules defined above for attribut es. This is the reason why the if needs no else: since Result
is initialized to Void, the result of the above f unction is a void value if y is void.
Deep clone and comparison 
The form of copy and compari son achieved by routines clone , equal  and copy  may be  
called shallow  since these operations work on an object at the first level on ly, never trying  
t o  f o l l o w  r e f e r e n c e s .  T h e r e  w i l l  a l s o  b e  a  n e e d  f o r  deep  variants which recursively  
duplicate an entire structure.See chapter 11 about 
assertions .
THE RUN-TIME STRUCTURE: OBJECTS  §8.6 248
T o  u n d e r s t a n d  t h e  d i f f e r e n c e s  a s s u m e  f o r  e x a m p l e  t h a t  w e  s t a r t  with the object  
structure appearing in black (except for the attribute and clas s names) under A in the figure  
on the facing page, where the entity a is attached to the o bject labeled O1.
For purposes of comparison, consid er first the sim ple reference  assignment
b := a
As pictured under B, this simply attaches the assignment’s target b to the same object  
O1 to which the source a was attached. No new object is created.
Next consider the cloning operation
c := clone (a)
This instruction will, as shown under C, create a single new object O4, field-by-field  
identical to O1. It copies the two reference fields onto the co rresponding fields of O4,  
yielding references that are  attached to the same objects  O1 and O3 as the originals. But it  
does not duplicate O3 itself, or  any other object other than O1 . This is why the basic clone 
operation is known as shallow: i t stops at the first level of t he object structure.
Note that a self-reference has disappeared: the landlord  field of O1 was attached to O1  
itself. In O4 this field becomes a reference to the original O1 .
In other cases, you may want to g o further and duplicate a stru cture recursively,  
without introducing any sharing of references such as occurred in the creation of O4. The  
function deep_clone  achieves this. Instead of stopp ing at the object attached to y, the 
process of creating deep_clone (y) recursively follows any reference fields contained in  
that object and duplicates the entire structure. (If y is void the result is void too.) The  
function will of cours e process cyclic reference structures pro perly. 
The bottom part of t he figure, labeled D, illustrates the r esult of executing 
d := deep_clone (a)
This case introduces n o new sharing; all t he objects accessible  directly or indirectly  
from O1 (the object attached to  a) will be duplicated, yieldin g new objects O5, O6 and O7.  
There is no connection between the old objects (O1, O2 and O3) and the new. Object O5,  
mimicking O1, has a self-reference.
In the same way that we need bot h deep and shallow clone operat ions, equality must  
have a deep variant. The deep_equal  function compares two obje ct structures to determine  
whether they are structurally id entical. In the figure’s exampl e, deep_equal holds between  
any two of a, b and d; but whereas equal (a, c) is true, since the corresponding objects O1 
and O4 are field-by-field identical, equal (a, d) is false. In fact equal  does not hold  
between d and any of the other three. (Both equal (a, b) and equal (b, c) hold.) In the  
general case we may note the following properties: 
• After an assignment x := clone (y) or a call x  copy (y), the expression equal (x, y) has 
value true. (For the first assignment this property holds wheth er or not y is void.) 
•A f t e r  x := deep_clone (y), the expression deep_equal (x, y) has value true. 
These properties will be express ed as postconditions of the cor responding routines. 
§8.6   OPERATIONS ON REFERENCES 249
(PERSON1 )"Almaviva" name
landlord
loved_one
(PERSON1 )"Figaro" name
landlord
loved_one
(PERSON1 )"Susanna" name
landlord
loved_onea
O2O1
O3
B Effect of b := a
bA Initial state
C Effect of c := clone (a)"Almaviva" name
landlord
loved_oneO4
c
(PERSON1 )"Almaviva" name
landlord
loved_one
(PERSON1 )"Figaro" name
landlord
loved_one
(PERSON1 )"Susanna" name
landlord
loved_oned
O6O5
O7D Effect of d := deep_clone (a)Various forms 
of assignment 
and cloning
THE RUN-TIME STRUCTURE: OBJECTS  §8.6 250
Deep storage: a first view of persistence
The study of dee p copy and equal ity leads to anot her mechanism which, in environments  
where it is available, provides one of the great practical adva ntages of the O-O method. 
So far, the discussion has not examined the question of input a nd output. But of  
course an object-oriented system will need to communicate with other systems and with  
the rest of the world. Since the information it manipulates is in the form of objects, this  
m e a n s  i t  m u s t  b e  a b l e  t o  w r i t e  a nd read objects to and from fil es, databases,  
communication lines a nd various devices. 
For simplicity this section will assume that the problem is to write to and write from files,  
and will use the terms “storage” and “retrieval” for these oper ations (“input” and “output”  
would also be adequate.) But the mechanisms studied must also b e applicable for  
exchanging objects with the outside world through other means o f communication, for  
example by sending and receiving objects through a network.
For instances of such classes as POINT  or BOOK1 , storage and retrieval of objects  
raise no particular novelty. These classes, used as the first e xamples at the beginning of  
this chapter, have attributes of types such as INTEGER , REAL  and STRING , for which  
well-understood external represen tations are available. Storing  an instance of such a class  
i n t o  a  f i l e ,  o r  r e t r i e v i n g  i t  f r o m  t h a t  f i l e ,  i s  s i m i l a r  t o  p e r forming an output or input  
operation on a Pascal record or a  C structure. Account must be taken, of course, of the  
peculiarities of data representations on dif ferent machines and  in different languages (C,  
for example, has a special convention for strings, which the la nguage expects to be  
terminated by a null character); but these are well-known techn ical problems for which  
standard solutions exi st. So it is reasonable to expect that fo r such objects a good O-O  
environment could provide gene ral-purpose pr ocedures, say read and write , which, in the  
manner of clone , copy  and consorts, would be av ailable to all classes. 
But such mechanisms will not tak e us very far because they do n ot handle a major  
component of the object structure : references. Since references  c a n  b e  r e p r e s e n t e d  i n  
memory (as addresses or otherwise) it is possible to find an ex ternal representation as well.  
That is not the difficult part of the problem. What matters is the meaning of these  
references. A reference attached  to an object is  worthless with out that object. 
So as soon as we start dealing w ith non-trivial objects — objec ts that contain  
r e f e r e n c e s  —  w e  c a n n o t  s a t i s f y  o u r s e l v e s  a n y  m o r e  w i t h  a  s t o r a g e and retrieval  
mechanism that would just work o n individual objects; the mecha nism must process,  
together with an objec t, all its dependents according to the fo llowing definition:
Definition: direct dependents, dependents
The direct dependents of an object are the objects attached to its reference  
fields, if any. 
The dependents of an object are t he object itself and (recursiv ely) the  
dependents of its direct dependents
§8.6   OPERATIONS ON REFERENCES 251
With the object structure shown below (identical to earlier exa mples), it would be  
meaningless to store into a file, or transmit over a network, j ust the object O1. The  
operation must also include th e dependents of O1: O2 and O3. 
In this example any one of the three objects has the other two as dependents. In the  
BOOK3  example reproduced below, we ma y store W1 by itself, and whene ver we store  
B1 or B2 we must store W1 as  well. 
The notion of dependent was impl icitly present in the presentat ion of deep_equal . 
Here is the general rule:Three mutually 
dependent 
objects
(PERSON1 )"Almaviva" name
landlord
loved_one
(PERSON1 )"Figaro" name
landlord
loved_one
(PERSON1 )"Susanna" name
landlord
loved_oneO1
O2 O3
“Book” and 
“Writer” 
objects"Life of Rossini"
1823title
date
(BOOK3 )307count"The R. and the B."
1832title
date
(BOOK3 )307page_
count
(WRITER )"Stendhal"
"Henri Beyle "name
real_name
1783 birth_ year
1842 death_ yearauthor authorpage_
W1B2 B1
THE RUN-TIME STRUCTURE: OBJECTS  §8.6 252
The basic mechanism which will a chieve this for our purposes is  k n o w n  a s  t h e  
STORABLE  f a c i l i t y  f r o m  t h e  n a m e  o f  t h e  B ase library class which include s the 
corresponding fe atures. The basic features of STORABLE  are of the form: 
store ( f: IO_MEDIUM )
retrieved ( f: IO_MEDIUM ): STORABLE
The effect of a call of the form x  store ( f ) is to store the object attached to x, together  
with all its dependents, in the file associated with f. The object attached to x is said to be  
the head object  of the stored structure. The generating class of x must be a descendant of  
STORABLE  (that is to say, it must inheri t directly or in directly from STORABLE ); so you  
will have to add STORABLE  to the list of its parents if i t is not already there. This ap plies 
only to the generating class of the head object; there is no pa rticular requirement on the  
generating classes of the depend ent objects — fo rtunately, sinc e a head object can have an  
arbitrary number of direct and i ndirect dependents, instances o f arbitrary  classes.
Class IO_MEDIUM is another Base library class, c overing not only files but also  
structures for network transmission. Clearly f must be non-void and the attached file or  
transmission medium must be writable. 
The result of a call retrieved ( f ) is an object structure recursi vely identical, in the sense  
of deep_clone , to the complete object  structure stored in f   by an earlier call to store . Feature  
retrieved  is a function; its result is a reference to the head object of  the retrieved structure. 
If you have already acquired a basic understanding of inheritan ce and of the associated  
type rules, you may have noted that retrieved  raises a typing problem. The result of this  
function is of type STORABLE ; but it seems that its normal use will be in assignments of  
the form x := retrieved ( f ) where the type of x is a proper descendant of STORABLE , not 
STORABLE  itself, even though the type rules will permit x := y only if the type of y is a 
descendant of the type of x — not the other way around. The key to this problem will be  
an important construct, the assignment attempt . All this will be examined in detail when  
we study inheritance and the associated type rules.
The STORABLE  mechanism is our first exam ple of what is known as a persistence
facility. An object is persistent  if it survives individual ses sions of the systems that  
manipulate it. STORABLE  only provides a par tial solution to the persistence problem,  
suffering from several limitations: Persistence Closure principle
Whenever a storage mechanism stores an object, it must store wi th it the  
dependents of that object. Whene ver a retrieval mechanism retri eves a  
previously store d object, it must also r etrieve any dependent o f that object  
that has not yet been retrieved. 
See “ASSIGNMENT 
ATTEMPT”, 16.5, page 591 .
§8.6   OPERATIONS ON REFERENCES 253
• In the structure stored and re trieved, only one object is know n individually: the head  
object. It may be desi rable to retain the id entity of other obj ects too. 
• As a consequence, the mechanism  is not directly usable to retr ieve objects  
selectively through contents-bas ed or keyword-based queries as in database  
management systems. 
• A call to retrieved  recreates the entire object structure. This means that you can not use  
two or more such calls to retrieve various parts of a structure , unless they are disjoint. 
To address this problem is to mo ve from a mere persistence mech anism to the notion  
of object-oriented database, pre sented in a later chapter, whic h also discusses a number of  
issues associated with STORABLE  and other persistence me chanisms, such as schema  
evolution (what happens when you retrieve an object and its cla ss has changed?) and  
persistent object identity.
But the above limitati ons should not obscure the considerable p ractical benefits of  
the STORABLE  mechanism as described above. In  fact one may conjecture that the 
absence of such a mechanism has been one of the major obstacles  to the use of  
sophisticated data structures in traditional development enviro nments. Without  
STORABLE  or its equivalent, storing a da ta structure becomes a major pr ogramming  
effort: for every kind of struct ure that you wan t to endow with  persistence properties you  
must write a special input and output mechanism, including a se t of mutually recursive  
procedures (one for each type) an d special-purpose traversal me chanisms (which are  
particularly tricky to  write in the case o f possibly cyclic str uctures). But the worst part is  
not even the wor k that you have to do in itially: as usual, the real trouble comes when the  
structure changes and you hav e to update the procedures. 
With STORABLE  a predefined mechanism is available regardless of your object  
structure, its complexity, and  the software’ s evolution. 
A typical application of the STORABLE  mechanism is a SA VE facility. Consider an  
interactive system, for example a text editor, a graphical edit or, a drafting program or a  
computer-aided design system; it  needs to provide its users wit h a SA VE command to store  
the state of the current session  into a file. The information s tored should be sufficient to  
restart the session at any later time, so it must include all t he important data structures of  
the system. Writing such a proce dure in an ad hoc fashion suffe rs from the difficulties  
mentioned; in particul ar, you will have to update it whenever y ou change a class during  
development. But with the STORABLE  mechanism and a good ch oice of head object, you  
can implement the SA VE facility  using a single instruction:
head   store (save_  file)
Just by itself, this mechanism w ould suffice to recommend an ob ject-oriented  
environment over its more traditional counterparts. Chapter 31 .
THE RUN-TIME STRUCTURE: OBJECTS  §8.7 254
8.7  COMPOSITE OBJECTS AND EXPANDED TYPES 
The preceding discussion describ ed the essentials of the run-ti me structure. It gives an  
important role to references. To  complete the picture, we must see how to handle values  
which are not references to objects, but  the objects t hemselves. 
References are not sufficient 
The values considered so far, sa ve for integers, booleans and t he like, were references to  
objects. Two reasons suggest tha t we may also ne ed entities who se values are objects:
• An important goal announced in t he last chapter is to have a c ompletely uniform type  
system, in which basic types (such as BOOLEAN  and INTEGER ) are handled in the  
same way as developer-de fined types (such as POINT  or BOOK ). But if you use an  
entity n to manipulate an integer, you wi ll almost always want the valu e of n to be 
an integer, for example 3, not a reference to an object contain ing the value 3. The  
reason is partly efficiency — th ink of the penalty in both time  and space that we  
would have to incur if every integer access were indirect; just  as important in this  
case is the goal of faithful mode ling. An integer is conceptual ly not the same thing  
as a reference to an integer. 
• Even with complex, developer-de fined objects, we may prefer in  some cases to  
consider that ob ject O1 contains a subobj ect O2, rather than a reference to another  
object O2. The reason again may be efficiency, faithful modelin g or both. 
Expanded types 
The answer to the need for model ing composite objects is simple . Let C be a class  
declared, as all classes so far, under  the form 
class C feature
…
end
C may be used as a type. An y entity declared of type C represents a reference; for  
that reason C is called a reference type . 
Now assume that we need an entity x whose value at run time will be an instance of  
C — not a reference to such an in stance. We may obtain this effe ct by declaring x as 
x : expanded  C
This notation uses a new keyword, expanded . The notation expanded  C denotes a  
type. The instances of this type  a r e  e x a c t l y  t h e  s a m e  a s  t h e  i n stances of C. The only  
difference affects declarations u sing these types: an entity of  type C denotes a reference  
which may become attac hed to an instance of C; an entity of type expanded  C, such as x 
above, directly deno tes an instance of C. 
This mechanism adds the notion of  composite object to the struc ture defined in the  
preceding sections. An object O is said to be composite if one or more of its fields are  
§8.7   COMPOSITE OBJECTS AND EXPANDED TYPES 255
t h e m s e l v e s  o b j e c t s  —  c a l l e d  subobjects  o f  O. The following example class (routines  
again omitted) shows how to d escribe composite objects: 
class COMPOSITE  feature
ref: C
sub: expanded  C
end
This class relies on C declared as above. COMPOSITE has two attributes: ref, 
denoting a reference, and sub, denoting a subobject; sub is what makes the class  
composite. Any direct instance of COMPOSITE  may look like  this: 
The ref  field is a reference att ached to an instance of C (or void). The sub field 
(which cannot be void) contains an  instance of C. 
A notational extension is convenient here. You may sometimes wr ite a class E with 
the intention that all ent ities declared of type E should be expanded. To  make this intention  
explicit, declare the class as 
expanded class E feature
… The rest as for any other class …
end
A class defined in this manner is said to be an expanded class.  Here too the new  
declaration changes no thing for in stances of E: they are the same as  if the class had been  
declared as just class  E … But an entity declared of type E will now denote an object, not  
a reference. As a consequence of  this new possibility, the noti on of “expanded type”  
includes two cases:
Definition: expanded type
A type is said to be expanded i n the following two cases: 
• It is of the form expanded  C. 
• It is of the form E, where E is an expand ed class.A composite 
object with one subobjectref
(COMPOSITE )sub (C)(C)
THE RUN-TIME STRUCTURE: OBJECTS  §8.7 256
It is not a mistake to declare an entity x as being of type expanded  E if E is an 
expanded class, just useless, si nce the result i n this case is the same as if you declare x to 
be just of type E. 
We now have two kinds of type; a type which is not expanded is a reference type (a 
term already used in this chapter). W e may apply the same termi nology to the entities  
correspondingly declared: refere nce entities and  expanded entit ies. Similarly, a class is an  
expanded class  if it has been declared as expanded  class …, a reference cl ass otherwise. 
The role of expanded types 
Why do we need expanded types? They play three major roles: 
• Improving efficiency. 
• Providing better modeling. 
• Supporting basi c types in a uniform obj ect-oriented type syste m. 
The first application may be the  most obvious at first: without  expanded types, you  
would have to use references eve ry time you need to describe co mposite objects. This  
means that access ing their subobjects would require an operatio n to follow a reference —  
“dereferencing”, as it is someti mes called – which implies a ti me penalty. There is also a  
space penalty, as the ru n-time structure mus t devote space to t he references themselves. 
This performance argument is not , however, the prime justificat ion. The key  
argument, in line with this chap ter’s general emphasis on objec t-oriented software  
construction as a modeling activ ity, is the need to model compo site objects separately  
from objects that contain referen ces to other objects. This is not an implementation issue  
but a conceptual one.
Consider the two attribute declarations 
D1 • ref: S
D2 • exp: expanded  S 
appearing in a class C (and assuming that S is a reference class). Declaration D1 simply  
expresses that every instance of C “knows about” a certain instance of S (unless ref is 
void). Declaration D2 is more co mmitting: it states that every instance of C contains  an 
instance of S. Aside from any implementation issue, this is a quite differen t relation.
In particular, the “contains” relation as provi ded by expanded types does not allow  
any sharing  of the contained elements, wher eas the “knows a bout” relation allows two or  
more references to be atta ched to the same object. 
You may apply this property to e nsure proper modeling of relati ons between objects.  
Consider for example t his class declaration:
§8.7   COMPOSITE OBJECTS AND EXPANDED TYPES 257
class WORKSTATION  feature
k: expanded  KEYBOARD
c: expanded  CPU
m: expanded  MONITOR
n: NETWORK
…
end
Under this model a computer work station has a keyboard, a CPU ( central processing  
unit) and a monitor, and is attac hed to a network. The keyboard , CPU and monitor are part  
of a single workstation, and can not be shared between two or mo re workstations. The  
network component, however, is s hared: many workstations can be  hooked up to the same  
network. The class definition re flects these properties by usin g expanded types  for the first  
three attributes, and a reference type for the network attribute. 
So the concept of expanded type, which at first sight appears t o be an  
implementation-level technique, actually helps describe some of  t h e  r e l a t i o n s  u s e d  i n  
information modeling. The “conta ins” relation, and its inverse often known as “is-part-
of  ”, are central to any effort at building models of external sys tems; they appear in  
analysis methods and in database modeling. 
The third major application of e xpanded types is  in fact a spec ial case of the second.  
The previous chapter emphasized the desirability of a uniform t ype system, based on the  
notion of class, which must enco mpass both developer-defined ty pes and basic types. The  
example of REAL  was used to show how, with the help of infix and prefix featur es, we can  All classes shown 
are assumed to be reference (non-
expanded ) classes .
“Knows about” 
and “contains” 
relations 
between objects
(WORKSTATION )KEYBOARD1
CPU1
MONITOR1
(WORKSTATION )KEYBOARD1
CPU2
MONITOR2
(WORKSTATION )KEYBOARD1
CPU3
MONITOR3
(NETWORK )k
c
m
nk
c
m
nk
c
m
n
See “A UNIFORM 
TYPE SYSTEM”, 7.4,page 171 . The outline 
of class REAL  was on 
page 189 .
THE RUN-TIME STRUCTURE: OBJECTS  §8.7 258
indeed model the notion of real number as a class; we can do th e same for the other basic  
types BOOLEAN , CHARACTER , INTEGER , DOUBLE . But a problem remains. If these  
classes were treated a s reference classes, an entity declared o f a basic type, such as 
r: REAL
would at run time denote a refer ence to a possible object conta ining a value (here of type  
REAL ). This is unacceptable: to conform to common practice, the val ue of r should be the  
real value itself. The solution follows from the earlier discus sion: define class REAL  as 
expanded. Its declaration will be
expanded  class  REAL feature  
… Feature declarations exactly  as given earlier (see page 189) …
end 
All the other basic types are similarly defined by expanded cla sses.
Aggregation
In some areas of computing scien ce — databases, information mod eling, requirements  
analysis — authors have developed a classification of the relat ions that may hold between  
elements of a modeled system. Of ten mentioned in this context i s the “aggregation”  
relation, which serves to express that every object of a certai n type is a combination (an  
aggregate) of zero or more objects, each of a specified type. F or example we might define  
“car” as an aggregation o f “engine”, “body” etc.
Expanded types provide the equiv alent mechanism. We may for exa mple declare  
class CAR with features of types expanded ENGINE and expanded BODY . Another way  
to express this observation is to note that aggregation is cove red by the “expanded client”  
relation, where a class C i s sa id  t o be  a n e xp an de d cl i en t of  a  c la ss  S i f it  c on ta i ns  a  
declaration of a feature of type expanded S (or just S if S is expanded). O ne advantage of  
this modeling approach is that “expanded client” is just a spec ial case of the general client  
relation, so that we can use a single framework and notation to  combine aggregation-like  
dependencies (that is to say, de pendencies on subobjects, such as the relation between  
WORKSTATION  and KEYBOARD  in the earlier example) wit h dependencies that permit  
sharing (such as the  relation between WORKSTATION  and NETWORK ).
With the object-oriented approac h, one can avoid the multiplici ty of relations found  
in the information modeling literature, and cover all possible cases with just two relations:  
client (expanded or no t) and inheritance.
Properties of expanded types 
Consider an expanded type E (of either form) and an expanded entity x of type E. 
Since the value of x is always an object, it can nev er be void. So the expression 
x = Void
will always yield the value fal se, and a call of the form x  some_   feature (arg1, …) will 
never raise the exception “call o n void target” th at was possib le in the case of references.“Void references and 
calls”, page 240 .
§8.7   COMPOSITE OBJECTS AND EXPANDED TYPES 259
Let object O be the value of x. As with the case of a non-void reference, x is said to  
be attached to O. So for any non -void entity we may talk of the  attached object, whether  
the entity is of reference or expanded type. 
What about creation? The instruction 
create  x
may be applied t o an expanded x. For reference x, its effect was to perform three steps:  
(C1) create a new object; (C 2) initialize its fields to the default values; (C 3) attach it to x. 
For expanded x, step C 1 is inappropriate, and step C 3 is unneeded; so the only effect is to  
set all fields to th eir default values. 
More generally, the presence of expanded types affects the defa ult initialization  
performed as part of C2. Assume a class, expanded or not, havin g one or more  
expanded attributes: 
class F feature
u: BOOLEAN
v: INTEGER
w: REAL
x: C
y: expanded  C
z: E
…
end
where E is expanded but C is not. The initialization of a direct instance of F involves  
setting the u field to false, the v field to 0, the w field to 0.0, the x field to a void reference,  
and the  y and z to instances of C and E respectively, whose fields are themselves initialized  
according to the standard rules.  This initialization process is  to be applied recursively,  
since C and E may themselves include expanded fields. 
As you may have realized, a rest riction is necessary for expand ed types to be usable  
(to ensure that the recursive process just defined always remai ns finite): although, as  
discussed earlier, the client re lation may in general include c ycles, such cycles must make  
n o  u s e  o f  e x p a n d e d  a t t r i b u t e s .  F o r  e x a m p l e  i t  i s  n o t  p e r m i t t e d  for class C to have an  
attribute of type expanded  D if class D has an attribute of type expanded  C; this would  
mean that every object of type C includes a subobject of type D and conversely — a clear  
impossibility. Hence the following  rule, based on the notion of  “expanded client” already  
introduced informally above:
Expanded Client rule
Let “expanded client” the relatio n between classes be defined a s follows: C
is an expanded client of S if some attribute of C is of an expanded type based  
on S (that is to say expanded  S, or just S if S is an expanded class). 
Then the expanded client relat ion may not incl ude any cycles.See “Effect of a 
basic creation instruction ”, page 
233.
Cycles in the client 
relation were stud-ied in “Self-refer-ence”, page 226 .
THE RUN-TIME STRUCTURE: OBJECTS  §8.7 260
In other words there may not be a set of classes A, B, C, … N such that A is an 
expanded client of B, B an expanded client of C etc., with N being an expanded client of  
A. In particular, A may not have an attribute of type expanded  A, as this would make A an 
expanded clien t of itself. 
No references to subobjects
A final comment about expanded t ypes will answer the question o f how to mix references  
and subobjects. An expanded clas s, or an expanded type based on  a reference class, may  
have reference attributes. So a subobject may contain reference s attached to objects:  
The situation pictured assumes the following d eclarations: 
class COMPOSITE1  feature
other : SOME_TYPE
sub: expanded  C
end
class C feature
ref: D
x: OTHER_TYPE ; y: YET_ANOTHER_TYPE
end
class D feature
…
end
Each COMPOSITE  instance, such as O_COMP in the figure, has a subobject (OC in  
the figure) containing a reference ref which may be attached to an object (OD in the figure). 
But the reverse situation, where a reference would become attac hed to a subobject,  
is impossible. (This will follow from the rules on assignment a nd argument passing,  
studied in the next section.) So the run-time structure can nev e r  c o m e  t o  t h e  s t a t e  
described by the picture on the facing page, where OE contains a reference to OC, a  
subobject of O_CMP1, and OC simila rly contains a  reference to i tself. A subobject 
with a reference to 
another objectother
(COMPOSITE1 )sub
(D)(C)ODOCO_COMP
ref
x
y
§8.8   ATTACHMENT: REFERENCE AND V ALUE SEMANTICS 261
This rule is open to criticism s ince it limits the modeling pow er of the approach.  
Earlier versions of this book’s notation did in f act permit ref erences to subobjects. But this  
possibility was found to cause more proble ms than it was worth:
•From the implementation’s perspective, the garbage collection m echanism must be  
prepared to deal with subobject references even if in a given e xecution there are few  
such references, or none at all . This caused a significant perf ormance degradation.
• From the viewpoint of modeling,  excluding subobject references  actually turned out  
to simplify system descriptions b y defining a single unit of re ferencing, the object.
The discussion will po int out what precise attachment rule woul d have to be  
modified to revert to the scheme  in which references may be att ached to subobjects.
8.8  ATTACHMENT: REFERENC E AND V ALUE SEMANTICS
(This section covers more specia lized information and you may s kip it on first reading.)
The introduction of ex panded types means tha t we must take a se cond look at two  
fundamental operations studied e arlier in this chapter: assignm ent, written :=, which  
attaches a reference to an object , and the associated compariso n operation, written =. Since  
entities may now denote objects a s well as references to object s, we must decide what  
assignment and equality will mean  in the first of  these cases.
Attachment
The semantics of assignment will  actually cover more than this operation. Another case in  
which the value of an entity may  change is argument passing in routine calls. Assume a  
routine (procedure or function) of the form 
r (…, x: SOME_TYPE , …)
Here entity x is one of the formal arguments  of r. Now consider a particular call to  
r, of one of the possible two for ms (unqualified and qualified):  
r (…, y, …)
t  r (…, y, …)
where expression y is the actual argument  having the same position in the list of actual  
arguments as x has in the list of formal arguments. other
(COMPOSITE1 )sub(E)
(C)OE
OCO_CMP1
ref
x
yWARNING : 
IMPOSSIBLE SITUATION  
(FOR PURPOSES OF 
ILLUSTRATION ONLY)A reference to 
a subobject
Garbage collection 
is studied in the next chapter .
If skipping , go to 
“DEALING WITH REFERENCES: BENEFITS AND DANGERS”, 8.9, page 265 .
THE RUN-TIME STRUCTURE: OBJECTS  §8.8 262
Whenever r gets started as a result of one of these calls, it initializes  each of its  
formal arguments with the value of the correspond ing actual arg ument, such as y for x. 
For simplicity and consistency, the rules governing such actual -formal argument  
associations are the same as the rules governing assignment. In  other words, the initial  
effect on x of such a call is  exactly as if x were the target of assignment of the form 
x := y
This rule yields a definition:
Exactly the same rules will be ap plicable in both cases to dete rmine whether an  
attachment is valid (d epending on the types of its target and s ource) and, if it is, what effect  
it will have at execution time. 
Reference and copy attachment 
We have seen a first rule for the effect of attachment when stu dying reference assignment.  
If both source and target are re ferences, then the effect of an  assignment 
x := y
and of the corresponding ar gument passing is to make x denote the same reference as  y. 
This was illustrated through several examples. If y is void prior to the attachment, the  
operation will make x void too; if y is attached to an object, x will end up attached to the  
same object. 
What now if the types of x and y are expanded? Reference  assignment would not  
make sense, but a copy (the shal low form) is possible. The mean ing of an attachment of  
an expanded source to an expande d target will indeed be a copy.  With the declarations 
x, y: expanded  SOME_CLASS
the assignment  x := y will copy every field of the object attached to y onto the  
corresponding field of t he object attached to x, producing the same effect as 
x  copy (y)
which of course is still legal i n this case. (In the case of re ference types, x := y a n d 
x  copy  (y) are both legal but have  different effects.) Definition: attachment
An attachment of y to x is either of the follo wing two operations: 
• An assignment of the form x := y. 
• The initialization of x at the time of a routine call, where x is a formal  
argument of a routine and y is the correspondin g actual argument in  
the call. 
In both cases, x is the target  of the attachment and y its source .
§8.8   ATTACHMENT: REFERENCE AND V ALUE SEMANTICS 263
This copy semantics for expanded  types yields the expected effe ct in the case of the  
basic types which, as noted above, are all expanded. For exampl e if m and n have been  
declared of type INTEGER , you will expect the assignment m := n, or a corresponding  
argument passing, to copy the value of n onto that of m. 
The analysis just applied to attachment transposes immediately to a related operation:  
comparison. Consider the boolean expressions x = y and x /= y, which will have opposite  
values. For x and y of reference types, as already noted, the tests compare refere nces: x =
y yields true if and only if x and y are either both void or both attached to the same object.  
For expanded x and y, this would not make sense; the only acceptable semantics is t o use 
field-by-field comparison, so that in this case x = y will have the same value as equal (x, y).
It is possible, as we will see in the discussion of inheritance , to adapt the semantics of  
equal to support a specific notion of equality for the instances of s ome class. This has no  
effect on the semantics of =, which, for safety and simplicity, is always that of the origi nal 
function standard_equal .
The basic rule for attachment and comparison, then, is summariz ed by the  
following observation:
Hybrid attachments 
In the cases seen so far, the so urce and target types of an att achment are of the same  
category — both expanded or both reference. What if they are of  different categories? 
First consider x := y where the target x is of an expanded type and the source y is of a  
reference type. Becau se reference assignment does not make sens e for x, the only acceptable  
semantics for this attachment is copy semantics: copy the field s of the object attached to y
onto the corresponding fields of the object attached to x. This is indeed the effect of the  
assignment in this case; but it only makes sense if y is non-void at the time of execution  
(otherwise there is no attached object). If y is void, the result will be  to trigger an exception.  
The effect of exceptions, and the specification of how to recov er from an exception, are  
discussed in a l ater chapter. 
For expanded x, the test x = Void  does not cause any abnormal event; it simply yields the  
result false. But there is no way we can find an acceptable sem antics for the assignment  
x := Void, so any attempt at executing it causes an exception. 
Now consider the other case: x := y where x is of a reference type and y i s  o f  a n  
expanded type. Then at run time y is always attached to an object, which we may call OY ,  
and the attachment s hould also attach x to an object. One possibi lity would be to attach x to 
OY . This convention, however, wo uld introduce the possibility o f references to subobjects,  
as in routine reattach  below: An attachment of y to x is a copy of objects x if x and y are of expanded types  
(including any of the basic types). It is a reference attachmen t if x and y are 
of reference types.
Similarly, an equality or inequality test x = y or x /= y is a comparison of  
objects for x and y of expanded types; it is a comparison of references if x and 
y are of reference types.“Fixed semantics 
for copy, clone and equality features”, page 583 .
See chapter 12 , in 
particular “Sources of exceptions”, page 412.
THE RUN-TIME STRUCTURE: OBJECTS  §8.8 264
class C feature
…
end
class  COMPOSITE2 feature
x: C
y: expanded  C
reattach
do x := y end
end
If, as suggested earlier, we pro hibit references  to subobjects,  we may in such a case  
prescribe that the attachment perform a clone  of OY . This will indeed  be the effect of the  
attachment for expande d source and referen ce target: attach the  target to a clone of the  
source object. 
The following table summarizes th e semantics of attachment in t he cases studied:
To allow references to subobjects, it would suffice to replace the clone semantics  
defined in the top-right entry by the semantics of reference at tachment.
Equality comparison 
The semantics of equality comparison (the = and /= signs) should be compatible with  
the semantics of attachment: if y /= z is true and you execute x := y, then both x = y and 
x /= z should be true immediatel y after the assignment.
Besides =, we have seen that there is an operation equal  applicable to objects. Which  
of these operations is available depends on the circumstances:
E1 •I f  x a n d  y are references, you can test both for reference equality and, if the 
references are not void, for object equality. We have defined t he operation x = y as 
denoting reference equality in this case. The equal  function was introduced to  
cover object equality; for completeness it also applies when x o r  y is void  
(returning true in this case only if both are). Type of source  y →
↓ Type of target x Reference Expanded
 
ReferenceReference attachment Clone; effect of  
x := clone (y)
 
ExpandedCopy; effect of  
x  copy (y) 
(will fail if y is void)Copy; effect of  
x  copy (y)Effect of 
attachment  
x := y
§8.9   DEALING WITH REFERENCES: BENEFITS AND DANGERS 265
E2 • If x and y are expanded, the only operation  that makes sense is object com parison. 
E3 • If x is a reference and y is expanded, object equality is also the only meaningful  
operation — again extended to accept void x, in which case it will return false since  
y cannot be void.
This analysis yields the desirable interpretation for = in all cases. For object  
comparison, equal  is always available, convenientl y extended to deal with cases in which  
one or both operands are void. = serves to apply reference comparison when it makes  
sense, defaulting to equal  in other cases:
By comparing with the preceding  table, you may check that = and /= are indeed  
compatible with := in the sense defined above. Recall in particular that equal (x, y) will be  
true as a result of x := clone (y) or x  copy (y).
This issue that we have just set tled arises in any language whi ch includes pointer or  
references (such as Pascal, Ada, Modula-2, C, Lisp etc.), but i s particularly acute in an  
object-oriented language in which all non-basic types are refer ence types; in addition, for  
reasons explained in the discussion section, the syntax does no t explicitly show them to  
be references, so we need t o be particularly careful.
8.9  DEALING WITH REFERENC ES: BENEFITS AND DANGERS
Two properties of the run-time model, as introduced in the prec eding sections, deserve  
further examination. One is the important role of references; t he other is the dual  
semantics of basic operations su ch as assignment, argument pass ing and equality tests  
which, as we have seen, produce different effects for reference  and expanded operands. 
Dynamic aliasing 
If x a n d  y a r e  o f  r e f e r e n c e  t y p e s  a n d  y is not void, the assignment x := y, or the  
corresponding attachme nt in a call, causes x and y to be attached to  the same object.     Type of y →
↓ Type of x Reference Expanded
 
ReferenceReference comparison equal (x, y) 
i.e. object comparison if x 
non-void, false if x void.
 
Expandedequal (x, y) 
i.e. object comparison if y
non-void, false if y void.equal (x, y) 
i.e. object comparison.Meaning of 
comparison  
x = y
THE RUN-TIME STRUCTURE: OBJECTS  §8.9 266
The result is to bind x and y in a durable way (until any further assignment to any of  
them). In particular, an operation of the form x  f, where f is some feature of the  
corresponding class, will have the same effect as y  f since they affect the same object. 
The attachment of x to the same object as y is known as dynamic aliasing: aliasing  
because the assignment makes an o bject accessible  through two r eferences, like a person  
known under two names; dynamic b ecause the aliasing occurs at r un time. 
Static aliasing, where a software text specifies that two names  will always denote the  
same value regardless of what happens at execution time, is als o possible in some  
programming languages: the Fortran EQUIVALENCE  directive states that two variables  
will always denote the contents of the same memory location; an d the C preprocessor  
directive  #define x y specifies that any further occurrence of x in the program text means  
exactly the same thing as y. 
Because of dynamic alia sing, attachment operations have a more far-reaching effect  
on entities of reference types t han on those of expanded types.  I f  x a nd  y a r e o f t y pe  
INTEGER , an example of expanded  type, the assignment x := y only resets the value of x
using that of y; but it does not durably bind x and y. For reference types, the assignment  
causes x and y to become aliases f or the same object. 
The semantics of aliasing 
A somewhat shocking consequence of aliasing (static or dynamic)  is that an operation may  
affect an entity that it does not even cite. 
Models of computation that do no t involve aliasi ng enjoy a plea sant property: the  
correctness of such extracts as
[NO SURPRISE]
-- Assume that here P ( y) holds
x := y
C (x)
-- Then here P ( y) still holds.
T h i s  e x a m p l e  a s s u m e s  t h a t  P (y) is an arbitrary property  of y, and C (x) some 
operation whose textua l description in the s oftware may involve  x but does not involve y. 
Correctness here means that the property of “NO SURPRISE” expre ssed by the comments  
is indeed satisfied: if P ( y) is true initially, then no action on x can invalidate this property.  
An operation on x does not affect a property of y.'A'
783x ySharing as a 
result of an 
attachment
§8.9   DEALING WITH REFERENCES: BENEFITS AND DANGERS 267
With entities of expanded types,  property NO SURPRISE indeed ho lds. Here is s  
typical example, assuming x and y of type INTEGER : 
-- Assume that here y >= 0
x := y
x := –1
-- Then here y >= 0 still holds.
In no way can the assignment to x have any effect on y in this case. But now consider  
a similar one involving dynamic aliasing. Let x and y be of type C, where class C is of the form 
class  C feature
boolattr : BOOLEAN  
-- Boolean attribute, modeli ng some object property.
set_true
-- Make boolattr  true.
do
boolattr := True
end
… Other features …
end
Assume that y is of type C and that its value at some run-time instant is not void.  
Then the following instance of t he above scheme violates proper ty NO SURPRISE: 
[SURPRISE, SURPRISE!]
-- Assume that y  boolattr  is false.
x := y
-- Here it is still true that y  boolattr  is false.
x  set_true
-- But then here y  boolattr  is true!
The last instruction of this extract does not involve y in any way; yet one of its effects  
is to change the  properties of y, as indicated by t he final comment. 
Coming to terms with dynamic aliasing 
Having seen the disturb ing consequences of reference assignment s and dynamic aliasing,  
one may legitimately ask why we s hould keep such a facility in our model of computation. 
The answer is twofold — partly theoretical and partly practical : 
• We need reference assignments if we are to benefit from the fu ll power of the object-
oriented method, in particular to describe complex data structu res. The issue here is  
again to make sure that our tool s are versatile enough for our modeling needs. 
• In the practice of object-oriented software construction, enca psulation makes it  
possible to avoid the dangers of reference manipulations. 
Let us examine these two important aspects in turn. x
y
boolattr False  True
THE RUN-TIME STRUCTURE: OBJECTS  §8.9 268
Aliasing in software and elsewhere 
The first observation is simply that many of the data structure s we will need require  
references and reference sharing.  Some standard data structures , for example, include  
c y c l i c a l l y  c h a i n e d  e l e m e n t s ,  w h i c h  y o u  c a n n o t  i m p l e m e n t  w i t h o u t  references. In  
r e p r e s e n t i n g  l i s t  a n d  t r e e  s t r u c t u r e s ,  i t  i s  o f t e n  c o n v e n i e n t  t o let every node contain a  
reference to its neighbor or par ent. The figure below shows a c ircular list representation,  
combining both of these ideas. O pen any textbook on fundamental  data structures and  
algorithms, as used in  introductory computi ng science courses, and you will find many  
such examples. With object techno logy we will want, if anything ,  t o  u s e  e v e n  m o r e  
sophisticated structures.
In fact the need for references, reference attachment and refer ence sharing already  
arises with quite unsophisticated data structures. Recall the c lasses used above to describe  
books; one of the variants was 
class BOOK3  feature
… Other features; …
author : WRITER
end
Here the need for refe rence sharing is simply a consequence of the property that two  
or more books may have the same author. Many of the examples of  this chapter also cause  
sharing; in the PERSON  case, several people may have t he same landlord . The question,  
as already noted, is modeling po wer, not just th e requirements of implementation. 
But then if b1 and b2 are two instances of BOOK3  with the same author, we have a  
case of aliasing: b1  author  and b2  author  are two references attached to the same object,  
and using any of them as target of a feature call will have exa ctly the same effect as using  
the other. Seen in this light, dynamic aliasing appears less as  a potentially dangerous  
software facility than as a fact of life, the price to pay for the convenience of being able to  
refer to things under more than one name. A linked 
circular list
first Sharedreferences
(aliasing)
Page 226 .
§8.9   DEALING WITH REFERENCES: BENEFITS AND DANGERS 269
It is indeed easy to find viola tions of the above NO SURPRISE p roperty without ever  
entering the software field. Cons ider the following property an d operation, defined for any  
book b: 
•NOT_NOBEL (b) stands for: “the author of b has never received the Nobel prize”. 
•NOBELIZE (b) stands for: “Give the Nobe l prize to the author of b”. 
Now assume rb d e n o t e s  t h e  b o o k  The Red and the Black  a n d  cp d e n o t e s  The 
Charterhouse of Parma . Then the following is a correct development: 
[SURPRISE IN OSLO]
-- Assume that here NOT_NOBEL (rb) holds
NOBELIZE (cp)
-- Then here NOT_NOBEL (rb) does not hold any more!
An operation on cp has changed a property of a different entity, rb, not even named  
in the instruction! T he consequences on rb may actually be quite significant (with a Nobel  
author an out-of-print book will be reprinted, its price may ri se etc.). In this non-software  
case exactly the same thing happens as when the operation x  set_true , in the earlier  
software example, produced  an important effect on y even though it d id not refer to y. 
So dynamic aliasing is not just a consequence of  programmers’ d irty tricks with  
references or pointers. It is a consequence of the human abilit y to name  things (“objects”  
in the most general se nse of the word), and to give many names to one thing. In classical  
rhetoric, this was known as a polyonymy , as with the use of “Cybele”, “Demeter” and  
“Ceres” for the same goddess, and antonomasia , the ability to refer to an object through  
indirect phrases, as with “The b eautiful daughter of Agammemnon ” for Helena of Troy.  
Polyonymy, antonomasia and the resulting dynamic aliasing are n ot restricted to gods and  
heroes; if in the cafeteria you overhear two conjectures from s eparate conversations, one  
stating that the spouse of the e ngineering Vice President just got a big promotion and the  
other that the company has fired  its accountant, you will not r ealize the contradiction —  
unless you know that the accountant is the VP’s husband. 
Encapsulating reference manipulations 
By now we have accumulated enough evidence that any realistic f ramework for modeling  
and software development must su pport the notion of reference, and consequently  
dynamic aliasing. How then do we cope with the unpleasant conse quences of these  
mechanisms? The inability to ensu r e  t h e  N O  S U R P R I S E  p r o p e r t y  i l lustrates how  
references and aliasing endanger our ability to reason systemat ically about our software,  
that is to say, to infer run-time properties of the software’s execution, in a safe and simple  
way, by examining the software text. 
To find an answer it helps to understand first how much of this  issue is specific to the  
object-oriented method. If you a re familiar with such programmi ng languages as Pascal,  
C, PL/I, Ada and Lisp you will probably have noted that much of  the above discussion  
applies to them as well. They all have a way of allocating obje cts dynamically (although  
in C the corresponding function, malloc , is in the library  rather than the l anguage proper)  Stendhal lived prior 
to the establishment of the prize , of 
course — and would probably not have got it anyway ; he did 
not even make it to the Académie .
THE RUN-TIME STRUCTURE: OBJECTS  §8.10 270
and of letting objects contain references to other objects. The  level of abstraction of the  
language mechanisms va ries significantly: C and PL/I pointers a re scantily dressed  
machine addresses; Pascal and Ad a use typing rul es to wrap poin ters in more respectable  
attire, although they do not need much promp ting to return to t heir original state. 
W h a t  t h e n  i s  n e w  w i t h  o b j e c t - o r i e n t e d  d e v e l o p m e n t ?  T h e  a n s w e r  l ies not in the  
theoretical power of the method (whose run-time structures are similar to those of Pascal or  
Ada, with the important differen ce of garbage collection, studi ed in the next chapter) but in  
the practice of software construc tion. O-O development implies reuse. In particular, any  
project in which many applicatio n classes perform tricky manipu lations (such as reference  
manipulation) is a flawed use of the object-oriented approach. Such operations should be  
encapsulated once and for all in library classes. 
Regardless of the application do main, if a system includes obje ct structures requiring  
non-trivial reference operations, the vast majority of these st ructures are not application-
specific but merely ins tances of such frequently needed and wel l-known structures as lists  
of various kinds, trees under var ious representations, graphs, hash tables and a few others.  
In a good O-O environment a libra ry will be readily available, offering many implementations  
of these structures; appendix A will sketch an example, the Base library. The classes of such  
a library may contain many operat ions on references (think for example of the reference  
manipulations n eeded to insert or delete an element in a linked  list, or a node in a tree using  
linked representation). The library should have been patiently crafted and validated, so as to  
take care of the tricky problems once and for all. 
If, as you are building the appl ication, you recognize the need  for complex object  
structures which are not adequat ely covered by the available li braries, you should look at  
them as requiring new general-pur pose classes. You should desig n and check them  
carefully, under the expectation that in due time they will bec ome part of some library.  
Using the terminology introduced  i n  a n  e a r l i e r  c h a p t e r ,  s u c h  a  case is an example of  
moving from a consum er’s to a producer ’s view of reuse. 
The remaining reference manipula tions in application-dependent classes should be  
restricted to simple and safe ope rations. (The bibliographical notes cite an article by  
Suzuki which explore s this idea further.)
8.10  DISCUSSION 
This chapter has introduced a num ber of rules and notations for  manipulating objects and  
the corresponding enti ties. Some of these co nventions may have surprised you. So it is  
useful to conclude our exploration of objects and their propert ies by examining the issues  
involved and the reasons behind t he choices made. Although I ho pe you will in the end  
agree with these choices, the mo re important goal of this discu ssion is to make sure that  
you fully understand the underly ing problems, so that even if y ou prefer a different  
solution you choose it  with your eyes open. “Reuse consumers, 
reuse producers”, page 69 .
§8.10   DISCUSSION 271
Graphical conventions 
To warm up let us begin with a little notational issue — a deta il, really, but software is  
sometimes in the details. This pa rticular detail is the set of conventions used to illustrate  
classes and objects in gra phical representations. 
The previous cha pter emphasized the importance of not confusing  the notions of  
class and object. Accordingly, t he graphical representations ar e different. Objects are  
represented as rectangles. Class es, as they appear in system ar chitecture diagrams, are  
represented by ellipses (connect ed by arrows representing the r elations between classes:  
single arrow for the i nheritance relation, d ouble arrow for the  client relation). 
Class and object representations  appear in different contexts: a class ellipse will be  
part of a diagram representing t he structure of a software syst em; an object rectangle will  
be part of a diagram r epresenting a snapshot of the state of a system during its execution.  
Because these two kinds of diagr am address completely different  p u r p o s e s ,  t h e r e  i s  
usually no opportunity in paper p resentations such as the prese nt book for having both  
class and object representations  appear in the same context. Bu t the situation is different  
with interactive CASE tools: dur ing the execution of a software  system, you may want (for  
example for debugging purposes) to look at a n object, and then display its generating class  
to examine the feature s, parents or other pr operties of that cl ass. 
The graphical conventions used f o r  c l a s s e s  a n d  o b j e c t s  a r e  c o m p atible with the  
standard established by Nerson and Waldén’s BON method. In BON (Business Object  
Notation), which is meant for us e in interactive CASE tools as well as for paper  
documentation, class yy-bubbles can be stret ched vertically so a s  t o  r e v e a l  a  c l a s s ’ s  
features, invariant, indexing wo rds, and other properties. 
As with any choi ce of graphical represen tation, there is no abs olute justification for  
the conventions used in BON and in this book. But if the graphi cal symbols at our disposal  
are ellipses and rectangles, and the elements to be represented  are classes and objects, then  
it does appear preferable to ass ign rectangles to objects: an o bject is a set of fields, so we  
can represent each field by a sm all rectangle and glue together  a set of fields to make up  
a bigger rectangle which  represents an object. 
A further conven tion, illustrated by the  figures of this chapte r, is to make expanded  
fields appear shaded, whereas re ferences fields are blank; subo bjects appear as smaller  
embedded rectangles, containing t heir own fields. All these con ventions follow from the  
decision to use rect angles for  objects. 
On the lighter side, it is hard to resist quoti ng the following  non-scientific argument,  
from Ian Graham’s critique o f an O-O analysis book that uses a diffe rent convention: 
Nor do I like showing classes as sharp corner ed triangles . I like to think that  
instances have sharp corn ers because if you drop them on your foot they  
hurt, whereas classes can’t hurt anyone and therefore have rounded corners .“The mold and the 
instance”, page 167.
On BON see the bib-
liographical notes and chapter 27.
From a review of 
Martin and Odell’s “Object-Oriented Analysis and Design” , in OOPS 
(British Computer 
Society O-O interest group newsletter ), 
16, Winter 1992 , 
pages 35-37 .
THE RUN-TIME STRUCTURE: OBJECTS  §8.10 272
References and simple values 
An important syntactical question is whether we should deal dif ferently with references  
and simple values. As noted, ass ignment and equality test have different meanings for  
references and for values of exp anded types — the latter includ ing values of basic types:  
integers and the like. Y et the s ame symbols are used in both ca ses: :=, =, /=. Is this not  
dangerous? Would it not be preferable to use different sets of symbols to remind the reader  
that the meanings are different? 
Using two sets of symb ols was indeed the solution of Simula 67.  Transposing the  
notation slightly so as to make i t compatible with those of the  present book, the Simula  
solution is to declare an en tity of a reference type C as 
x: reference  C
where the keyword reference  reminds the reader that instances of x will be references.  
Assuming the declarations 
m, n: INTEGER
x, y: reference  C
then different notations are use d for operations on simple and reference types, as  follows:
The Simula conventions  remove any ambiguity. Why not keep them then? The  
reason is that in practice they turn out in spite of the best i ntentions to cause more harm  
than help. The problems begin with a mundane matter: typing err ors. The tw o sets of  
symbols are so close that one te nds to make syntactical oversig hts, such as using := instead  
of :–. Such errors will be caught by the compiler. But although comp iler-checkable  
restrictions in programming languages are meant to help program mers, the checks are of  
no use here: either you know the difference between reference a nd value semantics, in  
which case the obligat ion to prove again, ea ch time you write a n assignment or equality,  
that you did understand this difference, is rather annoying; or  you do not understand the  
difference, but then th e compiler message will not help you muc h! 
The remarkable aspect of the Sim ula convention is that you do n ot in fact have a  
choice: for references, no prede fined construct is available th at would give value  
semantics. It might have seemed reasonable to allow two sets of  operations on entities a
and b of reference types: 
•a :– b for reference assignment, and a == b for reference comparison. 
•a := b for copy assignment (the equiva lent, in our notation, of eithe r a := clone (b) or 
a  copy (b)), and a = b for object comparison ( the equivalent of our equal (a, b)). OPERATIONEXPANDED 
OPERANDSREFERENCE 
OPERANDS
Assignment m := n x :– y
Equality test m = n x == y
Inequality test m /= n x =/= ySimula , covered in 
chapter 35 , abbrevi-
ates reference  to 
ref.
Simula-style 
notations for 
operations on reference and 
expanded 
values
§8.10   DISCUSSION 273
But this is not the ca se; for operands of re ference types, with  one exception, Simula  
only provides the first set of operations, and any attempt to u se := or = will produce a  
syntactical error. If you need operations of the second set (co py or clone, object  
comparison), you must write spec ific routines corresponding to our clone , copy  and equal
for each target class. (The exception is the TEXT  type, representing character strings, for  
which Simula does offer bo th sets of operations.) 
On further examination, by the wa y, the idea of a llowing both s ets of operations for  
all reference types does not app ear so clever. It would mean th at a trivial oversight such  
as typing := for :– would now go undetected by the compiler but produce an effect quite 
different from the programmer’s intent, for example a clone  where a reference assignment  
was intended. 
As a result of this analysis, th e notation of this book uses a different convention from  
Simula’s: the same symbols apply for expanded and reference typ es, with different  
semantics (value in one case, reference in the other). You can achieve the effect of value  
semantics for objects of referenc e types by using predefined ro utines, available on all  
types: 
•a := clone (b) or a  copy (b) for object assignment. 
•equal (a, b) for object (field-by-field) comparison. 
These notations are sufficiently  different from their reference  counterparts ( := and =, 
respectively) to avert a ny risk of confusion. 
Beyond the purely syntactical as pects, this issue is interestin g because it typifies  
some of the tradeoffs that arise in language design when a bala nce must be found between  
conflicting criteria. One criteri on, which won in the Simula ca se, may be stated as: 
• “Make sure different concepts a re expressed by different symbo ls”. 
But the opposing forces, which d ominated in the design of our n otation, say: 
• “Avoid bothering the software developer.” 
• “Weigh carefully any new restric tion against the actual benefi ts that it will bring in  
terms of security and other qual ity factors.” Here the restrict ion is the prohibition of
:= and similar operato rs for references. 
• “Make sure that the most common operations can be expressed by  short and simple  
notations.” The application of this principle requires some car e, as the language  
designer may be wrong in his guesses of what cases will be the most common. But  
in the present example it seems clear that on entities of expan ded types (such as  
INTEGER ) value assignment and c o m p a r i s o n  a r e  t h e  m ost frequent operati ons, 
whereas on references entities reference assignment and compari son are more  
frequent than clone, copy and ob ject comparison. So it is appro priate to use := and =
for the fundamental operations in both cases. 
THE RUN-TIME STRUCTURE: OBJECTS  §8.10 274
• “To keep the language small an d simple, do not introduce new n otations unless they  
are absolutely necessary”. This applies in particular if, as in  this example, existing  
notations will do the job and th ere is no danger of confusion. 
• “If you know there is a serious risk of confusion between two facilities, make the  
associated notations as differen t as possible.” This leads us t o avoid making both :–
and := available for the same opera nds with different semantics.
One more reason plays a role in the present case, although it i nvolves mechanisms  
that we have not yet studied. In later chapters we will learn t o write generic classes, such  
as LIST [G], where G, known as a formal generic param eter, stands for an arbitrary type. 
Such a class may manipul ate entities of type G and use them in assi gnments and equality  
tests. Clients that need to use the class will do so by providi ng a type to serve as actual  
generic parameter; for example they may use LIST [INTEGER ] or LIST [POINT ]. As 
these examples indicate, the act ual generic parameter may be an  expanded type (as in the  
first case) as well as a referen ce type (as in the second case) . In the routines of such a  
generic class, if a and b are of type G, it is often useful to use assignments of the form  
a := b or tests of the form a = b with the intent of obtaining v alue semantics  if the actual  
generic parameter is expanded (as with INTEGER ) and reference semantics if it is a  
reference type (as with POINT ). 
An example of a routine which needs such dual behavior is a pro cedure for inserting an  
element x into a list. The procedure creates a new list cell; if x is an integer, the cell must  
contain a copy of that integer, but if x is a reference to an object the cell will contain a  
reference to the same object. 
In such a case the rules defined  above ensure the desired dual behavior, which would  
have been impossible to achieve if a different syntax had been required for the two kinds  
of semantics. If, on the other h and, you want a single identica l behavior in all cases, you  
can specify it too: that behavior  can only be value semantics ( since reference semantics  
does not make sense for expanded  types); so in the appropriate routines you should use  
not := and = but clone  (or copy ) and equal . 
The form of clone and equality operations 
A  small point of style which may have surprised you is the form  under which routines  
clone  and equal  are called. The notations 
clone (x)
equal (x, y)
do not look very O-O at first; a dogmatic reading of the previo us chapter would suggest  
conventions that seem more in lin e with what was there called “ the object-oriented style  
of computation”; for example: 
x  twin
x  is_equal (y)“THE OBJECT-ORI-
ENTED STYLE OF COMPUTATION”, 7.7, page 181 .
§8.10   DISCUSSION 275
In a very early version of the notation, these were indeed the conventions. But they  
raise the problem of void refere nces. A feature call of the for m x  f (…) cannot be executed  
correctly if, at run time, the value of x is void. (In that case the call will trigger an exception  
which, unless the class contains  specific provis ions to recover  from the exception, will  
cause the execution of the entir e system to terminate abnormall y.) So the second set of  
conventions wo uld only work for non-void x. Because in many cases x may indeed be  
void, this would mean that most uses of twin would in practice be of the form 
if x = Void  then
z := Void
else
z := x  twin
end
and most uses of is_equal  of the form 
if
((x = Void ) and (y = Void )) or
((x /= Void ) and then  x  is_equal (y))
then
…
Needless to say, these conventions were not kept for long. We q uickly became tired  
of having to write such convolut ed expressions — and even more of having to face the  
consequences (run-time  errors) when we forgot. The conventions finally retained,  
described earlier in this chapter, have the pleasant property o f giving the expected results  
for void x: in that case clone (x) is a void value, and equal (x, y) is true if and only if y is 
also void. 
Procedure copy , called under the form x  copy (y), raises no particular problem: it  
requires x (and also y) to be non-void, but this requi rement is acceptable because it  is a 
consequence of the semantics of copy , which copies an object onto another and so does  
not makes sense unless both ob jects exist. The  condition on y,  as  e xp la i ne d i n a l at er  
chapter, is captured by an official precondition on copy  and so is present in a clear form in  
the documentation fo r this procedure.
It should be noted that a function is_equal  as introduced above exists. The reason is  
that it is often convenient to define specific variants of equa lity, adapted to a class and  
overriding the default semantics  of field-by-field comparison. To obtain this effect it  
suffices to redefine function is_equal  in the desired classes. Function equal  is defined in  
terms of is_equal  (through the ex pression shown above to illustrate the use of is_equal ),  
and so will follow i ts redefinitions.
In the case of clone , there is no need for twin. This is because clone  is simply defined  
as a creation plus a call to copy . So to adapt the meaning of clone  to the specific needs of  
a class it suffices to redefine procedure copy  for that class; clone  will automatically follow. and then is a variant 
of  and. See “Non-
strict boolean opera-tors”, page 454 .
See also “Fixed se-
mantics for copy, clone and equality features”, page 583.
THE RUN-TIME STRUCTURE: OBJECTS  §8.11 276
The status of universal operations 
The last comments have partly lif ted the veil on a question tha t have may caught your  
a t t e n t i o n :  w h a t  i s  t h e  s t a t u s  of the universal operations clone , copy , equal , is_equal , 
deep_clone , deep_equal ? 
Although fundamental in practice, these operations are not lang uage constructs.  
They come from a Kernel library class, ANY, which has the special property that every  
class written by a software deve loper automatically inherits (d irectly or indirectly) from  
ANY. This is why it is possible to redefine the features mentioned  to support a particular  
view of equality or copying. 
We need not concern ourselves with the details here, as they wi ll be studied together  
with inheritance. But it is usef ul to know that, thanks to the inheritance mechanism, we  
can rely on library classes to provide facilities that are then  made available to any class —  
and can be adapted by any class to suit its own specific purpos es. 
8.11  KEY CONCEPTS INTR ODUCED IN THIS CHAPTER 
• Object-oriented computation is c haracterized by a highly dynam ic run-time  
structure, where objects are crea ted on demand rather than pre- allocated. 
• Some of the objects manipulated by the software are (usually q uite indirect) models  
of outside objects. Others serve design and implementation purp oses only. 
• An object is made of a number of values called fields. Each fi eld corresponds to an  
attribute of the object’s generat or (the class of which the obj ect is a direct instance). 
• A value, in particular a field of  an object, is either an obje ct or a reference. 
• A reference is either void or a ttached to an object. The test x = Void  tells which of  
the two cases holds. A call with target x, such as x  f (…), can only be executed  
correctly if x is non-void. 
• If the declaration of a class begins with class  C …, an entity declared of type C will 
denote a reference, which may be come attached to instances of C. If the declaration  
begins with expanded  class  D …, an entity declared of type D will denote an object  
(an instance of D), and will never be void.
• The basic types ( BOOLEAN , CHARACTER , INTEGER , REAL , DOUBLE ) are 
defined by expa nded classes. 
• Expanded declarations also make  it possible to define composit e objects: objects  
with subobjects. 
• Object structures may contain  cyclic chains of references. 
• The creation instruction create  x creates an object, initializes its field to default  
values (such as void for referen ces and zero for numbers), and attaches x to it. If the  
class has defined creation proced ures, The instruction will als o perform, in the form  
create  x  creatproc  (…), any desired specific  initializations.“THE GLOBAL 
INHERITANCE STRUCTURE”, 16.2, page 580 .
§8.12   BIBLIOGRAPHICAL NOTES 277
• On entities of reference types, assignment ( :=) and equality test ( =) are reference  
operations. On entities of expand ed types, they represent copy and field-by-field  
comparison. They also have the a ppropriate seman tics for mixed operands. 
• Reference operations cause dynami c aliasing, which makes it mo r e  d i f f i c u l t  t o  
reason formally about software. In  practice, most non-trivial r eference  
manipulations should be encaps ulated in library classes. 
8.12  BIBLIOGRAPHICAL NOTES 
The notion of object identity pl ays an important role in databa ses, especially object-
oriented databas es. See chapter 31 and its bibliog raphical notes.
The graphical conventions of the  BON method (Business Object No tation), designed  
by Jean-Marc Nerson and Kim Waldén, appear in [Waldén 1995] . James McKim and  
Richard Bielak expound  the merits of multipl e creation procedur es in [Bielak 1994] .
The risks caused by unfettered po inter or reference operations have worried software  
methodologists for a long time, p rompting the inevitable sugges tion that they are the data  
equivalent of what abhorred goto instructions represent on the control side. A surprisingly  
little-known article by Nori Suzuki [Suzuki 1982]  explores whether a disciplined  
approach, using higher-level oper ations (in the same way that o ne avoids goto by sticking  
to the “structured programming” constructs of sequence, conditi onal and loop), could  
avoid the troubles of dynamic ali asing. Although the results ar e somewhat disappointing  
— by the author’s own admission — the article is useful reading .
I  a m  i n d e b t e d  t o  R o s s  S c a i f e  f r o m the University of Kentucky fo r help with  
rhetorical terms. See his page at http://www .uky.edu/ArtsSciences /Classics /rhetoric .html.
EXERCISES
E8.1  Books and authors
Starting from the various sketche s given in this chapter, write  classes BOOK  and WRITER
covering a useful view of books and their authors. Be sure to i nclude the relevant routines  
(not just the attributes as in most of this chapter). 
E8.2  Persons
Write a class PERSON  covering a simple notion of person, with attributes name  ( a 
STRING ), mother , father  and sibling  (describing the next older sibling if any). Include  
r o u t i n e s  w h i c h  w i l l  f i n d  ( r e s p e c tively) the list of names of an cestors, direct cousins,  
cousins direct o r indirect, uncles or a unts, siblings-in-laws, parents-in-laws etc. of a given  
person. Hint : write recursive procedures (bu t make sure to avoid infinite r ecursion where  
the relations, for example direct  or indirect cou sin, are cycli c.). 
THE RUN-TIME STRUCTURE: OBJECTS  §E8.3 278
E8.3  Notation design
Assume you are frequently using comparisons of the form x  is_equal (y) a nd  w a nt  t o  
simplify the notation to take ad vantage of infix features (appl icable here since is_equal  is 
a function with one argument). With an infix feature using some  operator §, the call will  
be written x § y. This little exerc ise asks you to invent a symbol for §, compatible with the  
rules on infix operators. There are of course many possible ans wers, and deciding between  
them is partly (bu t only partly) a ma tter of taste. 
Hint : The symbol should be easy to r emember and somehow suggest equ ality; but perhaps  
even more importantly it should be different enough from = to avoid mistakes. Here you  
can benefit from the study of C and C++ which, departing from m athematical tradition,  
use = for assignment rather than equal ity comparison, but for the la tter operation introduce  
a similar-looking symbol, ==. The matter is made even more delicate by the rule that  
permits treating an as signment as an expression, whose value is  the value bei ng assigned  
to the target, and by the rule accepting values such as integer s as boolean expressions,  
meaning true if non-zero, so tha t compilers will  accept a text of the form 
if (x = y) then  …
although in most practical cases it is in error (mistakenly usi ng = for ==), and will have  
the probably incorrect effect  of assigning the value of  y to x, returning true if and only if  
that value is non-zero. See “Operator fea-
tures”, page 187  
about infix features and permissible operators .
9  
Memory management 
Frankly, it would be nice  to forget about memory. 
Our programs would just  create objects as t hey please. One afte r the other, unused  
objects would vanish into abysses, while those most needed woul d slowly move closer to  
the top, like meritorio us employees of a large corporation who manage once in a while to  
catch the attention of a higher officer, and by making themselv es indispensable to their  
immediate superiors will with a bit of luck, at the end of a bu sy career, be admitted into  
the inner circle. 
But it is not so. Memory is not infinite; it does not harmoniou sly organize itself into  
a continuous spectrum of storage  layers with decreasing access speeds, to w hich objects  
would naturally distribute. We do need to fire our useless empl oyees, even if we must call  
it early retirement imposed with  regret because of the overall economic situation. This  
chapter examines who should be t hus downsized, how, and by whom . 
9.1  WHAT HAPPENS TO OBJECTS 
Object-oriented progra ms create objects. The previous chapter s howed how useful it is to  
rely on dynamic creation to obtai n flexible object structures, which automati cally adapt to  
the needs of a system’s execut ion in any particular case. 
Object creation 
We have seen the basic operation for allocating space to new ob jects. In its simplest form  
it appears as 
create  x
and its effect was defined as threefold: create a new object; a ttach it to the reference  x; and 
initialize its fields. 
A variant of the instruction call s an initialization procedure;  and you can also create  
new objects thr ough routines clone  and deep_clone . Since all these forms of allocation  
internally rely on basic creatio n instructions, we can restrict  ou r  at te nt i on t o  th e f or m  
create  x without fear of losing generality. 
We will now study the effect of su ch instructions on memory man agement.
MEMORY MANAGEMENT  §9.1 280
Three modes of object management 
First it is useful to broaden th e scope of the discussion. The form of object management  
used for object-oriented computa tion is only one of three commo nly found modes: static ,
stack-based  and free. The choice between these mode s determines how an entity can  
become attached to an object. 
Recall that an entity is a name in the software text representi ng a run-time value, or a  
succession of run-time values. Such values are either objects o r (possibly void) references  
to objects. Entities include attributes, formal routine argumen ts, local entities of routines  
and Result . The term attached  describes associations bet ween entities and objects: at  
some stage during execution, an entity x is attached to an object O if the value of x is either  
O (for x of expanded type) or a reference to O (for x of reference type). If x is attached to  
O, it is sometimes convenient to say also that O is attached to  x. But whereas a reference  
is attached to at most one object, an object may be attached to  two or more references;  
this is the problem of dynamic aliasing, discussed in the previ ous chapter. 
In the static mode, an entity may become attached to at most on e run-time object  
during the entire execution of th e software. This is the scheme  promoted by languages  
such as Fortran, designed to all ow an implementation technique which will allocate space  
for all objects (and attach them to the corresponding entities)  once and for all, at program  
loading time or at t he beginning of exe cution. 
The static mode is simple and supports efficient implementation  on the usual  
computer architectures. But it presents serious limitations: 
• It precludes recursion, since a recursive routine must be perm itted to have several  
incarnations active at once, each  with its own inc arnations of the routine’s entities. 
• It also precludes dynamically cr eated data structures, since t he compiler must be able  
to deduce the exact size of every data structure from the softw are text. Each array,  
for example, must be statically declared with its exact size. T his seriously limits the  
modeling power of the language: it is impossible to handle stru ctures that grow and  
shrink in response to run-time e vents, except by allocating the  maximum possible  
space for each of them — a technique that wastes memory, and is  rather dangerous  
since just one data structure ma y cause the whol e system execut ion to fail if its size  
has been underestimated. The static 
mode
FIXED MEMORY AREAObjects
§9.1   WHAT HAPPENS TO OBJECTS 281
The second scheme of object allo cation is the sta ck-based mode.  Here an entity may  
at run time become attached to s everal objects in succession, a nd the run-time mechanisms  
allocate and deallocate these ob jects in last-in, first-out ord er. When an object is  
deallocated, the corre sponding entit y becomes attached again to  the object to which it was  
previously a ttached, if any. 
Stack-based object management wa s made popular by Algol 60 and is supported  
(often in conjunction with one o r both of the other two modes) in most posterior  
programming languages. Stack-based allocation supports recursio n and, if the language  
permits it, arrays whose bounds only become known at run time. In Pascal and C,  
however, the mechanism only applie s to variables of basic types  and record types — not  
to arrays as it did in Algol. In  practice the data structures t hat developers w ould most often  
want to allocate in this fashion are precisely arrays. Even whe n it applies to arrays, stack-
based allocation  still does not support complex data structures  in their full generality. 
To obtain such general data stru ctures, we need the third and l ast scheme: the free  
mode, also called heap-based because of the way it is implement ed. This is the fully  
dynamic mode in which objects are created dynamically through e xplicit requests. An  
entity may become successively attached to any number of object s; the pattern of object  
creations is usually not predict able at compile time. Objects m ay, furthermore, contain  
references to other objects. 
The free mode allows us to create the sophisticated dynamic dat a structures which  
we will need if, as discussed in the previous chapter, we are t o take our software systems  
to their full modeling power. The stack-
based mode
Objects of block i
Memory allocated
on entry to block iMemory allocated
on entry to block i+1Objects of block i+1
Order of allocation
(on block entry)Order of
(on block exit)
THE STACKdeallocation
Dynamic arrays can 
be created in C through the malloc 
function , a mecha-
nism of the “free” kind, the mode stud-
ied next ; some Pas-
cal extensions support dynamic arrays . 
The free (heap-
based ) mode
THE HEAP
MEMORY MANAGEMENT  §9.1 282
Using the free mode 
The free mode is clearly the most  general, and is required for object-oriented computation.  
Many non-O-O languages use  it too. In particular: 
• Pascal uses the static mode for  arrays, the stack-based mode f or variables of type  
other than array or pointer, and the free mode for pointer vari ables. In the last case  
object creation is ach ieved by a call to a s pecial creation pro cedure, new. 
• C is similar to Pascal but in addition offers static non-array  variables and free arrays.  
Dynamic allocation of pointer var iables and arrays relies on a library function, malloc . 
• PL/I supports all modes. 
• Lisp systems have traditionally been highly dynamic, relying f or the most part on the  
free mode. One of the most important Lisp operations, used repe atedly to construct  
lists, is CONS , which creates a two-field cell, ready to serve as a list elem ent with the  
element’s value in the first field and a pointer to the next el ement in the second field.  
Here CONS , rather than explicit creation instructions, will be the princ ipal source of  
new objects 
Space reclamation in the three modes 
The ability to create objects dynamically, as in the stack-base d and free modes, raises the  
question of what to do when an ob ject becomes unused: is it pos sible to reclaim its memory  
space, so as to use it again for one or more new objects in lat er creation instructions? 
In the static mode, th e problem does not exi st: for every objec t, there is exactly one  
attached entity; execution needs to retain the object’s space a s long as the entity is active.  
S o  t h e r e  i s  n o  p o s s i b i l i t y  f o r  r e c l a m a t i o n  i n  t h e  p r o p e r  s e n s e .  A related technique is,  
however, sometimes used. If you are convinced that the objects attached to two entities  
will never be needed at the same time, if these entities need n ot retain their values between  
successive uses, and if space eff iciency is a critical problem,  you can assign the same  
memory location to two or more e ntities — if you are really sur e of what you are doing.  
This technique, known as overlay  is still, appallingly enoug h, practiced manually. 
If used at all, overlay should clearly be handled by automatic software tools, as the  
potential for errors is too high when programmers control the p rocess themselves. Once  
again a major problem is change: a decision to overlay two vari ables may be correct at a  
certain stage of the program’s evolution, but an unexpected cha nge may suddenly make  
it invalid. We will encounter similar problems below, in a more  modern context, with  
garbage collection. 
With the stack-based mode, the objects attached to an entity ma y be allocated on a  
stack. Block-structured language m ake things particularly simpl e: object allocation occurs  
at the same time for all entities  declared in a given block, al lowing the use of a single stack  
for a whole program. The scheme i s elegant indeed, as it just i nvolves two sets of  
concomitant events:  
§9.1   WHAT HAPPENS TO OBJECTS 283
The simplicity and efficiency of  this implementation technique are part of the reason  
why block-structured languag es have been so successful. 
With the free mode, things cease to be so simple. The problem c omes from the very  
power of the mechanism: since the pattern of object creation is  unknown at compile time,  
it is not possible to predict when a given o bject may become us eless. 
Detachment 
Objects may indeed, in the free mode, become useless to the sof tware at unpredictable  
times during execution, so that some mechanism (to be determine d later in this discussion)  
may reclaim the memory they occupy.
The reason is the presence in ou r execution mode  of operations performing what may  
be called detachment  — the reverse of attachment. The previous chapter studied at l ength 
h o w  e n t i t i e s  c a n  b e c o m e  a t t a c h e d  t o  o b j e c t s ,  b u t  d i d  n o t  e x a m i n e in any detail the  
consequences of detach ments. Now is the time to correct this. 
Detachment only affects entities  x of reference types. If x is of expanded type, the value  
of x is an object O, and there is no way to detach x from O. Note, however, that if x is an 
expanded attribute of some class, O represents a subobject of s ome bigger object BO;  
then BO, and with it O, may become unreachable for any of the r easons studied below.  
So for the rest of this chapter we may confine our attention to  entities of reference types.
The principal causes of detachme nt are the following, assuming x and y, entities of  
reference type, were initia lly attached to objects O1  and O2. The figure illustrates cases  
D1 and D 2. 
D1 • An assignment of the form x := Void , or x := v where v is void, detaches x from O1.Dynamic Property 
(event at execution time) Static Property (location in the software text) Implementation Technique
Object allocation Block entry. Push objects (one for each of the en tities local 
to the block) onto stack.
Object deallocation Block exit. Pop stack.Allocation and 
deallocation in a block-
structured 
language
Detachment
O1 O2x y z
O3 Attachments:
Before
After
MEMORY MANAGEMENT  §9.1 284
D2 • An assignment of the form y := z, where z is attached to an object other than O2,  
detaches y from O2.
D3 • Termination of a routine detach es formal arguments from any at tached objects.
D4 • A creation instruction create  x, attaches x to a newly created object, and hence  
detaches x if it was previously attached to an object O1.
Case D 3 corresponds to the rule given earlier that the semantics of an  assignment  
a :=  b is exactly the same as that of initializing a formal argument a of a routine r at the  
time of a call t  r (…, b, …), where the position of b in the call corresponds t o that of a in 
the declaration of r.
Unreachable objects 
Does detachment mean that the detached object — O1 or O2 on the  preceding figure —  
becomes useless and hence that t he runtime mechanisms can recla im the memory space it  
occupies, then recycle it for ot her objects? Tha t would be too easy! The entity for which  
an object was initially created may have lost all interest in i t, but because of dynamic  
aliasing other references may still be attached to it. For exam ple the last f igure may have  
shown only a partial view of atta chments; looking at a broader context might reveal that  
O1 and O2 are still reachable f rom other objects:  
But this is still not the entire  object structure. By getting e ven more context, we  
might now discover that O4 and O5 are themselves useless, so th at in the absence of other  
references O1 and O2 are  not needed after all. 
So the answer to the question “what objects can we reclaim?” mu st follow from a  
global analysis of the entire set  of objects created so far. We  can identify three kinds  
of object: 
C1 • Objects directly attached to en tities of the software text, kn own (from the language  
rules) to be needed. Detachment is 
not always death
O1 O2x y z
O3
O4O5
§9.1   WHAT HAPPENS TO OBJECTS 285
C2 • Dependents of objects of category C 1. (Recall that the direct dependents of an  
object are those to which it has references; here we are consid ering both direct and  
indirect dependents.) 
C3 • Objects which are in neither of the preceding tw o categories. 
The objects of category C 1 may be called the origins . Together with those of  
category C 2, the origins make up the set of reachable  objects. Those of category C3 are  
unreachable . They correspond to what was in formally called “useless object s” above. A  
more lively if somewhat macabre terminology uses the term “dead  objects” for C3, the  
origins and their dependents bei ng then called “live objects”. (Computing scientists,  
however, have not quite managed to reconcile their various meta phors, as the process of  
reclaiming dead objects, studied  below, is calle d “garbage coll ection”.) 
The term “root” is also used for  “origin”. But here the latter is preferable because an  
O-O system also has a “root object” and a root class. The resul ting ambiguity would  
not be too damaging since the root object, as seen below, is in deed one of the origins. 
The first step towards addressin g the problem of memory managem ent under the free  
mode is to separate the reachabl e objects from th e unreachable ones. To identify reachable  
objects, we must start from the o rigins and repeatedly follow a ll references. So the first  
question is to identify the origi ns; the answer depends on the run-time structure defined  
by the underlying language.
Reachable objects in classical approaches 
Because the unreachability probl em is already present in the ru n-time structure of such  
classical approaches as Pascal, C and Ada, it is interesting to  start with this case. (More  
accurately, this is interesting for the reader who is familiar with one of these approaches.  
If you are not in this category, you may prefer to skip this se ction and go directly to the  
next one, which moves right on to  the run-time structure of O-O  software.) 
The approaches quoted combine th e stack-based and free modes of  allocation. C and  
Ada also support the static mode , but to keep things simple we may ignore static allocation  
by viewing it as a special case of stack-based allocation: we t reat static objects as if they  
were allocated once a nd for all, when execut ion starts, at the bottom of the stack. (This is  
indeed the way Pascal developers  emulate static entities: they declare them in the  
outermost block.) 
Another common property of these approaches is that entities ma y denote pointers.  
To provide a better preparation for the object-oriented approac h of this book, where  
instead of pointers we use refer ences (a more abstract notion, as discussed in the previous  
chapter), let us prete nd that the pointers in question are actu ally references. This means in  
particular that we disregard the  weakly typed nature of pointer s in C. 
With these assumptions and simp lifications the origins, shown w ith thick borders on  
the following figure, are all the objects which are either allo cated on the stack or attached  
to references allocate d on the stack. The reachable objects (in cluding the origins) appear  
in color, the unreacha ble objects in black.
MEMORY MANAGEMENT  §9.1 286
Because the unreachability problem  only arises for objects allo cated under the free  
mode, and such objects are always  attached to entities of refer ence types, it  is convenient  
to ignore the reclamat ion problem for obje cts allocated on the stack (which can be handled  
simply by popping the stack at th e time of block exit) and to s tart from the references  
coming from the stack. We may call these references reference origins . They are shown  
with thick arrows in the figure.  A reference origin is either: 
O1 • The value of a local entity or routine argument of reference ty pe (as with the top  
two reference origins in the figure). 
O2 • A field of reference type, in an object allocated on the stack (as with the lowest  
reference origin i n the figure). 
As an example, consider the follo wing type and procedure declar ations, written in a  
syntax half-way between Pascal and the notation of the rest of this book (an entity of type  
reference  G is a reference that  may become attached  to objects of type G): 
type
COMPOSITE =
record
m: INTEGER
r: reference  COMPOSITE
end
…THE STACK
Stack top
Reference originOriginLive objects (in 
color)  and 
dead objects (in 
black ) in a 
combined 
stack-based 
and free model
§9.1   WHAT HAPPENS TO OBJECTS 287
procedure  p
local
n: INTEGER
c: COMPOSITE
s: reference  COMPOSITE
do
…
end
Every execution of p allocates three values on the stack:
The three new values are an integer n, which does not affect the problem of object  
management (since it will disapp ear when the procedure terminat es, and does not refer to  
any other object ); a reference s, which is an example of category O 1; and an object c of 
type COMPOSITE . This object is itself stack-ba sed and its allocated memory ma y be 
reclaimed on procedure termination; but it contains a reference  field for r, which is an  
example of category O 2. 
In summary , to determine the rea chable objects in a classical a pproach combining  
the stack-based and free modes, you can start from the referenc es on the stack (variables  
of reference types, and reference  fields of composite objects),  and repeatedly follow all  
reference fields of the a ttached objects if any. Entity 
allocation for a 
procedureTHE STACK
New stack top
Previous stack topmr
(COMPOSITE )c
ns
MEMORY MANAGEMENT  §9.1 288
Reachable objects in the object-oriented model 
The object-oriented run-time stru cture presented in the precedi ng chapter has a few  
differences from  the one just discussed.            
The execution of any system star ts with the creation of one obj ect, called the root  
object of the system, or just its root (when there is no confus ion with the root class, a static  
notion). Clearly, the root is one  of the origins in this case. 
Another set of origins arises because of the possible presence of local entities in a  
routine. Assume a r outine of the form
some_routine
local
rb1, rb2: BOOK3
eb: expanded  BOOK3
do
…
create  rb1
… Operations possi bly involving rb1, rb2 and eb …
end
Whenever a call to some_routine  is executed, and for the du ration of that  execution,  
the instructions in the ro utine’s body may refer to rb1, rb2 and eb, and hence to the  
attached objects if any. (For eb there is always an attached o bject, but at various points rb1
and rb2 may be void.) This means that such objects must be part of the  reachable set, even  
though they are not n ecessarily depende nts of the root. 
Local entities of reference types, such as rb1 and rb2, are similar to the local routine  
variables which, in the previous  model, were allocated on the s tack. Local entities of  
expanded types, such as eb, are similar to the stack-based objects. Reachability in 
the object-
oriented model
THE STACK
Stack topTHE ROOT
§9.1   WHAT HAPPENS TO OBJECTS 289
When a call to some_routine  terminates, the current incarnations of entities rb1, rb2
and eb disappear. As a result, any att ached objects cease to be part of the origin set. This  
does not necessarily mean that t hey become unreachable, as they  may in the meantime  
have become dependents of the  root object or other origins.
Assume for example that a is an attribute of the enclosing class and that the whole  
text of the routine is: 
some_routine
local
rb1, rb2: BOOK3
eb: expanded  BOOK3
do
create  rb1; create  rb2
a := rb1
end
The following figure shows in color  the objects that a call to some_routine will create  
and the references that it will reattach.
When a call to some_routine  terminates, the object O that  served as targe t of the call  
is still reachable (otherwise the re would have been no call!). The a field of O is now  
attached to the BOOK3  object B1 created by the firs t creation instruction (the one o f target  
rb1), which, then, remains reachable. In contrast, the objects B2 and EB that were attached  
to rb2 and eb during the call now become unrea chable: with the  routine text a s given there  
is no possibility that any of th e other objects of the system, reachable or not, could  
“remember” B2 or EB. Objects 
attached to 
local entities
THE STACKTHE ROOT
(BOOK3 )
Stack top before 
and after callStack top during execution of some_routine
rb2
rb1(BOOK3 )(BOOK3 )a
Objects and references in black 
exist before the call ; those in 
color  are created by the call .
Objects with   thick borders  
are reachable after the call .O
B1
B2EB
MEMORY MANAGEMENT  §9.1 290
The memory management problem in the object-oriented model 
W e  m a y  s u m m a r i z e  t h e  p r e c e d i n g  a nalysis by defining the origins , and hence of the  
reachable objects, in the object-oriented  framework:
The problem of memory management  arises from the unpredictabili ty of the  
operations which affect the set of reachable objects: creation and detachment. Because  
these operations are instruction s, appearing as part of a syste m’s control structures, there  
is usually no way to determine w ith certainty, from a mere exam ination of the software  
text, the pattern of ob ject creation and de tachment at run time . 
M o r e  p r e c i s e l y ,  s u c h  a  p r e d i c t i o n is possible in some cases, fo r data structures  
m a n a g e d  i n  a  s t r i c t l y  c o n t r o l l e d  w a y .  A n  e x a m p l e  i s  t h e  LINKED_LIST  library class  
studied in a later chapter, with the associated class LINKABLE  which describes linked list  
elements. Instances of LINKABLE  are only created through specific procedures of  
LINKED_LIST , and can only become unreachable as a result of executing the remove
procedure of that class. For suc h classes one might envision sp ecific reclamation  
procedures. (This  approach will be explore d later in this chapt er.) 
But such examples, although important, are only special cases. In the most general  
case we must face a difficult que stion: what do we do about unr eachable objects? 
The three answers 
Three general attitudes are possi ble as to objects  that become unreachable:
• Ignore the problem and hope that  there will be e nough memory t o accommodate all  
objects, reachable or not. This may be called the casual approach . 
• Ask developers to include in every application an algorithm th at looks for  
unreachable objects, and give th em mechanisms to free the corre sponding memory.  
This approach is called manual reclamation . Definition: origins, reachab le and unreachable objects
At any point during the execut ion of a system, the set of origins  is made  
of the following objects: 
• The system’s root object. 
• Any object attached to a local entity or formal argument of a  
routine currently being execute d (including the  local entity Result
for a function).
Any dependent, direct or ind irect, of these origins is reachable . Any other  
object is unreachable;  it is possible to reclaim the memory it occupies (for  
example to recycle it for other objects) without affecting the correct  
semantics of the system’s execution. 
About linked lists 
see “Linked list rep-resentation”, page 774, and subsequent 
sections .
§9.2   THE CASUAL APPROACH 291
• Include in the development envi ronment (as part  of the so-call ed runtime system)  
automatic mechanisms that will d etect and reclai m unreachable o bjects. This is  
called automatic garbage collection . 
The rest of this c hapter discusses these approaches. 
9.2  THE CASUAL APPROACH 
The first approach con sists in forgetting ab out the problem: ab andon dead objects to their  
fate. Execute creation instructio ns as needed, and do not worry  about what may later  
happen to those objects that have thus been allocated. 
Can the casual approach be justified? 
One case in which the casual app roach presents no particular pr oblem is that of systems  
that do not create many objects , such as small-s cale tests or e xperiments. 
More interesting is the case of systems that may in fact create  many objects, but in  
s u c h  a  w a y  t h a t  i t  i s  p o s s i b l e  t o  g u a r a n t e e  t h a t  n o n e  o r  v e r y  f ew of them become  
unreachable. As with the static a llocation scheme, no objects a re ever retired; the  
difference is that  creation occurs a t execution time. 
This case provides a good justification for the casual approach , as there is no need for  
reclamation. The number of objects created may still be too big  for the available memory,  
but no reclamation policy would a lleviate the problem if there is nothing to reclaim.
Some real-time programs  follow this scheme: for efficiency reas ons, they create all  
needed objects statically or at initialization time, avoiding a ny non-predictab le patterns of  
dynamic object creation. 
This method has its advocates, who usually are involved in the construction of “hard-
real-time” systems demanding gua ranteed sub-mill isecond respons e times to external  
events (such as a missile detection), and who as a consequence insist that the time to  
execute every operation must be fully predictable. But then mem ory management is only  
a small part of what we must give up: predictability requires t he absence of any kind of  
object allocation (creation instruction, malloc , recursion, possibly any call of a routine  
with local entities) after initialization; and it assumes a ded icated, single-user, single-
processing machine, with no pr eemptive operating system call an d in fact no operating  
system in the usual sense of the term. In such environments peo ple sometimes choose to  
program in assembly language, as t hey fear the additional unpre dictability of compiler-
generated code. All th is, of course, restricts the discussion t o a tiny (although strategic)  
part of the software  development world.
Do we care about memory any more? 
Another argument sometimes heard  to justify the casual approach  is the increasing  
availability of large memory spa ces, and the decreasing cost of  memory. 
MEMORY MANAGEMENT  §9.2 292
The memory involved may be virtu al as well as real. On a virtua l memory system,  
both primary and secondary memor y are divided into blocks calle d pages; when primary  
memory is needed, blocks of prim ary memory that have not been f requently used are  
moved to secondary memory (“page d out”). If such a system is us ed to run object-oriented  
systems, pages that contain reac hable objects will tend to be p aged out and leave main  
memory space to frequ ently used ones. 
If we indeed had almost infinite  amounts of almost free memory,  we could satisfy  
ourselves (as suggested at the v ery beginning of this chapter) with the casual approach.  
Unfortunately this is not the case. 
One reason is that in practice virtual memory is not really equ ivalent to real memory.  
If you store large numbers of objects in virtual memory, where a minority of reachable  
objects are interspersed with a majority of unreachable ones, t he system’s execution will  
constantly cause pages to be mov ed in and out, a phenomenon kno wn as thrashing  which  
leads to dramatic degr adation of time performance. Indeed, virt ual memory systems make  
it harder to separate the space a nd time aspects of efficiency.  
But there is a more serious limi tation to the casual approach. Even systems with a  
large memory have limits; it is always surprising to see how qu ickly programmers will  
reach them. And as was pointed out in the more general discussi on of efficiency, hardware  
advances — in time or in space —  should be put to good use. Lar ger memories are bought  
to be used, not wasted. 
As soon as you move beyond the c ase discussed above in which it  is possible to  
prove that only a small number of  objects will become unreachab le, you will have to face  
the reclamation problem. 
A byte here, a byte there, and soon we will be talking real cor pses 
It is time to lend our ears to the sad and edifying story of th e London Ambulance Service. 
The London Ambulance Service, sa id to be the lar gest in the wor ld, serves an area  
of about 1500 square kil ometers, a resident population of almos t seven million people and  
an even larger daytime  population. Every day  it handles over fi ve thousand patients and  
receives between two and  three thousand calls. 
As you may have guessed from the somber tone of this introducti on, computers (and  
more to the point computer software) got involved at some stage . At more than one stage,  
in fact: several attempted systems were discarded as inadequate  without being ever put  
into actual use, the latest in 1991, having burned seven and ha lf million pounds. Then in  
1992 a new system, developed at a cost of a million pounds, was  put into operation. It soon  
made headlines again; on October 28 and 29, television and pres s reports were announcing  
that twenty lives had been lost because of the system’s inadequ acy; in one particular case  
an ambulance crew is said to hav e radioed base on reaching the location of their call, to  
ask why the undertaker  had got there first. The Service’s chief  executive res igned and an  
inquiry commission was appointed. See “Efficiency”, 
page 9 .
 For the source of 
this information and of the quotes which follow , see the bib-
liographic notes , 
page 315 .
§9.3   RECLAIMING MEMORY: THE ISSUES 293
The Service did not immediately scrap the computerized system b ut switched to a  
hybrid mode — partly manual, partly relying on the system. Acco rding to the official report: 
This [hybrid ] system operated with reasonable success from the afternoon of 27 October 1992  
up to the early hours of 4 November . However , shortly after 2AM on 4 November the system  
slowed significantly and , shortly after this , locked up altogether . Attempts were made to re-boot  
(switch off and restart workstations ) in the manner that staff had previously been instructed by  
XX to do in these circumstances . This re-booting failed to overcome the problem with the result  
that calls in the system could not be printed out and mobilizations via [the system ] from incident  
summaries could not take place . Management and staff […] reverted fully to a manual , paper-
based system with voice or telephone mobilization .
What caused the system to fail in such a dismal way that it cou ld not be kept even as  
an adjunct to a manual operation? The inquiry report identifies  several reasons, but here  
is the clincher: 
The Inquiry Team has concluded that the system crash was caused by a minor programming error . 
In carrying out some work on the system some three weeks previously the XX programmer had  
inadvertently left in the system a piece of program code that caused a small amount of memory  
within the file server to be used up and not  released every time a vehicle mobilization was  
generated by the system . 
Over a three week period these activities had gradually used up all available memory thus causing  
the system to crash . This programming error should not have occurred and was caused by  
carelessness and lack of quality assurance of program code changes . Given the nature of the fault  
it is unlikely that it would have been detected through conventional programmer or user testing .
The reader will be the judge of how accurate it is to call the programming error  
“minor”, especially in view of t he crucial last comments (that the error would have been  
hard to find through testing), w hich will be discussed again be low. 
For anyone wondering whether the casual approach may be good en ough, and more  
generally for anyone who may be tempted to dismiss memory manag ement as “just an  
implementation issue”, the twent y victims of the London Ambulan ce Service will serve  
as a sobering reminder of the seriousness of the problems cover ed by this chapter. 
9.3  RECLAIMING MEMORY: THE ISSUES 
If we go beyond the ca sual approach and its simplistic assumpti ons, we must find how and  
when to reclaim memo ry. This in fact involves two issues: 
• How we will find out about dead elements ( detection ). 
• How the associate d memory is actually reclaimed ( reclamation ). 
For each of these tasks, we may look for a solution at any one of two possible levels: 
• The language implementation lev el — compiler and runtime syste m, providing the  
support common to all software w ritten in a certain language in  a certain  
computing environment.
• The application level — applicat ion programs, intended to solv e specific problems. “XX” in this quota-
tion and the next stands for the soft-ware company (named in the 
report ) which pro-
duced the system . 
MEMORY MANAGEMENT  §9.4 294
I n  t h e  f i r s t  c a s e  t h e  s e l e c t e d  m e mory management functions will  be handled  
automatically by the hardware-software machine. In the second c ase, each application  
developer has to take care o f these functi ons on his own.
T h e r e  i s  i n  f a c t  a  t h i r d  p o s s i b l e level, in-betw een these two: working at the  
component manufacturing  level, that is to say handlin g memory management functions  
in the general-purpose reusable library classes in an object-or iented environment. As at  
the application level, you can o nly use the programming languag e’s official mechanisms  
(rather than enjoying direct acce ss to hardware and operating s ystem facilities); but as at  
the language implementation level, you can address the memory m anagement problem, or  
part of it, once and for a ll for all ap plications.
Given two tasks and th ree possibilities for each, we are in pri nciple faced with nine  
possibilities. Actually, only f our or so make sense. We will re view those which are actually  
available in existing systems. 
9.4  PROGRAMMER-CONTROLLED DEALLOCATION
One popular solution is to provid e a reclamation facility at th e implementation level, while  
passing on the detection prob lem to software developers. 
This is certainly the easiest sol ution for language implementer s: all they have to do  
is to provide a primitive, say reclaim , such that a   reclaim  tells the runtime system that the  
object attached to a i s  no  lo ng er  n ee de d a nd  t he  co r re sp on di ng m em o ry  c el l s m a y be  
recycled for new objects. 
This is the solution adopted by such non object-oriented langua ges as Pascal  
(dispose  procedure), C ( free), PL/I ( FREE ), Modula-2 and Ada; you will also find it in  
most of the “hybrid object-orien ted languages”, in particular C ++ and Objective-C. 
This solution is favored by many programmers, especially in the  C world, who like  
to feel in full control of what happens. As a typical reaction here is a Usenet message,  
posted on the comp .lang.objective-c  discussion group in response to a suggestion that  
Objective-C could benefit from automatic reclamation:
I say a big NO ! Leaving an unreferenced object around is BAD PROGRAMMING . Object  
pointers ARE like ordinary pointers — if you [allocate an object ] you should be  
responsible for it , and free it when its finished with (didn't your mother always tell you to  
put your toys away when you'd finished with them ?).
For serious software development this attitude is not defensibl e. Grown-up  
developers must be prepared let someone else play with their “t o y s ”  f o r  t w o  r e a s o n s :  
reliability and ease  of development. 
The reliability issue 
Assume developers are i n control of dealloc ating objects with a  reclaim  mechanism. The  
possibility of an erroneous reclaim  is always lurking, especially in the presence of  
complex data structures. In part icular, as the software evolves , a reclaim  that used to be  
justified may become incorrect. Posting by Ian Ste-
phenson , 11 May 
1993 .
§9.4   PROGRAMMER-CONT ROLLED DEALLOCATION 295
Such a mistake causes what is known as the dangling reference  problem: the case in  
which an object keeps, in one of  its fields, a reference to ano ther object wh ich has been  
reclaimed. If the system then tries to use the reference after that object’s memory area has  
been recycled to hold wholly unr elated informati on, the result will usually be a run-time  
crash or (worse yet) errone ous and erratic behavior. 
This type of error is known to be the source of some of the mos t common and nasty  
bugs in the practice of C and derived languages. Programmers in  these languages  
particularly fear such bugs beca use of the difficulty of tracin g down their source, a  
difficulty that is easy to under stand: if the programmer forgot  to note that a certain  
reference was still attached to an object, and as a result wron gly issued a reclaim  on the  
object, it is often because the missed reference came from a co mpletely different part of  
the software. If so there will be  a great concept ual and physic al distance between the error  
(the wrong reclaim ) and its manifestation (a crash  or other abnormal behavior due  to an 
attempt to follow an incorrect reference); the latter may occur  long after the former, and  
in a seemingly unrelated part of the system. In addition the bu g may be hard to reproduce  
if the operating system does not  always allocate  memory in the same way.
Dismissing the issue, as in the Usenet message reproduced above , by claiming that  
only “BAD PROGRAMMING” leads to s uch situations, does nothing t o help. To err is  
human; to err when programming a c omputer is inevitable. Even i n a moderately complex  
application, no developer can be  trusted, or trust himself, to keep track of all run-time  
objects. This is a task for  computers, not people.
Many a C or C++ programmer has spent many a night trying to fig ure out what in  
the world could have happened to  one of his “toys”. It is not r are to see a project repeatedly  
delayed by such myst erious memory bugs.
The ease of development issue 
Even if we were able  to avoid erroneous reclaim calls, the question remains of how  
realistic it would be to ask deve lopers to handle object reclam ation. The snag is that,  
assuming you have positively iden tified an object that is up fo r reclamation, just releasing  
that object is usually not suff icient, as it may itself contain  references to other objects. 
Take the structure shown by the figure at the top of the next p age, the same one used  
in the previous chapter to describe the dynamic nature of objec t structures. Assume you  
have correctly deduced  that you may reclaim the top object. The n in the absence of any  
other references you may also reclaim the other two objects, wh ich it references directly  
in one case and indirectly in th e other. Not only may you recla im them, you should  do so:  
how good would it be to reclaim o nly part of a structure? In Pa scal terminology this is  
sometimes called the recursive dispose  problem: if the reclaim operations are to make any  
sense, they must recursively appl y to a whole data structure, n ot just to an individual  
object. But of course you need to make sure that no references remain to the other objects  
from the outside. Th is is an arduous and error-prone task. This figure origi-
nally appeared on page 226 . dispose , 
as noted , is the name 
of the Pascal proce-
dure for what is 
called reclaim  in this 
discussion .
MEMORY MANAGEMENT  §9.4 296
In this figure all the objects are of the same type. Consider n ow an entity x attached  
to an object O of type MY_TYPE , with the class  declaration 
class  MY_TYPE feature
attr1 : TYPE_1
attr2 : TYPE_2
end
Every object of type MY_TYPE , such as O, contains references which (unless void)  
are attached to objects of types TYPE_1  and TYPE_2 . Reclaiming O may imply that these  
two objects should als o be reclaimed, as well as any of their o wn direct or indirect  
dependents. Implementing the recursive dispose in this case mea n s  w r i t i n g  a  s e t  o f  
reclamation procedures , one for each type o f objects that may c ontain references to other  
objects. The result will be a se t of mutually recursive procedu res of great complication. 
All this leads to disaster. It i s indeed not uncommon, in langu ages that do not support  
automatic garbage collection, to  see a large part of the text o f an “application” system, and  
a large part of the development effort, being devoted to memory  management. Such a  
situation is unacceptable. As an application developer, you sho uld be able to concentrate  
on your job — solving applicatio n problems —, not become a book keeper or garbage  
collector (whichever metap hor is more appropriate). 
Needless to say, the increased s oftware complexity resulting fr om manual memory  
management results in decreased quality. In particular, it hamp ers readability and such  
other properties as ease of erro r detection and ease of modific ation. The resulting  
complexity further compounds the problem highlighted in the pre vious section —  
reliability. The more complex a system, the more likely it is t o contain errors. The sword  
of Damocles of a possible erroneous reclaim is always hanging over your head, likely to  
fall at the worst possible time:  when the system goes from test ing to product ion and, as a  
result, starts creating bigger a nd more intricate object struct ures. 
The conclusion is clear. Except i n tightly controlled situation s (as discussed in the  
next section), manual memory mana gement is not appropriate for serious software  
development — at least if ther e is any concern for quality. (PERSON1 )name
landlord
loved
(PERSON1 )name
landlord
loved
(PERSON1 )name
landlord
loved"Almaviva"
"Figaro” "Susanna"Direct and 
indirect self-
reference
§9.5   THE COMPONENT-LEVEL APPROACH 297
9.5  THE COMPONENT-LEVEL APPROACH
(This section describes a solutio n useful in a specific case on ly; you may skip it on first  
reading.)
B e f o r e  w e  m o v e  o n  t o  m o r e  a m b i t i ous schemes such as automatic g arbage  
collection, it is interesting to look at a solution which may b e described as a responsible  
alternative to the pre vious one, avoiding so me of its drawbacks . 
This solution is only applicable within an object-oriented, bot tom-up approach to  
software design, where data structures are not developed “on th e spot” as programs need  
them, but built as reusable classes: general-purpose implementa tions of abstract data  
types, with all the associat ed operations — features. 
What sets the object-oriented ap proach apart with respect to me mory management?  
Part of the novelty, rather than  technical, is organizational: with the method’s emphasis on  
reuse of libraries, there now st ands between the application de velopers and the  
implementers of the base technology (compiler and development t ools), a third group of  
people responsible for writing re usable components that impleme n t  t h e  m a i n  d a t a  
structures. Its members — who ma y of course participate at time s  i n  t h e  o t h e r  t w o  
activities — may be called the component manufacturers . 
The component manufacturers have  total control over all uses of  a given class, and  
so are in a better position to f ind an acceptabl e solution to t he memory management  
problem for all insta nces of that class. 
If the pattern of allocation and deallocation for the class is simple enough, the  
component manufacturers may be a ble to find an efficient soluti on which does not even  
require the underlyi ng runtime system to  p r o v i d e  a  s p e c i f i c  reclaim  routine; they can  
express everything in terms of h igher-level concepts. This may be called the component-
level approach. 
Managing space for a linked list 
Here is an example of the compon ent-level approach. Consider a class LINKED_LIST , 
describing lists that consist of a header and any number of lin ked cells, themselves  
instances of a class LINKABLE . The allocation and deallocation pattern for linked lists is  
simple. The objects of concern a re the “linkable” cells. In thi s example, the component  
manufacturers (the people responsible for classes LINKED_LIST  and LINKABLE ) know  
exactly how linkables are create d — by the insertion procedures  — and how linkables may  
become dead — as a result of the deletion procedures. So they c an manage the  
corresponding space in a specific way.
Let us assume that LINKED_LIST  has only two inse rtion procedures, put_right  and 
put_left , which insert a new element at the left and rig ht of the curre nt cursor position.  
Each will need to create exactly one new LINKABLE  object; they are the basic source of  
allocation due to LINKED_LIST . A typical implementation is: The next section is 
“AUTOMATIC MEMORY MAN-AGEMENT”, 9.6, page 301 . 
See illustrations of 
linked lists and LINKABLE objects 
on the next page.
MEMORY MANAGEMENT  §9.5 298
put_right (v: ELEMENT_TYPE )
-- Insert an element of value v to the right of cursor position.
require
…
local
new: LINKABLE
do
create  new  make (v)
 active    put_linkable_right (new)
… Instructions to update other links …
end
The creation instruction create  new   make (v) directs the language implementation  
level to allocate memory for a new object. 
In the same way that we control where objects are created, we k now exactly where  
they can become unreachable: thr ough one of the deletion proced ures. Let us assume three  
such procedures remove , remove_right , remove_left ; there may also be others such as  
remove_all_occurrences (which removes all occurren ces of a certain value) and wipe_out  
(which remove all elements), but we may assume that they intern ally rely on the first three,  
each of which makes exactly one LINKABLE  unreachable. Procedure remove , for 
example, may have the following form: 
remove
-- Delete element at cursor position.
do
…
 previous    put_linkable_right (next)
… Instructions to u pdate other links …
active := next
end
These deletion p rocedures provide the exact context for detecti ng unreachable  
objects and, if desired, putting them aside for later reuse. In  the absence of any automatic  
scheme for releasing memory, the  component manufacturer may saf ely conserve memory,  
by avoiding the allocation reques ted by an insertion when previ ous deletions have created  
unreachable LINKABLE objects and stored them so mewhere for later reuse. 
Assume we keep these instances of LINKABLE  in a data structure called available ; 
we will see below how to represe nt it. Then we may replace the creation instructions such  
as create  new  make (v) in put_right  and put_left  by 
new := fresh (v)
where fresh  is a new secret function of LINKED_LIST , which will return a ready-for-use  
linkable. Function fresh will attempt to obtain its result from the available  list, and will  
only perform a creation if the list is empty.active
vLINKABLE
object
active next previous
§9.5   THE COMPONENT-LEVEL APPROACH 299
Elements will be fed into available  by the deletion procedu res. For example, the  
body of remove  should now be of the form 
do
recycle (active )
-- The rest as before:
… Instructions to  update links: previous , next, first_element , active  …
where recycle , a new procedure of LINKED_LIST , plays the opposite role of fresh : adding  
its argument to the lis t of available objec ts. This procedure w ill be secret (not exported to  
any client) since it is f or internal use only.
Dealing with recycled objects
To implement fresh  a n d  recycle , we may, among other possible choices, represent  
available  as a stack: fresh  will pop from and recycle  will push onto the stack. Let us  
introduce a class STACK_OF_LINKABLES  for the occasion and add the following secret  
features to LINKED_LIST : 
available : STACK_OF_LINKABLES 
fresh (v: ELEMENT_TYPE ): LINKABLE
-- A new element with value v, for reuse in an insertion
do
if available   empty then
-- No choice but to perf orm an actual allocation
create  Result   make (v)
else
-- Reuse previously d iscarded linkable
Result := available   item; Result   put (v); available   remove
end
end
recycle (dead : LINKABLE )
-- Return dead  to the available list.
require
dead /= Void
do
available   put (dead )
end
We may declare class STACK_OF_LINKABLES  as follows: Exercise E23.1, page
807 (based on later 
methodological dis-cussions ), asks you 
to discuss whether it is proper for function fresh  to produce a 
side effect .
MEMORY MANAGEMENT  §9.5 300
class
STACK_OF_LINKABLES 
feature  {LINKED_LIST }
item: LINKABLE
-- Element at top
empty : BOOLEAN
-- Is there no item?
do
Result := (item = Void )
end
put (element : LINKABLE )
-- Add element  on top.
require
 element /= Void
do
element   put_right (item); item := element
end
remove
-- Remove last item added.
require
not empty
do
item := item   right
end
end
The stack representation, as pict ured, takes advantage of the right field already present  
in every LINKABLE  to link all recycled elements without using any extra space. LINKABLE
must export right  and put_right  to STACK_OF_LINKABLES  as well as LINKED_LIST . 
Feature available , as declared, is an attribute of the class. This means that ea ch 
linked list will have its own sta ck of linkables. It is of cour se a better use of space, if a  
given system contains several lis ts, to share the pool of recyc led linkables over the whole  
system. The technique to do this, once functions , will be introduced later; making  
available  a once function means that only one instance of the class will  exist throughout  
a given system execution, achieving the desired goal.
Discussion 
This example shows what the comp onent-level approach can do to alleviate the problem  
of space reclamation by treating it at the compone nt manufactur ing level. It assumes that  
the underlying language implement ation does not offer the autom atic mechanisms  
described in the next sections; rather than burdening applicati on programs with memory  
management problems, with all the risks discussed earlier, the solution presented assigns  
both detection and reclamation to  the basic reusa ble classes. itemright
right
right(top of stack)
Stack elements
… 
Exercise E9.3, page 
316, and E9.4 . On 
once functions see “CONSTANTS OF CLASS TYPES”, 18.3, page 646 . 
§9.6   AUTOMATIC MEMORY MANAGEMENT 301
The drawbacks and benefits are c lear. Problems of manual memory  management  
(reliability risks, tediousness) d o  n o t  m a g i c a l l y  v a n i s h ;  c o m i n g up with a foolproof  
memory management scheme for a particular data structure, as do ne above for linked lists,  
is hard. But instead of letting each application developer cope  with the issue, we assign  
this job to component manufactur ers; it should fi t well in thei r general task of chiseling  
out high-quality reusable components. The extra effort is justi fied by the benefits of  
having good compon ents available for frequ ent use by many diffe rent appli cations.
The component-level ap proach assumes a data structure whose pat terns of creation  
and obsolescence are simple and perfectly understood. This cove rs only certain cases; for  
many structures the pattern is unpredictable or too complicated . When the approach is  
applicable, it provides a better solution, when the underlying language system does not  
offer automatic memory management , than letting each applicatio n developer try to  
handle the problem manually, or not handle it at all.
9.6  AUTOMATIC MEMORY MANAGEMENT
None of the approaches seen so f ar is fully satisfactory. A gen eral solution to the problem  
of memory management for objects  involves doing a serious job a t the language  
implementation level. 
The need for automatic techniques 
A  good O-O environment should of fer an automatic memory managem ent mechanism  
which will detect and reclaim un reachable objects, allowing app lication developers to  
concentrate on their job — application development. 
The preceding discussion should suffice to show how important i t is to have such a  
facility available. In the words of Michael Schweitzer and Lamb ert Strether: 
An object-oriented program withou t automatic memory management is  
roughly the same as a pressure cooker without a safety valve : sooner or later  
the thing is sure to blow up ! 
Many development environments a dvertized as O-O still do not su pport such  
mechanisms. They may have other features which make them attrac tive at first; and indeed  
they may work nicely on small systems. But for serious developm ent you run the risk that  
they will let you down as soon a s the applicati on reaches real size. To summarize in the  
form of concrete advice:
Two major approaches are applica ble to automatic memory managem ent: reference  
counting and garbage co llection. They are b oth worth examining,  although the second one  
is by far the more powerful and generally applicable. In choosing an O-O environment — or just an O-O language compil er — 
for production development, restrict your attention to solution s that offer  
automatic memory management.From [Schweitzer 
1991],  page 57 . 
MEMORY MANAGEMENT  §9.7 302
What exactly is reclamation? 
One technical point before we look at reference counting and ga rbage collection. With any  
form of automatic stor age management, the question arises of wh at it concretely means  
for the mechanism to “reclaim” a n object which it has detected as being unreachable. Two  
interpretations a re possible: 
• The mechanism may add the object’s memory to a “free cell list ” which it constantly  
maintains, in line with the techniques used by the earlier comp onent-level scheme.  
A subsequent creat ion instruction ( create  x…) will then look first in this list to find  
space for the desired new object ; only if the list is empty, or  contains no appropriate  
cell, will the instruction requir e memory from the underlying o perating system. This  
may be called the  internal free list  approach. 
• Alternatively, reclaiming an object may mean returning the ass ociated memory to  
the operating system. In practice,  this solution will usually i nclude some aspects of  
the first: to avoid the overhead of repeated system calls, recl aimed objects will  
temporarily be kept in a list, whose contents are returned to t he operating system  
whenever their combined size rea ches a certain threshold. This may be called the  
actual reclamation  approach. 
Although both solutions  are possible, long-running systems (in particular systems  
that must run forever) require actual reclamation. The reason i s easy to understand:  
assume an application which neve r stops creating objects, of wh ich a large proportion will  
eventually become unreachable, so  that there is an upper bound on the total number of  
objects reachable at any one time, even though the total number  of created objects since  
the beginning of a session is unb ounded. Then with the internal  free list approach it is  
possible to have a situation wher e the application will forever  keep asking for more  
memory even though its actual memory needs are not growing. An exercise at the end of  
this chapter asks you to construc t a pattern that will exhibit this behavior.
It would be frustrating to have automatic memory management and  still find  
ourselves in the London Ambulance Service situation — encroachi ng byte by byte on the  
available memory for no good reason, until execution runs out o f space and ends in disaster. 
9.7  REFERENCE COUNTING 
The idea behind the first automa tic memory manag ement technique , reference counting,  
is simple. In every object, we k eep a count of the number of re ferences to the object; when  
this count becomes null, the object may be recycled. 
This solution is not hard to imp lement (at the language impleme ntation level). We  
must update the reference count of any object in  response to al l operations that can create  
the object, attach a new referenc e to it and detach a reference  from it. 
Any operation that creates an object must initialize its refere nce count to one. This  
is the case in particular with the creation instruction create  a, which creates an object and  
attaches it to a. (The case of clone  will be studied shortly.)Exercise E9.1, page 
316.
§9.7   REFERENCE COUNTING 303
Any operation that attaches a new reference to an object O must  increase O’s  
reference count by one. Such atta chment operations are of two k inds (where the value of  
a is a reference attached to O): 
A1 •b := a (assignment). 
A2 •x  r (…, a, …), where r is some routine (a rgument passing).
Any operation which detaches a r eference from O must decrease i ts reference count  
by one. Such detachment opera tions are of two kinds: 
D1 •A n y  a s s i g n m e n t  a := b. Note that this is also an attachment operation (A1)  for the  
object attached to  b. (So if b was also attached to O we will both increment and  
decrement O’s count, l eaving it unchanged —  the desired outcome .)
D2 • Termination of a routine call of the form x  r (…, a, …). (If a occurs more than once  
in the list of actual arguments we must count one detachment pe r occurrence.) 
After such an operation, the imp lementation must also check whe ther O’s reference  
count has reached value  zero; if so, it may reclaim the object.
Finally the case of clone  must be handled carefully. The operation a := clone (b), 
which duplicates the object OB attached to b, if any, and attaches the resulting new object  
OA to a, must not duplicate the reference count. Instead, it must init ialize the reference  
count of OA to one; in addition, if OB had any non-void referen ce fields, it must increase  
by one, for every such field, the  reference count of the attach ed object. (If two or more  
fields are attached to a single object, its reference count wil l be increased as many times.)
One obvious drawback of referenc e counting is the performance o verhead in both  
time and space. For every operat ion on references the implement ation will now execute  
an arithmetic operation — and, in the detachment case, a condit ional instruction. In  
addition, every object must be ext ended with an extra field to hold the count.
But there is an even more serious problem which makes reference  counting,  
unfortunately, of littl e practical use. (“Unfortunately” becaus e this technique is not too  
hard to implement.) Th e problem is cyclic st ructures. Consider once again our staple  
example  of a structure with mut ually referring objects:
Uncollectible 
cyclic structure
"Almaviva" name
landlord
loved_one
"Figaro" name
landlord
loved_one"Susanna"
landlord
loved_oneO
a
O1
O3 O24
1 2name
MEMORY MANAGEMENT  §9.8 304
The objects in the ri ght part of the  figure, O1, O 2 and O3, con tain cyclic references  
to each other; assume that no ou tside object other than O conta ins a reference to any of  
these objects. The cor responding reference counts have been dis played below each object.
Now assume that (as suggested by the ) the reference from O  to O1 is detached,  
for example because a routine call with target O executes the i nstruction 
a := Void
Then the three objects on the ri ght have become unreachable. Bu t the reference  
counting mechanism will never det ect this situati on: the above instruction decreases O1’s  
count to three; after that the r eference counts of the three co lored objects will stay positive  
forever, preventing them  from being reclaimed. 
Because of this problem, referenc e counting is only applicable to structures which  
are guaranteed never to include any cycle. This makes it unsuit able as a general-purpose  
mechanism at the language implem entation level, since it is imp ossible to guarantee that  
arbitrary systems will not creat e cyclic structures. So the onl y application that would seem  
to remain is as a technique to b e used by library developers at  the component  
manufacturing level. Unfortunately if the component-level techn iques of the previous  
section are not applicable it is  usually because the structures  at hand are too complex, and  
in particular because they contain cycles. 
9.8  GARBAGE COLLECTION 
The most general techn ique, and in fact the only fully satisfac tory one, is automatic  
garbage collection, or just gar bage collecti on for short. 
The garbage collection mechanism 
A garbage collector is a facilit y included in the runtime syste m for a programming  
language. (The runtime system, o r just runtime for short, is a component of the  
programming language’s implementa tion; it complements the compi ler by providing the  
mechanisms needed at execution t ime to support the execution of  software systems written  
in the language.) The garbage collector will take care of both detecting and reclaiming  
unreachable objects, without the need for explicit handling by application software —  
although application so ftware may have vari ous facilities at it s disposal to control the  
collector’s operation. 
A detailed exploration of garbage  collection techniques would j ustify a book of its  
own (which remains to be written). Let us take a look at the ge neral principles of garbage  
collectors and the problems that they raise, focusing on the pr operties that are directly  
relevant to applic ation developers.
See the bibliographi-
cal notes on page 315 for references on garbage collection . 
§9.8   GARBAGE COLLECTION 305
Garbage collector requirements
A garbage collector should, of co urse, be correct. This is actu ally two requirements:
It is just as easy to write a sound collector (never collect an y object) as a complete one  
(collect all objects); the difficulty is of course to achieve b oth properties in a  single product.
Soundness is an absolute requirement: better no garbage collect or than one which,  
once in a while, steals an activ e object from your application!  You must be able to trust  
memory management blindly; in fa ct, you should be able to forge t about it most of the time,  
being content enough to know tha t someone, somehow, collects th e mess in your software  
the same way someone, somehow, collects the garbage in your off ice while you are gone  
— but does not take away your bo oks, your computer, or the fami ly pictures on your desk.
Completeness is desirable too, since without it you may still f ace the problem that the  
garbage collector was supposed t o solve: memory wasted on usele ss objects. But here we  
may be able to accept less than perfection: a quasi-complete co llector could still be useful  
if it collects the bulk of the ga rbage while occasionally missi ng an object or two.
Let us refine and improve this  observation. In reality you will want any industrial-
grade collector to be complete, lest you get back to the uncert ainties of env ironments with  
no memory management. Completenes s is in practice just as neces sary as soun dness, but  
less pressing if we rephrase the definition as: “every unreacha ble object will ultimately  be 
collected”. Suppose that we can make the collection process mor e efficient overall  
through an algorithm t hat eventually colle cts every unreachable  object but may lag in  
getting to some of them: such a scheme would be acceptable for most applications. This  
is the idea of “generation scavenging” algorithms discussed bel ow, which for efficiency’s  
sake spend most of their efforts  scanning the memory areas most  likely to contain  
unreachable objects, and take car e of the remaining areas at le ss frequent intervals.
If we start considering such tradeoffs it will be necessary to characterize a garbage collector,  
beyond the yes-no criteria of soundness and completeness, by a more quantitative property  
which we may call timeliness : the time it takes — both the average value and the upper  
bound will be interesting — between the moment an object become s unreachable and the  
moment the collector, assum ed to be both sound and complete, re claims it.
The definition of soundness illuminates the difficulties associ a t e d  w i t h  g a r b a g e  
collection for some languages, an d the respective roles of a la nguage and its  
implementation. Why, for example, is garbage collection usually  not available for C++?  
The reasons most commonly cited are cultural: in the C world ea ch developer is supposed  
to take care of his toys (in Ste phenson’s words); he simply doe s not trust any automatic  
mechanism to manage his own business. But if this were the true  reason, rather than a  
posteriori justification, C++ envi ronments could at least offer  garbage collection as an  
option, and most do not.Garbage collector properties
Soundness : every collected ob ject is unreachable.
Completeness : every unreachable object will be collected.
MEMORY MANAGEMENT  §9.8 306
The real issue is language desi gn, not compiling technology or even cultural  
attitudes. C++, in the C traditi on, is rather weakly typed, pro viding casts  —  t y p e  
conversions — through which you can refer to an object of a cer tain type thr ough an entity  
of another type, with f ew restrictions on po ssible type combina tions. The syntax
(OTHER_TYPE ) x
denotes x viewed as an entity of type OTHER_TYPE , related or not to the true type of x. 
G o o d  C + +  b o o k s  c e n s u r e  t h e  w i l d e r applications of this common p ractice, but  
methodological aspersions are of  no use to the compiler writer,  who must deal with the  
language as defined. Now imagine  the following scenario: a refe rence to an object of some  
useful type, say NUCLEAR_SUBMARINE , is temporarily cast into an integer; the garbage  
collector jumps in and examines the value, seeing nothing but t he most innocent-looking  
of integers; finding no other re ference to the object, it recla ims it; but now the program  
casts the integer back to its true vocation of nuclear submarin e reference; and it tries to  
access the now inexiste nt object, with cons equences of great so rrow to all affected.
Various techniques have been pro posed around this problem. Beca use they usually  
involve some restrictions on the use of the language, they have  not found their ways into  
common commercial offerings. The J ava language may be viewed as  a form of C++ which  
has dramatically restr icted the type system — going so far as t o remove genericity and  
multiple inherita nce — to make ga rbage collection  possible at l ast in a C-based world.
With a carefully designed type s ystem, it is of course possible  to provide the whole  
power of multiple inheritance an d genericity while ensuring typ e safety and language  
support for efficien t garbage collection.
Garbage collection basis 
Let us come now to how a g arbage collector works.
The basic algorithm usually includes two phases, at least conce ptually: mark and  
sweep. The mark phase, starting from the  origins, follows references r ecursively to  
traverse the active part of the s tructure, marking as reachable  all the objects it encounters.  
The sweep phase traverses the wh ole memory structure, reclaimin g unmarked elements  
and unmarking everything. 
As with reference counting, objects must include an extra field , used here for the  
marking; but the space overhead is negligible, since one bit su ffices per object. As will be  
seen when we study dynamic binding, implementation of O-O facil ities requires that every  
object carry some extra internal  information (such as its type)  in addition to its official  
fields corresponding to the attrib utes of the generating class.  This information typically  
occupies one or two words per ob ject; the marking bit can usual ly be squeezed into one of  
these extra words, so that in pr actice there is no observable o verhead. 
All-or-nothing collection 
When should the garbage c ollector be triggered? 
Classical garbage collectors are  activated on demand and run to  completion. In other  
words the garbage collector is i nactive as long as there is som e memory left to the  
application; when the applicatio n  r u n s  o u t  o f  m e m o r y ,  i t  t r i g g e rs an entire garbage  
collection cycle — mark phas e followed by sweep phase. The origins are the 
objects directly attached to entities of the software text . 
See “Reachable objects in the object-oriented model”, page 288 . 
§9.8   GARBAGE COLLECTION 307
This technique may be called the all-or-nothing approach. Its a dvantage is that it  
causes no overhead as long as th ere is enough memory; the progr am is only penalized by  
memory management when it has exceeded availa ble resources. 
But all-or-nothing garbage collection has a serious potential d rawback: a complete  
mark-sweep cycle may t ake a long time — especially in a virtual  memory environment in  
which filling the memor y means filling a very large virtual add ress space, which the  
garbage collector will then have to traverse entirely, all that  time preventing the  
application from proceeding.
This scheme may be acceptable for batch applications, although with a high ratio of  
virtual to real memory thrashing  may cause serious performance degradation if a system  
creates many objects and a large proportion of them become unre achable. All-or-nothing  
garbage collection will not work,  however, for interactive or r eal-time systems. Imagine a  
missile interception system which has a 50-millisecond window t o react when an enemy  
missile is fired. Assume everyth ing works fine until the softwa re runs out of memory, at  
which stage it defers to the garb age collector; but — bad luck — this is precisely when the  
missile comes in! Even in less l ife-threatening applications, s uch as a interactive systems,  
it is not pleasant to use a tool (for example a text editor) wh ich, once in a while, gets  
unpredictably hung for ten minute s or so because the underlying  implementation has  
entered a garbage collection cycle. 
In such cases th e problem is not necessa rily the global effect of garbage collection  
on efficiency: a certain overall performance pena lty may be per fectly tolerable to users  
and developers as the price to p ay for the gain in reliability and convenience afforded by  
automatic garbage colle ction. But such a penalty should be even ly spread; what will  
usually not be acceptable is the  unpredictable bursts of memory  management activity  
caused by the all-or-nothing app roach. Better a tortoise than a  hare which, once in a while  
and without warning, takes a hal f-hour nap. Reference counting,  were it not for its fatal  
flaw, would satisfy this observa tion that uniformly slow is oft en preferable to usually fast  
but occasionally unpredictable. 
Of course the penalty, besides be ing uniform, must also be smal l. If the application  
without a garbage collector is a indeed a hare, no one will rea lly settle for a tortoise; what  
w e  c a n  a c c e p t  i s  a  s o m e w h a t  l e s s  a g i l e  h a r e .  A  g o o d  g a r b a g e  c o l lector will have an  
overhead of 5% to 15%. Although so me managers, developers and u sers will scream that  
this is unacceptable, I know ver y few applications that cannot tolerate this kind of cost,  
especially in light of the obviou s observation that in the abse nce of garbage collection the  
software will have to perform manual reclamation, which does no t come for free either  
(even if we concentrate on execution overhead only and disregar d the overhead on  
development time and the reliabi lity problems). Unfortunately m ost of the few  
benchmarks that exist in this ar e a  e n d  u p ,  i n  t h e i r  e f f o r t  t o  m easure the measurable,  
comparing the incomparable: a system executed with no garbage c ollection and no manual  
reclamation, versus one running with garbage collection. Even u nder this unfavorable  
light, however, a performance cos t in the quoted range makes ga rbage collection shine. 
This discussion has identified t he two complementary efficiency  issues for garbage  
collectors: overall performance  and incrementality . 
MEMORY MANAGEMENT  §9.8 308
Advanced approaches to garbage collection 
A good collector should  provide good perfor mance both overall a nd incrementally,  
making itself suitable for interactive or even real-time applic ations. 
A first requirement is to give de velopers some control over the  activation and de-
activation of collector cycles. I n particular, the environment’ s libraries should offer procedures 
collection_off
collection_on
collect_now
such that a call to the first spe cifies that no collector cycle  should start until further notice;  
a call to the second resumes nor mal operation; and a call to th e third immediately triggers  
a complete cycle. Then if a syst em contains a time-critical sec tion, which must not be  
subject to any unpredictable delay , the developer will put a ca ll to collection_off  at the  
beginning of the section and a call to collection_on  at the end; and at any point where the  
application is known to be idle (for example during certain inp ut or output operations) the  
developer may, if usef ul, include a call to collect_now . 
A more advanced technique, used i n some form by most modern gar bage collectors,  
is known as generation scavenging . It follows from the experimental observation that  
“old objects will stay around”: the more garbage  collection cyc les an object has survived,  
the better chance it has of surv iving many more cycles or even remaining forever  
reachable. This property is precious since the sweep part of ga rbage collection tends to  
consume a considerable amount of  time, so that the collector wi ll greatly benefit from any  
information allowing it to exami ne certain categories less freq uently than others. 
Generation scavenging will detect objects that have existed for  more than a certain  
number of cycles. This is called tenuring  (by analogy with the mechanisms that protect  
instances of the real-life class PROFESSOR  o n c e  t h e y  h a v e  s u r v i v e d  a  f e w  c y c l e s  o f  
university politics). Tenured objects will be set aside and han dled by a separate collection  
process, which will run  less frequently tha n the collector of “ young” objects. 
Generation scavenging helps incr ementality, but does not fully achieve it, since there  
remains a need to perform fu ll collections occasionally. 
Practical implementations of gen eration scavenging use many var iations on this  
basic idea. In particular, it is common to divide objects not j ust into young and old, but  
into several generations, with d ifferent policies for collectin g the various generations.  
These ideas have a cons iderable effect on t he overall performan ce of garbage collection.
Parallel garbage collection algorithms 
To obtain a full solution to the  incrementality problem, an att ractive idea (if  the underlying  
operating system supports multipr ocessing) is to assign garbage  collection to a separate  
thread of control.  This is known as on-the-fly , or parallel , garbage collection. 
W i t h  o n - t h e - f l y  g a r b a g e  c o l l e c t i o n ,  e x e c u t i o n  o f  a n  O - O  s y s t e m  involves two  
separate threads (ofte n corresponding to tw o separate processes  of the operating system):  
the application and the collecto r. Only the application can all ocate memory, through  
creation instructions;  only the collector ca n free memory, thro ugh reclaim  operations. 
§9.9   PRACTICAL ISSUES O F GARBAGE COLLECTION 309
The collector will run continuou sly, repeatedly executing a mar k phase followed by  
a sweep phase to detect and pick  up the application’s unreachab le objects. Think of an  
endless New York ticker-tape par ade, forever marching through t he streets of the city. The  
application is the parade, gener ously scattering, wherever it p asses, objects of all kinds;  
the garbage collector is the cle aning squad which follows at a short distance, gathering all  
that has been left.
The separate threads of control need not be physically distinct  processes. With  
modern operating systems they can be threads; or, to avoid the overhead of switching  
between processes or even threads, they may be plain coroutines . Even so, however, on-
the-fly garbage collection tends  in practice to have unsatisfac tory overall performance.  
This is regrettable since the me thod’s incrementality is indeed  (with Dijkstra’s algorithm,  
see the reference in the bibli ographic notes) quite good. 
In my opinion (the proper word he re, since this comment reflect s hope, not a  
scientifically established result) parallel garbage collection remains the so lution of the  
future, but will require cooperat ion from the hardware. Rather than stealing time from the  
processor which handles the application, garbage collection sho uld be handled by a  
separate processor, ent irely devoted to that task and designed so as to interfere as little as  
possible with the proces sor or processors de voted to the applic ation. 
This idea requires changes to the dominant hardware architectur e s  a n d  s o  i s  n o t  
likely to be widely implemented soon. But in an answer to the s ometimes asked question
“What kind of hardware support would be most useful for object technology ?”
the presence of a separate garba ge collection pr ocessor should,  I believe, be the first item  
on the wish list. 
9.9  PRACTICAL ISSUES OF GARBAGE COLLECTION 
An environment providing automat ic memory management through ga rbage collection  
must not only use excellent garb age collection algorithms but a lso provide a few facilities  
w h i c h ,  a l t h o u g h  n o t  c e n t r a l  t o  a  t h e o r y  o f  m e m o r y  m a n a g e m e n t ,  a r e  e s s e n t i a l  f o r  t h e  
practical use of t he environment. 
Class MEMORY  
Several of the required faciliti es can be provided in the form of features callable by  
application software. As always in such case s (facilities to be  used by developers who  
need to tune or adapt a basic me chanism of the method and langu age) the most convenient  
approach is to group these features in a class, which we will c all MEMORY . Then any class  
that needs these facilities will inherit from MEMORY . 
A similar approach will be used for adapting the exception hand ling mechanism (class  
EXCEPTIONS ) and the concurrency mechanism (class CONCURRENCY ). 
Among the features of class MEMORY  will be the procedures discussed earlier for  
stopping the collection mechanism,  resuming it, and triggering a full collection:  
collection_off , collection_on , collect_now .The notion of corou-
tine will be intro-duced in the concurrency chap-ter. See “Corou-
tines”, page 1012 .
See “ADVANCED 
EXCEPTION HAN-DLING”, 12.6, page 431 about EXCEP-
TIONS  and 
“REQUESTING SPECIAL SER-VICE”, 30.8, page 998 about CON-
CURRENCY .
MEMORY MANAGEMENT  §9.9 310
A disposal mechanism 
Another important procedure of MEMORY  is dispose  (not to be confused with its Pascal  
namesake, which frees memory). I t addresses an important practi cal problem sometimes  
called finalization . If the garbage collector recla ims an object that is associate d with some  
external resources, you may wish  to specify a certain action — such as freeing the  
resources — to be executed at re clamation time. A typical examp le is a class FILE , whose  
instances will represent files of the operating system. It is d esirable to have a way of  
specifying that whenever the garb age collector reclaims an inst ance of FILE  t h a t  h a s  
become unreachab le it will call a certai n procedure to close th e associated physical file.
More generally let us assume a procedure dispose  which executes the operations  
needed at the time an instance of the class is reclaimed. With a manual approach to  
memory management no particular problem would arise: it would s uffice to include a call  
to dispose just before every call to reclaim . The “destructors” of C++ take care of both  
operations: dispose  and reclaim . With a garbage collector, however, the software does not  
directly control (for all the good reasons that we have explore d) the moment at which an  
object is reclaimed; so it is impossible to include explicit ca lls to dispose  at the right places. 
The answer relies on the power o f object technology and in part icular on inheritance  
and redefinition. (These techniqu es are studied in later chapte rs but their application here  
is simple enough to be understan dable without a d etailed grasp of their princ iples.) Class  
MEMORY  has a procedure dispose , whose body performs  no action at all: 
dispose
-- Action to be taken in case of reclamation  by garbage collect or;
-- nothing by default.
-- Called automatically by garbage collector.
do
end
T h e n  a n y  c l a s s  w h i c h  r e q u i r e s  s p e c i a l  d i s p o s e  a c t i o n s  w h e n e v e r  the collector  
reclaims one of its instances will redefine procedure dispose  to perform these actions. For  
example, assuming that class FILE  has a boolean attribute opened  and a procedure close , 
both with the obvious semantics, it will redefine dispose  appropriately: 
dispose
-- Action to be taken in case of reclamation  by garbage collect or:
-- close the  associated file if open.
-- Called automatically by garbage collector.
do
if opened then
close
end
end
As the comments indicate, the ru le is that any object reclamati on will cause a call to  
dispose  — either the original empty procedure for the (by far commones t) case in which  
no redefinition has occurred in the generating class, or the re defined version. 
§9.9   PRACTICAL ISSUES O F GARBAGE COLLECTION 311
Garbage collection and external calls 
A well-engineered object-oriente d environment with garbage coll ection must address  
another practical problem. O-O s oftware will in many cases have  to interact with software  
written in other languages. In a later chapter we will see how best to ensure this interaction  
with the non-O-O world. 
If your software indeed uses calls to routines written in other  languages (called  
external routines  in the rest of this d iscussion), you may have to pass to these  routines  
references to objects. This cause s a potential danger with resp ect to memory management.  
Assume that an external routine is of the following form (trans posed to the appropriate  
foreign la nguage): 
r (x: SOME_TYPE )
do
…
a := x
…
end
where a is an entity which may retain its value between successive act ivations of r; for 
example a could be a global or “static” variable in traditional language s, or a class attribute  
in our O-O notation. Consider a call r (y), where y is attached to some object O1. Then it  
is possible that some time after  the call O1 becomes unreachabl e from the object-oriented  
side while there is still a reference to it (from a) in the external software. The garbage  
collector could — and eventually  should — reclaim O1, but this is wrong.
For such cases we must provide p rocedures, callable from the ex ternal software,  
which  will protect a retain ed  o bject from the co llector , and  te rminate such protection.  
These procedures may be called under the form 
adopt (a)
wean  (a)
and should be part of any interfa ce library supporting the comm unication between object-
oriented and external software. The C interface library of the mechanism described in the  
next section supports such a faci lity. “Adopting” an object tak es it off the reach of the  
reclamation mechanism; “weaning”  it makes it rec laimable again.  
Passing objects to non-object-ori ented languages and retaining references to them  
from the foreign side of the bor der is of course risky business . But it is not always possible  
to avoid it. For example an object-oriented project may need a special interf ace between  
the O-O language and a n existing database management system; in  such cases you may  
need to let the other side retai n information about your object s. Such low-level  
manipulations should never appear in normal application softwar e, but should be  
encapsulated in utility classes,  written with particular care s o as to hide the details from  
the rest of the softwa re and protect it agai nst possible troubl e.See “INTERF AC-
ING WITH NON-O-O SOFTWARE”, 13.1, page 439 .
MEMORY MANAGEMENT  §9.10 312
9.10  AN ENVIRONMENT WITH MEMORY MANAGEMENT 
As a conclusion let us take a pe ek at how one particular enviro nment — the one presented  
more broadly in the last chapter  of this book — handles memory management. This will  
give an example of practical, sta te-of-the-art approaches to th e problem.
Basics
Memory management is automatic. The environment includes a garb age collector, which  
is always on by default . It is sufficiently  unobtrusive to have  caused users to call and ask  
“what should I do to turn on the garbage collector ?”, only to be told that it is already on!  
In normal usage, inclu ding interactive appli cations, you will n ot notice it. You can turn it  
off through collection_off  as discussed earlier.
Unlike the collectors found in many other environments, the gar bage collector does  
not just free memory for reuse by further object allocations in  the same system execution,  
but actually returns it to the operating system for use by othe r applications (at least on  
operating systems that do provid e a mechanism to free memory fo r good). We have seen  
how essential that property was,  especially for systems that mu st run permanently or for a  
long time.
Additional engineering goals pres ided over the garbage collecto r design: efficient  
memory collection; small memory overhead; incremental behavior (avoiding blocking the  
application for any sign ificant period of time).
Challenges
The garbage collector must face the following issues, following  from the practical  
constraints on object allocation  in a modern, O-O  environment:
• O-O routines can call external f unctions, in particular C funct ions, which have their  
own needs for memory allocation. We must therefore consider tha t there are two  
distinct kinds of memory: obje ct memory and external memory.
• All objects are not created equal . Arrays and strings have a va riable size; instances of  
other classes have a fixed size.
• Finally, as noted, it is not enough to free memory for reuse by  the O-O application:  
we must also be able to give it back for good to the operating system.
For these reasons, memory allocation cannot rely on the standar d malloc system call  
which, among other lim itations, does not ret urn memory to the o perating system. Instead,  
the environment asks the operati ng system’s kernel for memory c hunks and allocates  
objects in these chunks us ing its own mechanisms.
Object movement
The need to return memory to the  operating system is the source  of one of the most delicate  
parts of the mechanism: garbage collection can mo ve objects aro und.
§9.10   AN ENVIRONMENT WITH MEMORY MANAGEMENT 313
This property has by far caused the most headaches in the imple mentation of the  
collector. But it has also made the mechanism robust and practi cal; without it there would  
be no way to use garba ge collection for lo ng-running, mission-c ritical systems.
If you stay within the O-O world you need not think about objec t movement, except  
as a guarantee that your system will not expand forever, even i f it keeps creating new  
objects (provided the t otal size of reachab le objects is bounde d). But you will need to  
consider this pr operty if you also use e xternal routines, writt en for example in C, and pass  
objects to them. If the C side st ores somewhere, in the form of  a  p l a i n  a d d r e s s  ( a  C  
pointer), a reference to an object from the O-O world, you may be in trouble if it tries to  
use it without protection ten mi nutes later: by then the object  may have moved elsewhere,  
and the address may contain some thing completely different, or nothing at all. A simple  
library mechanism solves the issue: the C function should “acce ss” the object and access  
it through the appropriate macro , which will find the object wh erever it is.
Garbage collection mechanism
Here is an outline of the algorit hm used by the g arbage collect or.
Rather than a single algorithm t he solution actually relies on a combination of basic  
algorithms, used together (for s ome of them) or independently. Each activation of the  
collector selects an algorithm o r algorithm combination based o n such criteria as the  
urgency of the memory need. The basic algorithms include genera tion scavenging, mark-
and-sweep and memory compaction, plus a few others less relevan t to this discussion.
The idea behind generation scavenging  w a s  d e s c r i b e d  e a r l i e r  i n  t h i s  c h a p t e r :  
concentrate on young objects, si nce they have the greatest like lihood of yielding  
collectable garbage. A main adva ntage of this algorithm is that  it need not explore all the  
objects, but only those which can be reached from local entitie s, and from old objects  
containing references to young objects. Each time the algorithm  processes a generation,  
all the surviving objects become  older; when they reach a given  age, they are tenured to  
the next generation. The algorit hm looks for the right tradeoff  between low tenure age (too  
many old objects) and high tenure age (too frequent scavengings ).
The algorithm still ne eds, once in a while, to perform a full mark-and-sweep  to find  
any unreachable objects that gen eration scavenging may have mis sed. There are two steps:  
mark recursively explores and mar ks the reachable objects; sweep traverses applicable  
memory and collects the marked objects.
Memory compaction  compacts memory, returning unused parts to the operating  
system, at the lowest possible c ost. The algorithm divides the memory into n blocks and  
takes n–1 cycles to compact them all.
MEMORY MANAGEMENT  §9.10 314
Bulimia and anorexia
Since operating system calls (allocate memory, return memory) a re expensive, the  
memory compaction algorithm is co nservative: rather than return ing all the blocks that  
have been freed, it will keep a few of them around to build a s mall reserve of available  
memory. This way if the applica tion starts shortly afterwards t o allocate objects again the  
memory will be readily available , without any need to call the operating system.
Without this technique , the fairly frequent  case of a bulimic-a norexic application —  
an application that regularly goe s into a mad allocation binge,  followed by a purge period  
during which it gets rid of many objects — would cause the memo ry management  
mechanism consta ntly to get memory from the operating system, r eturn it, then ask again.
Garbage collector operation
The garbage collector gets into action when one of the two oper ations that request  
memory, a creation instruction ( create  x…) or a clone, triggers it. The trigger criterion is  
not just that the application ha s run out of memory: preferring  prevention to cure, the  
mechanism may activate  itself when it dete cts various condition s in advance of actual  
memory exhaustion.
If the primary allocation area i s full, the collector will exec ute a scavenging cycle. In  
most cases this will free enough  memory for the current needs. If not, the next step is to  
g o  t h r o u g h  a  f u l l  m a r k - a n d - s w e e p  c o l l e c t i o n  c y c l e ,  g e n e r a l l y  f o llowed by memory  
compaction. Only if all this fai ls to provide the required spac e will the application, as a  
last resort, ask the operating s ystem for more memory, if it is  still not possible to allocate  
a new object.
The main algorithms are incremen tal, and their time consumption  is a few percent of  
the application’s execution time . Internal statistics keep trac k of the memory allocated and  
help determine the proper algorithm to call.
You can tune the collector’s beh avior by setting various parame ters; in particular,  
selecting the speed  o p t i o n  w i l l  c a u s e  t h e  a l g o r i t h m s  n o t  t o  t r y  t o  c o l l e c t  a l l  a v a ilable 
memory (through the compaction m echanism described above) but i nstead to call the  
operating system’s allocation fa cilities earlier. This optimize s speed over compactness.  
The various parameter-setting mechanisms are obtained, like collection_off , collect_now  
and dispose , from class MEMORY .
The memory management mechanism resu lting from the combination of all these  
techniques has made it possible to develop and run successfully  the kind of large,  
ambitious applications which nee d to create many objects, creat e them fast, and (while  
remaining careful about overall usage of space) let someone els e worry about the  
mundane consequences.
§9.11   KEY CONCEPTS INTR ODUCED IN THIS CHAPTER 315
9.11  KEY CONCEPTS INTRODUCED IN THIS CHAPTER 
• There are three basic modes of object creation: static, stack- based and free. The last  
is characteristic of object-orie nted languages but also occurs elsewhere, for example  
in Lisp, Pascal (pointers and new), C ( malloc ), Ada (access types).
• In programs that create many objects, objects may become unrea chable; their  
memory space is lost, leading to  memory waste and, in extreme c ases, failure from  
lack of space even though some space is not used. 
• The issue may be safely ignored  in the case of programs that c reate few unreachable  
objects, or few objects altogeth er as compared to the available  memory size. 
• In all other cases (highly dynamic data structures, limited me mory resources), any  
solution will involve  two components: detection  of dead objects, and reclamation  of 
the associated space. 
• Either task may be handled by t he language imple mentation, the  component  
manufacturing level or  application programs. 
• Leaving application programs in charge of detection is cumbers ome and dangerous.  
So is a memory reclamation opera tion in a high-level language. 
• I n  s o m e  c o n t e x t s ,  i t  i s  p o s s i b l e to provide simple memory mana gement at the  
component level. Detection is ha ndled by the components; reclam ation, by either the  
components or the lang uage implementation. 
• Reference counting is inefficient , and does not work for cycli c structures. 
• Garbage collection is the most general technique. It is possib le to keep its potential  
overhead on normal system execut ion acceptably low and, through  sufficiently  
incremental algorithms, not visib le in normal interactive appli cations. 
•Generation scavenging  improves the efficiency of ga rbage collection algorithms by  
using the observation that many objects die (become unreachable ) young.
• A good memory management mechan ism should retur n unused space not just to the  
current application but to the operating system.
• A practical memory management s cheme was described, offering a  combination of  
algorithms and ways for application developers to tune the mech anism, including  
turning garbage collection off  and on in sensi tive sections.
9.12  BIBLIOGRAPHICAL NOTES 
A broader perspective on the dif ferent models of object creatio n, discussed at the  
beginning of this chapter , is provided by the “ contour model ” of programming language  
execution, which  may be found in [Johnston 1971] . 
The information about the London Ambulance Service fiasco comes  f r o m  a n  
extensive set of messages posted on the Risks forum ( comp .risks Usenet newsgroup)  
moderated by Peter G. Neumann, i n April and October of 1992. I relied particularly on  
several messages by Br ian Randell — quotin g journal articles ( The Independent , 29 and  
30 October 1992) and BBC bulletins — as well as Trevor Jenkins,  Jean Ramaekers, John  
MEMORY MANAGEMENT  §E9.1 316
Jones, Tony Lezard, and Paul Johnson (to whom I am grateful for  bringing this example  
to my attention). The primary comp .risks  issue on this topic is 14.4 8; see also 13.38, 13.42,  
13.43, 14.02. The newsgroup arch ives are accessible through the  World-Wide Web at  
http://catless .ncl.ac.uk/Risks .
A parallel garbage collection algorithm was introduced in [Dijkstra 1978] . 
[Cohen  1984]  discusses the performance issues of such algorithms. Generatio n 
scavenging was introduced in [Ungar 1984] . 
The garbage collection mechanism of ISE’s environment sketched at the end of this  
chapter was built by Raphaël Manf r e d i  a n d  r e f i n e d  b y  F a b r i c e  F r anceschi (whose  
technical report served as the basis for the presentation here)  and Xavier Le V ourch.
EXERCISES
E9.1  Patterns of object creation
In the discussion of automatic m emory management it was pointed  out that the “internal  
free list” approach (in which th e space of reclaimed objects is  not physically returned to  
the operating system, but kept i n a list for use by future crea tion instructions) may cause  
the memory allocated to an appli cation to grow forever even tho ugh the actual memory  
requirement is bounded, whereas t he “actual reclamation” approa ch (in which a reclaim  
operation actually returns memor y) would result in bounded memo ry usage. Devise a  
pattern of object creation and r eclamation which exhibits this problem. 
You may describe such a pattern as a sequence o1 o2 o3 … where each oi is either 1,  
indicating the allocatio n of one memory unit, or –n (for some integer  n), indicating the  
reclamation of n memory units. 
E9.2  What level of reclamation?
The component level policy, if i mplemented in a language like P ascal or C where an  
operating system dispose  or free facility is available, could us e this facility directly rather  
than managing its own free list for every type of data structur e. Discuss the pros and cons  
of both approaches. 
E9.3  Sharing the stack  of available elements
(This exercise assumes familiarity with the results of chapter 18.) Rewrite the feature  
available , giving the stack of available elements in the component-level  approach, so that  
the stack will be shared by all linked lists of a  certain type.  (Hint : use a once function.)
E9.4  Sharing more
(This exercise assumes that you have solved the previous one, a nd that you have read up  
to chapter 18.) Is it possible to make the available stack shared by linked lists of all types?“What exactly is 
reclamation?”, page302.
“THE COMPO-
NENT-LEVEL APPROACH”, 9.5, page 297.
10  
Genericity 
Fr o m  t h e  m e r g i n g  o f  m o d u l e  a n d  t y p e s  c o n c e p t s ,  w e  h a v e  b e e n  a b l e  to develop a  
powerful notion of class, which serves as the basis of the obje ct-oriented method and can  
already, as it stands, enable us to do much. But to achieve our  goals of extendibility,  
reusability and reliability we must make the class construct mo re flexible, an effort that  
will proceed in two directions. One, vertical in the figure bel ow, represents abstraction and  
specialization; it will give ri se to the study of inheritance i n subsequent chapters. The  
present chapter studies the other dimension, horizontal in the figure: type parameterization,  
also known as genericity.
10.1  HORIZONTAL AND VERTICAL TYPE GENERALIZATION
With the mechanisms studied so far we have all that we need to write the class at the center  
of the figure, LIST_OF_BOOKS , of which an instance repre sents a list of book objects.  
We know what kinds of feature it would have: put to add an element, remove  to delete an  
element, count  to find out how many elements are present and so on. But it is  easy to see  
two ways of generali zing the notion of LIST_OF_BOOKS :Dimensions of 
generalization
LIST_OF_
PEOPLELIST_OF_
BOOKSLIST_OF_
JOURNALSSET_OF_
BOOKS
LINKED_LIST_
OF_BOOKSAbstraction
SpecializationType parameterization Type parameterization
GENERICITY  §10.2 318
• Lists are a special case of “container” structure, of which ot her examples (among  
many) include trees, st acks and arrays. A m ore abstract variant  might be described  
by a class SET_OF_BOOKS . A more specialized varia nt, covering a particular  
choice of list representation, might be described by a class LINKED_LIST_OF_
BOOKS . This is the vertical dimension  of our figure — the dimension of inheritance.
• Lists of books are a special case of lists of objects of any p articular kind, of which  
other examples (among many) include lists of journals, lists of  p e o p l e ,  l i s t s  o f  
integers. This is the horizontal dimension of our figure — the dimension of  
genericity, our topic for the re st of this chapter. By giving c lasses pa rameters  
representing arbitrary types, we will avoid the need to write m any quasi-identical  
classes — such as LIST_OF_BOOKS  and LIST_OF_PEOPLE — without sacrificing  
the safety afforded by static typing.
The relation between these two m echanisms is an elusive questio n for students of  
object-oriented concepts. Should  inheritance and genericity be viewed as comrades or  
competitors in the rush towards more flexible software? That qu estion is the subject of an  
appendix. In the present chapter  we concentrate on genericity; this will also enable us to  
take a closer look at one of the most common examples of generi c structure: arrays.
10.2  THE NEED FOR TYPE PARAMETERIZATION
Genericity is not really a new concept in this discussion, alth ough we have not yet seen it  
applied to classes. We encountered the idea a first time when r eviewing traditional  
approaches to reusability; and w hen we studied the mathematical  model — abstract data  
types — we saw the nee d to define an ADT as parameterized by ty pes.
Generic abstract data types
Our working ADT example, STACK , was declared as STACK [G], meaning that any actual  
use requires you to specify an “actual generic parameter” repre senting the type of the  
objects stored in a particular stack. The name G as used in the ADT’s specification stands  
for any possible type that these stack elements may have; it is  called the formal generic  
parameter  of the class. With this approach you can use a single specific ation for all  
possible stacks; the alternative , hard to accept, would be to h ave a class INTEGER_STACK , 
a class REAL_STACK  and so on.
Any ADT describing “container” str uctures — data structures suc h as sets, lists,  
trees, matrices, arrays and many others that serve to keep obje cts of various possible types  
— will be similarly generic.
The same concerns, applied to the container classes of our soft ware systems rather  
than to the container ADTs of our mathematical models, will yie ld a similar solution.
The issue
Let us keep the stack example, n o longer as a mathematical ADT but as a software class.  
We know how to write a class INTEGER_STACK  describing the notion of stack of  Appendix B .
See “Genericity”, 
page 96 , and again 
“Genericity”, page 131.
§10.2   THE NEED FOR TYP E PARAMETERIZATION 319
integers. Features will include count  (number of elements), put (push a new element), item
(top element), remove  (pop the top element), empty  (is this stack empty?). 
Type INTEGER  will be used frequently in this class. For example it is the t ype of the  
argument of put and of the result of item: 
put (element : INTEGER )
-- Push element  on top.
do … end
item: INTEGER
-- Item at top
do … end
These appearances of type INTEGER  follow from the rule of explicit declaration that  
we have used in developing the notation: any time you introduce  an entity, denoting  
possible run-time objects, you must write an explicit type decl aration for it, such as element :
INTEGER . Here this means that you must specify a type for the query item, for the argument  
element  of procedure put, and for other entities denoting possible stack elements.
But as a consequence y ou must write a different class for every  s o r t  o f  s t a c k :  
INTEGER_STACK , REAL_STACK , POINT_STACK , BOOK_STACK … All such stack  
classes will be identical except for the type declarations of item, element and a few other  
entities: since the basic operations on a stack are the same re gardless of the type of stack  
elements, nothing in the bodies o f the various routines depends  on the choice of  
INTEGER , REAL , POINT or BOOK as the type of stack element. For anyone concerned  
with reusability, this is not attractive.
The issue, then, is the contradi ction that container classes se em to cause between two  
of the fundamental quality goals  introduced at t he beginning of  this book:
• Reliability: retaining the bene fits of type safety through exp licit type declarations.
• Reusab ility : b eing  ab le to write a sin gle softw are element co v ering variants of a  
given notion.
The role of typing
Why insist on explicit type decla rations (the first of the two requirements)? This is part of  
the general question of typing, to which an entire chapter is d evoted later in this book. It is  
not too early to note the two basic reasons why an O-O notation  should be statically typed:
•T h e  readability  reason: explicit declarations t ell the reader, loud and clear,  about the  
intended use of every element. T his is precious to whoever — th e original author, or  
someone else — needs to understa nd the element, for example to debug or extend it.
•T h e  reliability reason: thanks to explicit type declarations, a compiler will b e able to  
detect erroneous operations befo re they have had a chance to st rike. In the  
fundamental operations of object -oriented computation, feature calls of the general  
form x  f (a, …), where x is of some type TX, the potential for mischief is manyfold:  
the class corresponding to TX might not have a feature called f; the feature might  Chapter 17.
GENERICITY  §10.3 320
exist but be secret; the number o f arguments might not coincide  with what has been  
declared for f  in the class; the type for  a or another argument might not be compatible  
with what f expects. In all such cases, let ting the software text go throu gh unopposed  
— as in a language without static  t y p e c h e c k i n g  —  w o u l d  u s u a l l y  mean nasty  
consequences at run ti me, such as the program crashing with a d iagnostic of the form  
“Message not understood  ” (the typical outcome in Smallt alk, a non-statically-typed  
O-O language). With explicit typ ing, the compiler will not let the erroneous  
construct through. 
The key to software reliability, as was pointed out in the disc ussion of that notion, is  
prevention more than cure. Many studies have found that the cos t of correcting an error  
grows astronomically when the ti me of detection is delayed. Sta tic typing, which enables  
the early detection of type erro rs, is a fundamental tool in th e quest for reliability.
Without these considerations we would not need explicit declara tions, and so we  
would not need genericity. As a consequence the rest of this ch apter only applies to  
statically typed  languages, that is to say langu ages which require all entities  to be declared  
and enforce rules enabling comp ilers to detect type inconsisten cies prior to execution. In  
a non-statically-typed language s uch as Smalltalk, there is no role for genericity; this  
removes a language cons truct, but also rem oves any protection a gainst schemes such as
my_stack   put (my_circle )
my_account  := my_stack   item
my_account   withdraw (5000 )
where an element is retrieved fr om the top of the stack and tre ated as if it were a bank  
account even though it is in reality (because of the first inst ruction) a circle, so that the  
software ends up trying to withdra w five thousand dollars from a circle on the screen.
Static typing protects  us against such mishaps; combining it wi t h  t h e  r e u s a b i l i t y  
requirement implies th at we develop a mechanism for genericity.
10.3  GENERIC CLASSES
Reconciling static typ ing with the requirement of reusability f or classes describing  
container structures means, a s illustrated by the stack  example, that we want both to:
• Declare a type for every entity appearing in the text of a sta ck class, including entities  
representing stack elements.
• Write the class so that it does  not give out any clue about th e elements’ type, and  
hence that it can be used to buil d stacks of arbitrary elements .
At first sight these requirement s seem irreconcilable but they are not. The first one  
commands us to declare a type; it does not assume that the decl aration is exact! As soon as  
we have provided a type name, we will have pacified the type ch ecking mechanism.  
(“Name your fear, and it will go away”.) Hence the idea of gene ricity: to obtain a type-
parameterized class, equip it wi th the name of a fictitious typ e, called the formal generic  
parameter. 
§10.3   GENERIC CLASSES 321
Declaring a generic class
B y  c o n v e n t i o n  t h e  g e n e r i c  p a r ameter will use the name G for Generic; this is a style  
recommendation, not a f ormal rule. If we ne ed more generic para meters they will be called  
H, I and so on.
The syntax will include the formal generic parameters in square  brackets after the  
class name, as with generic ADT s in a previous chapter. Here is  an example:
note
description : "Stacks of elements of an arbitrary type G  "
class  STACK [G] feature
count : INTEGER
-- Number of elements in stack
empty : BOOLEAN
--Are there no items?
do … end
full: BOOLEAN
-- Is representation full?
do … end
item: G
-- Top element
do … end
put (x: G)
-- Add x on top.
do … end
remove
-- Remove top element.
do … end
end
In the class, you may use a formal generic parameter such as G in declarations: not  
only for function results (as in item) and formal arguments of routines (as in put), but also  
for attributes and local entities. 
Using a generic class
A client may use a generic class  to declare entities of its own , such as an entity  
representing a stack. In such a case, the declaration must prov ide types, called actual  
generic parameters  — as many as the class has form al generic parameters, here jus t one:
sp: STACK  [POINT  ]
Providing an actual generic para meter to a generic class so as to produce a type, as  
here, is called a generic derivation , and the resulting type, such as STACK [POINT  ], is 
said to be gener ically derived.
GENERICITY  §10.3 322
A generic derivation both pr oduces and requires a type:
• The result of t he derivation, STACK [POINT  ] in this examp le, is a type.
• To produce this result, you need an existing type to serve as actual generic parameter,  
POINT  in the example.
The actual generic parameter is an arbitrary type. Nothing prev ents us, in particular,  
from choosing a type that is its elf generically derived; assumi ng another generic class  
LIST [G], we can define a stac k of lists of points:
slp: STACK  [LIST [POINT  ]]
or even, using STACK [POINT  ] itself as the actual generic parameter, a stack of stacks  
of points:
ssp: STACK [STACK [POINT  ]]
There is no limit — other than s uggested by the usual guideline  that software texts  
should remain simple — to the depth of such nesting.
Terminology
To discuss genericity , we need to be preci se about the terms th at we use:
• To produce a type such as STACK [POINT  ] by providing a type, here POINT , as 
actual generic parameter for a generic class, here STACK , is to perform a  generic  
derivation. You may encounter the term “generic instantiation” for that process, but  
it is confusing because “instan tiation” normally denotes a run- time event, the  
production of an object — an ins tance — from its mold (a class) . Generic derivation  
is a static mechanism, affecting the text of the software, not its execution. So it is  
better to use complete ly differe nt terms.
• This book uses the term “paramet er” exclusively to denote the types that  
parameterize generic classes, ne ver to denote the values that a  routine call may pass  
to that routine, called arguments . In traditional software parlance “parameter” and  
“argument” are synonymous. Altho ugh the decision of which term to use for routines  
and which for generic classes is  a matter of convention, it is desirable to stick to a  
consistent rule to a void any confusion.
Type checking 
Using genericity, you can guarant ee that a data structure will only contain elements of a  
single type. Assuming a class  contains the declarations 
sc: STACK [CIRCLE ]; sa: STACK [ACCOUNT  ]; c: CIRCLE ; a: ACCOUNT
then the following are valid ins tructions in routines of that c lass: 
sc  put (c) -- Push a circle ont o a stack of circles
sa  put (a) -- Push an account on to a stack of accounts
c := sc  item -- Assign to a circle entity t he top of a stack of circles
§10.3   GENERIC CLASSES 323
but each of the following is i nvalid and will be rejected:
sc  put (a); -- Attempt to push an acco unt onto a stack of circles
sa  put (c); -- Attempt to push a circl e onto a stack of accounts
c := sa  item -- Attempt to access a s a circle the top o f a stack of accounts
This will rule out erroneous oper ations of the kind described e arlier, such as  
attempting to withdraw  money from a circle.
The type rule
The type rule that makes the fir st set of examples valid and th e second invalid is intuitively  
clear but let us make it precise.
First the basic non-ge neric rule. Consider a feature declared a s follows, with no use  
of any formal generic parameter, in a non-generic class C
f (a: T ): U …
Then a call of the form x  f (d ), appearing in an arbitrary class B where x is of type  
C, will be typewise correct if and only if: f  is available to B — that is to say , generally  
exported, or exported selectively to a set of classes including  B; and d is of type T. (When  
w e  b r i n g  i n h e r i t a n c e  i n t o  t h e  p i c t u r e  w e  w i l l  a l s o  a c c e p t  d if its type is based on a  
descendant of T.) The result of the call — ther e is a result since the example  assumes that  
f  is a function — is of type U.
Now assume that C is generic, with G as formal generic paramet er, and has a feature
h (a: G): G …
A call to h will be of the form y  h (e) for some entity y that has been declared, for  
some type V, as
y: C [V]
The counterpart of the n on-generic rule is that e m u s t  n o w  b e  o f  t y p e  V (or a 
compatible type in the sense of inheritance), since the corresp onding formal argument a is 
declared as being of type G, the formal generic parameter, and in the case of y we may  
consider G, wherever it appears in class C, as a place holder for V. Similarly, the result of  
the call will be of type V. The earlier examples all follow this model: a call of the for m 
s  put (z) requires an argument z of type POINT  if s is of type STACK  [POINT  ], INTEGER  
if s is of type STACK  [INTEGER ]; and s  item returns a result of type POINT  in the first  
case and INTEGER  in the second.
These examples involve features with zero or one argument, but the rule  
immediately extends to an arb itrary number of arguments.
Operations on entities of generic types 
In a generic class C [G, H, …] consider an entity whose type  is one of the formal generic  
parameters, for example x of type G. When the class is used by a client to declare entities,  
G may ultimately represent any type . So any operation that the ro utines of C perform on  
x must be applicable to all types.  This leaves only five kinds o f operation:This will be the Fea-
ture Application rule, page 473.
GENERICITY  §10.3 324
In particular , a creation instruction of the form  create  x is illegal, since we know  
nothing about the crea tion procedures, if an y ,  d e f i n e d  f o r  p o s s ible actual generic  
parameters cor responding to G. 
C a s e s  G 4  a n d  G 5  r e f e r  t o  c l a s s  ANY. Mentioned a few times already, this class  
contains features that all classes will inherit. So you can be assured that whatever actual  
type G represents in a particular generic derivation will have access  to them. Among the  
features of ANY are all the basic operations for copying and comp aring objects:  clone , 
copy , equal , copy , deep_clone , deep_equal  and others. This means it is all right, for x and 
y of a formal generic type G, to use instructions such as
x  copy (y)
x := clone (y)
if equal (x, y) then …
Ignoring ANY, case G4 permits a call a  f (x) in a generic class C [G] if f  takes a formal  
argument of type G. In particular a could be of type D [G], where D is another generic  
class, declared as D [G] with a feature f that takes an argument of type G, here denoting  
D’s own formal generic parameter. (If the preceding sentence doe s not immediately make  
sense, please read it once more  and it will, I hope, soon seem as clear as a mountain creek!)
Types and classes
We have learned to view the clas s, the central notion in object  technology, a s the product  
of the corporate merge r between the module and type concepts. U ntil we had genericity,  
we could say that every class is  a module and is also a type.
W i t h  g e n e r i c i t y ,  t h e  s e c o n d  o f  t h e s e  s t a t e m e n t s  i s  n o t  l i t e r a l l y true any more,  
although the nuance will be small.  A generic class declared as C [G] is, rather than a type,  
a type pattern covering an infin ite set of possible types; you can obtain any one of these  
by providing an actual generic pa rameter — itself  a type — corr esponding to G.Uses of entities of a formal generic type
The valid uses for an entity x whose type G is a formal generic parameter are  
the following: 
G1 • Use of x as left-hand side in an assignment,  x := y, where the right-
hand side expression y is also of type G. 
G2 • Use of x as right-hand side of an assignment y := x, where the left-
hand side entity y is also of type G. 
G3 • Use of x in a boolean expression of the form  x = y or x /= y, where y
is also of type G.
G4 • Use of x as actual argument in a routine call corresponding to a formal  
argument declared of type G, or of type ANY.
G5 • Use as target of a call to a feature of ANY.
See “THE GLOBAL 
INHERITANCE STRUCTURE”, 16.2, page 580.
To check creek-  
clarity do exercise 
E10.3, page 330.
§10.4   ARRAYS 325
This yields a more general and fle xible notion. But for what we  gain in power we  
have to pay a small price in sim plicity: only through a small a buse of language can we  
continue talking, if x is declared of type T, about “the features of T  ” or “the clients of T ”; 
other than  a class, T may now be a generi cally derived type C [U ] for some generic class  
C and some type U. Of course there is still a class involved — class C —, which is why  
the abuse of langu age is acceptable.
When we need to be rigorous the terminology is the following. A ny type  T is 
associated with a class, the base class  of T, so that it is always correct to talk about the  
features or clients of T ’s base class. If T is a non-generic class, then  it is its own base class.  
If T is a generic derivation of the form C [U, …], then the base class of T is C.
The notion of base class will again be useful when we introduce  yet another kind of type,  
also (like all others in the O-O approach) based on classes, bu t indirectly: anchored types.
10.4  ARRAYS 
As a conclusion to this discussi on it is useful to take a look at a very useful example of  
container class: ARRAY , which represents one -dimensional arrays.
Arrays as objects
The notion of array is usually part of a programming language’s  definition. But with object  
technology we do not need to burden the notation with special p redefined constructs: an  
array is just a container object , an instance of a class which we may call ARRAY .
ARRAY  is a good example of generic cl ass. Here is a first outline:
note
description : "Sequences of values , all of the same type or of a conforming one , %
%accessible through integer indices in a contiguous interval "
class  ARRAY [G] creation
make
feature
make (minindex , maxindex : INTEGER )
-- Allocate arra y with bounds minindex  and maxindex
-- (empty if minindex  > maxindex )
do … end
lower , upper , count : INTEGER
-- Minimum and maximum l egal index; array size.
put (v: G; i: INTEGER )
-- Assign v to the entry of index i
do … end
infix  "@", item (i: INTEGER ): G
-- Entry of index i 
do … end
end“ANCHORED 
DECLARATION”, 16.7, page 598.
A better version of the
class, relying on 
assertions , appears in
“Arrays revisited”, page 372 .
GENERICITY  §10.4 326
To create an array of bounds m and n, with a declared of type ARRAY [T ] for some  
type T, you will execute the creation instruction
create  a  make (m, n)
To set the value of an array element you will use procedure put: the call a  put (x, i)
sets the value of the i-th element to x. To access the value of an element you will use  
function item (the synonym infix "@" will be explained shortly), as in
x := a  item (i)
Here is a sketch of how you might  use the class from a client:
pa: ARRAY [POINT  ]; p1: POINT ; i, j: INTEGER
…
create  pa  make (–32, 101) -- Allocate array wit h the bounds shown.
pa  put (p1, i)- -  A s s i g n  p1 to entry of index i.
…
p1 := pa  item ( j)- -  A s s i g n  t o  p1 the value of entry of index j.
In conventional (say Pascal)  notation, you would write 
pa [i] := p1 for pa  put (i, p1)
p1 := pa [i] for p1 := pa  item (i)
Array properties
A few observations on t he preceding class:
• Similar classes exist for a rrays with more dimensions: ARRAY2  etc. 
•F e a t u r e  count may be implemented as either an attribute or a function, since it 
satisfies count = upper – lower+1 . This is expressed in the actual class by an  
invariant, as explained in the next chapter. 
• More generally, assertion techniques will allow us to associat e precise consistency  
conditions with put and item, expressing that calls are  only valid if the index i is 
between lower  and upper . 
The idea of describing arrays as objects and ARRAY  as a class is a good example of  
the unifying and simplifying powe r of object technology, which helps us narrow down the  
notation (the design o r programming l anguage) to the bare essen tials and reduce the  
number of special-purpose constr ucts. Here an array is simply v iewed as an example of a  
container structure, with its ow n access method represented by features put and item.
Since ARRAY  is a normal class, it can fully participate in what an earlier  chapter called  
the object-oriented games; in par ticular other classes can inhe rit from it. A class  
ARRAYED_LIST describing the impleme ntation of the abstract notion of list by  arrays can  
be a descendant of both LIST  and ARRAY . We will study many such constructions.
As soon as we learn about asserti ons we will take this unifying  approach even  
further; thanks to preconditions, we will be able to handle thr ough the normal concepts of  
the object-oriented method one m ore problem tradi tionally thoug ht to require special-
purpose mechanisms: run-time bou nds checking (monitoring array accesses to enforce the  
rule that all indices must  lie between the bounds).
§10.4   ARRAYS 327
Efficiency considerations
The fear may arise that all this elegance and simplicity could cause performa nce to take a  
hit. One of the primary reasons developers use arrays in tradit ional approaches is that the  
basic operations — accessing or modifying an array element know n through its index —  
are fast. Are we now going to pay the price of a routine call e very time we use item or put?
We do not need to. That ARRAY  looks to the unsuspecti ng developer as a normal  
class does not prevent the compi ler from cheating — from relyin g on some insider  
information. This information en ables the compiler to detect ca lls to item and put and 
hijack them so as to generate ex actly the same code that a Fort ran, Pascal or C compiler  
would produce for eq uivalent instructions  as shown above ( p1 := pa [i] and pa [i] := p1 in 
P a s c a l  s y n t a x ) .  S o  t h e  d e v e l o p e r  w i l l  g a i n  t h e  b e s t  o f  b o t h  w o r l d s :  t h e  u n i f o r m i t y ,  
generality, simplicity, and ease  of use of the O-O solution; an d the performance of the  
traditional solution.
The compiler’s job is not trivial. As will be clear in the stud y of inheritance, it is possible  
for a descendant of class ARRAY  to redefine any feature of the class, and such  
redefinitions may be called indirectly through dynamic binding.  So compilers must  
perform a thorough analysis to check that the replacement is in deed correct. Today’s  
compilers from ISE and other companies can indeed, for a typica l array-intensive  
computation typical of large scientific software, generate code  whose efficiency matches  
that of hand-written C or Fortra n code.
An infix synonym
Class ARRAY  provides the opportunity to int roduce a small facility that, a lthough not  
directly related to the other topics of this chapter, will be u seful in practice. The  
declaration of feature item actually reads
infix  "@", item (i: INTEGER ): G …
This introduces two feature names infix  "@" and item as synonyms, that is to say as  
denoting the same feat ure, given by the declaration that follow s.  I n g en er a l,  a  f ea tu re  
declaration of the form
a, b, c, … “Feature description”
is considered as an abbreviation  for a sequence of declarations  of the form
a “Feature description”
b “Feature description”
c “Feature description”
…
all for the same “Feature description” . This is applicable to attributes (where the “Feature  
description”  is of the form   : some_type ) as well as routines (where it reads is routine_body ).
The benefit in this example is t hat you have a simpler notation  for array access.  
Although consistent with the access mechanisms for other data s tructures, the notation  
a  item (i) is more wordy than the traditional a [i] found, with some variants, in Pascal, C,  The notion of infix 
feature was intro-duced in “Operator features”, page 187 .
GENERICITY  §10.5 328
Fortran and so on. By defining infix "@"as a synonym, you can actually beat traditional  
languages at their own terseness  game by writing an array eleme nt as a @ i (the supreme  
dream: undercutting — by one keystroke — even C!). Note again t hat this is not a special  
language mechanism but the strai ghtforward application of a gen eral O-O concept,  
operator features, combined he re with the notion of synonym.
10.5  THE COST OF GENERICITY
As always, we need to make sure that the object-oriented techni ques that we introduce for  
reusability, extendibility and r eliability do not imply a perfo rmance overhead. The  
question has just been raised an d answered for arrays; but we n eed to examine it for the  
genericity mechanism at large. H ow much will genericity cost?
The concern arises in particular  because of the experience of C ++, where genericity  
(known as the template  m e c h a n i s m )  w a s  a  l a t e  a d d i t i o n  t o  t h e  l a n g u a g e ,  c a u s i n g  
performance difficulties. It app ears that some compiler impleme ntations take the idea of  
parameterization literally, generating a different copy of the class features for each actual  
generic parameter! As a conseque nce the literature warns C++ pr ogrammers of the  
dangers of using templ ates too generously:
Template instantiation time is already an issue for some C++ users … If a user  
creates a List<int>, a List<String >, a List<Widget >, and a List<Blidget >
(where Widget  and Blidget  are user-defined classes) , and calls head , tail, and 
insert  on all four objects , then each of these functi ons will be instantiated [in 
the sense of generically derived] four times . A widely useful class such as List
might be instantiated in user pr ograms with many different types , causing many  
functions to be instantiated . Thus , a significant amount  of code might be  
generated for the [features of] the List template [class] .
The authors of this advice (both with respected C++ expertise f rom the original  
AT&T group, one of them co-author of the official C++ reference  [Ellis 1990]) go on  
proposing various techniques for avoiding template derivation. But developers should of  
course be protected from such concerns. Genericity should not i mply code duplication; it  
is possible, with appropriate la nguage design and a good compil er, to generate a single  
target code for any generic cla ss, so that all of the following  will be small or zero:
• Effect on compilation time.
• Effect on the size of  the gener ated code.
• Effect on execution time.
• Effect on execution space.
When working in such an environment, you can use the full power  of genericity  
without any fear of unpleasant effects on either compile-time o r at run-time performance.From: Martin Car-
roll & Margaret Ellis, “Reducing Instantia-tion Time”, in “C++ Report”, vol. 6, no. 5, July-August 1994, pages 14, 16 and 64. List<T>  would be 
LIST [T] in the nota-
tion of this book.
§10.6   DISCUSSION: NOT DONE YET 329
10.6  DISCUSSION: NOT DONE YET
The presentation of genericity h as introduced the basic ideas. B u t ,  a s  y o u  m a y  h a v e  
noticed, it leaves  two important que stions unanswered.
First, in our effort to guarantee  type safety, we may have erre d on the conservative  
side. We will be prevented from pushing a bank account onto a STACK  [CIRCLE ], or a 
point onto a STACK [ACCOUNT  ]. This is what we want: it is hard to imagine what kind  
of application — other than gen eral-purpose utilities such as a  database management  
system — would need to handle a stack containing both points an d bank accounts. But what  
about a graphics application asking for a stack that contains a  few circles, a few rectangles,  
a few points? This request seems quite reasonable, and we canno t accommodate it; the type  
system defined so far will reject the call figure_stack   put (that_point ) if figure_stack  has 
been declared of type STACK  [FIGURE  ] and that_point of any type other than FIGURE . 
We can give a name to such structures: polymorphic data structures . The challenge will  
be to support them without renounci ng the benefits of type safe ty.
Second, our generic parameters re present arbitrary types. This is fine for stacks and  
arrays, since any object is by es sence “stackable” and storable  into an array. But when we  
come to structures such as vecto rs, we will want to be able to add two vectors, requiring  
that we can also add two vector elements; and if we want to def ine a hash table class, we  
will need the certainty that a ha sh function is applicable to e very table element. Such a  
form of genericity, whereby the f ormal generic parameter does n ot any more stand for an  
arbitrary type, but represents a  type guaranteed to offer certa in operations, will be called  
constrained genericity .
For both of these problems, the object-oriented method will pro vide simple and  
elegant solutions, both based on  combining gener icity with inhe ritance.
10.7  KEY CONCEPTS INTRODUCED IN THIS CHAPTER 
• Classes may have formal generic  parameters representing types.  
• Generic classes serve to descri be general container data struc tures, implemented in  
the same way regardless of t he elements they contain. 
• Genericity is only needed in a typed language, to ensure stati cally checkabl e type safety.
• A client of a generic  class must provide ac tual types for the formal parameters. 
• The only permitted operations o n an entity whose type is a for mal generic parameter  
are operations applicable to eve ry type. The entity may serve a s left- or right-hand  
s i d e  o f  a n  a s s i g n m e n t ,  a c t u a l  r o utine argument, or operand of a n equality or  
inequality test. It may also par ticipate in universally applica ble features such as  
cloning and object equality testing.
• The notion of array can be covered by a generic library class,  without any specific  
language mechanism but also without any los s in run-time perfor mance.
• More flexible advanced uses of genericity — polymorphic data s tructures,  
constrained genericity — requir e the introduction of inheritanc e.
GENERICITY  §10.8 330
10.8  BIBLIOGRAPHICAL NOTES 
An early language support ing genericity was LPG [Bert 1983] . Ada made the concept  
widely known through its generic package mechanism. 
Genericity has also b een introduced in for mal specification lan guages such as Z,  
CLEAR and OBJ-2, to which references appear in the chapter on a bstract data types. The  
generic mechanism described here  was derived from the mechanism  introduced in an early  
version of Z [Abrial 1980]  [Abrial 1980a]  and extended in M [M 1985b] . 
Aside from the notation of this book, one of the first object-o riented languages to  
offer genericity was D EC’s Trellis language [Schaffert 1986] .
EXERCISES
E10.1  Constrained genericity
This exercise is a little peculi ar since it asks you a question  to which a detailed answer  
a p p e a r s  l a t e r  i n  t h e  b o o k .  I t s  a i m  i s  t o  g e t  y o u  t h i n k i n g  a b o u t  the proper language  
structures, and compar e your answer to what will be introduced later. It will only be  
worthwhile if you are new to this  problem and have not yet seen  t h e  o b j e c t - o r i e n t e d  
solution. Familiarity with how t he problem is handled in other approaches, notably Ada,  
may be helpful but is not required.
The question is about constrained genericity, a need that was p resented in the  
discussion section. De vise a language mecha nism, compatible wit h the spirit of the object-
oriented approac h and with the notations seen so far, that will  address constrained  
genericity by enabling the author  of a generic class to specify  that valid actual generic  
parameters must posses s certain operations.
E10.2  Two-dimensional arrays
Using class ARRAY  both as inspiration and as basi s for the implementation, write  a generic  
class ARRAY2  describing two-dimensional arrays. 
E10.3  Using your own formal generic parameter as someone else’ s actual
Construct an example in which a routine of a generic class C [G] calls a routine declared  
in another generic class D [G] as taking a formal argument of type G.For references on 
Ada see chapter 33 .
Page 160 .
11  
Design by Contract: 
building reliable software
E quipped with the basic concepts o f class, object and genericity , you can by now write  
software modules that implement possibly parameterized types of  data structures.  
Congratulations. This is a signi ficant step in the quest for be tter software architectures. 
But the techniques seen so far are not sufficient to implement the comprehensive  
view of quality introduced at th e beginning of this book. The q uality factors on which we  
have concentrated — reusability,  extendibility, compatibility —  must not be a ttained at the  
expense of reliability ( correctness  a n d  robustness ). Although, as recalled next, the  
reliability concern was visible in many aspects of the discussi on, we need more.
The need to pay more attention to the semantic properties of ou r classes will be  
particularly clear if you remember  how classes were defined: as  implementations of  
abstract data types. The classes  seen so far consist of attribu tes and routines, which indeed  
represent the functions of an ADT specification. But an ADT is more than just a list of  
available operations: remember the role played by the semantic properties, as expressed  
by the axioms and preconditions. They are essential to capture the true nature of the type’s  
instances. In studying classes, we have — temporarily — lost si ght of this semantic  
aspect of the ADT concept. We will need to bring it back into t he method if we want our  
software to be not just flexible  and reusable, but also correct  and robust.
Assertions and the associated co ncepts, explained in this chapt er, provide some of the  
answer. Although not foolproof, the mechanisms presented below provide the programmer  
with essential tools for expressi ng and validating correctness arguments. The key concept  
will be Design by Contract : viewing the relationship betw een a class and its clients as a  
formal agreement, expressing each  party’s rights and obligation s. Only through such a  
precise definition of every module’s claims and responsibilitie s can we hope to attain a  
significant degree o f trust in large software systems. 
I n  r e v i e w i n g  t h e s e  c o n c e p t s ,  w e  s h a l l  a l s o  e n c o u n t e r  a  k e y  p r o b lem of software  
engineering: how to deal with ru n-time errors — with contract v iolations. This leads to the  
subject of exception handling , covered in the next chapte r. The distribution of roles  
between the two chapters roughly reflects the distinction betwe en the two components of  
reliability; as you will recall, correctness was defined as the  software’s ability to perform  
according to its specification, and robustness as its ability t o react to cases not included in  
the specification. Assertions (this chapter) generally cover co rrectness, and exceptions  
(next chapter) general ly cover robustness.
DESIGN BY CONTRACT: BUILDING RELIABLE SOFTWARE  §11.1 332
Some important extensions to the  basic ideas of Design by Contr act will have to wait  
until the presentation of inherita nce, polymorphism and dynamic  binding, enabling us to  
go from contracts to subcontracting . 
11.1  BASIC RELIABILITY MECHANISMS
The preceding chapters already introduced a set of techniques t hat directly address the goal  
of producing reliable software. Let us review them briefly; it would be useless to consider  
more advanced concepts until we h ave put in place all the basic  reliability mechanisms.
First, the defining property of object technology is an almost obsessive concern with  
the structure  of software systems. By definin g simple, modular, extendible a rchitectures,  
we make it easier to ensure reli ability than with contorted str uctures as often result from  
earlier methods. In particular the effort to limit inter-module  communication to the strict  
minimum was central to  the discussion of modularity that got us  started; it resulted in the  
prohibition of such common reliability risks as global variable s, and in the definition of  
restricted communication mechani sms, the client and inheritance  relations. The general  
observation is that the single b iggest enemy of reliability (an d perhaps of software quality  
in general) is complexity. Keeping our structures as simple as possible is not enough to  
ensure reliability, but it is a n ecessary condition. So the dis cussion of the previous chapters  
provides the righ t starting point for the  systematic effort of the present one.
Also necessary if not sufficient  is the constant emphasis on ma king our software  
elegant and readable . Software texts are not just written, they are read and rewrit ten 
many times; clarity and simplicity of notation, such as have be en attempted in the  
language constructs introduced s o far, are a required basis for  any more sophisticated  
approach to reliability.
Another indispensable weapon is a utomatic memory management, sp ecifically  
garbage collection . The chapter on memory manageme nt explained in detail why, for  any 
system that creates and manipula tes dynamic data  structures, it  would be dangerous to rely  
on manual reclamation (or no rec lamation). Garba ge collection i s not a luxury; it is a  
crucial reliability-enhancing co mponent of any O- O environment.
The same can be said of another technique presen ted (in connect ion with genericity)  
in the last chapter: static typi ng. Without statically enforced  type rules, we would be at the  
mercy of run-tim e typing errors.
All these techniques provide the  necessary basis, from which we  can now take a  
closer look at what it will take for a software system to be co rrect and robust.
§11.2   ABOUT SOFTWARE CORRECTNESS 333
11.2  ABOUT SOFTWARE CORRECTNESS
We should first ask ourselves what it means  for a software element to be correct. The  
observations and deductions that will help answer this question  will seem rather trivial at  
first; but let us not forget the  comment (made once by a very f amous scientist) that  
scientific reasoning is nothing b ut the result of starting from  ordinary observations and  
continuing with simple  deductions — only very patiently and stu bbornly.
Assume someone comes to you with a 300,000-line C program and a sks you “Is this  
program correct?”. There is not much you can answer. (If you ar e a consultant, though, try  
answering “no” and cha rging a high fee. You might just be right .)
To consider the question meaning ful, you would need to get not only the program  
but also a precise des cription of what it is  supposed to do — a  specification .
The same comment is applicable, of course, regardless of the si ze of a program. The  
instruction x := y + 1  is neither correct nor incorrect; these notions only make sens e with  
respect to a statement of what o ne expects from the instruction  — what effect it is intended  
to have on the state of the prog ram variables. The instruction is correct for the specification
“Make sure that x and y have different values”
but it is incorrect vis-à-vis the specification
“Make sure that x has a negative value”
(since, assuming that the ent ities involved are integers, x may end up bei ng non-negative  
after the assignment, dep ending on the value of y).
These examples illustrate the pr operty that must serve as the s tarting point of any  
discussion of correctness:
A software system or software el ement is neither correct nor in correct per se; it is  
correct or incorrect with respec t to a certain specification. S trictly speaking, we should not  
discuss whether software elements are correct , but whether they are consistent  with their  
specifications. This discussion will continue to use the well-a ccepted term “correctness”,  
but we should always remember that the question of correctness does not apply to software  
elements; it applies to pairs made of a software element and a specification.Software Correctness property
Correctness is a r elative notion.
DESIGN BY CONTRACT: BUILDING RELIABLE SOFTWARE  §11.3 334
In this chapter we will learn ho w to express suc h specification s through assertions , 
to help us assess the correctness  of our software. But we will go further. It turns out (and  
only someone who has not practiced the approach will think of t his as a paradox) that just  
writing the specification is a p recious first step towards ensuring  that the softw are actually  
meets it. So we will derive tremendous benefits from writing th e assertions at the same  
time as we write the software — or indeed before we write the s oftware. Among the  
consequences we will  find the following:
•Producing software that is correct from the start because it is  designed to be correct.  
The title of an article written by Harlan D. Mills (one of the originators of  
“Structured Programming”) in the nineteen-seventies provides th e right mood: How 
to write correct pr ograms and know it . To “know it” means to equip the software, at  
the time you write it, with the arguments showing its correctne ss.
• Getting a much better understan ding of the prob lem and its eve ntual solutions.
• Facilitating the task of software documentation. As we will se e later in this chapter,  
assertions will play a central p art in the objec t-oriented appr oach to documentation.
• Providing a basis for syste matic testing and debugging.
The rest of this chapter exp lores these applications.
A word of warning: C, C++ and some other languages (following t he lead of Algol  
W) have an “assert” instruction that tests whether a certain co ndition holds at a certain  
stage of the software’s executio n, and stops execution if it do es not. Althou gh relevant to  
the present discussion, this conc ept represents only a small pa rt of the use of assertions in  
the object-oriented method. So i f like many other software deve lopers you are familiar  
with such instructions but have not been exposed to the more ge neral picture, almost all  
the concepts of this c hapter will be new.
11.3  EXPRESSING A SPECIFICATION
We can turn the preceding informal observations into a simple m athematical notation,  
borrowed from the theory of formal program validation, and prec ious for reasoning about  
the correctness of software elements.
Correctness formulae
Let A be some operation (for example an  instruction or a routine body ). A correctness  
formula  is an expression of the form
denoting the following propert y, which may o r may not hold:{P} A {Q}[Mills 1975]. 
§11.3   EXPRESSING A SPECIFICATION 335
Correctness formul ae (also called Hoare triples ) are a mathematical notation, not a  
programming construct; they are n ot part of our software langua ge, but only designed to  
guide us through this discussion by helping to express properti es of software  elements. 
In {P} A {Q} we have seen that A denotes an operation; P and Q are properties of  
the various entities involved, also called assertions (the word  will be defined more  
precisely later). Of the two assertions, P is called the precondition and Q the postcondition.  
Here is a trivial correctness fo rmula (which, assuming that x is an integer entity, holds):
The use of correctness formulae is a direct application of the Software Correctness  
Property. What the Property stat ed informally — that correctnes s is only meaningful  
relative to a particu lar specification — co rrectness formulae t urn into a form that is  
directly usable for working on t he software: from now on the di scourse about software  
correctness will not  be about individual software elements A, but about triples containing  
a software element A, a precondition P and a postcondition Q. The sole aim of the game  
is to establish th at the resulting {P} A {Q} correctness formulae hold.
The number 13 appearing in the postcondition is not a typo! Assuming a corre ct 
implementation of integer arithmetic, the above formula holds: if x >= 9 is true before the  
instruction, x >= 13 will be true after the instructi on. Of course we can assert mor e 
interesting things: with the given precondition, the most inter esting postcondition is the  
strongest possible one, here x >= 14; with the given postcondition, the most interesting  
precondition is the weakest  possible one, here x >= 8. From a formula that holds, you can  
always get another one by strengthening the precondition or wea kening the postcondition.  
We will now examine more carefully these notions of “stronger” and “weaker”.
Weak and strong conditions
One way to look at a specification of the form {P} A {Q} is to view it as a job description  
for A — an ad in the paper, which sta tes “We are looking for someone  whose work will be  
to start from initial situ ations as characterized by P, and deliver resu lts as defined by Q”.
Here is a small quiz to help you sharpen your und erstanding of the concepts.
Assume one of your friends is looking for a job and comes acros s several such ads,  
all with similar salary and benefits, but differing by their Ps and Qs. (Tough times have  
encouraged the companies that p ublish the ads to resort to this  notation, which they like  
for its mathematical compactness  s i n c e  t h e  n e w s p a p e r  c h a r g e s  b y  the word.) Like  
everyone else, your friend is lazy, that is to say, wants to ha ve the easiest possible job. He  
is asking for your adv ice, always a dangerous situation. What s hould you recommend for  
P:  c h o o s e  a  j o b  w i t h  a  weak  precondition, or a strong  one? Same question for the  
postcondition Q. (The answers appear right afte r this, but do take the time to  decide the  
issue for yourself befor e turning the page.) Meaning of a correctness formula {P} A {Q} 
“Any execution of A, starting in a state where P holds , will terminate in a 
state where Q holds .”
{x >= 9}  x := x + 5  {x >= 13}
DESIGN BY CONTRACT: BUILDING RELIABLE SOFTWARE  §11.3 336
The precondition first. From the  viewpoint of the prospective e mployee — the  
person who has to perform  what has been called A — the precondition P defines the  
conditions under which the requi red job will start or, to put i t differently, the set of cases  
that have to be handled. So a strong P is good news: it means that you only have to deal  
with a limited set of situations. The stronger the P, the easier for the employee. In fact, the  
perfect sinecure is the job defined by
The postcondition has been left unspecified because it does not  matter what it is.  
Indeed if you eve r see such an ad, do not even bother reading t he postcondition; take the  
job right away . The precondition False  is the strongest possible assertion, since it is never  
satisfied in any state. Any request to execute A will be incorrect, and the fault lies not with  
the agent responsible for A but with the requester — the client — since it did not observe  
the required precondition, for t he good reason that it is impos sible to observe it. Whatever  
A does or does not do may be useless , but is always correct — in the sense, defined earlier,  
of being consistent w ith the specification.
The above job specification is probably what a famous police ch ief of a Southern US city  
had in mind, a long time ago, when, asked by an interviewer why  he had chosen his  
career, he replied: “Obvious — it is the only job where the cus tomer is always wrong”.
For the postcondition Q, the situation is reversed. A  strong postcondition is bad  
news: it indicates that you have to deliver more results. The w eaker the Q, the better for  
the employee. In fact, the secon d best sinecure in the world is  the job define d, regardless  
of the precondition, by
The postcondition True is the weakest possible asser tion, satisfied by all states.
The notions of “stronger” and “weaker” are formally defined fro m logic: P1 is said to be  
stronger than P2, and P2 weaker than P1, if P1 implies P2 and they are not equal. As every  
proposition implies True, and False  implies every proposition, it is indeed legitimate to  
speak of True as the weakest and False  as the strongest of all possible assertions.
Why, by the way, is Sinecure 2 only the “second best” job in th e world? The reason  
has to do with a fine point that you may have noticed in the de finition of the meaning of  
{P} A {Q} on the preceding page: terminat ion. The definition stated that  the execution  
must terminate  in a state satisfying Q whenever it is started in a state satisfying  P. With  
Sinecure 1 there are no states satisfying P, so it does not matter what A does, even if it is  
a program text whose execution wo uld go into an infinite loop o r crash the computer. Any  
A will be “correct” with respect to the given specification. With  Sinecure 2, however, there  Sinecure 1
{False }  A  {…}
Sinecure 2
{…}  A  {True}
§11.4   INTRODUCING ASSERTI ONS INTO SOFTWARE TEXTS 337
must be a final state; that state does not need to satisfy any specific properties, but it must  
exist. From the viewpoint of whoever has to perform A: you need to do nothing, but you  
must do it in finite time .
Readers familiar with theoretical  computing science or program proving techniques will  
have noted that the {P} A {Q} notation as used here denotes total correctness , which  
includes termination as well as conformance to specification. ( The property that a  
program will satisfy its specification if it terminates is know n as partial correctness.) See  
[M 1990]  for a detailed presentation of these concepts.
The discussion of whether a stronger or weaker assertion is “ba d news” or “good news”  
has taken the viewpoint of the prospective employee. If, changi ng sides, we start looking at  
the situation as if we were the employer, everything is reverse d: a weaker precondition will  
be good news, as it means a job that handles a broader set of i nput cases; so will be a stronger  
postcondition, as it means more significant results. This rever sal of criteria is typical of  
discussions of software correctne ss, and will reappear as the c entral notion of this chapter:  
contracts  between client and supplier modules, in which a benefit for on e is an obligation  
for the other. To produce effective and reliable software is to  draw up the contract  
representing the best possible compromise in all applicable cli ent-supplier communications.
11.4  INTRODUCING ASSERTIONS INTO SOFTWARE TEXTS
Once we have defined the correctness of a software element as t he consistency of its  
implementation with its specificat ion, we should take steps to include the specification,  
together with the implementation , in the software itself. For m ost of the software  
community this is still a novel idea: we are accustomed to prog rams as defining the  
operations that we command our hardware-software machines to ex ecute for us (the how); 
it is less common to treat the d escription of the software’s pu rposes (the what ) as being  
part of the software itself.
To express the specification, we  will rely on assertions. An as sertion is an expression  
involving some entities of the s oftware, and stating a property  that these entities may  
satisfy at certain stages of sof tware execution. A typical asse rtion might express that a  
certain integer has a positive value  or that a cer tain referenc e is not void. 
Mathematically, the closest notion is that of predicate, althou gh the assertion  
language that we shall use has o nly part of the power of full p redicate calculus. 
Syntactically, the assertions of our notation will simply be bo olean expressions, with  
a few extensions. One of  these extensions, the old notation, is introduced later in this  
chapter. Another is the us e of the semicolon, as in 
n > 0 ; x /=  Void
The meaning of the semicolon is equivalent to that of an and. As between  
declarations and instructions, th e semicolon is actually option al, and we will omit it when  
assertion clauses appear on separate lines; just consider that there is an implicit and
between successive assertion lines. These conventions facilitat e identification of the  
individual components of an asse rtion. It is indeed possible, a nd usually desirable, to label  
these components ind ividually, as in 
DESIGN BY CONTRACT: BUILDING RELIABLE SOFTWARE  §11.5 338
Positive : n > 0
Not_void : x /= Void
If present, the labels (such as Positive  and Not_void  in this example) will play a role  
in the run-time effect of asserti ons — to be discussed later in  this chapter — but for the  
moment they are mainly there f or clarity and documentation.
T h e  n e x t  f e w  s e c t i o n s  w i l l  r e v i e w  t h i s  p r i n c i p a l  a p p l i c a t i o n  o f  assertions: as a  
conceptual tool enabli ng software developers to construct corre ct systems and to  
document why they are correct. 
11.5  PRECONDITIONS AND POSTCONDITIONS 
The first use of assertions is t he semantic specification of ro utines. A routine is not just a  
p i e c e  o f  c o d e ;  a s  t h e  i m p l e m e n t a t i o n  o f  s o m e  f u n c t i o n  f r o m  a n  a bstract data type  
specification, it should perform a useful task. It is necessary  to express this task precisely,  
both as an aid in designing it ( you cannot hope to ensure that a routine is correct unless  
you have specified what it is su pposed to do) and, later, as an  aid to understa nding its text. 
You may specify the task perform ed by a routine by two assertio ns associated with  
the routine: a precondition  and a postcondition . The precondition states the properties that  
must hold whenever the routine i s called; the postcondition sta tes the properties that the  
routine guarantees when it returns.
A stack class 
An example will enable us to bec ome familiar with the practical  use of assertions. In the  
previous chapter, we saw the outline of a generic stack class, under the form
class STACK [G] feature
… Declaration of the features:
 count , empty , full, put, remove , item
end
An implementation will appear bel ow. Before considering impleme ntation issues,  
however, it is important to note that the routines are characte rized by strong semantic  
properties, independent of any specific representation. For exa mple: 
• Routines remove  and item are only applicable if the number of elements is not zero. 
•put increases the number of elements by one; remove decreases it by one. 
Such properties are part of the abstract data type specificatio n, and even people who  
do not use any approach remotely as formal as ADTs understand t hem implicitly. But in  
common approaches to so ftware construction software texts revea l no trace of them.  
Through routine preconditions an d postconditions you can turn t hem into explicit  
elements of the software.
We will express preconditions an d postconditions as clauses of routine declarations  
introduced by the keywords require  and ensure respectively. For the s tack class, leaving  
the routine implementations blan k for the time b eing, this give s: 
§11.5   PRECONDITIONS  AND POSTCONDITIONS 339
note
description : "Stacks : Dispenser structures with a Last-In , First-Out  % 
%access policy "
class  STACK1 [G] feature -- Access
count : INTEGER
-- Number of stack elements
item: G
-- Top element
require
not empty
do
…
end
feature  -- Status report
empty : BOOLEAN
-- Is stack empty?
do … end
full: BOOLEAN
-- Is stack representation full?
do
…
end
feature  -- Element change
put (x: G)
-- Add x on top.
require
not full
do
…
ensure
not empty
item = x
count = old count + 1
end
remove
-- Remove top element.
require
not empty
do
…
ensure
not full
count = old count – 1
end
end
DESIGN BY CONTRACT: BUILDING RELIABLE SOFTWARE  §11.5 340
Both the require  and the ensure  clauses are optional; whe n present, they appear at  
the places shown. The require  appears before the local  clause, if present. The next  
sections explain in more detail the meaning of preconditions an d postconditions. 
Note the division into several feature clauses, useful to group the features into categories  
indicated by the clauses’ header comments. Access , Status report  and Element  change  are 
some of a dozen or so standard categories used throughout the l ibraries and, whenever  
applicable, subsequent examples in this book.
Preconditions 
A precondition expresses the cons traints under which a routine will function properly. Here:
•put may not be called if the st ack representation is full. 
•remove  and item may not be applied to an empty stack. 
A precondition applies to all ca lls of the routine, both from w ithin the class and from  
c l i e n t s .  A  c o r r e c t  s y s t e m  w i l l  n e v e r  e x e c u t e  a  c a l l  i n  a  s t a t e  that does not satisfy the  
precondition of th e called routine. 
Postconditions 
A postcondition expresses propert ies of the state resulting fro m a routine’s execution. Here: 
•A f t e r  a  put, the stack may not be empty, it s top is the element just pushe d, and its  
number of elements has b een increased by one. 
•A f t e r  a  remove , the stack may not be full, and its number of elements has bee n 
decreased by one. 
The presence of a postcondition clause in a routine expresses a  guarantee on the part  
of the routine’s implementor tha t the routine will yield a stat e satisfying certain properties,  
assuming it has been called with  the preconditi on satisfied. 
A special notation, old, is available in postconditions; put a n d  remove  u s e  i t  t o  
express the changes to count . The notation old e, where e i s  a n  e x p r e s s i o n  ( i n  m o s t  
practical cases an attribute ), denotes the value that e had on routine entry. Any occurrence  
of e not preceded by old in the postcondition denotes the value of the expression on ex it. 
The postcondition of put includes the clause
count = old count + 1
to state that put, when applied to any object, mu st increase by one the value of  the count
field of that object. 
A pedagogical note
If you are like most software pr ofessionals who get exposed to these ideas for the first  
time, you may be itching to know what effect, if any, the asser tions have on the execution  
of the software, and in particular what happens if one of them gets violated at run time —  
if full is true when someone calls put, or empty  is true when put terminates one of its  
executions. It is too early to give the full answer but as a pr eview we can use the lawyer’s  
favorite: it depends .More on feature cat-
egories in “A stack class”, page 348 .
§11.6   CONTRACTING FOR SOFTWARE RELIABILITY 341
More precisely , it depends on what you want. Y ou may decide to treat assertions  
purely as comments, with no effec t on the software’s execution;  then a run-time assertion  
violation will remain undetected. But it is also possible to us e assertions to check that  
everything goes according to pla n; then during execution the en vironment will  
automatically monitor that all a ssertions hold when they should , and if one does not it will  
trigger an exception, usually terminating execution and printin g a message indicating  
clearly what happened. (It is als o possible to include an excep tion handling clause that will  
try to recover from the exceptio n and continue execution; excep tion handling is discussed  
in detail in the next chapter.) To specify the policy that you want — no assertion checking,  
or assertion monitoring at one of  various possible levels — you  will use a compilation  
option, which you c an set separately for each class.
The full details of run-time ass ertion monitori ng do appear lat er in this chapter. But  
it would be a mistake to attach too much importance to this asp ect at this stage (one of the  
reasons why you were warned earli er not to think too much about  the C notion of assertion  
if that has been your only exposure to the concept). Other aspe cts of assertions demand  
our attention first. We have onl y started to see assertions as a technique to help us get our  
software right in the first place ; we still have much to discov er of their methodological  role 
as built-in guardians of reliabi lity. The question of what happ ens if we do fail (in particular  
if an assertion, in spite of all our ef forts, is not satisfied at some execution instant) is  
important too, but only after we  have done all we could to prev ent it from arising.
So (although it is never bad to think ahead) you do not need at  this point to be too  
preoccupied by such questions as the possible performance penal ty implied by the old
construct. Must the ru n-time system preserve  values before we s tart a routine, just to be  
able to evaluate an old expression appearing in the postcondition? It depends : in some  
circumstances (for example testing and debugging) it will indee d be useful to evaluate  
assertions; in others (for examp le production runs of fully val idated systems) you can treat  
them as mere annotations  to the software text.
All that counts for th e next few sections is the methodological  contribution of  
assertions, and of the associate d method of Design by Contract:  as a conceptual tool for  
analysis, design, implementation and documentation, helping us to build software in  
which reliability is built-in , rather than achiev ed or attempted after the fact through  
debugging; in Mills’s terms, ena bling us to build  correct progr ams and know it.
11.6  CONTRACTING FOR SOFTWARE RELIABILITY 
Defining a preconditio n and a postcondition for a routine is a way to define a contract  that 
binds the routine and its callers. 
Rights and obligations 
By associating clauses require  pre and ensure  post with a routine r, the class tells its clients:
“If you promise to call r with pre satisfied then I, in return, promise to deliver  
a final state in which post is satisfied.”See “Monitoring 
assertions at run time”, page 392 .
DESIGN BY CONTRACT: BUILDING RELIABLE SOFTWARE  §11.6 342
In relations between people or companies, a contract is a writt en document that  
serves to clarify the terms of a relationship. It is really sur prising that in software, where  
precision is so important and am biguity so risky, this idea has  taken so long to impose  
itself. A precondition- postcondition pair fo r a routine will de scribe the contract that the  
routine (the supplier  of a certain service) def ines for its callers (the clients  of that service).
Perhaps the most distinctive feat ure of contracts as they occur  in human affairs is that  
any good contract entails obliga tions as well as benefits for b oth parties — with an  
obligation for one usually turni ng into a benefit for the other . This is true of contracts  
between classes, too: 
• The precondition binds the clie nt: it defines the conditions u nder which a call to the  
routine is legitimate. It is an obligation  for the client and a benefit  for the supplier.
• The postcondition binds the cl ass: it defines the conditions t hat must be ensured by  
the routine on return. I t is a benefit for t he client and an ob ligation for the supplier.
The benefits are, for the client , the guarantee that certain pr operties will hold after  
the call; for the supplier, the guarantee that certain assumpti ons will be satisfied whenever  
the routine is called. The oblig ations are, for the client, to satisfy the requirements as stated  
by the precondition; for the sup plier, to do the job as stated by the postcondition.
Here is the contract for one of the routi nes in our example:
Zen and the art of software reli ability: guaranteeing more by c hecking less
Although you may not have noticed  it yet, one of the contract r ules given goes against the  
generally accepted wisdom in software engineering; shocking at first to many, it is among  
the method’s main contributions t o software reliability and des erves emphasis.
The rule reflects the above obser vation that the precondition i s a benefit  f o r  t h e  
supplier and is expressed in the  bottom-right box of the table:  if the client’s part of the  put OBLIGATIONS BENEFITS
Client(Satisfy precondition :)
Only call put (x) on a non-
full stack.(From postcondition :)
Get stack updated: not 
empty, x on top ( item yields 
x, count  increased by 1).
Supplier (Satisfy postcondition :)
Update stack representation 
to have  x on top ( item yields 
x), count  increased by 1, 
not empty.(From precondition :)
Simpler processing thanks 
to the assumption that stack is not full.A routine 
contract : 
routine put for 
a stack class
§11.6   CONTRACTING FOR SOFTWARE RELIABILITY 343
contract is not fulfil led, that is to say if the call does not satisfy the precondition, then the  
class is not bound by the postco ndition. In this case the routi ne may do what it pleases:  
return any value; loop  indefinitely without returning a value; or even crash the execution  
in some wild way. This is the case in which (in reference to th e discussion at the beginning  
of this chapter) “the customer is wrong”.
The first advantage of this convention is that it considerably simplifies the  
programming style. Havi ng specified as a precondition the const raints which calls to a  
routine must observe, you, the cl ass developer, may assume when  writing the routine body  
that the constraints are satisfi ed; you do not need to test for  them in the body. So if a square  
root function, meant t o produce a real number as a result, is o f the form
sqrt (x: REAL ): REAL
-- Square root of x
require
x >= 0
do … end
you may write the algorithm for c omputing the square root witho ut any concern for the  
case in which x is negative; this is taken care of by the precondition and bec omes the  
responsibility of your clients. (At first sight this may appear  dangerous; but read on.) 
Actually the method of Design by  Contract goes fu rther. Writing  the do clause of the  
routine under the form
if x < 0 then
“Handle the error, somehow”
else
“Proceed with normal s quare root computation”
end
is not just unnecessary but unacc eptable. This may be expressed  as a methodological rule:
T h i s  r u l e  i s  t h e  r e v e r s e  o f  w h a t  m a n y  s o f t w a r e  e n g i n e e r i n g  o r  p rogramming  
methodology textboo ks advocate, often under the name defensive programming  — the  
idea that to obtain reliable soft ware you should design every c omponent of a system so  
that it protects itself as much as possible. Better check too m uch, this approach holds, than  
not enough; one is never too car eful when dealing with stranger s. A redundant check  
might not help, but at least it will not hurt.
Design by Contract follows from the opposite observation: redun dant checks can and  
indeed will hurt. Of course this will at first se em strange; th e natural reaction is to think  
that an extra check — for example routine sqrt containing the ab ove conditional  
instruction testing for x < 0 even though callers have been instructed to ensure x >= 0 — Non-Redundancy principle
Under no circumstances shall the body of a routine ever test fo r the routine’s  
precondition.
DESIGN BY CONTRACT: BUILDING RELIABLE SOFTWARE  §11.6 344
may at worst be useless, but can not possibly cause any damage. S u c h  a  c o m m e n t ,  
however, comes from a microscopi c understanding of reliability,  focused on individual  
software elements such as the sqrt routine. If we restrict our view to the narrow world of  
sqrt, then the routine seems more rob ust with the extra test than w ithout it. But the world  
of a system is not restricted to  a routine; it c ontains a multi tude of routines in a multitude  
o f  c l a s s e s .  T o  o b t a i n  r e l i a b l e  s y s t e m s  w e  m u s t  g o  f r o m  t h e  m i c r oscopic view to a  
macroscopic view e ncompassing the en tire architecture.
If we take this global view, simplicity  becomes a crucial criterion. As was noted at  
the beginning of this chapter, c omplexity is the major enemy of  quality. When we bring in  
this concern, possibly redundant checks do not appear so harmle ss any more! Extrapolated  
to the thousands of routines of a medium-size system (or the te ns or hundreds of thousands  
of routines of a l arger one), the if x < 0 then  … of sqrt, innocuous at first sight, begins to  
look like a monster of useless complexity. By adding possibly r edundant checks, you add  
more software; more software means more complexity, and in part icular more sources of  
conditions that could go wrong; hence the need for more checks,  meaning more software;  
and so on ad infinitum. If we start on this road only one thing  is certain: we will never 
obtain reliability. The more we write, the more we will have to  write.
To avoid this infinite chase we should never start it. With Des ign by Contract you are  
invited to identify the consistency conditions that are necessa ry to the proper functioning  
of each client-supplier coopera tion (each contract); and to spe cify, for each one of these  
conditions, whose responsibility it is  to enforce it: the client ’s, or the supplier’s. The  
answer may vary, and is partly a matter of design style; advice  will be given below on how  
best to choose it. But once you have made the decision, you sho uld stick to it: if a  
correctness requirement appears i n the precondition, indicating  that the requirement is part  
of the client’s responsibility, there must not be a correspondi ng test in the routine; and if  
it is not in the precondition, the n the routine mu st check for the requirement.
Defensive programming a ppears in contrast to cover up for the l ack of a systematic  
approach by blindly putting in as many checks as possible, furt hering the problem of  
reliability rather than addressing it seriously.
Redundant checking, it should be noted, is a standard technique  in hardware. The  
difference is that in a hardware system some object that was fo und to be in a correct state  
at some point may later have its  integrity destroyed because of  reasons beyond the control  
of the system itself, such as interference from another system,  harmful external event, or  
simply wear and tear. For that reason it is normal practice, fo r example, to have both the  
sender and the receiver of an elect ronic signal check its integ rity. 
But no such phenomenon occurs in software: if I can prove or ch eck in some way that a
is non-negative whenever sqrt (a) is called, I do not need to insert a check for x Š≥ 0, 
where x is the corresponding formal argument, in the body of sqrt. Nothing will happen  
to a between the time it is “sent” by the caller and the time it is  “received” (under the name  
x) by the routine. Software does not wear out when used for too long; it is not subject to  
line loss, to interference or to noise.
Also note that in most cases what is called redundant checking in hardware is not really  
redundant: one actually applies different  and complementary verifications, such as a  
p a r i t y  c h e c k  a n d  s o m e  o t h e r  t e s t .  E v e n  w h e n  t h e  c h e c k s  a r e  t h e  same they are often  
§11.6   CONTRACTING FOR SOFTWARE RELIABILITY 345
applied by different devices, as in the just mentioned case of a sender and receiver that  
both check a signal, or in a redundant computer system where se veral computers perform  
the same computation, with a voting mechanism to resolve discre pancies.
Another drawback of defensive programming is its costs. Redunda nt checks imply a  
performance penalty — often enou gh in practice to make develope rs wary of defensive  
programming regardless of what the textbooks say. If they do ma ke the effort to include  
these checks, removing some of th em later to improve performanc e will be tedious. The  
techniques of this chapter will also leave room for extra check s, but if you ch oose to enable  
them you will rely on the develo pment environmen t to carry them  out for you. To remove  
them, once the software has been debugged, it suffices to chang e a compilation option  
(details soon). The software its elf does not contain any redund ant elements.
Aside from performance considera tions, however, the principal r eason to distrust  
defensive programming is simply o ur goal of getting the best po ssible reliability. For a  
system of any significant size the  individual quality of the va rious elements involved is  
not enough; what will c ount most is the gua rantee that for ever y interaction between two  
elements there is an explicit roster of mutual obligations and benefits — the contract.  
Hence the Zen-style paradox of our conclusion: that to get more  reliability the best policy  
is often to check less.
Assertions are not an input checking mechanism
It is useful here to emphasize a few properties of the approach  which, although implicit in  
the preceding discussion, have be en shown by experience to requ ire further explanations.  
The following comments should help address some of the question s that may have been  
forming in your mind as you were reading about the  basic ideas of Design by Contract.
To avoid a common misu nderstanding, make sur e to note that each  of the contracts  
discussed holds between a routine  (the supplier) and another ro utine (its caller): we are  
concerned about software-to-software communication, not softwar e-to-human or  
software-to-outside-world. A prec ondition will not take care of  correcting user input, for  
example in a read_  positive_integer  routine that expects the interactive user to enter a  
positive number. Including in th e routine a prec ondition of the  form
require
input > 0
would be wishful thinking, not a reliability technique. Here th ere is no substitute for the  
usual condition-checking constr ucts, including the venerable if … then  …; the exception  
handling mechanism stu died in the next chapt er may also be help ful.
Assertions do have a role to pla y in a solution to this problem  of input validation. In  
line with the criterion of Modular Protection, the method encou rages validating any objects  
obtained from the outside world  — from sensors,  from user input , from a network … — as  
close to the source of the object s as possible, using “filter” modules if necessary:“Modular protec-
tion”, page 45 .
DESIGN BY CONTRACT: BUILDING RELIABLE SOFTWARE  §11.6 346
In obtaining information from the outside (communication paths shown in color) you  
cannot rely on preconditions. Bu t part of the task of the input  modules shown in grey in  
the middle of the figure is to g uarantee that no information is  passed further to the right —  
to the modules responsible for t he system’s actual computations  — unless it satisfies the  
conditions required for correct processing. In this approach th ere will be ample use of  
assertions in the software-to-so f t w a r e  c o m m u n i c a t i o n  p a t h s  r e p r esented by the black  
dotted lines on the right. The postconditions achieved by the r outines of the input modules  
will have to match (or exceed, in the sense of “stronger” defin ed earlier) the preconditions  
imposed by the pro cessing routines.
The routines of the filter classes may be compared to security officers in, say, a large  
government laboratory. To meet experts from the laboratory and ask them technical  
questions, you must submit to screening procedures. But it is n ot the same person who  
checks your authorization level and answers the questions. The physicists, once you have  
been officially brought into their offices, assume you satisfy the preconditions; and you  
will not get much help from the guards on theoretical physics.
Assertions are not control structures
Another common misunderstanding, r elated to the one just discus sed, is to think of  
assertions as control structures  — as techniques to handle spec ial cases. It should be clear  
by now that this is not their role. If you want to write a rout ine sqrt t h a t  w i l l  h a n d l e  
negative arguments a certain way , and non-negative arguments an other way, a require
clause is not what you need.  Conditional instructions ( if … then  … else …) and related  
constructs to deal with vari ous cases (such as Pascal’s case … of … or the inspect
instruction of this book’s notat ion) are perfectly appropriate for such purposes.
Assertions are something else. T hey express correctness conditi ons. If sqrt has its  
precondition, a c all for which x < 0 is not a special case: it is  a bug, plain and simple.
“Bug” is not a very scientific word but is clear enough to anyo ne in software; we will  
look for more precise terminology  in the next section. For the moment we can pursue the  
assertion violation ru le further by noting a consequence of the  contract view:Assertion Violation rule (1)
A run-time assertion violation is  the manifestation of a bug in  the software.External objects Input and vali dation modules Processing modulesUsing filter 
modules
§11.6   CONTRACTING FOR SOFTWARE RELIABILITY 347
A precondition violati on means that the routine’s caller, altho ugh obligated by the  
contract to satisfy a certain req uirement, did not. This is a b ug in the client itself; the  
routine is not involved. (“The c ustomer is wrong”.) An outside observer might of course  
criticize the contract as too de manding, as with the unsatisfia ble require  False
precondition or our fictitious Sinecure 1 example (“the customer is always  wrong”), but  
this is too late to argue over the contract: it is the contract , and the client did not observe  
its part of the d eal. So if there is a me chanism for monitoring  assertions during execution  
— as will be introduced shortly — and it detects such a precond ition violation , the routine  
should not be executed at all. It has stated the conditions und er which it can operate, and  
these conditions do no t hold; trying to exec ute it would make n o sense.
A postcondition violation means that the routine, presumably ca lled under correct  
conditions, was not ab le to fulfill its contract. Here too the distribution of guilt and  
innocence is clear, although it is the reverse of the previous one: the bug is in the routine;  
the caller is innocent.
Errors, defects and other creeping creatures
The appearance of the word “bug”  in the preceding analysis of a ssertion violation causes  
is a good opportunity to clarify the terminology. In Edsger W. Dijkstra’s view, using the  
word “bug” is a lame attempt by software people to blame someon e else by implying that  
mistakes somehow creep into the software from the outside while  the developers are  
looking elsewhere — as if were n ot the developers who made the mistakes in the first place.
Yet the term enjoys enduring success, if only because it is col orful and readily  
understood. Like the rest of the  software literature, this book  u s e s  i t  f r e e l y .  B u t  i t  i s  
appropriate to complement it by more specific (if more stodgy) terms for cases in which  
we need precise distinctions.
The causal relation is clear: fa ults are due to defects, which result from errors.Assertion violation rule (2)
A precondition violation is the manifestation of  a bug in the c lient.
A postcondition violation is the manifestation of a bug in the supplier.
Terms to denote software woes
An error  is a wrong decision made during the development of a software  
system.
A defect  is a property of a software system that may cause the system t o 
depart from its intended behavior.
A fault is the event of a software syst em departing from its intended behavior  
during one of its executions.
DESIGN BY CONTRACT: BUILDING RELIABLE SOFTWARE  §11.7 348
“Bug” usually has the meaning of  defect (“are you sure there re mains no other bug  
in this routine?”). This is the interpretation in this book. Bu t in informal discussions it is  
also used in the sense of fault (“We have had bug-free operatio n for the last three weeks”)  
or error (“the bug was that I  used an unsorted list”).
11.7  WORKING WITH ASSERTIONS
Let us now probe further the use  of preconditions and postcondi tions, continuing with  
fairly elementary examples. Assertions, some simple, some elabo rate, will be pervasive in  
the examples of the following chapters.
A stack class
The assertion-equipped STACK  class was left in a sketchy form ( STACK1 ). We can now  
come up with a full version incl uding a spelled out implementat ion.
For an effective (directly usable) class we must choose an impl ementation. Let us use  
the array implementation illustrated at the beginning of the di scussion of abstrac t data types:
The array will be called representation and will have bounds 1 and capacity ; the 
implementation also uses a n integer, the attribute count , to mark the top of the stack.
Note that as we discover inherita nce we will see how to write d eferred classes that  
cover several possible implement ations rather than just one. Ev en for a class that uses a  
particular implementat ion, for example by arrays as here, we wi ll be able to inherit  from 
the implementation class ARRAY  r a t h e r  t h a n  u s e  i t  a s  a  c l i e n t  ( a l t h o u g h  s o m e  o b j e c t -
oriented developers will still p refer the client  approach). For  the moment, however, we can  
do without any inheritance-related technique.
Here is the class. Recall that if a is an array then the operation to assign value x to its 
i-th element is a  put (x, i), and the value of its i-th element is given by a  item (i) or,  
equivalently, a @ i . If, as here, the bounds of the array are 1 and capacity , then i must in  
all cases lie betw een these bounds.Stack 
implemented 
with an array (see page 123 
for other 
representations )
representation(ARRAY _UP)“Push” operation:
count := count + 1
representation [count ] := xcountcapacity
1
For an array-based 
stack implementation using inheritance , see 
“IMPLEMENTA-TION INHERI-TANCE”, 24.8, page 844.
§11.7   WORKING WITH ASSERTIONS 349
note
description : "Stacks : Dispenser structures with a Last-In , First-Out  %
%access policy , and a fixed maximum capacity "
class  STACK2 [G] creation  
make
feature -- Initialization
make (n: INTEGER )
-- Allocate stack for a maximum of n elements
require
positive_capacity : n >= 0
do
capacity := n
create  representation   make (1, capacity )
ensure
capacity_set : capacity = n
array_allocated : representation /= Void
stack_empty : empty
end
feature -- Access
capacity : INTEGER  
-- Maximum number of stack elements
count : INTEGER  
-- Number of stack elements
item: G
-- Top element
require
not_empty : not empty  -- i.e.  count > 0
do
Result := representation @ count
end
feature  -- Status report
empty : BOOLEAN
-- Is stack empty?
do
Result := (count = 0)
ensure
empty_definition : Result = (count = 0)
endOn the export status 
of capacity  see exer-
cise E11.4, page 409.
DESIGN BY CONTRACT: BUILDING RELIABLE SOFTWARE  §11.7 350
full: BOOLEAN
-- Is stack full?
do
Result := (count = capacity )
ensure
full_definition : Result = (count = capacity )
end
feature -- Element change
put (x: G)
-- Add x on top
require
not_full : not full -- i.e.  count < capacity in this representation
do
count := count + 1
representation   put (count , x)
ensure
not_empty : not empty
added_to_top : item = x
one_more_item : count = old count + 1
in_top_array_entry : representation @ count = x
end
remove
-- Remove top element
require
not_empty : not empty -- i.e.  count > 0 
do
count := count – 1
ensure
not_full : not full
one_fewer : count = old count – 1
end
feature {NONE } -- Implementation
representation : ARRAY [G]
-- The array used to h old the stack elements
invariant
… To be filled in later (see page 364) …
end
This class text illustrates the simplicity of working with asse rtions. It is complete  
except for the invariant  clause, which will be added late r in this chapter. Let us expl ore 
its various properties.Invariants are intro-
duced in “CLASS 
INVARIANTS”, 11.8, page 363 .
§11.7   WORKING WITH ASSERTIONS 351
This is the first ful l-fledged class of this chapter, not too f ar from what you will find  
in professional libraries of reu sable object-ori ented component s such as the Base libraries.  
(Apart from the use of inheritance and a few extra features, wh at still distinguishes this  
class from its real -life counterparts is the absence of the invariant clause.)
Before studying the assertions, a general note about the struct ure of the class. As  
soon as a class has more than tw o or three features, it becomes  essential to organize its  
features in a coherent way. The notation helps by providing the  possibility of including  
multiple feature  clauses. An earlier chapter introduced this facility as a way to specify a  
different export status for certain features, as done here for the last part of the class, labeled  
-- Implementation  to specify that feature representation is secret. But as already  
previewed in STACK1  you can take advantage  of multiple feature clauses even when t he 
export status is the same. The p urpose is to make  the class eas ier to read, and easier to  
manage, by grouping fe atures into general categories. After eac h feature  keyword appears  
a comment (known as the Feature Cl ause Comment) de fining the ge neral role of the  
features that follow. The categories used in the example are th ose of STACK1 , plus  
Initialization  for the creat ion procedure.
The standard feature categories and associated Feature Clause C omments are part of  
the general rules for consistency and organization of reusable library classes. A more  
complete list appears in the chapter on style rules.
The imperative and the applicative
The assertions of STACK2  illustrate a fundamental concep t of which we got a first glimp se 
when we studied the transition from abstract data types to clas ses: the difference between  
imperative and applicative views.
The assertions in empty  and full may have caused you to r aise an eyebrow. Here  
again is the text of full:
full: BOOLEAN
-- Is stack full?
do
Result := (count = capacity )
ensure
full_definition : Result = (count = capacity )
end
The postcondition expresses that Result  has the same value as count = capacity . 
(Since both sides of the equality, the entity Result  and the expression count = capacity , are 
boolean, this means that the function returns true if and only if count is equal to capacity .) 
But what is the point of writing this postcondition, one may as k, since the body of the  
routine (the do clause) says exactly the same  thing through the instruction  
Result  := (count  = capacity ), whose only difference with the  postcondition c lause is its us e 
of := rather than =? Is the postcondi tion not redundant?On multiple feature 
clauses and export-ing to NONE see 
“SELECTIVE 
EXPORTS AND INFORMATION 
HIDING”, 7.8, 
page 191.
“Feature clause 
header comments”, page 889 .
“Introducing a more 
imperative view”, page 145 .
DESIGN BY CONTRACT: BUILDING RELIABLE SOFTWARE  §11.7 352
Actually, there is a big difference between the two constructs,  and no redundancy at  
all. The instruction Result := (count = capacity ) is a command that we give to our virtual  
computer (the hardware-software machine) to change its state in  a certain way; it performs  
an action. The assertion Result = (count = capacity ) does not do anythi ng: it specifies a  
property of the expected end sta te, as visible to the routine’s  caller.
The instruction is prescriptive ; the assertion is descriptive . The instruction describes  
the “how”; the assertion describ es the “what”. The instruction i s  p a r t  o f  t h e  
implementation; the assertion is an elem ent of spe cification.
The instruction is imperative ; the assertion is applicative . These two terms  
emphasize the fundamental differ ence between the worlds of comp uting and mathematics:
• Computer operations may change the state of the hardware-softw are machine.  
Instructions of common programming  languages are commands (impe rative 
constructs) directing the machine to execute such operations.
• Mathematical reasoning never changes anything; as noted in the  presentation of  
abstract data types, taking the square root of the number 2 doe s not change that  
number. Mathematics instead desc ribes how to use properties of known objects, such  
as the number 2, to infer pr operties of ot hers, such as , obtained from the former  
by applying  (hence the name) certain mathem atical derivations such as squa re root.
That the two notations are so cl ose in our example — assignment  := and equality =
— should not obscure this fundamental difference. The assertion  describes an intended  
result, and the instruction (the loop body) prescribes a partic ular way to achieve that result.  
Someone using the class to write a client module will typically  be interested in the  
assertion but not in  the implementation.
The reason for the closeness of notations for assignment and eq uality is that  
assignment is indeed in many cases the straightforward way to a chieve equality; in our  
example the chosen implementation, Result := (count = capacity ), is indeed the obvious one.  
But as soon as we move on to mor e advanced examples the concept ual difference between  
the specification and the implem entation will be  much larger; e ven in the simple case of a  
function to compute the squa re root of a real number x, where the postco ndition is just  
something like abs (Result ^ 2 – x ) <= tolerance with abs denoting absolute value and  
tolerance  a tolerance value, the instruct ions in the func tion’s body wil l be far less trivial  
since they have to implement a g eneral algorithm for the comput ation of square roots.
Even for put in class STACK2 , the same specification could have led to different  
implementations, although the differences are minor; for exampl e the body could be
if count = capacity then  Result := True else Result := False end
perhaps simplified (thanks to the rules of default initializati on) into
if count = capacity then  Result := True end
So the presence of related eleme nts in the body and the postcon dition is not evidence  
of redundancy; it is evidence of  consistency between the implem entation and the  
specification — that is to say , of correctness as defined at th e beginning of this chapter.2
§11.7   WORKING WITH ASSERTIONS 353
In passing, we have encountered a property of assertions that w i l l  m e r i t  f u r t h e r  
development: their rel evance for authors of client classes, who m we should not ask to read  
routine implementations, but who need a more abstract descripti on of the routine’s role.  
This idea will lead to the notion of short form  discussed later in this chapter as the basic  
class documentation mechanism.
A caveat: for practical reasons we will allow assertions to inc lude some seemingly  
imperative elements (f unctions). This issue will be explored at  the end of this chapter.
As a summary of this discussion it is useful to list the words that have been used to  
contrast the two c ategories of soft ware elements:
A note on empty structures
The precondition of the  creation procedure make  in class STACK1  requires a comment. It  
states n >= 0, hence allowing empty stacks. If n is zero, make  will call the creation  
procedure for arrays, also named make , with arguments 1 and 0 for the lower and upper  
bounds respectively. This is not  a n  e r r o r ,  b u t  f o l l o w s  f r o m  a  c onvention regarding  
ARRAY ’s creation procedure:  using a first argument greater than the second by one creates  
an empty array.
A zero n for a stack, or a first creation argument greater than the sec ond for an array,  
is not wrong but simply means that this particular stack or arr ay should be empty. An error  
would only occur out of a call attempting to access an element from the structure, for  
example a put for the stack or an item for the array , both of whose preconditions will  
always be false for an empty structure (“ my customer is always wrong”). 
When you define a general data s t r u c t u r e  s u c h  a s  a  s t a c k  o r  a r r ay, you should  
determine whether the case of an  empty structure is conceptuall y meaningful. In some  
cases it is not: for example mos t definitions of the notion of tree start from the assumption  
that there is at least one node, the root. But if the empty cas e raises no logical impossibility,  
as with arrays and stacks, you sh ould plan for it in the design  of your data structure,  
acknowledging that clients will, every once in a while, create empty instances, and should  
not suf fer for it. An application system may for example need a  stack for n elements,  
where n is an upper bound on the number of elements to be stacked, com puted by the  
application just before it creat es the stack; in some runs that  number may be zero. This is  
not an error, simply an extreme case.
The array mechanism of Algol W provides a counter-example. When  a dynamically  
allocated array has an empty range, the program terminates in e rror — even if it was a  
perfectly valid array which simply happened to be empty on that  particular run. This is too  
restrictive: an array with zero size is valid, it simply does n ot allow acces s to any element.Implementation Specification
Instruction Expression
How What
Imperative Applicative
Prescription DescriptionSee “Including func-
tions in assertions”, page 400.
The 
imperative-
applicative opposition
DESIGN BY CONTRACT: BUILDING RELIABLE SOFTWARE  §11.7 354
Precondition design: tolerant or demanding?
Central to Design by Contract is th e idea, expressed as the Non-R edundancy principle,  
that for any consistency conditi on that could jeopardize a rout ine’s proper functioning you  
should assign enforcement of this condition to only one of the two partners in the contract.
Which one? In each case you  have two possibilities:
• Either you assign the responsib ility to clients, in which case  the condition will appear  
as part of the routine’s precondition.
• Or you appoint the supplier, in which case the condition will appear in a conditional  
instruction of the form if condition  then  …, or an equivalent control structure, in the  
routine’s body.
We can call the first attitude demanding  and the second one tolerant . The STACK2  
class illustrates the demanding style; a tolerant version of th e class would have routines  
with no preconditions, such as
remove
-- Remove top element
do
if empty then
print ("Error : attempt to pop an empty stack ")
else
count := count – 1
end
end
I n  t h e  a n a l o g y  w i t h  h u m a n  c o n t r a c t s we can think of the demandi ng style as  
characterizing an experienced con tractor who expects his client s to “do their homework”  
before calling on him; he has no trouble finding business, and will reject requests that  
appear too broad or unreasonable. The tolerant style evokes the  i m a g e  o f  a  f r e s h l y  
established consulting practice,  whose owner is so desperate fo r business that he will take  
anything, having put in h is driveway a big sign:The principle was on 
page 343.
Warning : not the 
recommended style .
§11.7   WORKING WITH ASSERTIONS 355
Which is the better style? To a certain extent this is a matter  of personal choice (as  
opposed to the Non-Redundancy pr inciple, which was absolute in stating that it is never 
acceptable to deal with a correctness condition on both the cli ent and supplier sides). A  
strong case can be made, however, for the demanding style illus trated by STACK2 , 
especially in the case of software meant to be reusable — and i n O-O development we  
should always write our software  with the goal of  ultimately ma king it reusable.
At first the tolerant style might appear better for both reusab ility and reliability; after  
all the demanding approach appear s to put more responsibility o n the clients, and there are  
typically many clients for a sin gle supplier — even more so for  a reusable class. Is it not  
preferable, then, to let the sup plier take care of the correctn ess conditions once and for all,  
rather than requir e every client to do it for itself?
If we look more closely at the is sue this reasoning does not ho ld. The correctness  
conditions describe wh at the routine requires to be able to do its job properly. The tolerant  
remove on the facing page is a good co unter-example: what can a poor s tack-popping  
routine do for an empty stack? It makes a brave attempt by outp utting an error message,  
but this is clearly inadequate: a specialized utility module su ch as a stack handler has no  
business messing up the system’s user output. We could try some thing more sophisticated,  
but remove simply does not have the prope r context; the focus of class STACK2 is too 
narrow to determine what to do in the case of an empty stack. Only the client  — a module  
using stacks in some application,  for example the parsing modul e in a compiler — has  
enough information to decide what an attempt  to pop an empty st ack really means: is it a  
normal although useless request that we should simply ignore, e xecuting a null operation?  
Or is it an error, and if so, how should we handle it: raise an  exception, correct the situation  
before trying again, o r (the least likely a nswer) output a user -visible error message?
In the square root example, you may remember the fictitious rou tine text quoted in  
the discussion pre ceding the Non-Red undancy principle:
if x < 0 then
“Handle the error, somehow”
else
“Proceed with normal s quare root computation”
endNO PRECONDITION
TOO BIG
OR TOO SMALL !
Page 343 .
DESIGN BY CONTRACT: BUILDING RELIABLE SOFTWARE  §11.7 356
The operative word is “ somehow ”. The then  clause is incantation more than  
software: there is really no good  general-purpose technique for  handling the x < 0 case.  
Here again a general-purpose routine has no clue. Only the clie nt author can know what  
the call means in this case — an  error in the software, a case in which the expected result  
is 0, a reason to tr igger an exception …
In this case as in the attempt at a tolerant remove , the position of the routine is not  
unlike that of a postman asked to deliver a postcard with no de livery address and no return  
address: the case falls outside of the contract, and there is n o good way to decide what to do.
In the spirit of Design by Contra ct, the demanding approach to precondition design  
does not attempt to produce rout ines that are all things to all  clients. Instead, it insists that  
each routine do a well-defined jo b and do it well (correctly, e fficiently, generally enough  
to be reusable by many clients …), and specify clearly what cases it cannot handle. In fact  
you cannot hope that the routine will do its job well unless  you have carefully  
circumscribed that job. A factot um routine, which wants to do a  computation and check  
for abnormal cases and take corrective actions and notify the c lient and produce a result  
anyway, will most likely fail to  fulfill any of these goals pro perly.
The routine author doe s not try to outsmart his clients; if he is not sure of what the  
routine is supposed to do in a ce rtain abnormal s ituation, he e xcludes it explicitly through  
the precondition. This attitude i s more generally a consequence  of the overall theme in this  
book: building software systems as sets of modul es that mind th eir own business.
If you read the supplementary mathematical section in the chapt er on abstract data types,  
you may have noted the similarity between the present discussio n and the arguments for  
using partial functions in the mathematical model, rather than special error values such  
as ωINTEGER . The two ideas are indeed very close, and Design by Contract i s in part the  
application to software constr uction of the concept of partial function, so remarkably  
flexible and powerful in formal specification.
A word of caution: the demanding  approach is only applicable if  the preconditions  
remain reasonable. Otherwise the  job of writing a module would become easy: start every  
routine with require  False  so that, as we have seen, any r outine body will be correct. Wh at 
does “reasonable ” concretely mean for th e precondition of a rou tine? Here is a more  
precise characterization:
Reasonable Precondition principle
Every routine precondition (in a  “demanding” design approach) m ust satisfy  
the following requirements:
• The precondition appears in the official documentation distrib uted to  
authors of client modules.
• It is possible to justify the need for the precondition in ter ms of the  
specification only.“Alternatives to par-
tial functions”, page 151.
§11.7   WORKING WITH ASSERTIONS 357
The first requirement will be su pported by the notion of short form studied later in  
this chapter. The second require ment excludes restrictions mean t only for the supplier’s  
convenience in implementing the routine. For example when you w ant to pop a stack the  
precondition not empty is a logical requirement that can  be justified “in terms of the  
specification only”, t hrough the simple observation that in an empty stack there is nothing  
to pop; and when you wa nt to compute the re al square root of a number, the precondition  
x >= 0 is a direct result of the mathe matical property that negative real numbers do not  
have real sq uare roots.
Some restrictions may arise from  the general kind of implementa tion selected. For  
example the presence of require not full as precondition to the push operation put in 
STACK2  is due to the decision of using  an array for the implementatio n of stacks. But such  
a case does not violate the prin ciple, as the bou nded nature of  STACK2  stacks has been  
made part of the specification: the class does not claim to rep resent arbitrary stacks, but  
only stacks of finite maximum capacity (as expressed for exampl e in the note clause of  
the class). The abstract data type serving as specification of this class  is  not the mo st  
general notion of stack, but t he notion of bounded stack.
In general, it is desirable to avoid bounded structures; even a  stack implemented by arrays  
can use array resizing. This is the case with the most commonly  used stack class in the  
Base libraries, which follows the STACK2  style but without a notion of capacity ; a stack  
that overflows its current capac ity resizes itself silently to accommodate the new 
elements.
Preconditions and export status
You may have noted the need for a supplementary requirement on preconditions, which does not  
figure in the Reasonable Precond ition principle: to be satisfia ble by the clients, the precondition  
must not use fea tures that are hidden fr om the clients as a res ult of export restrictions.
Assume for example the  following situation:
-- Warning: this is an  invalid class, for purposes of illustrat ion only.
class  SNEAKY feature
tricky
require
accredited
do
…
end
feature {NONE }
accredited : BOOLEAN do … end
end
The specification for tricky states that any call to that  procedure must satisfy the  
condition expressed by  the boolean function accredited . But whereas the class exports  
tricky  to all clients, it keeps accredited  secret, so that clients have no way of finding out,  The general stack 
ADT was studied in chapter 6 ; the 
bounded stack ADT was the subject of exercise E6.9, page 162.
DESIGN BY CONTRACT: BUILDING RELIABLE SOFTWARE  §11.7 358
before a call, whether the call is indeed correct. This clearly  unacceptable situation is akin,  
in human contracts, to a deal in which the supplier would impos e some conditions not  
stated explicitly in the contract, and hence could reject a cli ent’s request as incorrect  
without giving the client any wa y to determine in advance wheth er it is correct.
The reason why the Reasonable Pr econdition princ iple does not c over such cases is  
that here a methodological princ iple does not suffice: we need a language rule to be  
enforced by compilers, not left to the decision of developers.
The rule must take into account a ll possible export situations,  not just those  
i l l u s t r a t e d  a b o v e  i n  w h i c h  a  f e a t u r e  i s  a v a i l a b l e  t o  a l l  c l i e n t s (tricky ) or to no client  
(accredited ). As you will recall from the d iscussion of information hiding , it is also  
possible to make a feature available to some clients only, by d eclaring it in a feature clause  
appearing as feature {A, B, …}, which makes it a vailable only to A, B, … a n d  t h e i r  
descendants. Hence  the language rule:
With this rule every client that is in a position to call the f eature will also be in a  
position to check for its preco ndition. The rul e makes class SNEAKY invalid, since tricky
is generally exported (available to all clients); you can turn it into a valid class by making  
accredited  also generally exported. If tricky  had appeared in a feature clause starting with  
feature {A, B, C}, then accredited  would have to be exported at least to A, B and C (by 
appearing in the same feature clause as tricky , or by appearing in a clause of the form
feature {A, B, C}, or feature {A, B, C, D, …}, or just feature ). Any violation of this rule  
is a compile-tim e error. Class SNEAKY , for example, will be r ejected by the compiler.
There is no such rule for postconditions. It is not an error fo r some clauses of a  
postcondition clause to refer to  secret features, or features t hat are not as broadly exported  
as the enclosing routine; this si mply means that you are expres sing properties of the  
routine’s effect that are not di rectly usable by  clients. This was the case with the put
procedure in STACK2 , which had the form
put (x: G)
-- Add x on top
require
 not full
do
…
ensure
… Other clauses …
in_top_array_entry : representation @ count = x
endPrecondition Availability rule
Every feature appearing in the p recondition of a routine must b e available to  
every client to which th e routine is available.“SELECTIVE 
EXPORTS AND INFORMATION HID-ING”, 7.8, page 191 .
For the  Other clauses  
see page 350 .
§11.7   WORKING WITH ASSERTIONS 359
The last postcondition clause in dicates that the array entry at  index count  contains  
the element just pushed. This is  an implementation property; ev en though put is generally  
available (exported to all clients), array representation  is secret. But there is nothing  
wrong with the postcondition; it simply includes, along with pr operties that are directly  
useful to clients (the “ Other clauses ”), one that is only meanin gful for someone who reads  
the entire class text. Such secret clauses will not appear in t he “short” form of the class —  
the documentation fo r client authors.
A tolerant module
(On first reading you may skip t his section or just look throug h it quickly.)
The simple but unprotected basic modules may not be robust enou gh  f o r us e b y  
arbitrary clients. In some cases there will be a need for new c lasses to serve as filters,  
interposed not between the software and the external world (as with filters of the kind  
discussed earlier in this chapte r) but between software and oth er software: possibly  
careless clients on on e side, unprotected c lasses on the other.
Although we have seen that this is generally not the right appr oach, it is useful to  
examine how classes will look if we do decide to use the tolera nt style in a specific case.  
Class STACK3 , appearing next, illustrates the idea. Because the class needs  to set integer  
error codes, it is convenient to  rely on a property of the nota tion that has not been  
introduced yet: “unique” integer  constants. If you declare a se t of attributes as
a, b, c, …: INTEGER unique
the effect is to define a, b, c … as integer constants with cons ecutive positive values. These  
values will be assigned by the c ompiler, and are guaranteed to be different for all constants  
thus declared, relieving you of having to invent separate codes . By conventi on, constant  
attributes such as these have na mes beginning wi th an upper-cas e letter, with the rest in  
lower case, as in  Underflow .
Here, using this technique, is a  tolerant version of our earlie r stack class. Make sure  
to note that this class text (wh ich you may just  skim through o n first reading) is included  
here only to make sure you under stand the tolerant style; it is  not an example of the  
generally recommended design — fo r reasons that will be discuss ed below, but will  
probably be clear en ough as you browse through the text.
note
description : "Stacks : Dispenser structures with a Last-In , First-Out  %
%access policy , and a fixed maximum capacity ; %
%tolerant version , setting an error code in case  %
%of impossible operations ."
class  STACK3 [G] creation  
makeFor filters of the first 
kind see “Assertions are not an input 
checking mecha-
nism”, page 345 .
“UNIQUE VALUES”,
18.6, page 654 .
DESIGN BY CONTRACT: BUILDING RELIABLE SOFTWARE  §11.7 360
feature -- Initialization
make (n: INTEGER )
-- Allocate stack for a maximum of n elements if n > 0;
-- otherwise set error  to Negative_size .
-- No precondition!
do
if capacity >= 0 then
capacity := n
create  representation   make (capacity )
else
error := Negative_size
end
ensure
error_code_i f_impossible : (n < 0) = (error = Negative_size )
no_error_if_  possible : (n >= 0) = (error = 0)
capacity_set_if_no_error : (error = 0) implies (capacity = n)
allocated_if_no_error : (error = 0) implies (representation /= Void )
end
feature -- Access
item: G
-- Top element if present; otherw ise the type’s default value.
-- with error  set to Underflow .
-- No precondition!
do
if not empty then
check representation /= Void end
Result := representation   item
error := 0
else
error := Underflow
-- In this case the result is the default value
end
ensure
error_code_i f_impossible : (old empty ) = (error = Underflow )
no_error_if_  possible : (not (old empty )) = (error = 0)
end
feature -- Status report
empty : BOOLEAN
-- Number of stack elements
do
Result := (capacity = 0) or else representation   empty
end
§11.7   WORKING WITH ASSERTIONS 361
error : INTEGER
-- Error indicator, se t by various features  to a non-zero value  
-- if they cannot  do their job
full: BOOLEAN
-- Number of stack elements
do
Result := (capacity = 0) or else representation   full
end
Overflow , Underflow , Negative_size : INTEGER unique
-- Possible error codes
feature -- Element change
put (x: G)
-- Add x on top if possible; oth erwise set error code.
-- No precondition!
do
if full then
error := Overflow
else
check representation /= Void end
representation   put (x); error := 0
end
ensure
error_code_if_impossible : (old full) = (error = Overflow )
no_error_if_  possible : (not old full) = (error = 0)
not_empty_if _no_error : (error = 0) implies  not empty
added_to_top _if_no_error : (error = 0) implies  item = x
one_more_ite m_if_no_error : (error = 0) implies  count = old count + 1
end
remove
-- Remove top element if pos sible; otherwise set error.
-- No precondition!
do
if empty then
error := Underflow
else
check representation /= Void end
representation   remove
error := 0
end
ensure
error_code_if_impossible : (old empty ) = (error = Underflow )
no_error_if_  possible : (not old empty ) = (error = 0)
not_full_if_no_error : (error = 0) implies  not full
one_fewer_item_if_no_error : (error = 0) implies  count = old count – 1
end
DESIGN BY CONTRACT: BUILDING RELIABLE SOFTWARE  §11.7 362
feature {NONE } -- Implementation
representation : STACK2 [G]
-- The unprotected stack  used as implementation
capacity : INTEGER
-- The maximum number of stack elements
end
The operations of this class have no preconditions (or, more ac curately, have True as 
their preconditi ons). For those that may  result in abnormal sit uations, the postcondition  
has been refined to distinguish between correct and erroneous p rocessing. An operation  
such as s  remove , where s is a STACK3 , will set s  error  to 0 or to Underflow (which, from  
the rules on unique values, is k nown to be strictly positive) a nd, in the latter case, do  
nothing else. It is still the ca ller’s responsibility to check for s  error  after the call. As  
noted, a general-pur pose module such as STACK3  has no way to decid e what to do in the  
case of an erroneous popping attem pt: produce an error message,  take corrective action … 
Such filter modules serve to sepa rate algorithmic  techniques to  deal with normal  
cases and techniques for handling errors. This is the distincti on between correctness and  
robustness explained at the begin ning of this book: writing a m odule that performs  
correctly in legal cases is one task; making sure that other ca ses are also processed  
decently is another. Both are necessary, but they should be han dled separately. Failure to  
do so is one of the principal re asons why so many software syst ems are hopelessly  
complex: any algorithm that does  anything useful also takes car e of checking that it is  
applicable, and for good measure tries to handle the cases in w hich it is not. Such software  
soon mushrooms into a total mess.
A few technical comments apply to this example: 
• An instance of STACK3  i s  n o t  a n  a r r a y  b u t  a  s t r u c t u r e  c o n t a i n i n g  a  r e f e r e n c e  
(representation ) to an instance of STACK2 , itself containing a reference to an array.  
These two indirections, detrimen tal to efficiency, can be avoid ed through inheritance  
as studied in later chapters.
•The boolean operator or else  is similar to or but ignores the second operand if it does  
not affect the result and trying  to evaluate it could cause tro uble.
•T h e  check  instruction used in put and remove  serves to state that a certain assertion  
is satisfied. It will be stu died later in this chapter.
Finally, you will have n oted the heaviness of STACK3 , especially if you compare it  
to the simplicity that STACK2 achieves with its precondition. STACK3  is good evidence  
that a tolerant style may lead t o uselessly complex software. T he demanding style, in  
contrast, follows from the gener al spirit of Design by Contract . Trying to handle all  
possible (and impossible) cases is not necessarily the best way  to help your clients. If  
instead you build clas ses that impose poss ibly strict but reaso nable usage conditions, and  
describe these conditions precis ely as part of the official doc umentation for the class, you  
actually make life easier for the clients. This has been called  the tough love  approach: you  
can often serve your clients bet ter by being mor e restrictive.See “A REVIEW OF 
EXTERNAL F AC-TORS”, 1.2, page 4 .
On or else  see “Non-
strict boolean opera-tors”, page 454 .
§11.8   CLASS INV ARIANTS 363
Better an efficient supplier that states its functionally justi fied limitations than a  
overzealous one that tries to se cond-guess its clients, making possibly inappropriate  
decisions for abnormal cases, and sacrificing simp licity and ef ficiency.
For modules whose clie nts are other software modules, the deman ding approach is  
usually the right one. A possibl e exception is the case of modu les intended for clients  
whose authors use a non-O-O lan guage and may not have understoo d the basic concepts  
of Design by Contract.
The tolerant approach remains useful for software elements that  d e a l  n o t  w i t h  o t h e r  
software elements but with data coming from the outside world, such as user input, or  
sensor data. Then, as noted earlier, filter modules are often n ecessary to separate the  
actual processing modules (the physicists in our metaphor) from  those which simply  
qualify data and reject anything that is not appropriate (the g uards). This separation of  
concerns is essential for mainta ining the simplicity of softwar e elements on both sides.  
STACK3  provides an idea of what such modules may look like.
11.8  CLASS INV ARIANTS
Preconditions and post conditions describe th e properties of ind ividual routines. There is  
also a need for expressing globa l properties of the instances o f a class, which must be  
preserved by all routin es. Such properties will make up the cla ss invariant, capturing the  
deeper semantic proper ties and integrity con straints characteri zing a class.
Definition and example 
C o n s i d e r  a g a i n  t h e  e a r l i e r  i m p l e m e n t a t i o n  o f  s t a c k s  b y  a r r a y s ,  the one without the  
protections ( STACK2 ): 
class STACK2 [G] creation
make 
feature
… make , empty , full, item , put, remove …
capacity : INTEGER
count : INTEGER
feature {NONE } -- Implementation
representation : ARRAY [G]
end
The attributes of the class — array representation  and integers capacity  and count  — 
constitute the stack r epresentation. Althou gh routine precondit ions and postconditions,  
given earlier, express some of th e semantic properties of stack s, they fail to express other  
important consistency properties linking the attributes. For ex ample, count  should always  
remain between 0 and capacity :
0 <= count ; count <= capacity
(implying also that capacity >= 0), and capacity  should be the array size:“Assertions are not an
input checking mech-anism”, page 345 .
Page 349 .
DESIGN BY CONTRACT: BUILDING RELIABLE SOFTWARE  §11.8 364
capacity = representation   capacity
A class invariant is such an ass ertion, expressing general cons istency constraints that  
a p p l y  t o  e v e r y  c l a s s  i n s t a n c e  a s  a whole; this is different fro m preconditions and  
postconditions, which charact erize individu al routines. 
The above assertions involve onl y attributes. Invariants may al so express the  
semantic relations between funct ions, or between functions and attributes. For example  
the invariant for STACK2  may include the following prope rty describing the connection  
between empty  and count : 
empty = (count = 0)
In this example, the invariant assertion links an attribute and  a function; it is not  
particularly interesting as it me rely repeats an assertion that  appears in the postcondition  
of the function (here empty ). More useful assertions are those which involve either only  
attributes, as above, or  more than one function.
Here is another typical example.  Assume — in lin e with previous  examples dealing  
with the notion of bank account — that we have a class BANK_ACCOUNT  with features  
deposits_list , withdrawals_list  a n d  balance . Then the invariant for such a class could  
include a clause of the form:
consistent _balance : deposits_list   total – withdrawals_list   total = balance
where the function total gives the cumulated value of a list of operations (deposits or  
withdrawals). This states the ba sic consistency condition betwe en the value s accessible  
through features deposits_list , withdrawals_list  and balance .
Form and properties of class invariants 
Syntactically , a class invariant is an assertion, appearing in the invariant  clause of the  
class, after the  features and just before the end, as in 
class STACK4 [G] creation
… As in STACK2 …
feature
… As in STACK2 …
invariant
count_non_negative : 0 <= count
count_bounded : count <= capacity
consistent_with_array_size : capacity = representation   capacity
empty_if_no_elements : empty = (count = 0)
item_at_top : (count > 0) implies (representation   item (count ) = item )
end
An invariant for a class C is a set of assertions that every instance of C will satisfy at  
all “stable” times. Stable times a re those in whic h the instanc e is in an observable state: This example was 
first discussed in  
“Uniform Access”, page 55
. It will serve 
again to illustrate persistence issues: “Correction”, page 1045.
For the features of 
STACK2 see page 
349.
§11.8   CLASS INV ARIANTS 365
• On instance creation, that is to say after execution of create  a or create  a  make (…), 
where a is of type C. 
• Before and after every remote call a  r (…) to a routine r of the class. 
The following figure, showing the life of an object, helps put the notions of invariant  
and stable time in place.
Life as an object, to tell the truth, is not that thrilling (in  case you ever wondered).  
At the beginning — left of the f igure — you do not exist. You a re begot by a creation  
instruction create  a or create  a  make (…), or a clone , and reach y our first station in life.  
Then things get qu ite boring: through some reference a, clients use you, one after the other,  
by applying operat ions of the form a  f (…) where f  is a feature of your generating class.  
And so on forever, or at least until execution terminates.
The invariant is the characterist ic property of the states repr esented by gray squares  
in the figure — S1 etc. These are the “stable times” mentioned above: those at which the  
object is observable from the ou tside, in the sense that a clie nt can apply a feature to it.  
They include:
• The state that result s from the creation of an object (S1 in t he figure).
• T h e  s t a t e s  i m m e d i a t e l y  b e f o r e  a n d  a f t e r  a  c a l l  o f  t h e  f o r m  a  some_routine (…)
executed by a client.
Here the context is sequential computation, but the ideas will transpose to concurrent  
systems in a later chapter. create  a make (…)
S1
S2S3S4a  f (…)
a  g (…)
a  f (…)The life of an 
object
Chapter 30 covers 
concurrency ; see in 
particular “Concur-rent accesses to an object”, page 982 .
DESIGN BY CONTRACT: BUILDING RELIABLE SOFTWARE  §11.8 366
An invariant that varies
In spite of its name, the invari ant does not need to be satisfi ed at all times, although in the  
STACK4 example it does remain true after the initial creation. In the more general case, it  
is perfectly accepta ble for a procedure g to begin by trying to work towards its goal — its  
postcondition — and in the process to destroy the invariant (as  in human affairs, trying to  
do something useful may disrupt the established order of things ); then it spends the second  
part of its execution scurrying to restore the invariant withou t losing too much of whatever  
ground has been gained. At some i ntermediate stages, such as th e instant marked  in the  
figure, the invariant will not hold; this is fine as long as th e procedure reestablishes the  
invariant before termi nating its e xecution.
Who must preserve the invariant?
Qualified calls, of the form a  f (…), executed on behalf of a cli ent, are the only ones that  
must always start from a state s atisfying the invariant and lea ve a state satisfying the  
invariant; there is no such rule  for unqualified calls of the f orm f (…), which are not  
directly executed by clients but  only serve as auxiliary tools for carrying out the needs of  
qualified calls. As a consequenc e, the obligation to maintain t he invariant applies only to  
the body of features that are exported either generally or sele ctively; a secret feature —  
one that is available to no client — is not  affected by the inv ariant.
From this discussion follows the  rule that precisely defines wh en an assertion is a  
correct invariant for a class:
Note that in this rule: 
• Every class is considered to ha ve a creation procedure, define d as a null operation if  
not explicitly specified. 
• The state of an object is defin ed by all its fields (the value s of the class attributes for  
this particular instance). 
• The preconditi on of a routine may invol ve the initial state an d the arguments. Invariant rule
An assertion I is a correct class invariant for a class C if and only if it meets  
the following two conditions: 
E1 • Every creation procedure of C, when applied to arguments satisfying  
its precondition in a state where the attributes have their def ault 
values, yields a s tate satisfying I. 
E2 • Every exported routine of the class, when applied to arguments and a 
state satisfying both I and the routine’s precondition, yields a state  
satisfying I. 
§11.8   CLASS INV ARIANTS 367
• The postcondition may only invol ve the final state, the initia l state (through the old
notation) and, in the case of a function, the returned value, g iven by the predefined  
entity Result . 
• The invariant may onl y involve the state. 
Assertions may use functions, but such functions are an indirec t way of referring to the  
attributes — to the state.
A mathematical stateme nt of the Invariant rule appears later in  this chapter.
You can use the Invariant rule a s a basis for an swering a quest ion that comes up in  
light of earlier discussions: what would it mean if an invarian t clause turned out to be  
violated during system  execution? We saw before that a precondi tion violation signals an  
error (a “bug”) in the client, a postcondition violation an err or in the supplier. The answer  
will be for invariants as for po stconditions; you have all the elements for deriving this  
property by yourself.
The role of class invaria nts in software engineering
Property E 2 indicates that we may consider the invariant as being implicit ly added  
(anded) to both the prec ondition and postcondi tion of every exporte d routine. So in  
principle the notion of  invariant is super fluous: we could do w ithout it by enriching the  
preconditions and postconditions of all routines in the class.
Such a transformation is of course not desirable. It would comp licate the routine  
texts; but more importantly, we would lose the deeper meaning o f the invariant, which  
transcends individual routines a nd  ap pl ie s t o t he  cl as s a s a  w h ole. One should in fact  
consider that the invariant applies not only to the routines ac tually written in the class, but  
also to any ones that might be a dded later, thus serving as con trol over future evolution of  
the class. This will be reflect ed in the inheritance rules.
In the view of software development introduced at the beginning  of this book, we  
accept that change is inevitable, an d  w e  t r y  t o  c o n t r o l  i t .  S o m e aspects of a software  
system, and of its individual co mponents — classes — may be exp ected to change faster  
than others. Adding, removing or changing features, in particul ar, is a frequent and normal  
event. In this volatile process one will want to cling to prope rties that, although they may  
change too — for we can hardly gu arantee that any aspect of a s ystem will remain set for  
eternity — will change far less often. Invariants, because they  capture the fundamental  
semantic constraints  applying to a class , play this role.
The STACK2  example illustrates the basic ideas, but to appreciate the ful l power of  
the concept of invariant you sho uld be on the lookout for furth er examples of invariants in  
the rest of this book. To me the notion of the invariant is one  of the most illuminating  
concepts that can be learned from the object-oriented method. O nly when I have derived  
the invariant (for a class that I write) or read and understood  it (for someone else’s class)  
do I feel that I know wh at the class is about.This is the topic of 
exercise E11.8, page 409. The reasoning 
for preconditions and postconditions was in “Assertions are not control structures”, page 346
DESIGN BY CONTRACT: BUILDING RELIABLE SOFTWARE  §11.8 368
Invariants and contracting
Invariants have a clear interpre tation in the contract metaphor . Human contracts often  
contain references to general cl auses or regulations that apply  to all contracts within a  
certain category; think of a city ’s zoning regulations, which a pply to all house-building  
contracts. Invariants play a sim ilar role for software contract s: the invariant of a class  
affects all the contracts between  a routine of the class and a client. 
Let us probe further. It was not ed above that we may consider t he invariant as being  
added to both the precondition a nd postcondition of every expor ted routine. Let body  be 
the body of a routine (the s et of instructions in its do clause), pre its precondition, post its 
postcondition and INV the class invariant. The correctness requirement on the routine  may 
be expressed, using the notation introduced earlier in this cha pter, as:
{INV and pre} body {INV and post}
(As you will remember this  means: any execution of body , started in any state in which  
INV and pre both hold, will terminate in a state in which both INV and post hold.)
For the supplier author — the person who writes body — is the invariant good news  
or bad news, that is to say, doe s it make the job easier or har der?
T h e  a n s w e r ,  a s  y o u  w i l l  h a v e  f i g u r e d  o u t  f r o m  t h e  e a r l i e r  d i s c u ssion, is: both.  
Remember our lazy job applicant, who wanted a strong  p r e c o n d i t i o n  a n d  a  weak 
postcondition. Here adding INV makes stronger or equal both the precondition and the  
postcondition. (From the rules of logic, a and b always implies a, that is to say, is stronger  
than or equal to a.) So, if you are in charge of implementing the body , the invariant:
• Makes your job easier: in additi on to the official preconditio n pre, you may  
assume that the initial state satisfies INV, further restricting the set of cases that  
you must handle.
• Makes your job harder: in addi tion to your official postcondit ion post, you must  
ensure that the final state satisfies INV.
T h e s e  o b s e r v a t i o n s  a r e  c o n s i s t e n t  w i t h  t h e  v i e w  o f  t h e  i n v a r i a n t as a general  
consistency condition that appli es to the class as a whole, and  hence to all of its routines.  
As the author of such a routine, you have the benefit of being permitted to take this  
condition for granted at the sta rt of the routin e; but you have  the obligation to ensure that  
the routine will satisfy it again on termination — so that the next routine to be executed  
on the same object can in turn take it f or granted.
The class BANK_ACCOUNT mentioned above, with the invariant clause
deposits_list   total – withdrawals_list   total = balance
provides a good example. If you have to add a routine to the cl ass, this clause gives you  
the guarantee that the features deposits_list , withdrawals_list  and balance  have consistent  
values, so you do not need to check this property (and then, as  we have seen, you must not
check it). But it also means that you must write the routine so  that, whatever else it does,  
it will leave the object in a state that again satisfies the pr operty. So a procedure withdraw , The notation was 
defined on page 335.
§11.9   WHEN IS A CLASS CORRECT? 369
used to record a withdrawal operation, should not just update withdrawals_list : it must  
also, if balance  is an attribute, update the value of balance  to take the withdrawal into  
account and restore the invariant, enabling any other routine c alled later on the same object  
to benefit from the same original assumption that facilitated t he work of withdraw .
Rather than an attribute, balance  could be a function, whose body computes and returns  
the value of deposits_list  l total – withdrawals_list  l total; in this case procedure withdraw  
does not need to do anything special to maintain the invariant. The abil ity to switch at will  
between the two representations without affecting the client is  an illustration of the  
principle of Uniform Access.
This example shows the idea of class invariant as a transpositi on to software of one  
of the rules of polite behavior:  that if you use a shared facil ity — say an office kitchen —  
you should leave it for others, after each use, in the state in  which you would like to find  
it when you start.
11.9  WHEN IS A CLASS CORRECT?
Although we still have to see a few more constructs involving a ssertions, it is useful to  
take a brief pause and examine so me of the implications of what  we have learned about  
preconditions, postconditions and invariants. This section does  n o t  i n t r o d u c e  a n y  n e w  
constructs, but describes some of  the theoretical background. E ven on your first reading I  
think you should get familiar wit h these ideas as they are cent ral to a proper understanding  
of the method, and will be precio us when we try to figure out h ow to use inheritance well.
The correctness of a class 
With preconditions, postconditi ons and invariants, we can now d efine precisely what it  
means for a class to be correct. 
The basis for the answer appeare d at the beginning of this chap ter: a class, like any  
other software element, is corre ct or incorrect not by itself b ut with respect to a  
specification. By intr oducing precond itions, postcon ditions and  invariants we have given  
ourselves a way to include some of the specification in the cla ss text itself. This provides  
a basis against which to assess correctness: the class is corre ct if and only if its  
implementation, as given by the routine bodies, is consistent w ith the preconditions,  
postconditions a nd invariant. 
The notation {P} A {Q} introduced at the begi nning of this chapter helps express this  
precisely. Remember that the mean ing of such a correctness form ula is: whenever A is 
executed in a st ate satisfying P, the execution will termina te in a state satisfying Q.
Let C be a class, INV its class invariant . For any routine r of the class, call prer (xr)
and postr (xr) its precondition an d postcondition; xr denotes the possible arguments of r, 
to which both the precondition an d the postcondit ion may refer.  (If the precondition or  
postcondition is missing fro m the routine text, then prer or postr is just True.) Call Bodyr
the body of routine r. See “Uniform 
Access”, page 55 .
If you prefer to skip 
the theory you should turn to “AN ASSER-TION INSTRUC-TION”, 11.11, page 378.
DESIGN BY CONTRACT: BUILDING RELIABLE SOFTWARE  §11.9 370
Finally, let DefaultC be the assertion expressing that the attributes of C have the  
default values of their types. For example DefaultSTACK2 , referring to the earlier stack  
class, is the assertion 
representation = Void
capacity = 0
count = 0
These notations permit a general definition of class correctnes s:
This rule — previewed informally in the BANK_ACCOUNT example — is a  
mathematical statement of the ea rlier informal d iagram showing the lifecycle of a typical  
object, which is worth looking  at again:
Condition C 1 means that any creatio n procedure (such as make  in the figure), when  
called with its precondition satisfied, must yield an initial s tate (S1 in the figure) that  
satisfies the invariant and the procedure’s post condition. Cond ition C 2 expresses that any  
exported routine r (such as f or g in the figure), if called in a state (S1, S2 or S3) satisfying  
both its precondition and the in variant, must terminate in a st ate that satisfies both its  
postcondition and the invariant.Definition: class correctness
A class is correct wit h respect to its ass ertions if and only i f: 
C1 • For any valid set of arguments xp to a creation procedure p: 
{DefaultC and prep (xp )}  Bodyp  {postp (xp) and INV} 
C2 • For every exported routine r and any set of valid arguments xr:
{prer (xr ) and INV}  Bodyr  {postr (xr) and INV}
The life of an 
object  
(This figure first 
appeared on page 
365.) create  a  make (…)
S1
S2
S3S4a  f (…)
a  g (…)
a  f (…)
§11.9   WHEN IS A CLASS CORRECT? 371
If we focus on invariants, we may look at the preceding definit ion of class correctness  
as working by induction on the set of instances of a class. Rul e C1 is the base step of the  
induction, stating that the invariant holds for all newborn obj ects — those which directly  
result from a creation instruction. Rule C 2 is the induction step, through which we  
determine that if a certain generation of instances satisfies t he invariant, then the next  
generation — the set of instances obtained by applying exported  features to the members  
of the current generation — will also satisfy it. Since by star ting from newborn objects  
and going from generation to generation through exported featur es we obtain all possible  
instances of the class, the mechanism enables us to determine t hat all instances satisfy  
the invariant.
Two practical observations: 
• If the class has no creation  clause, we may consider that it has a single implicit  
creation procedure nothing  with an empty body . Applying rule C 1 to Bnothing then 
means that DefaultC must imply INV: the default values must satisfy the invariant. 
• A requirement of the form {P} A {Q} does not commit A in any way for cases in  
which P is not initially satisfied. So the notation is in line with th e property discussed  
in detail earlier in this chapte r: the contract is not binding on the routine if the client  
fails to observe its part of the deal. Accordingly, the definit ion of class correctness  
leaves the routines of the class  free to do as they please for any call that violates the  
precondition or the invariant. 
What has just been d escribed is how to define  the correctness of a class. In practice,  
we may also want to check  whether a given class is indeed correct. This issue will be  
discussed later in this chapter.
The role of creation procedures
The discussion of invarian ts yields a better understanding of the n otion of creation procedure.
A class invariant expresses the set of properties that objects (instances of the class)  
must satisfy in what has been called the stable moments of thei r lifetime. In particular,  
these properties must hold  upon instance creation. 
The standard object allocation mechanism initializes fields to the default values of the  
corresponding attribute types; t hese values may or may not sati sfy the invariant. If not, a  
specific creation procedure is r equired; it should set the valu es of the attributes so as to  
satisfy the invariant. So creatio n may be seen as  the operation  that ensures th at all instances  
of a class start  their lives in a correct  mode — one in which t he invariant is satisfied. 
The first presentation of creati on procedures introduced them a s a way to answer a  
more mundane (and obvious) quest ion: how do I override the defa ult initialization rules if  
they do not suit me for a particular class, or if I want to pro vide my clients with more than  
one initialization mechanism? But  with the introduction of inva riants and the theoretical  
discussion summarized by rule C 1, we also see the more profound role of creation  
procedures: they are here to mak e sure that any instance of the  class, when it starts its life,  
already satisfies the fundamental rules of i ts caste — the clas s invariant.See “CREATION 
PROCEDURES”, 8.4, page 236 , in par-
ticular “Rules on cre-ation procedures”, page 238
DESIGN BY CONTRACT: BUILDING RELIABLE SOFTWARE  §11.9 372
Arrays revisited 
The library class ARRAY  was sketched in the previous chapter. Only now, however, are w e 
in a position to give its defini tion properly. The notion of ar ray fundamentally requires  
preconditions, postconditions and an invariant.
Here is a better sketch with ass ertions. Preconditions express the basic requirement  
on array access and modification:  indices should be in the perm itted range. The invariant  
shows the relation between count , lower  a n d  upper ; it would allow count to be 
implemented as a function rather than an attribute.
note
description : "Sequences of values , all of the same type or of a conforming one , %
%accessible through in teger indices in a contiguous interval "
class  ARRAY [G] creation
make
feature -- Initialization
make (minindex , maxindex : INTEGER )
-- Allocate array with bounds minindex  and maxindex
-- (empty if minindex > maxindex ).
require
meaningful_bounds : maxindex >= minindex – 1
do
…
ensure
exact_bounds_if_non_empty : (maxindex >= minindex ) implies
((lower = minindex ) and (upper = maxindex ))
conventions_if_empty : (maxindex < minindex ) implies
((lower = 1) and (upper = 0))
end
feature  -- Access
lower , upper , count : INTEGER
-- Minimum and maximum le gal indices; array size.
infix  "@", item (i: INTEGER ): G
-- Entry of index i 
require
index_not_too_small : lower <= i
index_not_too_large : i <= upper
do … endSee “ARRAYS”, 10.4,
page 325 .
§11.10   THE ADT CONNECTION 373
feature  -- Element change
put (v: G; i: INTEGER )
-- Assign v to the entry of index i
require
index_not_too_small : lower <= i
index_not_too_large : i <= upper
do
…
ensure
element_replaced : item (i) = v
end
invariant  
consistent_count : count = upper – lower + 1
non_negative_count : count >= 0 
end
The only part left blank is the  implementation of routines item and put. Because  
efficient array manipulation will require low-level system acce ss, the routines will  
actually be implemented using external  clauses, intr oduced in a lat er chapter.
11.10  THE ADT  CONNECTION
A class — you have heard this quite a few times by now — is an implementation of an  
abstract data type, whether form ally specified or (as in many c ases) just implicitly  
understood. As noted a t the beginnin g of this chapter, we may v iew assertions as a way to  
re-introduce into the class the s emantic properties of the unde rlying ADT. Let us perfect  
our understanding of assertion co ncepts by clarifying the conne ction of assertions to the  
components of an abstract data type specification.
Not just a collection of functions 
As studied in the ADT chapter, an  abstract data t ype is made of  four elements:
• The name of the type, possibly with generic parameters (TYPES paragraph).
• The list of functions with thei r signatures (FUNCTIONS paragra ph).
• The axioms (AXIOMS paragraph) e xpressing proper ties of the fun ctions’ results.
• The restrictions on the functio ns’ applicability (PRECONDITION S paragraph)
Simple-minded applications of ab stract data types often overloo k the last two parts.  
This removes much of the appeal of the approach, since precondi tions and axioms express  
the semantic properties of the functions. If you omit them and simply view “stack” as  
encapsulating the (not spec ified further) operations put, remove  e t c . ,  y o u  r e t a i n  t h e  
benefits of information hiding, but that is all. The notion of stack becomes an empty shell,  This section explores 
the implications of previous concepts . 
Some readers may prefer to skip to “AN ASSERTION INSTRUCTION”, 11.11, page 378
DESIGN BY CONTRACT: BUILDING RELIABLE SOFTWARE  §11.10 374
with no semantics other than sug gested by the operation names. (And in the approach of  
this book that is of little comfort, since for reasons of struc ture, consistency and reusability  
we deliberately choose general names — put, remove , item … — rather than concrete,  
type-specific names such as push , pop and top.)
This risk transposes to programmi ng in an O-O language: the rou tines which are  
supposed to implement the operati ons of the corres ponding abstr act data types could in  
principle perform just about any operations. Assertions avert t hat risk by bringing the  
semantics back in. 
Class features vs. ADT functions
To understand the relation betwee n assertions and ADTs we need first to establish the  
relation between class features and their ADT counterparts — th e ADT’s functions. An  
earlier discussion introduced thre e categories of function: cre ators, queries and  
commands. As you will recall, the category of a function
f : A × B × … → X
depended on where the ADT, say T, appeared among the types A, B, … X involved in this  
signature:
•I f  T appears on the right only, f  is a creator; in the class it yields a creation procedure.
•If T appears only on the left of the arrow, f  is a query, providing access to properties  
of instances of the class. The c orresponding features are eithe r attributes or functions  
(collectively called queries, f or classes as well as ADTs).
•I f  T appears on both the left and the right, f is a command function, which yields a  
new object from one or more existing objects. Often f will be expressed, at the  
implementation stage, by a proce dure (also called a command) wh ich modifies an  
object, rather than creating a ne w object as a function would d o.
Expressing the axioms 
From the correspondence between ADT functions and class feature s we can deduce the  
correspondence between semantic ADT properties and class assert ions: 
• A precondition for one of the s pecification’s functions reappe ars as precondition  
clauses for the corresponding routine. 
• An axiom involving a command function, poss ibly with one or mo re query  
functions, reapp ears as postcondition cl auses of the correspond ing procedure. 
• Axioms involving only query func tions reappear a s postconditio ns of the  
corresponding fu nctions or (especially i f more than one functio n is involved, or if at  
least one of the queries is impl emented as an attribute) as cla uses of the invariant. 
• Axioms involving constructor fu nctions reappear  in the postcon dition of the  
corresponding creation procedure. 
At this point you should go back to the precondit ions and axiom s of the ADT STACK
and compare them with the assertions of class STACK4 (including those of STACK2 ).See “Function cate-
gories”, page 134 .
See “Attributes and 
routines”, page 173 .
Exercise E11.2, 
page 408 . The ADT 
specification is on page 139 .
§11.10   THE ADT CONNECTION 375
The abstraction function
It is instructive to think of the  preceding observations in ter ms of the following figure,  
inspired by the discussion in [Hoare 1972a] , which pictures the notion “ C is a correct  
implementation  of A”.          
A is an abstract data type, and C as a class implementing it . For an abstract function  
af of the ADT specification — of whi ch we assume for simplicity t hat it yields a result  
also of type A — there will be a concrete feature cf  in the class.
The arrows labeled a represent the abstraction  function  which, for an y instance of  
the class, or “concrete object”,  yields the abstract object (in stance of the ADT) that it  
represents. As will be seen, thi s function is us ually partial, and the inverse relation is  
usually not a function.
The implementation is correct if (for all functions af applicable to abstract data types,  
and their implementations cf ) the diagram is commutative, that is to say: 
where  ; is the composition operator betw een functions; in other words, for any two  
functions f and g, f ; g is the function h such that h (x) = g (  f (x)) for every applicable x. 
(The composition  f ; g is also written g ° f  with the order of the operands reversed.)
The property states that for eve ry concrete object CONC_1, it d oes not matter in  
which order you apply the transformation (abstract af or concrete cf  ) and the abstraction;  
the two paths, represented by do tted lines, lead to the same ab stract object ABST_2. The  
result is the same whether you:
• Apply the concrete transformation cf, then abstract the result, yielding a (cf (CONC_1 )).
• Abstract first, then apply the abstract transforma tion af, yielding af (a (CONC_1 )).Class-ADT Consistency property
(cf ; a) = (a ; af  )Non-mathematical 
readers may skip this section
Transformations
on abstract and 
concrete objects
(See also the figure 
on page 229 .)
a aaf
cfCONC_1ABST_1
CONC_2ABST_2
Concrete objects (ins tances of the class C)Abstract objects (in stances of the ADT A)
DESIGN BY CONTRACT: BUILDING RELIABLE SOFTWARE  §11.10 376
Implementation invariants 
Certain assertions appear in inv ariants although they have no d irect counterparts in the  
abstract data type specification s. These assertions involve att ributes, including some  
secret attributes which, by definition, would be meaningless in  the abstract data type. A  
simple example is the following properties  appearing in the inv ariant of STACK4 : 
count_non_n egative : 0 <= count
count_bounded : count <= capacity
Such assertions constitute the part of the class invariant know n as the  
implementati on invariant . They serve to express the cons istency of the representation  
chosen in the class (here by attributes count , capacity  and representation ) vis-à-vis the  
corresponding abstract data type. 
The figure on the previous page helps understand the concept of  implementation  
invariant. It illustrates the characteristic properties of the abstraction function a 
(represented by the vertical arr ows), which we sh ould explore a  little further.
First, is it correct to talk about a as being the abstraction function , as suggested by  
the upwards arrows representing a in the preceding figure? Recal l that a function (partial  
or total) maps every source element to at most one target eleme nt, as opposed to the more  
general case of a relation which  has no such restriction. If we  go downwards rather than  
upwards in the figure and examine the inverse of a, which we may call the representation  
relation , we will usually find it not to be a function, since there are  in general many  
possible representations of a gi ven abstract object. In the arr ay implementation that  
represents every stack as a pair <representation , count >, an abstract stack has many  
different representations, as illustrated by the figure on the facing page; they all have the  
same value for count  and for the entries of array representation  between indices 1 and 
count , but the size capacity of the array can be any valu e greater than or equal to count , 
and the array positi ons beyond index count  may contain arbitrary values.
Since the class interface is res tricted to the features directl y deduced from the ADT’s  
functions, clients have no way o f distinguishing between the be haviors of several concrete  
objects that all represent the s ame abstract object (that is to  say, all have the same a value).  
Note in particular that procedure remove in STACK4 does its job sim ply by executing
count := count – 1
without bothering to clear the previous top entry, now at index  count + 1 ; changing an  
entry of index higher than count  modifies a concrete stack object CS, but has no effect on  
the associated abstract stack a (CS) .
So the implementation relation i s usually not a function. But i ts inverse the  
abstraction function a (the upwards arrows in both figures) is indeed a function sinc e every  
concrete object represents at most one abstract object. In the stack example, every valid  
<representation , count > pair represents just one abstract stack (the stack with count  
elements, given, from the bo ttom up, by the entries of representation  at indices 1 to count ). STACK4  and its 
invariant appeared on page 364 .
§11.10   THE ADT CONNECTION 377
Both of the concrete stacks in t his figure are implementations of the abstract stack  
consisting of three elements of values 342, –133  and 5 from the  bottom up. That a is a 
function is a universal requireme nt: if the same concrete objec t could be interpreted as  
implementing more than one abstra ct object, the chosen represen tation would be  
ambiguous and henc e inadequate. So it is proper that the arrow associated with a points  
up in all the figures depicting connections between abstract an d concrete types. (The  
discussion for inheritance will suggest a similar convention.)
The abstraction function a is usually a partial  function: not every  possible concrete  
object is a valid representation  of an abstract object. In the example, not every  
<representation , count > pair is a valid representatio n of an abstract stack; if representation
is an array of capacity three and count  has value 4, they do not together represent a stack.  
Valid representations (members o f the domain of the abstraction  function) are  those pairs  
for which count  has a value between zero and the size of the array. This prope rty is the  
implementation invariant.
In mathematical terms, the imple mentation invariant is the char acteristic function of  
the domain  of the abstraction function, that is to say, the property that  defines when that  
function is applicable. (The cha racteristic function of a subse t A is the boolean property  
that is true on A and false elsewhere.)
The implementation invariant is the one part of the class’s ass ertions that has no  
counterpart in the abstract data  type specification. It relates  not to the abstract data type,  
b u t  t o  i t s  r e p r e s e n t a t i o n .  I t  d e fines when a candidate concrete  object is indeed the  
implementation of one (and the n only one) abstract object.342–1335
representationcount = 3capacity = 6
1 342–1338870
451
05
representationcount = capacity = 3
1 342–1335count = 3
Abstract  
stack object
CS1CS2 a a
Concrete
stack objectsSame abstract 
object , two 
representations
DESIGN BY CONTRACT: BUILDING RELIABLE SOFTWARE  §11.11 378
11.11  AN ASSERTION INSTRUCTION
The uses of assertions seen so f ar — preconditio ns, postconditi ons and class invariants —  
are central components of the method. They establish the connec tion between object-
oriented software construction an d the underlying  theory (abstr act data types). Class  
invariants, in particular, cannot  be understood, or even discus sed, in a non-O-O approach.
Some other uses of assertions, although less specific to the me thod, are also precious  
in a systematic software development process and should be part  of our notation. They  
include the check  instruction, as well as loop correctness constructs (loop inva riant and  
variant) which will be rev iewed in the next section.
The check  instruction serves to express th e software write r’s conviction  t h a t  a  
certain property will be satisfie d at certain stages of the com putation. Syntactically, the  
construct is an instructio n, written under the form
check
assertion_clause1
assertion_clause2
…
assertion_clausen
end
Including this instruction in th e text of a routine is a way to  state that:
“Whenever control reaches this instruction at execution time , the assertion  
shown (as given by its assertion clauses ) will hold .”
This is a way to reassure yourself that certain properties are satisfied, and (even more  
importantly) to make explicit fo r future readers of your softwa re the hypotheses on which  
you have been relying. Writing so ftware requires making frequen t assumptions about  
properties of the objects of your system; as a trivial but typi cal example, any function call  
of the form sqrt (x), where sqrt is a routine requiring a non- negative argument, relies on  
the assumption that x is positive or zero. This assumption may be immediately obviou s 
from the context, for e xample if the call i s part of a conditio nal instruction of the form
if x >= 0 then  y := sqrt (x) end
but the justification may also b e more indirect, based for exam ple on an earlier instruction  
that computed x as the sum of two squares:
x := a ^2 + b^2
The check  instruction makes it possible to  express such an assumption if  it is not  
immediately obvious fr om the context, as in
x := a ^2 + b^2
… Other instructions …
check 
x >= 0
-- Because x was computed above as a sum of squares.
end
y := sqrt (x)
§11.11   AN ASSERTION INSTRUCTION 379
No if … then  … protects the call to sqrt in this example; the check  indicates that the  
call is correct. It is good practice to include, as here, a com ment stating the  reason invoked  
to support the assumption (“ -- Because x…”). The extra two steps of indentation for the  
instruction are also  part of the recommended style; they sugges t that the instruction is not  
meant, in normal circumstances, t o affect the algorithmic progr ession of the routine.
This example is typical of what is probably the most useful app lication of the check  
instruction: adding such an instr uction just before a call to a  routine that has a certain  
precondition (here w e may assume that sqrt has a precondition requiring its argument to  
be non-negative), when you are convinced that the call satisfie s the precondition but this  
is not immediately obvious from the context. As another example  assume s is a stack and  
you include in you r code a call
s  remove
at a position where you are certain that  s is not empty, for example because the call has  
been preceded by n “put” and m “remove ” instructions with n > m. Then there is no need  
to protect the call by an if not s  empty then …; but if the reason for the correctness of the  
call is not immediately obvious from the context, you may want to remind the reader that  
the omission of any protection w as a conscious decision, not an  oversight. You can achieve  
this by adding before the call the instruction
check  not s  empty end
A variant of this case occurs wh en you write a call of the form  x  f  with the certainty  
that x is not void, so that you do not need to enclose this call in a  conditional instruction if 
x /= Void then …, but the non-vacuity argument i s not obvious from the context.  W e 
encountered this in the procedures put and remove of our “protected stack” class STACK3 . 
The body of put used a call to the corr esponding procedure in STACK2 , as follows:
if full then
error := Overflow
else
check representation /= Void end
representation   put (x); error := 0
end
Here a reader might think the call representation   put (x) in the else potentially unsafe  
since it is not preceded by a test for representation /= Void . But if you examine the class  
text you will realize that if full is false then capacity  must be positive and hence  
representation  cannot be void. This is an impo rtant and not quite trivial pro perty, which  
should be part of the implementa tion invariant of the class. In  fact, with a fully stated  
implementation invariant , we should rewrite the check  instruction as:
check 
representation_exists : representation /= Void
-- Because of clause representation_exists_if_not_full  of the
-- implementation invariant.
endThis is from the body 
of put on page 361 .
Exercise E11.5, page 
409, asks you for the 
implementation invariant of STACK3
DESIGN BY CONTRACT: BUILDING RELIABLE SOFTWARE  §11.12 380
In ordinary approaches to software construction, although calls  and other operations  
often (as in the various precedi ng examples) rely for their cor rectness on various  
assumptions, these assumptions remain largely implicit. The dev eloper will convince  
himself that a certain property always holds at a certain point , and will put this analysis to  
good use in writing the software text; but after a while all th at survives is the text; the  
rationale is gone. Someone — eve n the original author, a few mo nths later — who needs  
to understand the software, perh aps to modify it, will not have  access to the assumption  
and will have to figure out from  scratch what in the world the author may have had in  
mind. The check  instruction helps avoid this pr oblem by encouraging you to doc ument  
your non-trivial assumptions.
As with the other assertion mechanisms of this chapter, the ben efit goes beyond helping  
you get things right  in the first place, to helping you find that you got them wrong . You 
can, using a compilation option, turn the check  into a true executable instruction, which  
will do nothing if all its assertion clauses are true, but will  produce an exception and stop  
execution if any of them is false. So if one of your assumption s was actually not justified  
you should find out quickly. The mechanisms for enabling check -checking will be  
reviewed short ly.
11.12  LOOP INV ARIANTS AND V ARIANTS
Our last assertion constructs he lp us get loops right. They nic ely complement the  
mechanisms seen so far, but are not really specific to the obje ct-oriented method, so it is  
all right to skip this section on first reading.
Loop trouble
The ability to repeat a certain c omputation an arbitrary number  of times without  
succumbing to exhausti on, indeed without e xperiencing any degra dation whatsoever, is  
the principal difference between  the computational abilities of  computers and those of  
humans. This is why loops are so important; just imagine what y ou could do in a language  
that only has the other two principal control structures, seque ncing and conditional  
instructions, but no l oops (and no support for recursive routin e calls, the other basic  
mechanism permitting i terative computations).
But with power comes risk. Loops are notoriously hard to get ri ght. Typical trouble  
includes:
• “Off-by-one” errors (performing  one iteration too many or too few).
• Improper handling of borderline cases such as empty structures : for example a loop  
may work properly on a large array, but fail when the array has  zero or one element.
• Failure to terminat e (“infinite looping”) in some cases.
Binary search — a staple of Computing Science 101 courses — is a good illustration  
of how tricky loops can be even when they appear trivial. Consi der an array t of integers  
assumed to be in increasing order and indexed from 1 to n; binary search is a way to decide  
whether a certain integer value x appears in the array: if the array has no elements, the  If skipping, go to 
“USING ASSER-TIONS”, 11.13, page 389.
See exercise E11.7, 
page 409 .
§11.12   LOOP INV ARIANTS AND V ARIANTS 381
answer is no; if the array has one element, the answer is yes i f and only if that element has  
value x; otherwise compare x to the element at the array’s middle position, and repeat on  
the lower or higher half dependi ng on whether that element is g reater or lesser than x. The 
four loop algorithms below all at tempt to implement this simple  idea; unfortunately all are  
wrong, as you are invited to che ck by yourself b y finding, for each of them, a case in which  
it will not work properly.
Recall that t @ m  denotes the element at index i in array t. The // operator denotes integer  
division, for example 7 // 2 and 6 //2 have value 3. The loop syntax is explained next but 
should be self-explanatory; the from  clause introduces the loop initialization.
BS1
from
i := 1; j := n
until  i = j loop
m := (i + j) // 2 
if t @ m <= x then
i := m 
else 
j := m
end
end
Result := (x = t @ i )BS2
from
i := 1; j := n; found := false
until  i = j and not  found loop
m := (i + j) // 2 
if t @ m < x then
i := m + 1
elseif  t @ m = x then
found := true 
else
 j := m – 1
end
end
Result := found
BS3
from
i := 0; j := n
until  i = j loop
m := (i + j + 1 ) // 2 
if t @ m <= x then
i := m + 1
else
j := m
end
end
if i >= 1 and i <= n then
Result := (x = t @ i )
else
Result := false
endBS4
from
i := 0; j := n + 1
until  i = j loop
m := (i + j) // 2 
if t @ m <= x then
i := m + 1
else 
j := m
end
end
if i >= 1 and i <= n then
Result := (x = t @ i )
else 
Result := false
endFour (wrong ) 
attempts at 
binary search .
From [M 1990]
DESIGN BY CONTRACT: BUILDING RELIABLE SOFTWARE  §11.12 382
Getting loops right
The judicious use of assertions c an help avoid such problems. A  loop may have an  
associated assertion, the  loop invariant  (not to be confused with the class invariant for the  
enclosing class); it  may also have a loop variant , not an assertion but an integer  
expression. The invariant and va riant will help us guarantee th at a loop is correct.
To understand these notions it is necessary to realize that a l oop is always a way to  
compute a certain result by successive approximations .
Take the trivial example of com puting the maximum value of an a rray of integers  
using the obvious algorithm:
maxarray (t: ARRAY [INTEGER ]): INTEGER
-- The highest of the va lues in the entries of t
require
t  capacity >= 1
local
i: INTEGER
do
from
i := t  lower
Result := t @ lower
until i = t  upper loop
i := i + 1
Result := Result   max (t @ i )
end
end
We initialize i to the array’s lower bound i := t  lower  a n d  t h e  e n t i t y  Result  
representing the future result to the value of the associated e ntry t @ lower . (We know that  
this entry exists thanks to the routine’s precondition, which s tates that the array has at least  
one element.) Then we iterate until i has reached the upper bound, at each stage increasing  
i by one and replacing Result by the value of t @ i , the element at index i, if higher than  
the previous value of Result . (We rely on a max function for integers: a  max (b), for two  
integers a and b, is the maximum of  their values.)
§11.12   LOOP INV ARIANTS AND V ARIANTS 383
This computation works by success ive approximations. We approac h the array by its  
successive slices: [ lower , lower ], [lower , lower+1 ], [lower , lower  +2] and so on up to the  
full approximation [ lower , upper ].
The invariant property is that at each stage through the loop Result  is the maximum  
of the current approximation of t he array. This is true after t he initialization, since the  
instructions in the from  clause ensure that Result  is the maximum of the first  
approximation, the  trivial slice [ lower , lower ] consisting of just one  element. Then on each  
iteration we extend the slice by one element — improving our ap proximation of the array  
— and make sure to maintain the invariant by updating Result  if the new value is higher  
than the previous maximum. At th e end, the appr oximation covers  the entire array, and  
since we have maintained inv ariant the property that Result  is the maximum of the current  
approximation we  know that it now is the  maximum of the array a s a whole.
Ingredients for a provably correct loop
The simple example of computing an array’s maximum illustrates the general scheme of  
loop computation, which applies to  the following standard situa tion. You have determined  
that the solution to a certain problem is an element belonging to an n-dimensional surface  
POST : to solve the problem is to find an element of POST . In some cases POST  has just  
one element — the solution — but in general there  m a y  b e  m o r e  t h a n  o n e  a c c e p t a b l e 
solution. Loops are useful when  you have no way of shooting str aight at POST  but you see  
an indirect strategy: aiming first into an m-dimensional surface INV that includes POST  (for 
m > n); then approaching POST , iteration by iterati on, without ever leaving INV. The 
following figure illustrates this process.Approximating 
an array by 
successive slices
lower upper
Array slice Array element
DESIGN BY CONTRACT: BUILDING RELIABLE SOFTWARE  §11.12 384
A loop computation has th e following ingredients:
•A  g o a l  post, the postcondition, defined as a property that any satisfactor y end state  
o f  t h e  c o m p u t a t i o n  m u s t  s a t i s f y .  E x a m p l e :  “ Result  is the maximum value in the  
array”. The goal is represented in the figure by the set of sta tes POST satisfying post.
• An invariant property inv, which is a generalization of t he goal, that is to say include s 
the goal as a special case. Example: “ Result  is the maximum value in a non-empty  
array slice beginning at the lower bound”.  The invariant is rep resented in the figure  
by the set of states INV satisfying inv.
• An initial point init which is known to be in INV, that is to say to sa tisfy the invariant.  
Example: the state in which the value of i is the array’s lower bound and the value of  
Result  is that of the array element at  that index, satisfying the inv ariant since the  
maximum of a one-element slice is the value of the element.
• A transformation body  which, starting from a point in INV but not in POST , yields a  
point closer to POST and still in INV. In the example this transformation extends the  
array slice by one element, and replaces Result  by the value of that element if higher  
than the previous Result . The loop body in function maxarray  is an implementation  
of that transformation.
• An upper bound on the number of applications of body  necessary to bring a point in  
INV to POST . This will be the varia nt, as explai ned next.
Computations by successive approx imations are a mainstay of num erical analysis,  
but the idea applies mo re broadly. An impor tant difference is t hat in pure mathematics we  
accept that a series of approximations may have a limit even th ough it cannot reach it  
through a finite number of a pproximations: the sequence 1, 1/2, 1/3, 1/4, …, 1/n, … has INV
POSTinitbody
body
body
bodybody
bodyA loop 
computation (   from [M 1990])
§11.12   LOOP INV ARIANTS AND V ARIANTS 385
limit 0 but no element of the sequence has value zero. In compu ting, we want to see the  
results on our screen during our lifetime, so we insist that al l approximation sequences  
reach their goal a fter a finite numb er of iterations.
Computer implementations of numerical algorithms also require f inite convergence: even  
when the mathematical algorithm would only converge at infinity , we cut off the  
approximation process when we fe el that we are close enough.
The practical way to guarantee t ermination of a loop process is  to associate with the  
loop an integer quanti ty, the loop variant , which enjoys the fo llowing properties:
• The variant is always non-negative.
• Any execution of the loop body  (the transformation called body  in the figure)  
decreases the variant.
Since a non-negative integer quan tity cannot decrease forever, your ability to exhibit  
such a variant for one of your loops guarantees that the loop w ill always t erminate.The  
variant is an upper bound, for e ach point in the sequence, of t he maximum number of  
applications of body  that will land the point in POST . In the array maximum computation,  
a variant is e asy to find: t  upper – i . This satisfies b oth conditions:
•Because the routine pr econdition requires t  capacity  to be positive (that is to say, the  
routine is only applicable to no n-empty arrays) and the invaria nt of class ARRAY  
indicates that capacity = upper – lower + 1 , the property i <= t  upper  (part of the  
loop’s invariant ) will always be satisfied when i is initialized to t  lower .
• Any execution of the loop bod y performs the instruction i := i + 1 , reducing the  
variant by one.
In this example the loop is simp ly an iteration over a sequence  of integer values in a  
finite interval, known in common programming languages as a “fo r loop” or a “DO loop”;  
termination is not difficult to p rove, although one must always  check the details (here, for  
example, that i always starts no greater than t  upper  because of the routine’s  
precondition). For more sophisti cated loops, the number of iter ations is not that easy to  
determine in advance, so ascerta ining termination is more of a challenge; the only  
universal technique is  to find a variant.
One more notion is needed to tra nsform the scheme just outlined  into a software text  
describing a loop: we need a sim ple way of determining whether a certain iteration has  
reached the goal (the postcondition) post. Because the iteration is constrained to remain  
within INV, and POST  is part of INV, it is usually possible to find a condition exit such that  
an element of INV belongs to POST  if and only if it satisfies exit. In other words, the  
postcondition post and the invariant inv are related by
post = inv and exit
so that we can stop the loop — whose intermediate states, by co nstruction, always satisfy  
inv — as soon as exit is satisfied. In the maxarray example, the obvious exit condition is  
i = t  upper : if this property is true togeth er with the inva riant, which s tates that Result  is 
the maximum value in the array slice [ t  lower , i], then Result  is the maximum value in the  
array slice [ t  lower , t  upper ], hence in the entire array —  the desired p ostcondition.The invariant of class
ARRAY  appeared on 
page 373 .
DESIGN BY CONTRACT: BUILDING RELIABLE SOFTWARE  §11.12 386
Loop syntax
The syntax for loops follows dir ectly from the preceding ration ale. It will include the  
elements listed as necessary:
• A loop invariant inv — an assertion.
• An exit condition exit, whose conjunction with inv achieves the desired goal.
•A  v a r i a n t  var — an integer expression.
• A set of initialization instructions init, which always produces a state that satisfies  
inv and makes var non-negative.
• A set of body instructions body which, when started in a state where inv holds and  
var is non-negative, preserves the invariant and decreases the var iant while keeping  
it non-negative (so that the resulting state still satisfies inv and has for var a value  
that is less than before but  has not gone below zero).
The loop syntax combining these ingredients is straightforward:
from
init
invariant
inv
variant
var
until
exit
loop
body
end
The invariant  and variant  clauses are optional. The from  clause is required (but the  
init instructions may be empty). The effect of this instruction is t o execute the init 
instructions and then, zero or more times, the body  instructions; the latter are executed  
only as long as exit is false.
In Pascal, C etc. the loop would be a “while” loop, since the l oop body is executed  
zero or more times, unlike the “ repeat  … until ”  l o o p  f o r  w h i c h  t h e  b o d y  i s  a l w a y s  
executed at least once. Here the test is an exit condition, not  a continuation condition, and  
the loop syntax includes room for  initialization. So the equiva lent in Pascal of from init 
until exit loop body end is
init;
while  not exit do bodyWarning : this is Pas-
cal, not the O-O nota-
tion.
§11.12   LOOP INV ARIANTS AND V ARIANTS 387
With a variant and an in variant the loop for maxarray  appears as
from
i := t  lower ; Result := t @ lower
invariant
-- Result  is the maximum of  the elements of t at indices t  lower  to i.
variant
t  lower – i
until
i = t  upper
loop
i := i + 1
Result := Result   max (t @ i )
end
Note that the invariant is expre ssed informally as a comment; t he discussion section  
of this chapter will e xplain this limitatio n of the assertion l anguage.
Here is another example, first s hown without variant or invaria nt. The purpose of the  
following function is to compute the greatest common divisor (g c d )  o f  t w o  p o s i t i v e  
integers a and b with Euclid’s algorithm:
gcd (a, b: INTEGER ): INTEGER
-- Greatest common divisor of a and b
require
a > 0; b > 0
local
x, y: INTEGER
do
from
x := a; y := b
until
x = y
loop
if x > y then  x := x – y else y := y – x end
end
Result := x
ensure
-- Result  is the greatest common divisor of a and b
end
How do we know that function gcd ensures its postcondition — that it indeed  
computes the greatest common divisor of a and b? One way to check this is to note that  
the following property is true af ter loop initialization and pr eserved by every iteration: “The expressive 
power of assertions”,page 399 .
DESIGN BY CONTRACT: BUILDING RELIABLE SOFTWARE  §11.12 388
x > 0; y > 0
-- The pair  <x, y> has the same greatest commo n divisor as the pair < a, b>
This will serve as o ur loop invariant inv. Clearly, INV is satisfied after execution of  
the from  clause. Also, if inv is satisfied before an exe cution of the loop body 
if x > y then  x := x – y else y := y – x end
under the loop continuation condition x /= y, then inv will still be satisfied after execution  
of this instruction; this is be cause replacing the greater of t wo positive non-equal numbers  
by their difference leaves them positive and does not change th eir gcd. 
We have shown inv to be satisfied before the first iteration and preserved by eve ry 
iteration. It follows tha t on loop exit, when x = y becomes true, inv still holds; that is to say:
x = y and “The pair  <x, y> has the same greatest common divisor as the pair < a, b>”
which implies that the gcd is x because of the mathematical property that the gcd of any  
integer x and itself is x.
How do we know that the loop will always terminate? We need a v ariant. If x is greater  
than y, the loop body replaces x by x – y ; if y is greater than x, it replaces y by y – x . We 
cannot choose x as a variant, because we cannot be sure that an arbitrary loop  iteration will  
decrease x; nor can we be sure that it will decrease y, so y is also not an appropriate variant.  
But we can be sure that it will decrease either x or y, and hence their maximum x  max (y); 
this maximum will never become negative, so it provides the sou ght variant. We may now  
write the loop with all its clauses: 
from
x := a; y := b
invariant
x > 0; y > 0
-- The pair < x, y> has the same greatest co mmon divisor as the pair < a, b>
variant
x  max (y)
until
x = y
loop
if x > y then x := x – y else y := y – x end
end
As noted, the invariant  and variant  clauses in loops are op tional. When present,  
they help clarify the purpose of a loop and check its correctne ss. Any non-trivial loop may  
be characterized by an interesti ng invariant and variant; many of the examples in  
subsequent chapters include vari ants and invariants, providing insights into the underlying  
algorithms and the ir correctness. 
§11.13   USING ASSERTIONS 389
11.13  USING ASSERTIONS
W e  h a v e  n o w  s e e n  a l l  t h e  c o n s t r u cts involving assertions and sh ould review all the  
benefits that we can derive from them. There are four main appl ications: 
• Help in writing correct software. 
• Documentation aid. 
• Support for testing, debuggi ng and quality assurance. 
• Support for software fault tolerance. 
Only the last two assu me the ability to mon itor assertions at r un time.
Assertions as a tool for writing correct software 
The first use is purely methodol ogical and perhaps the most imp ortant. It has been  
explored in detail in the preced ing sections: spelling out the exact requirements on each  
routine, and the global properti es of classes and loops, helps developers produce software  
that is correct the first time a round, as opposed to the more c ommon approach of trying to  
debug software into correctness.  The benefits of precise specif ications and a systematic  
approach to program construction  cannot be overemphasized. Thro ughout this book,  
whenever we encounter a program e l e m e n t ,  w e  s h a l l  s e e k  t o  e x p r e ss as precisely as  
possible the formal properties of that element. 
The key idea runs through this  chapter: the principle of Design by Contract . To use  
features from a certain module is  to contract out for services.  Good contracts are those  
which exactly specify the rights and obligations of each party,  and the limits  to these rights  
and obligations. In software design, where correctness and robu stness are so important, we  
need to spell out the terms of t he contracts as a prerequisite to enforcing them. Assertions  
provide the means to state preci sely what is expected from and guaranteed to each side in  
these arrangements. 
Using assertions for documentati on: the short form of a class
The second use is essential in the production of reusable softw are elements and, more  
generally, in organizing the interfaces of modules in large sof tware systems.  
Preconditions, postconditions an d class invariants provide pote ntial clients of a module  
with basic information about the services offered by the module , expressed in a concise  
and precise form. No amount of ve rbose documentat ion can replac e a set of carefully  
expressed assertions, appearing in the software itself .
To learn how a particular project ignored this rule and lost an  entire space mission at a  
cost of $500 million, see the very last section of this chapter .
The automatic doc umentation tool short  uses assertions as an  important component  
in extracting from a class the information that is relevant to potential clients. The short  
form of a class is a high-level view of the class. It only incl udes the information that is  
useful to authors of client clas ses; so it does not show anythi ng about secret features and,  
for public features, it does not  show the implementation (the do clauses). But the short  
form does retain the assertions,  which provide essential docume ntation by s tating the  
contracts that the class  offers to its clients. “POSTSCRIPT: 
THE ARIANE 5 CRASH”, page 410.
Chapter 23 discusses
short  in detail .
DESIGN BY CONTRACT: BUILDING RELIABLE SOFTWARE  §11.13 390
Here is the short form of class STACK4 :
note
description : "Stacks : Dispenser structures with a Last-In , First-Out  %
%access policy , and a fixed maximum capacity "
class interface STACK4 [G] creation  
make
feature -- Initialization
make (n: INTEGER )
-- Allocate stack for a maximum of n elements
require
non_negative_capacity : n >= 0
ensure
capacity_set : capacity = n
end
feature -- Access
capacity : INTEGER
-- Maximum number of stack elements
count : INTEGER
-- Number of stack elements
item: G
-- Top element
require
not_empty : not empty  -- i.e.  count > 0
end
feature  -- Status report
empty : BOOLEAN
-- Is stack empty?
ensure
empty_definition : Result = (count = 0)
end
full: BOOLEAN
-- Is stack full?
ensure
full_definition : Result = (count = capacity )
endSTACK4 appeared 
on page 364 , based 
on STACK2 from 
page 349 .
§11.13   USING ASSERTIONS 391
feature -- Element change
put (x: G)
-- Add x on top
require
not_full : not full
ensure
not_empty : not empty
added_to_top : item = x
one_more_item : count = old count + 1
end
remove
-- Remove top element
require
not_empty : not empty -- i.e.  count > 0 
ensure
not_full : not full
one_fewer : count = old count – 1
end
invariant
count_non_negative : 0 <= count
count_bounded : count <= capacity
empty_if_no_elements : empty = (count = 0)
end
This short form is not a syntactically valid class text (hence the use of class interface
rather than the usual class  to avoid any confusion), althou gh it is easy to turn it into a  valid 
deferred  class, a notion to be seen in detail in our study of inheritan ce.
In the ISE environment, you obtain the short form of a class by  clicking on the  
corresponding button in a Class Tool displaying a class; you ca n generate plain text, as  
well as versions formated for a whole host of formats such as H TML (for Web browsing),  
RTF (Microsoft’s Rich Text Format), FrameMaker’s MML, TEX, troff and others. You  
can also define your own format, for example if you are using s ome text processing tool  
with its specific conventions f or specifying fonts and layout.
If you compare the short form’s assertions to those of the clas s, you will notice that all  
the clauses involving representation  have disappeared, since that  attribute is not exported.
The short form of documentation is particularly intere sting for several r easons:
• The documentation is at a highe r level of abstraction than wha t it describes, an  
essential requirement for quality documentation. The actual imp lementation,  
describing the how, has been removed, but the assertions, ex plaining the what (or in 
some cases the why) are still there. Note that the header comments of routines, w hich 
complement assertions by giving a  less formal explanation of ea ch routine’s purpose,  
are retained, a s well as the description entry of the note clause.See chapter 36  about
the environment .
DESIGN BY CONTRACT: BUILDING RELIABLE SOFTWARE  §11.13 392
•A direct consequence of the Self- Documentation principle studie d in our review of  
modularity concepts, the short fo rm treats documentation not as  a separate product  
but as information cont ained in the software itself. This means  that there is only one  
product to maintain, a requireme nt that runs through this book.  There is also, as a  
result, a much better chance tha t the documentation will be cor rect, since by having  
everything at the same place you decrease the risk of forgettin g to update the  
documentation after a change t o the software, or conversely.
• T h e  s h o r t  f o r m  c a n  b e  e x t r a c t e d  f r o m  t h e  c l a s s  b y  a u t o m a t i c  t o ols. So the  
documentation is not something that you have to write; instead it is something that  
you ask “the computer”  to produce, at the click of a mouse butt on, when you need it.
It is interesting to compare thi s approach with the notion of p ackage interface present  
in Ada (“specification part”), where you write a module (packag e) in two parts: the  
interface and the implementation . Java uses a similar mechanism . The interface of a  
package has some similarities to  the short form of a class, but  also significant differences:
• There are no assertions, so all  the “specificat ion” that you c an give is in the form of  
type declarations and comments.
• The interface is not produced b y a tool but written separately . So the developer has  
to state many things twice: the headers of routines, their sign atures, any header  
comments, declarations of public variables. This forced redunda ncy is tedious (it  
would be even more so with assertions) and, as always, raises t he risk of  
inconsistency, as you may change  one of the two parts and forge t to update the other.
The short form (complemented by its variant the flat-short form , which deals with  
inheritance and is studied in a later chapter) is a principal c ontribution of the object-
oriented method. In the  daily practice of O-O development it ap pears all the time not just  
as a tool for documenting softwa re, particularly reusable libra ries, but also as the standard  
format in which developers and ma nagers study existing designs,  prepare new designs,  
and discuss proposed designs.
The reason for the central role of the short form in O-O develo pment is that it finally  
fulfills the goal defined by the analysis of reusability requir ements at the beginning of this  
book. There we arrived at the requirement for abstracted modules  as the basic unit of reuse.  
A class in its short (or flat-short) form is the abstracted mod ule that we have been seeking.
Monitoring assertions at run time
It is time now to deal in full wi th the question “what is the e ffect of assertions at run time?”.  
As previewed at the beginning of this chapter, the answer is up  to the developer, based on a  
compilation option. To set that option, you should not, of cour se, have to change the actual  
class texts; you will rely inst ead on the Ace file. Recall that  an Ace file, written in Lace, allows  
you to describe how to assemb le and compile a system. 
Recall too that Lace is just one possible control language for assembling O-O systems,  
not an immutable component of the method. You will need somethi ng like Lace, even  
if it is not exactly Lace, to go  from individual software compo nents to complete  
compilable systems.“Self-Documenta-
tion”, page 54 .
“The flat-short 
form”, page 543 .
“Reuse of 
abstracted mod-ules”, page 73 .
Lace and Ace files 
were introduced in “Assembling a sys-tem”, page 198 .
§11.13   USING ASSERTIONS 393
H e r e  i s  h o w  t o  a d a p t  a  s i m p l e  A c e  ( t h e  o n e  u s e d  a s  e x a m p l e  i n  t he original  
presentation of Lace) to set some  assertion-monitoring options:
system  painting root
GRAPHICS
default
assertion (require )
cluster
base_library : " \ library  \ base"
graphical_library : " \ library  \ graphics "
option
assertion (all): BUTTON , yy-unknown_BITMAP
end
painting_application : " \ user \ application "
option
assertion (no)
end
end -- system painting
The default  clause indicates that for most classes of the system only prec onditions  
will be checked ( require ). Two clusters override this default: graphical_library , which  
will monitor all assertions ( all), but only for classes BUTTON and yy-unknown_BITMAP ; 
and painting_application , which has disabled any asserti on checking for all its classes . 
This illustrates how to define an  assertion monitoring level fo r the system as a whole, for  
all the classes of a cluster , or for some classes only.
The following assertion checking l evels may appear between pare ntheses in  
assertion (…):
•no: do not execute anything for as sertions. In this mode assertio ns have no more  
effect on executi on than comments.
•require : check that precondition s hold on routine entry.
•ensure : check that postcondition s hold on routine exit.
•invariant : check that class invariants hol d on routine entry and exit fo r qualified  
calls.
•loop: check that loops invariants hol d before and after every loop iteration, and that  
variants decrease while remaining non-negative.
•check : execute check  instructions by checking that  the correspond ing assertions  
hold. all is a synonym for check .
Excluding no, each of these levels implies th e previous ones; in particular  it does not  
make sense to monitor postconditions unless you also monitor pr econditions,  since the  
principles of Design by Contract indicate that a routine is req uired to ensure its  
postcondition onl y if it was called with its precondition satis fied (otherwise “the customer  
is wrong”). This explains why check and all are synonyms.Warning : this text is 
in Lace , not in the  
O-O notation .
A qualified call is a 
call from the outside , 
as in x l f, as opposed 
to a plain internal callf. See “Qualified and 
unqualified calls”, page 186.
DESIGN BY CONTRACT: BUILDING RELIABLE SOFTWARE  §11.13 394
If turned on, assertion monitori ng will have no visible effect,  except for the CPU  
cycles that it takes away from your computation, as long as the  assertions that it monitors  
all evaluate to true. But having any assertion evaluate to fals e is a rather serious event  
which will usually lea d to termination. Actually it will trigge r an exception, but unless you  
have taken special measures to catch the exception (see next) e verything will stop. An  
exception history table  will be produced, of the general form
Failure: object: O2 class: YOUR_CLASS  routine: your_routine
Cause: precondition violation, clause: not_too_small
Called by: object: O2 class: YOUR_CLASS  routine: his_routine
Called by: object: O1 class: HER_CLASS  routine: her_routine
…
This gives the call chain, starti ng from the routine that cause d the exception, the  
object to which is was applied a nd its generating class. Object s are identified by internal  
codes. The form shown here is on ly a sketch; the discussion of exceptions will give a more  
complete example  of the exceptio n history table.
The optional labels that you can  add to the individual clauses of an assertion, such as  
not_too_small  in
your_routine (x: INTEGER )
require
not_too_small : x >= Minimum_value
…
prove convenient here, since the y will be listed in the excepti on trace, helping you identify  
what exactly went wrong.
How much assertion monitoring?
What level of assertion tracing should you enable? The answer i s a tradeoff between the  
following consideratio ns: how much you trust the correctness of  your software; how  
crucial it is to get the utmost efficiency; how serious the con sequences of an undetected  
run-time error can be.
In extreme cases, the  situation is clear:
• When you are debuggin g a system, or more ge nerally testing it prior to release, you  
should enable assertion monitorin g at the highest level for the  classes of the system  
(although not necessarily for th e libraries that it uses, as ex plained next). This ability  
is one of the principal contribut ions to software development o f the method  
presented in this book. Until they have actually had the experi ence of testing a large,  
assertion-loaded system using th e assertion monitoring mechanis ms described in  
this section, few people realize the power of these ideas and h ow profoundly they  
affect the practice of  software development.
• If you have a fully trusted system in an efficiency-critical a pplication area — the  
kind where every microsecond cou nts — you may consider removing  all monitoring.See page 421 for the 
detailed form .
§11.13   USING ASSERTIONS 395
The last advice is somewhat para doxical since in the absence of  formal proving  
techniques (see the discussion section of this chapter) it is s eldom possible to “trust a  
system fully” — except by monitoring its assertions. This is a special case of a general  
observation made with his custom ary eloquence by C.A.R. Hoare:
It is absurd to make elaborate security checks on debugging runs , when no trust  
is put in the results , and then remove them in production runs , when an erroneous  
result could be expe nsive or disastrous . What would we think of a sailing  
enthusiast who wears his life-jacket when training on dry land but takes it off as  
soon as he goes to sea ?
An interesting possibility is th e option that only checks preco nditions: assertion  
(require ). In production runs — that is t o say, past debugging and quali ty assurance — it  
has the advantage of avoiding cat astrophes that would result fr o m  u n d e t e c t e d  c a l l s  t o  
routines outside of their requir ements, while costing significa n t l y  l e s s  i n  r u n - t i m e  
overhead than options that also check postconditions and invari ants. (Invariants, in  
particular, can be quite expensive to monitor since the method suggests writing rich  
invariants that include all rele vant consistency  conditions on a class, and the invariant is  
checked on entry and exit for every qualified call.)
Precondition checking is indeed t he default compilation option if you do not include  
a specific assertion  option in your Ace,  so that the clause default assertion (require )
appearing in the exa mple Ace for system painting  was not necessary.
This option is particularly inte resting for libraries. Remember  t h e  b a s i c  r u l e  o n  
assertion violations: a violated  precondition indicates an erro r in the client; a violated  
postcondition or  invariant indicates an error in the supplier. So if you are relying on  
reusable libraries tha t you assume to be of high quality, it is  generally not desirable to  
monitor their postconditions and  invariants: this would mean th at you suspect the libraries  
themselves, and although the pos sibility of a library error is of course always open it  
should only be i nvestigated (for a widely used library coming f rom a reputable source)  
once you have ruled out the presence, a priori  much more likely, of an error in your own  
client software. But even for a perfect library it is useful to  check preconditions : the goal  
is to find errors in  client software.
Perhaps the most obvious example is array bound checking. In th e ARRAY  class we  
saw that put, item and the latter’s synonym infix  "@" all had the prec ondition clauses
index_not_too_small : lower <= i
index_not_too_large : i <= upper
Enabling precondition checking for the class solves a well-know n problem of any  
so f tw a r e t ha t  us es  a rr a ys : t he  p ossibility of an  out-of-bounds array access, which will  
usually scoop some mem ory area containing other data or code, c ausing ravages. Many  
compilers for conventional progr amming languages offer special compilation options to  
monitor array access at run time. But in object technology, jus t as we treat arrays through  
general notions of class and objec t rather than sp ecial constru cts, we can handle array  
bound monitoring throug h the general mechanism for precondition  checking. Just use a  
version of ARRAY  compiled with assertion (require ).From [Hoare 1973] .
Second Assertion 
Violation rule, page 347.
See the class text 
starting on page 372 .
DESIGN BY CONTRACT: BUILDING RELIABLE SOFTWARE  §11.13 396
Should bounds always be checked? Hoare thinks so:
In our Algol compiler every occurrence of every subscript of every array element  
was on every occasion ch ecked at run time agai nst the declared bounds . Many  
years later we asked our customers whet her they wished us to provide an option  
to switch off these checks in the interest of efficiency in production runs .
Unanimously they urged us not to — th ey already knew how frequently index  
errors occur on production runs where failure could be disastrous . I note with  
fear and horror that even today , language designers and users have not learned  
this lesson . In any respectable br anch of engineering , failure to observe such  
elementary precautions would ha ve long been against the law .
These comments should be discusse d not just for arrays but for preconditions in  
general. If indeed “index errors frequently occur on production  runs” this must be true of  
other precondition violations too.
One may defend a less extreme pos ition. (Some might of course s ee here an attempt  
at self-preservation, coming from a “language designer” who has  provided a way to turn  
off assertion checking, thro ugh Lace options such as assertion (no), and presumably does  
not like being branded as acting “ a g a i n s t  t h e  l a w ” . )  F i r s t ,  a  c ompany which delivers  
software in which precondition errors “frequently occur on prod uction runs” probably has  
a problem with its software qual ity practices, which run-time a ssertion monitoring will not  
solve. Monitoring addr esses the symptoms (  faults  in the terminology in troduced earlier in  
this chapter), not the cause (de fects and errors). True, assert ion monitoring is in such a case  
beneficial to the software’s end -users: however unpleasant it i s to have a system end its  
interruption with some message s pouting insults about precondit ions and other venomous  
beasts unknown to a layman, this is better than continuing oper ation and producing bad  
results. But in the long term a practice of always delivering s ystems with some level of  
assertion monitoring also has neg ative effects: it can encourag e among developers, even  
unconsciously, a happy -go-lucky attitude tow ards correctness, j ustified by the knowledge  
t h a t  i f  a n  e r r o r  r e m a i n s  i t  w i l l  be caught by the users through  an assertion violation,  
reported to the supplier, and fi xed for the following release. So can’t we stop testing right  
now and start shipping?
It is hard to give an absolute answer to the question “should w e leave some assertion  
monitoring on?” without some kno wledge of the performance overh ead of assertion  
monitoring. If adding some monito ring multiplied the execution time by ten, few people  
outside of the mission -critical-computing community would suppo rt Hoare’s view; if the  
overhead were two percent, few p eople would disagree with it. I n practice, o f course, the  
penalty will be some where in-between.
How much is it, by the way? This clearly depends on what the so ftware does and how  
many assertions it has, but it is possible to give empirical ob servations. In ISE’s experience  
the cost for monitoring preconditions (the default option, incl uding of course array bounds  
checking) is on the order of 50% . What is frustrating is that m ore than 75% of that cost is  
due not to precondition checking per se but to the supporting m achinery of monitoring  
calls — recording every routine entry and every routine exit — so that if a precondition  
fails the environment can say which one and where. (A message o f the form Execution  From [Hoare 1981];  
slightly abridged .
§11.13   USING ASSERTIONS 397
stopped because some assertion was violated somewhere  would not be very useful.) This  
may be called the Precondition Checking Paradox: precondition c hecking is by itself cheap  
enough, but to get it you have to pay for something else. As to  postcondition and invariant  
checking, they can bring the pen alty to 100% to 200%. (Although  circumstances vary,  
preconditions are often relatively simple consistency condition s such as x > 0 or a /= Void , 
whereas many postconditions and invariants express more advance d semantic properties.)
One might fear that bringing perf ormance into this discussion m ay lead to  
compromising on correctness, aga inst the principle expressed at  the beginning of this book:
Necessary as tradeoffs betw een quality factors may be , one factor stands out  
from the rest : correctness . There is never any justi fication for compromising on  
correctness for the sake of other concerns , such as efficiency . If the software  
does not perform its function , the rest is useless . 
Considering performanc e when we decide whether to leave asserti on monitoring on  
is not, however, a violation of this principle. The point is no t to sacrifice correctness for  
efficiency, but to determine what we should do for systems that  a r e  not c o r r e c t  —  
obviously because we have not wor ked hard enough at making them  correct.
In fact, efficiency may be part of correctness. Consider a mete orological system that  
takes twelve hours to predict the next-day’s weather (two hours  would be more useful, of  
course). The system has been tho roughly optimized ; in particula r it does not have run-time  
checking for array bound violati ons or other such faults. It ha s also undergone careful  
development and extensive testin g .  N o w  a s s u m e  t h a t  a d d i n g  t h e  r un-time checks  
multiplies the execution time by two, giving a forecasting syst em that takes 24 hours to  
predict tomorrow’s weather. Woul d you enable these checks? No.
Although the examples that first come to mind when discussing s uch performance vs.
safety issues tend to be of the Patriot-against-Scud variety, I  prefer the weather forecasting  
example because here one cannot dismiss the efficiency issue of fhand by saying “just buy  
a faster microprocessor”. In meteorological computing, the hard ware tends already  to be 
the fastest parallel comput er available on the market.
Let us not stop here but ask the really hard questions. Assume the original running  
time of twelve hours was with checking enabled . Would you disable it to get a six-hour  
forecast? Now assume that you al so have the option of applying the improved efficiency to  
keep the same running time but use a more accurate forecasting model (since you can afford  
more grid points); would you do it? I think that in either case , if offered “ an option to switch  
off the checks in the interest of efficiency in production runs ”, almost everyone will say yes.
So in the end the choice of assertion monitoring level at produ ction time is not as  
simple as Hoare’s rule suggests . But a few precise and strict p rinciples do hold:
• Remember that a software system should be made reliable before  it begins operation.  
The key is to apply the reliabil ity techniques described in the  software engineering  
literature, including those which appear in this chapter and th roughout this book.
• If you are a project manager, never let the developers assume that the production  
versions will have checks turned  on. Make everyo ne accept that — especially for the  Page 15 .
DESIGN BY CONTRACT: BUILDING RELIABLE SOFTWARE  §11.14 398
biggest production runs, those w hich by nature make the consequ ences of potential  
errors most frightening — all checks may be off.
• Make sure that during development assertion checking is always  turned on at least  
at the precondition level.
• Perform extensive testing with all the checks enabled. Also turn all checks on as  
soon as any bug is encounte red during development.
• For the standard production vers ions, decide whe ther to choose  a no-check version  
or a protected version (usually at the precondition level) base d on your assessment,  
from an engineering perspective,  of the relative weight of the three factors cited at  
the beginning of this discussion: how much you trust the correc tness of your  
software (meaning in part how hard you have worked  at making it correct and  
convincing yourself and others tha t it is); how crucial it is t o get the utmost  
efficiency; and how serious the c onsequences of an undetected r un-time error can be.
• If you decide to go for a no-ch eck version, also include in yo ur delivery a version  
that checks at least for preconditions. That way, if the system  starts exhibiting  
abnormal behavior against all you r expectations, you can ask th e users — those at  
least who have not been killed b y the first erroneous productio n runs — to switch to  
the checking version,  helping you find out quickly what is wron g.
Used in this way, run-time asser tion monitoring provides a rema rkable aid for quickly  
weeding out any errors that may have survived a systematic soft ware construction process.
11.14  DISCUSSION
The assertion mechanism presented in this chapter raises some d elicate issues, which we  
must now examine.
Why run-time monitoring?
S h o u l d  w e  r e a l l y  h a v e  t o  c h e c k  a s s e r t i o n s  a t  r u n  t i m e ?  A f t e r  a l l we were able, using  
assertions, to give a theoretical definition of what it means f or a class to be correct: every  
creation procedure should ensure the invariant, and every routi ne body, when started in a  
state satisfying the precondition and the invariant, should mai ntain the invariant and  
ensure the postcondition. This  m e a n s  t h a t  w e  s h o u l d  s i m p l y  prove the m + n
corresponding propertie s mathematically (for m creation procedures and n exported  
routines), and then do away with run-time assertion monitoring.
We should, but we cannot. Althoug h mathematical program proving  has been an  
active area of research for many years, and has enjoyed some su ccesses, it is not possible  
today to prove the correctness of realistic software systems wr itten in full-fledged  
programming languages.
We would also need a more extensive assertion language. The IFL  sublanguage,  
discussed below, could be used a s part of a multi-tier proof st rategy.See “WHEN IS A 
CLASS COR-RECT?”, 11.9, page 369.
§11.14   DISCUSSION 399
Even if proof techniques and too ls eventually become available,  one may suspect  
that run-time checks will not go away, if only to cope with hard-to-predict events such as  
hardware faults, and to make up for possible bug s in the proof software itself — in other  
words to apply the well-known e ngineering technique of multiple  independent  checking.
The expressive power of assertions
As you may have noted, the assertion language that we have used  is essentially the  
language of boolean expressions, extended with a few concepts s uch as old. As a result,  
we may find it too restrictive w hen we would like to include in  our classes some of the  
properties that were easy to expr ess in the mathe matical notati on for abstract data types.
The assertions for sta ck classes provide a g ood example of what  we can and cannot  
say. We found that many of the p reconditions and axioms from th e original ADT  
specification of chapter 6 gave assertion clauses; for example the axiom
A4 •not empty  (put (s, x))
gives the postcondition not empty in procedure put. But in some cases we do not have the  
immediate counterpart in the cla ss. None of the postconditions for remove  in the stack  
classes given so far includes anything to repre sent the axiom
A2 • remove  (put (s, x)) = s
W e can of course add an informal property to the postcondition by resorting to  
a comment: 
remove
-- Remove top element
require
not_empty : not empty -- i.e.  count > 0 
do
count := count – 1
ensure
not_full : not full
one_  fewer : count = old count – 1
LIFO_  policy : -- item is the last element pushed (by put) 
     -- and not yet removed, if any.
end
Similar informal assertions, syn tactically expressed as comment s, appeared in the  
loop invariants for maxarray and gcd.
I n  s u c h  a  c a s e ,  t w o  o f  t h e  p r i n c i p a l  u s e s  o f  a s s e r t i o n s  d i s c u s s ed earlier remain  
applicable at least in part: help in composing correct software , and help in documentation  
(an assertion clause that is synt actically a comment will appea r in the short form). The  
other uses, in particular debuggi ng and testing, assume the abi lity to evaluate assertions  
and do not apply any more.Both on page 387 .
DESIGN BY CONTRACT: BUILDING RELIABLE SOFTWARE  §11.14 400
It would be preferable to express all assertions formally. The best way to reach this  
goal is to extend the assertion language so that it can describ e arbitrary properties; this  
requires the ability to describe complex mathemat ical objects s uch as sets, sequences,  
functions and relations, and inc luding the full power of first- order predicat e calculus,  
which allows quantified expressi ons (“for all” and “there exist s”). Formal specification  
languages exist which provide at  least part of this expressive power. The best known are  
Z, VDM, Larch and OBJ-2; both Z and VDM have had object-oriente d extensions, such  
as Object-Z, in recent years, an d the last two were close to O- O concepts already. The  
bibliographic not es to chapter 6 provide references.
Including a full specification language into the language of th is book would have  
completely changed its nature. The language is meant to be simp le, easy to learn,  
applicable to all areas of software construction, and implement able efficiently (with a final  
run-time performance similar to that of Fortran and C, and a fa st compilati on process).
Instead, the assertion mechanism is an engi neering tradeoff: it  includes enough  
formal elements to have a substa ntial effect on software qualit y; but stops at the point of  
diminishing return — the threshold beyond which the benefits of  more formality might  
start being offset by the decrea se of learnability, simplicity and efficiency.
Determining that threshold is clearly a matter of personal judg ment. I have been surprised  
that, for the software community at large, the threshold has no t moved since the first edition  
of this book. Our field needs more formality, but the professio n has not realized it yet.
So for the time being, and probably for quite a while, assertio ns will remain boolean  
expressions extended with a f ew mechanisms such as the old expression in postconditions.  
The limitation is not as stringent as it seems at first, becaus e boolean expres sions can use  
function calls .
Including functions in assertions
A boolean expression is not rest ricted to using attributes or l ocal entities. We have already  
used the possibility of calling functions  in assertions: the precondition for put in our stack  
classes was not full, were full is the function
full: BOOLEAN
-- Is stack full?
do
Result := (count = capacity )
ensure
full_definition : Result = (count = capacity )
end
This is our little assertion secr et: we get out of the strangle hold of propositional  
calculus — basic boolean expressi ons involving attributes, loca l entities and boolean  
operators such as and, or, not — thanks to function routines , which give us the power to  
compute a boolean valu e in any way we like. (You should not be troubled by the presence  
§11.14   DISCUSSION 401
of a postcondition in full itself, as it does not create an y harmful circularity. Details  
shortly.)
Using function routines is a way to obtain more abstract assert ions. For example, some  
people may prefer replacing the p recondition of the array opera tions, expressed earlier as
index_not_too_small : lower <= i
index_not_too_large : i <= upper
by a single clau se of the form
index_in_bounds : correct_index (i)
with the function definition
correct_index (i: INTEGER ): BOOLEAN
-- Is i within the array bounds?
do
Result := (i >= lower ) and (i <= upper )
ensure
definition : Result = ((i >= lower ) and (i <= upper ))
end
Another advantage of the use of functions in assertions is that  it may provide a way  
to circumvent the limitations on expressive power arising from the absence of first-order  
predicate calculus mechanisms. T he informal invariant of our maxarray  loop
-- Result is the maximum of the elements of  t at indices  t  lower to i
may be expressed  formally as 
Result = (t  slice (lower , i))  max
assuming a function slice which yields the set of element s between two indices of an arr ay, 
and a function max which yields the maxi mum element in a set.
This approach has been explored in [M 1995a]  as a way to extend the power of the  
assertion mechanism, possibly leading to a fully formal develop ment method (that is to  
say, to software that may be proven  correct mathematically). Two central ideas in this  
investigation are the use of libraries in any large-scale proof  process, so that one could  
prove real, large-scale systems  in a multi-tier proof structure  using conditional proofs,  
and the definition of a restricted language of a purely applica tive nature — IFL, for  
Intermediate Functional Language — in which to express the func tions used in assertions.  
IFL is a subset of the notation of this book, which excludes so me imperative constructs  
such as arbitrary assignments.
The risk that such efforts try to address is clear: as soon as we permit functions in  
assertions, we introduce potentia lly imperative elements (routi nes) into th e heretofore  
purely applicative world of asse rtions. Without functions, we h a d  t h e  c l e a r  a n d  c l e a n  
separation of roles emp hasized in the earli er discussion: instr uctions prescribe, assertions  
describe. Now we open the gates of the applicative city to the imperative hordes.
Yet it is hard to resist the power of using functions, as the a lternatives are not without  
their drawbacks either:“The imperative and 
the applicative”, page 351 .
DESIGN BY CONTRACT: BUILDING RELIABLE SOFTWARE  §11.14 402
• Including a full specification sublanguage could, as noted, ca use problems of ease of  
learning and efficiency.
•P e r h a p s  w o r s e ,  i t  i s  n o t  e v e n  c l ear that commonly accepted asse rtion languages  
would suffice. Take what most pe ople versed in these topics wou ld suggest as the  
natural candidate: first-order p redicate calculus. This formali sm will not enable us to  
express some propertie s of immediate interest to developers and  common use in  
a s s e r t i o n s ,  s u c h  a s  “ t h e  g r a p h  h as no cycles” (a typical invari ant clause).  
Mathematically this would be stated as r+ ∩ r = ∅ where r is the graph’s relation  
and + is transitive closure. Although  it is possible to conceive of a specification  
language that supports the se notions, most do not.
This is all the more troubling b ecause, for a programmer, writi ng a boolean-valued  
function routine cyclic  that explores the graph and ret urns true if and only if there is a 
cycle, is not particularly hard. Such examples provide a strong  argument for contenting  
o urselves with  a basic assertio n lan guage an d usin g functio ns f or anything beyond its  
expressive power.
But the need to separate applica tive and imperative elements re mains. Any function  
routine used in an assertion to specify the properties of a sof tware element should be  
“beyond reproach”, more precisel y beyond imperative reproach; i t should not cause any  
permanent change of the abstract state.
This informal requirement is clear enough in practice; the IFL sublanguage formalizes it  
by excluding all the imperative elements which either change th e global state of the  
system or do not have trivial applicative equivalents, in parti cular:
• Assignments to attributes.
• Assignments in loops.
• Calls to routines not themselves in IFL.
If you exert the proper care by sticking to functions that are simple and self-evidently  
correct, the use of function rout ines in assertions can provide  you with a powerful means  
of abstraction.
A technical point may have ca ught your attention. A function f  used by an assertion  
for a routine r (or the invariant of t he class containing r) may itself have assertions, as  
illustrated by both the full and correct_index  examples. This raises a potential problem for  
run-time assertion monitorin g: if as part of a call to r we evaluate an assertion and this  
causes a call to f, we do not want the  call to evaluate any assertion that f  itself may have.  
For one thing, it is easy to construct examples that would caus e infinite recursion. But  
even without that risk it would be just wrong to  evaluate the a ssertions of f. This would  
mean that we treat as peers the routines of our computation, su ch as r, and their assertions’s  
functions, such as f — contradicting the rule that asse rtions should be on a higher pl ane 
than the software they protect, and their correctness crystal-c lear. The rule is simple: 
Assertion Evaluation rule
During the process of evaluatin g an assertion at  run-time, rout ine calls shall  
be executed without any evaluati on of the associated assertions .The transitive closure
of a relation is obtained by iterating it any number of times . For example 
“ancestor” is the transitive closure of “parent” .
§11.14   DISCUSSION 403
If a call to f occurs as part of ass ertion checking for r, that is too late to ask whether  
f satisfies its assertions. The proper time for such a question is when you decide to use f  in 
the assertions applicable to r.
We can use an analogy introduced earlier. Think of f  as a security guard at the  
entrance of a nuclear plant, in c harge of inspecting the creden tials of visitors. There are  
requirements on guards too. But  you will run the background che ck on a guard in advance;  
not while he is screeni ng the day’s visitors.
Class invariants and reference semantics 
The object-oriented model developed so far includes two apparen tly unrelate d aspects,  
both useful:
• The notion of class invariant , as developed in this chapter.
•A flexible run-time model which,  f o r  v a r i o u s  r e a s o n s  d e t a i l e d  i n an earlier  
chapter (in particular the modeling needs of realistic systems) , makes  
considerable use  of references.
Unfortunately these individually desirable properties cause tro uble when put together.
The problem is, once again, dynam ic aliasing, which prevents us  from checking the  
correctness of a class on the basis of that class alone. We hav e seen that the correctness of  
a class means m + n  properties expressing that (if we concentrate on the invariant  INV, 
ignoring precond itions and postconditions which play no direct role here):
P1 •  Every one of the m creation procedures produces  an object that satisfies INV. 
P2 •  Every one of the n exported routines preserves INV. 
These two conditions seem sufficient to guarantee that INV is indeed invariant. The  
proof is apparently trivial: since INV will be satisfied initiall y, and preserved by every  
routine call, it shoul d by induction be sati sfied at all stable  times. 
This informal proof, however, is not valid in the presence of r eference semantics and  
dynamic aliasing. The problem is that attributes of an object m ay be modified by an  
operation on another object. So even if all a  r operations preserve INV on the object OA  
attached to a, some operation b  s (for b attached to another object) may destroy INV for 
OA. So even with conditions P 1 and P 2 satisfied, INV may not be an invariant. 
Here is a simple example. Assume classes A and B, each with an attribute whose type  
is the other’s class: 
class  A … feature  forward : B … end
class  B … feature  backward : A … end
We require that following the forward  reference (if defined) from an instance of A
and then the backward  reference from the corresponding B will yield the original A. This  
may be expressed as an i nvariant property of A: 
round_trip : (forward /= Void ) implies (forward   backward = Current )See chapter 8 , in par-
ticular “DEALING WITH REFER-ENCES: BENEFITS AND DANGERS”, 8.9, page 265 .
DESIGN BY CONTRACT: BUILDING RELIABLE SOFTWARE  §11.14 404
Here is a situation involving in stances of both classes and sat isfying the invariant:
Invariant clauses of the round_trip form are not uncommon; think of forward  in class  
PERSON  denoting a person’s residence, and backward in class HOUSE denoting a house’s  
resident. Then round_trip states that the resident of any person’s residence is that pers on, 
a simple consistency requirement . Another example is the linked  implementation of trees,  
where the attributes of a tree n ode include references to its f irst child and to its parent,  
introducing the following round_trip -style property in  the invariant:
(first_child /= Void ) implies (first_child   parent = Current )
Assume, however, that th e invariant clause of B, if any, says nothing about the  
attribute backward . The following version of A appears consistent with the invariant: 
class A feature
forward : B
attach (b1: B)
-- Link b1 to current object.
do
forward := b1
-- Update b1’s backward referenc e for consistency:
if b1 /= Void then
b1  attach (Current )
end
end
invariant
round_trip : (forward /= Void ) implies  (forward   backward = Current )
end
The call b1  attach  is meant to restore the invariant after an update of forward . Class  
B must provide its own attach  procedure: 
class B feature
backward : BConsistency of 
forward and 
backward 
referencesOA
(A)OB
(B)backward
forward
§11.14   DISCUSSION 405
attach (a1: A)
-- Link a1 to current object.
do
backward := a1
end
end
Class A appears to be correct: a proce dure-less creatio n instruction e nsures the  
invariant round_trip  ( s i n c e  i t  i n i t i a l i z e s  forward  to a void reference), and its sole  
procedure will a lways preserve round_trip . But consider e xecution of the following: 
a1: A; b1: B
…
create  a1; create  b1
a1  attach (b1)
b1  attach (Void)
Here is the situation after the last instruction: 
The invariant is violated on OA! This object is now linked to O B, but OB is not  
linked to OA since its backward  field is void. (A call to b1  attach (…) could also have  
linked OB to an instance of A other than OA, which woul d be equally incorrect.)
What happened? Dynamic aliasing has struck again. The proof of correctness of  
class A outlined above is valid: every opera tion of the form a1  r, where a1 is a reference  
to object OA, will preserve round_trip  since the corresponding features of A (here there is  
only one, attach ) have been designed accordingly.  But this is not sufficient to  preserve the  
consistency of OA, since propert ies of OA may in volve instances  of other classes, such as  
B in the example, and the proof s ays nothing abou t the effect of  t h e s e  o t h e r  c l a s s e s ’  
features on the invariant of A.
This problem is important enough to deserve a name: Indirect Invariant Effect . It 
may arise as soon as we allow dyn amic aliasing, through which a n operation may modify  
an object even without  involving any entity attached to it. But  we have seen how much we  
need dynamic aliasing; and the forward -backward  scheme, far from being just an  
academic example, is as noted a useful pattern f or practical ap plications and libraries.Violating the 
invariantOA
(A)OB
(B)backward
forward
a1b1
DESIGN BY CONTRACT: BUILDING RELIABLE SOFTWARE  §11.15 406
What can we do? The immediate an swer involves the conventions f or run-time  
monitoring of assertions. You ma y have wondered why the effect of enabling assertion  
monitoring at the assertion  (invariant ) level was described as
“Check that class invariants hold on r outine entry and exit for qualified calls .”
Why both entry and exit? Without  the Indirect Invariant Effect,  it would suffice to  
check the invariant when exitin g qualified calls. (It is also c hecked at the en d of creation  
calls.) But now we have to be mor e careful, since between the t ermination of a call and the  
beginning of the next one on the same object, some call may hav e affected that object even  
though its target w as another object.
A more satisfactory solution wou ld be to obtain a statically en forceable validity rule,  
which would guarantee that whenever the invariant of a class A involves references to  
instances of a class B, the invariant of B includes a mirror clause. In our example we can  
avoid trouble by including in B an invariant clause trip_round  mirroring round_trip :
trip_round : (backward /= Void ) implies (backward   forward = Current )
It may be possible to generalize thi s observation to a universa l mirroring rule.  
Whether such a rule indeed exists, solving the Indirect Invaria nt Effect and removing the  
need for double run-time monitor ing, requires fu rther investiga tion.
More to come
We are not done with Design by Contract. Two important conseque nces of the principles  
remain to be studied:
• How they lead to a disciplined exception handling mechanism; t his is the topic of the  
next chapter.
•How they combine with inheritanc e, allowing us to specify that any semantic  
constraints that apply to a clas s also apply to its descendants , and that semantic  
constraints on a feature apply to its eventual redeclarations; this will be part of our  
study of inheritance.
More generally, assertions and D esign by Contract  will accompan y us throughout  
the rest of this book , enabling us to check , whenever we write software elements, that we  
know what we are doing.
11.15  KEY CONCEPTS INTRODUCED IN THIS CHAPTER 
• Assertions are boolean expressions expressing the semantic pro perties of classes and  
reintroducing the axioms and pre conditions of the corresponding  abstract data types. 
• Assertions are used in precondi tions (requirements under which  routines are  
applicable), postconditions (prop erties guaranteed on routine e xit) and class  
invariants (properties that chara cterize class instances over t heir lifetime). Other  
constructs that involve assertions are l oop invariants and the check  instruction. Page 393 .
“INHERITANCE 
AND ASSER-TIONS”, page 569 .
§11.16   BIBLIOGRAPHICAL NOTES 407
• A precondition and a postconditi o n  a s s o c i a t e d  w i t h  a  r o u t i n e  d escribe a contract  
between the class and its client s. The contract is only binding  on the routine  
inasmuch as calls observe the pr econdition; the routine then gu arantees the  
postcondition on return. The not ion of contracting provides a p owerful metaphor for  
the construction of c orrect software. 
• The invariant of a class expre sses the semantic constraints on  instances of the class.  
The invariant is implicitly added to the precondition and the p ostcondition of every  
exported routine of the class.
• A  c l a s s  d e s c r i b e s  o n e  p o s s i b l e  r e p r e s e n t a t i o n  o f  a n  a b s t r a c t  d ata type; the  
correspondence between the two is expressed by the abstraction function, which is  
usually partial. The inverse relation is in general not a funct ion. 
• An implementation invariant, pa rt of the class invariant, expr esses the co rrectness of  
the representation vis-à-vis the  corresponding abstract data ty pe. 
• A loop may have a loop invarian t, used to deduc e properties of  the result, and a  
variant, used to ascertain termination.
• If a class is equipped with asse rtions, it is possible to defi ne formally what it means  
for the class to be correct.
• Assertions serve four purposes:  aid in constructing correct pr ograms; documentation  
aid; debugging aid; basis fo r an exception mechanism.
• The assertion language of our n otation does not include first- order predicate  
calculus, but can exp ress many higher-leve l properties through function calls,  
although the functions  involved must be simp le and of unimpeach able correctness.
• The combination of invariants a nd dynamic aliasing raises the Indirect Invariant  
Effect, which may cause an objec t to violate its invariant thro ugh no fault of its own.
11.16  BIBLIOGRAPHICAL NOTES
According to Tony Hoare:
An early advocate of using assertions in  programming was none other than Alan  
Turing himself . On 24 June 1950 at a conference in Cambridge , he gave a short  
talk entitled “Checking a La rge Routine” which explai ns the idea with great  
clarity . “How can one check a large routin e in the sense th at it’s right ? In order  
that the man who checks may not have too difficult a task , the programmer should  
make a number of definite assertions  which can be ch ecked individually , and from  
which the correctness of the whole program easily follows .”
The notion of assertion as prese nted in this chapter comes from  the work on program  
correctness pionee red by Bob Floyd [Floyd 1967] , Tony Hoare [Hoare 1969]  and Edsger  
Dijkstra [Dijkstra 1976] , and further described in [Gries 1981] . The book Introduction to  
the Theory of Programming Languages [M 1990]  presents a survey of the field.From [Hoare 1981] .
DESIGN BY CONTRACT: BUILDING RELIABLE SOFTWARE  §E11.1 408
The notion of class invariant com e s  f r o m  H o a r e ’ s  w o r k  o n  d a t a  t ype invariants  
[Hoare 1972a] . See also applications to program design in [Jones 1980]  [Jones 1986] . A 
formal theory of morphisms between abstract data types may be f ound in [Goguen 1978] . 
Formal specification languages i nclude Z, VDM, OBJ-2 and Larch;  s e e  t h e  
bibliographical refe rences to chapter 6. Object-oriented formal  specification languages  
i n c l u d e  O b j e c t  Z ,  Z + + ,  M o o Z ,  O O Z E ,  S m a l l V D M  a n d  V D M + + ,  a l l  o f  w hich are  
described in [Lano 1994]  which gives many more references.
The IEEE Computer Society publishe s standards for the terminolo gy of software errors,  
defects, failures [IEEE 1990]  [IEEE 1993] . Its Web page is at http://www .computer .org.
Surprisingly , few programming lan guages have included syntactic al provision for  
assertions; an early example (th e first to my knowledge) was Ho are’s and Wirth’s Algol  W 
[Hoare 1966] , the immediate precursor of Pascal. Others include Alphard [Shaw 1981]
and Euclid [Lampson 1977] , which were specifically desig ned to allow the construction  
of provably correct programs. The connection with object-orient ed development  
introduced by th e notation developed in this book was foreshado wed by the assertions of  
CLU [Liskov 1981]  which, however, are not execut able. Another CL U-based book by  
Liskov and Guttag [Liskov 1986] ,  o n e  o f  t h e  f e w  p r o g r a m m i n g  m e t h o d o l o g y  t e x t s  t o  
discuss in depth how to build reliable software, promotes the “ defensive programming”  
approach of which the present ch apter has developed a critique.
The notion of Design by Contract  presented in this chapter and developed in the rest  
of this book comes from [M 1987a]  and was further developed in [M 1988] , [M 1989c] , 
[M 1992b]  and [M 1992c] . [M 1994a]  discusses the tolerant and demanding approaches  
to precondition design, with par ticular emphasis on their appli cation to the design of  
reusable libraries, and introduce s the “tough love” policy . Fur ther developments of the  
ideas have been contributed by James McKim in [McKim 1992a]  (which led to some of  
the initial ideas for IFL), [McKim 1995] , [McKim 1996] , [McKim 1996a] ; see also 
[Henderson-Sellers 1994a]  which examines the view point of the supplier.
EXERCISES
E11.1  Complex numbers
Write the abstract data type  specification for a class COMPLEX  describing the notion of  
complex number with ar ithmetic operations.  Assume perfect arith metic. 
E11.2  A class and its ADT
Examine all the preconditions and axioms of the STACK  abstract data type introduced in  
an earlier chapter and study whet her and how each  is reflected in class STACK4 .The ADT specification
appears on page 139 . 
STACK4  is on page 
364 and includes STACK2 , page 349
§E11.3   EXERCISES 409
E11.3  Complete assertions for stacks
Show that by introducing a secret function body  which returns the body of a stack, it is  
possible to make the  assertions in a STACK  class reflect the full corresponding abstract  
data type specificatio n. Discuss the  theoretical and practical value of this technique.
E11.4  Exporting the size
Why is capacity  exported for the bounded impl ementation of stacks, class STACK2 ?
E11.5  An implementation invariant
Write the implementation invariant for class STACK3 .
E11.6  Assertions and exports
The discussion of usi ng functions in asserti ons introduced a fu nction correct_index  for the  
precondition of item and put. If you add this function to class ARRAY , what export status  
must you give it?
E11.7  Finding the bugs
Show that each of the four attempts at binary search algorithms  advertized as “wrong” is  
indeed incorrect. ( Hint : unlike proving an algorithm cor rect, which requires showing t hat 
it will work for all possible cas es, proving it incorrect only requires that you find one case 
in which the algorithm will prod uce a wrong result, fail to ter minate, or execute an illegal  
operation such as an out-of-bound s array access or other precon dition violation.)
E11.8  Invariant violations
The discussion i n this chapter has shown  that a precondition vi olation indicates an error  
in the client, and a postcondition violation indicates an error  in the supplier. Explain why  
an invariant violation also reflects a supplier error.
E11.9  Random number generators
Write a class implementing pseudo -random number generation, bas ed on a sequence  
ni = f (ni-1) where  f  is a given function and the seed n0 will be provided by clients of the  
class. Functions should have no side effects. (Assume f i s  k n o w n ;  y o u  c a n  f i n d  s u c h  
functions in textbooks such as [ Knuth 1981], and in numerical l ibraries.)Page 349 .
“A tolerant mod-
ule”, page 359 .
Page 401 .
Page 381 .
DESIGN BY CONTRACT: BUILDING RELIABLE SOFTWARE  §E11.10 410
E11.10  A queue module
Write a class implementing queues (first-in, first-out policy),  with appropriate assertions,  
in the sty le of the STACK  classes of th is chapter. 
E11.11  A set module
Write a class implementing sets of elements of an arbitrary typ es, with the standard set  
operations (membership test, addition of a new element, union, intersection etc.). Be sure  
to include the proper assertions. Any correct implementation, s uch as linked lists or arrays,  
is acceptable.
POSTSCRIPT: THE ARIANE 5 CRASH
As this book was being printed, t he European Space Agency relea sed the report of the  
international investigation into  the test flight of the Ariane 5 launcher, which crashed on  
June 4, 1996, 40 seconds after l ift-off, at a reported cost of 500 million dolla rs (uninsured).
The cause of the crash: a failure of the on-board computer syst ems. The cause of that  
failure: a conversion from a 64-bit floating-point number (the mission’s “hor izontal bias”)  
to a 16-bit signed integer produ ced an exception because the nu m b e r  w a s  n o t  
representable with 16 bits. Although some other possible except ions were monitored  
(using the Ada mechanisms described in the next chapter) prior analysis had shown that  
this particular one could not occur; so it was decided not to e ncumber the code with an  
extra exception handler.
The real cause: insuff icient specification. The analysis that t he value would always  
fit in 16 bits was in fact correc t — but for the Ariane 4 fligh t trajectory! The code was  
reused for Ariane 5, and the assu mption, although stated in an obscure part of some  
technical document, was simply f orgotten. It did not apply any more to Ariane 5.
With the Design by Contract appro ach, it would have been stated  in a precondition:
require
horizontal_bias <= Maximum_horizontal_bias
naturally prompting the quality assurance team to check all use s of the routine and to detect  
that some could violate the assertion. Although we will never k now, it seems almost certain  
that the mistake would have been caught, probably through stati c analysis, and at worst  
during testing thanks to the asse rtion monitoring mechanisms de scribed in this chapter.
The lesson is clear: reuse without contracts is folly . The “abstracted modules” that  
we have defined as our units of reuse must be equipped with cle ar specifications of their  
operating conditions — preconditi ons, postconditions, invariant s; and these specifications  
must be in the modules themselves , not in external documents. The principles that we have  
learned, particularly Design by C ontract and Self-Documentation , are a required condition  
of any successful reusability policy. Even if your mistakes wou ld cost less than half a  
billion dollars, remember this rule as you go after the great p otential benefits of reuse: to  
be reusable, a module must be specified; and the programming la nguage must support  
assertion mechanisms that will put the specification in the sof tware itself.For a more detailed 
discussion see [M 1997a] .
12  
When the contract is broken: 
exception handling
Like it or not, it is no use pret ending: in spite  of all static precautions, some unexpected  
and undesired event will sooner or later occur while one of you r systems is executing. This  
is known as an excepti on and you must be pre pared to deal with it.
12.1  BASIC CONCEPTS OF EXCEPTION HANDLING
The literature on exception hand ling is often not very precise about what really constitutes  
an exception. One of the consequences is that the exception mec hanisms present in such  
programming languages as PL/I and Ada are often misused: instea d of being reserved for  
truly abnormal cases, they end up serving as inter-routine goto instructions, violating the  
principle of Modular Protection.
Fortunately, the Design by Contr act theory introduced in the pr eceding chapter  
provides a good framework for de fining precisely the concepts i nvolved.
Failures
Informally, an exception is an abnormal event that disrupts the  execution of a system. To  
obtain a more rigorous definitio n, it is useful to concentrate first on a more elementary  
concept, failure, whic h follows dire ctly from the contract idea .
A routine is not just some arbitrary sequence of instructions b ut the implementation  
of a certain specification — the routine’s contract. Any call m ust terminate in a state that  
satisfies the precondition and the class invariant. There is al so an implicit clause in the  
contract: that the routine must not have caused an abnormal ope rating system signal,  
resulting for example from memory exhaustion or arithmetic over flow and interrupting  
the normal flow of control i n the system’s execution.
It must refrain from causing such events , but of course not everything in life is what  
it must be, and we may expect tha t once in a while a routine ca ll will be unable to satisfy  
its contract — triggering an abn ormal signal, producing a final  state that violates the  
postcondition or the invariant, or calling another routine in a  state that does not satisfy that  
routine’s precondition (assumin g run-time assertion monitoring in the last two cases).
WHEN THE CONTRACT IS BROKEN : EXCEPTION HANDLING  §12.1 412
Such a case will b e called a failure.
The discussion will use the phra se “routine fail ure”, or just “ failure”, as an  
abbreviation for “failure of a r outine call”. Of course what su cceeds or fails is not a routine  
(an element of the sof tware text) but one particular call to th at routine at run time.
Exceptions
From the notion of failure we can derive a precise definition o f exceptions. A routine fails  
because of some specific event (a rithmetic overflow, assertion violation …) that interrupts  
its execution. Such an event is an exception.
Often an exception will cause failure of the routine. But you can prevent this from  
occurring by writing the routine so that it will catch the exce ption and try to restore a state  
from which the computation will p roceed. This is the reason why  failure and e xception are  
different concepts: every failure results from an exception, bu t not every exception results  
in failure.
The study of software anomalies in the previous chapter introdu ced the terms fault
(for a harmful execution event), defect  (for an inadequacy of system, which may cause  
faults) and error  (for a mistake in the thinking process, which may lead to defe cts). A  
failure is a fault; an exception is often a fault too, but not if its possible occurrence has  
been anticipated so that the so ftware can recover from the exce ption.
Sources of exceptions
The software development framework introduced so far opens the possibility of specific  
categories of exception , listed at the top of the facing page.
Case E 1 reflects one of the basic requi rements of using references: a call a  f  is only  
meaningful if a is attached to an  object, that is to say n on-void. This was dis cussed in the  
presentation of the dynamic model.
Case E 2 also has to do with void values . Remember that “attachment” co vers 
assignment and argument passing,  which have the same semantics.  W e  s a w  i n  t h e  
discussion of attachment that it is possible to attach a refere nce to an expand ed target, the  
result being to copy the corresp onding object. This assumes tha t the object exists; if the  
source is void, the attachment  will trigger an exception.Definitions: success, failure
A routine call succeeds if it te rminates its execution in a sta te satisfying the  
routine’s contract. It fai ls if it does not succeed.
Definition: exception
An exception is a run-time event  that may cause a routine call to fail.
See “Errors, defects 
and other creeping 
creatures”, page 347 .
“Void references and 
calls”, page 240 .
“Hybrid attach-
ments”, page 263 .
§12.1   BASIC CONCEPTS OF EXCEPTION HANDLING 413
Case E 3 follows from signals that the operating system sends to an app lication when  
it detects an abnormal event, such as a fault in an arithmetic operation (underflow,  
overflow) or an attempt to alloc ate memory when none is availab le.
Case E 4 arises when a routine fails, as a result of an exception that happened during  
its own execution and from which it was not able to recover. Th is will be seen in more  
detail below, but be sure to note  the rule that r esults from ca se E4:
Cases E 5 to E10 can only occur if run -time assertion monitoring has been enabl ed at 
the proper level: at least assertion (require ) for E 5, assertion (loop) for E 8 and E 9 etc.
Case E 11 assumes that the software may include calls to a procedure raise  whose  
sole goal is to raise an excepti on. Such a proce dure will be in troduced later.
Causes of failure
Along with the list of possible exception cases, it is useful f or the record to define when a  
failure  (itself the source of an except ion in the caller, as per case E4) can occur:Definition: exception cases
An exception may occur during the execution of a routine r as a result of any  
of the followi ng situations:
E1 • Attempting a qualified feature call a  f and finding that a is void.
E2 • Attempting to attach a void value to an expanded target.
E3 • Executing an operation that p roduces an abnormal condition d etected  
by the hardware or t he operating system.
E4 • Calling a rou tine that fails.
E5 • Finding that th e precondition of r does not hold on entry.
E6 • Finding that the postcondition of r does not hold on exit.
E7 • Finding that the cl ass invariant does no t hold on entry or e xit.
E8 • Finding that the in variant of a loop does not hold after the  from  clause  
or after an iteration of the loop body.
E9 • Finding that an iteration of a loop’s body does not decrease  the variant.
E10 • Executing a check  instruction and finding that its assertion does not  
hold.
E11 • Executing an instruction mean t explicitly to trigger an exc eption.
Failures and exceptions
A failure of a routine causes an exception  in its caller.
See “Monitoring 
assertions at run 
time”, page 392 .
WHEN THE CONTRACT IS BROKEN : EXCEPTION HANDLING  §12.2 414
The definitions of failure and e xception are mut ually recursive : a failure arises from  
an exception, and one of the pri ncipal sources of  exceptions in  a calling routine (E 4) is the  
failure of a c alled routine.
12.2  HANDLING EXCEPTIONS
We now have a definition of what  may happen — ex ceptions — and of what we would  
prefer not to happen as a result — failure. Let us equip oursel ves with ways to deal with  
exceptions so as to avoid failure. What can a routine do when i ts execution  is suddenly  
interrupted by an unwelcome diversion?
As so often in this presentation, we can get help towards an an swer by looking at  
examples of how not to do things. Here the C mechanism (coming from Unix) and an A da 
textbook will oblige.
How not to do it — a C-Unix example
The first counter-example mechanism (most notably present on Un ix, although it has been  
made available on other platform s running C) is a procedure cal led signal  which you can  
call under the form
signal (signal_code , your_routine )
with the effect of planting a reference to your_routine  into the software, as the routine that  
should be called whenev er a signal of code signal_code occurs. A signal code is one of a  
number of possible integers such as SIGILL  (illegal instruction) and SIGFPE  (floating-
point exception). You may include as many calls to signal  as you like, so as to associate  
different routines with different signals.
Then assume some instruction executed after the call to signal triggers a signal of  
code signal_code . Were it not for the signal  call, this event would immediately terminate  
the execution in an abnormal state. Instead it will cause a cal l to your_routine , which  
presumably performs some corrective action, and then will … resume the execution exactly  
at the point where the exception occurred. This is dangerous, a s you have no guarantee that  
the cause of the trouble has been addressed at all; if the comp utation was interrupted by a  
signal it was probably impossible to complete it starting from its initial state.
What you will need in most cases is a way to correct the situat ion and then restart
the routine in a new, improved initial state. We will see a sim ple mechanism that  
implements this scheme. Note that one can achieve it in C too, on most platforms, by  
combining the signal  facility with two oth er library routines: setjmp  to insert a marker into  
the execution record for possible later return, and longjmp  to return to such a marker, even  
if several calls have be en started since the setjmp . The setjmp -longjmp  mechanism is,  Definition: failure cases
A routine call will fail if and only if an exception occurs dur ing its execution  
and the routine does not r ecover from the exception.We have yet to see 
what it means for a routine to “recover” from an exception .
§12.2   HANDLING EXCEPTIONS 415
however, delicate to use; it can be useful in the target code g enerated by a compiler — and  
can indeed serve, together with signal ,  t o  i m p l e m e n t  t h e  h i g h - l e v e l  O - O  e x c e p t i o n  
mechanism introduced later in th is chapter — but is not fit for  direct consumption by  
human programmers.
How not to do it — an Ada example
Here is a routine taken from an Ada textbook:
sqrt (x: REAL ) return REAL
begin
if x < 0.0 then
raise  Negative
else
normal_square_root_computation
end
exception
when  Negative =>
put ("Negative argument ")
return
when  others  => …
end -- sqrt
T h i s  e x a m p l e  w a s  p r o b a b l y  m e a n t  j u s t  a s  a  s y n t a c t i c a l  i l l u s t r a t ion of the Ada  
mechanism, and was obviously written quickly (for example it fa ils to return a value in the  
exceptional case); so it would be  unfair to criticize it as if it were an earnest example of  
good programming. But it provides  a  us ef ul  po in t  of  re f er en ce  b y clearly showing an  
undesirable way of handling excep tions. Given the intended uses  of Ada — military and  
space systems — one can only hope  that not too many actual Ada programs have taken  
this model verbatim.
The goal is to compute  the real square root of a real number. B ut what if the number  
is negative? Ada has no assertion s, so the routine performs a t est and, if it finds n to be  
negative, raises  an exception.
The Ada instruction raise  Exc interrupts execution of the  current routine, triggering  
an exception of code Exc. Once raised, an exception can be caught, through a routine’s (or 
block’s) exception clause. Such a cla use, of the form
exception
when  code_a1 , code_a2 , …=> Instructions_a ;
when code_b1 , … => Instructions_b ;
…
is able to handl e any exception whose c ode is one of those list ed in the when  subclauses;  
it will execute Instructions_a  for codes code_a1 , code_a2 , … and so on for the others. One  
of the subclauses may, as in the example, start with when  others , and will then handle any  
exception not explicitly named i n the other subclauses. If an e xception occurs but its code  From Sommerville 
and Morrison , “Soft-
ware Development with Ada” , Addison-
Wesley , 1987 . Letter 
case, indentation , 
semicolon usage and 
the name of the float-
ing-point type have been adapted to the 
conventions of the 
present book ; Non_
positive  has been 
changed to Negative .
WHEN THE CONTRACT IS BROKEN : EXCEPTION HANDLING  §12.2 416
is not listed (explicitly or through when  others ), the routine will pass it to its caller; if  
there is no caller, meaning that  the failed routine is the main  program, execut ion terminates  
abnormally.
In the example there is no need to go to the caller since the e xception, just after being  
raised, is caught by the exception  clause of the routine itself, which contains a subclause  
when  Negative => …
But what then do the correspondi ng instructions do? Here they a re again:
put ("Negative argument ")
return
In other words: print out a mess age — a delicate thought, consi dering was happens  
next; and then return to the caller. The caller will not be not ified of the event, and will  
continue its execution  as if nothing had h appened. Thinking aga in of typical applications  
of Ada, we may just wish that ar tillery computations, which can  indeed require square root  
computations, do not follow this  scheme, as it might direct a f ew missiles to the wrong  
soldiers (some of whom may, howe ver, have the consolation of se eing the error message  
shortly before the encounter).
This technique is probably worse than the C-Unix signal  mechanism, which at least  
picks up the computation where it left. A when  subclause that ends with return  does not  
even continue the current routine (assuming there are more inst ructions to execute); it gives  
up and returns to the caller as if everything were fine, althou gh everything is not fine.  
Managers — and, to continue with the military theme, officers —  know this situation well:  
you have assigned a task to someone, and are told the task has been completed — but it has  
not. This leads to some of the worst disasters in human affairs , and in software affairs too.
This counter-example h olds a lesson for Ada programmers: under almost no  
circumstances should a when  s u b c l a u s e  t e r m i n a t e  i t s  e x e c u t i o n  w i t h  a  return . The 
qualification “almost” is here for completeness, to account for  a special case, the false 
alarm , discussed below; but that case is very rare. Ending exception  handling with a  
return  m e a n s  p r e t e n d i n g  t o  t h e  c a l l e r  t h a t  e v e r y t h i n g  i s  r i g h t  w h e n  i t is not. This is  
dangerous and unacceptable. If you  are unable to correct the pr oblem and satisfy the Ada  
routine’s contract, you  should make the routine fail. Ada provi des a simple mechanism to  
do this: in an exception  clause you may execute a raise  instruction written as just
raise
whose effect is to re-raise the original exceptio n to the calle r. This is the proper way of  
terminating an executi on that is not able to fulfill its contra ct.
Ada Exception rule
The execution of any  Ada exception handle r should en d by either  executing  
a raise  instruction or ret rying the enclosin g program unit.
§12.2   HANDLING EXCEPTIONS 417
Exception handling principles
These counter-examples help show  t h e  w a y  t o  a  d i s c i p l i n e d  u s e  o f exceptions. The  
following principle wi ll serve as a basis for the discussion.
Let us do away first with the fa lse alarm case, which correspon ds to the basic C-Unix  
mechanism as we have seen it. Here is an example. Some window s ystems will cause an  
exception if the user of an interactive system resizes a window  while some process is  
executing in it. Assume that suc h a process does not perform an y window output; then the  
exception was harmless. But even in such case there are usually  b e t t e r  w a y s ,  s u c h  a s  
disabling the signals altogether , so that no exception will occ ur. This is how we will deal  
with false alarms in the mec hanism of the next sections.
False alarms are only possible for operating system signals — i n fact, only for signals  
of the more benign kind, since you cannot ignore an arithmetic overflow or an inability to  
allocate requested memory. Excep tions of all the other categori es indicate trouble that  
cannot be ignored. It would be absurd, for example, to proceed with a routine after finding  
that its precondit ion does not hold.
So much for false alarms (unfortunately, since they are the eas iest case to handle).  
For the rest of this discussion we concentrate on true exceptio ns, those which we cannot  
just turn off like an ov ersensitive car alarm.
Retrying  is the most hopeful strategy: we have lost a battle, but we ha ve not lost the  
war. Even though our initial plan  for meeting our contract has been disrupted, we still  
think that we can satisfy our cli ent by trying another tack. If  we succeed, the client will be  
entirely unaffected by the excep tion: after one or more new att empts followin g the initial  
failed one, we will return norma lly, having fulfilled the contr act. (“Mission accomplished,  
Sir. The usual little t roubles along the way, Sir. All fine by now, Sir.”)
What is the “other tack” to be tr ied on the second attempt? It might be a different  
algorithm; or it might be the same algorithm, executed again af ter some chang es have been  
brought to the state of the exec ution (attributes, local entiti es) in the hope of preventing  
the exception from occurring agai n. In some cases, it may even be the original routine tried  
again without any change whatsoe ver; this is applicable if the exception was due to some  Disciplined Exception Handling principle
There are only two legitimate re sponses to an exception that oc curs during  
the execution of a routine:
R1 •Retrying : attempt to change the conditi ons that led to the exception  
and to execute the routi ne again from the start.
R2 •Failure  (also known as organized panic ): clean up the environment,  
terminate the call and repo rt failure to the caller.
In addition, exception s resulting from some  operating system si gnals (case  
E3 of the classification of excepti ons) may in rare cases justify  a false alarm
response: determine that the exc eption is harmless and pick up the routine’s  
execution where it started.The classification of 
exception cases , 
including E3 , is on 
page 413 .
WHEN THE CONTRACT IS BROKEN : EXCEPTION HANDLING  §12.2 418
e x t e r n a l  e v e n t  —  t r a n s ient hardware malfunction, temporarily bu sy device or  
communication line — which we do not control alth ough we expect  it will go away.
With the other response, failure , we accept that we not only have lost the battle (the  
current attempt at executing the routine body) but cannot win t he war (the attempt to  
terminate the call so as to satisfy the contract). So we give u p, but we must first ensure two  
conditions, explaining the use of  “organized panic” as a more v ivid synonym for “failure”:
• Making sure (unlike wh at happened in the sqrt counter-example) that the caller gets  
an exception. This is the panic  aspect: the routine has failed to live up to its contract.
• Restoring a consistent execution state — the organized  aspect.
What is a “consistent” state? Fr om our study of class correctne ss in the previous  
chapter we know the an swer: a state that sa tisfies the invarian t. We saw that in the course  
of its work a routine execution may temporar ily violate the inv ariant, with the  intention of  
restoring it before termination.  But if an exception occurs in an intermediate state the  
invariant may be violated. The routine must restore it before r eturning control to its caller.
The call chain
To discuss the exception handlin g mechanism it will be useful t o have a clear picture of  
the sequence of calls that may l ead to an exception. This is th e notion of call chain, already  
present  in the explanation of the Ada mechanism.
Let r0 be the root creation procedure of a certain system (in Ada r0 would be the main  
program). At any time during the execution, there is a current routine , the routine whose  
execution was started last; it was started by the execution of a certain routine; that routine  
was itself called by a routine; and so on. If we follow this ca lled-to-caller chain all the way  
through we will end up at r0. The reverse chain ( r0, the last routine r1 that it called, the last  
routine r2 that r1 called, and so on down to the cur rent routine) is the call chai n.
If a routine produces a n exception (as pict ured at the bottom-r ight of the figure), it  
may be necessary to go  up the chain until finding a routine tha t is equipped to handle the  
exception — or stop ex ecution if we reach r0, not having found any applicable exception  
handler. This was the case in Ad a when no routine in the call c hain has an exception  clause  
with a when  clause that names t he excepti on type or others .The call chainr0r1
r2
r3
r4Routine call
§12.3   AN EXCEP TION MECHANISM 419
12.3  AN EXCEPTION MECHANISM
From the preceding analysis follows the exception mechanism tha t fits best with the  
object-oriented approach and th e ideas of Design by Contract.
The basic properties will follow  from a simple language additio n — two keywords  
— to the framework of the preced ing chapters. A library class, EXCEPTIONS , will also  
be available for cases in which you need to fine-tune the mecha nism.
Rescue and Retry
First, it must be possible to sp ecify, in the text of a routine , how to deal wi th an exception  
that occurs during one of its calls. We need a new clause for t hat purpose; the most  
appropriate keyword is rescue , indicating that the clause describes how to try to recover  
from an undesirable run- time event. Because the rescue clause describes operations to be  
executed when the routine’s behavior is outside of the standard  case described by the  
precondition ( require ), body ( do) and postcondition ( ensure ), it will appear, when  
present, after all t hese other clauses:
routine
require
precondition
local
… Local entity declarations …
do
body
ensure
postcondition
rescue
rescue_clause
end
The rescue_clause  is a sequence of instructions . Whenever an exception occurs  
during the executi on of the normal body , this execution will stop and the rescue_clause
will be executed instead. There is at most one rescue  clause in a routine, but it can find  
out what the exception was (usin g techniques introduced later),  so that you will be able to  
treat different kinds of excepti on differently if you wish to.
The other new construct is the retry instruction, written just retry . This instruction  
may only appear in a rescue  clause. Its execution consists in re-starting the routine body  
from the beginning. The initiali zations are of course not repea ted.
T h e s e  c o n s t r u c t s  a r e  t h e  d i r e c t  i m p l e m e n t a t i o n  o f  t h e  D i s c i p l i n ed Exception  
Handling principle. The retry  instruction provi des the mechanism for retrying; a rescue
clause that does not execute a retry  leads to failure.
WHEN THE CONTRACT IS BROKEN : EXCEPTION HANDLING  §12.3 420
How to fail without really trying
The last observation i s worth emphasizing:
So if you have wondered how rou tines can fail in practice — cau sing case E 4 of the  
exception classification — this is it.
As a special case, consider a routine which does not have a rescue  clause. In practice  
this will be the case with the v ast majority of routines since the approach to exception  
handling developed here suggests equipping only a select few ro utines with such a clause.
Ignoring possible local entity declarations, arguments, precond ition and postcondition, the  
routine appears as
routine
do
body
end
Then if we consider — as a tempor ary convention — that the abse nce of a rescue
clause is the same thing as an e mpty rescue clause, that is to say
routine
do
body
rescue
-- Nothing here (emp ty instruction list)
end
the Failure principle has an imme diate consequence: if an excep tion occurs in a routine  
without rescue  clause it will cause the routin e to fail, triggering an except ion in its caller.
Treating an absent rescue  clause as if it were present but empty is a good enough  
approximation at this stage of the discussion; but we will need  to refine this rule slightly  
when we start looking at the effect of exceptions on the class invariant.
An exception history table
If a routine fails, eith er because it has no rescue  clause at all o r because its rescue  clause  
executes to the end without a retry , it will interrupt the execution of its caller with a  
“Routine failed” (E 4) exception. The caller is then faced with the same two possibi lities:  
either it has a rescue  c l a u s e  t h a t  c a n  e x e c u t e  a  s u c c e s s f u l  retry and get rid of the  
exception, or it will fail too, p assing the exception one level  up the call chain.Failure principle
Execution of a rescue  clause to its end, not leading to a retry  instruction,  
causes the current r outine call to fail.
See page 413 .
For the exact conven-
tion see “When there is no rescue clause”, 
page 430 .
§12.3   AN EXCEP TION MECHANISM 421
If in the end no routine in the call chain is able to recover f rom the exception, the  
execution as a whole will fail. In such a case the environment should print out a clear  
description of what happened, th e exception hist ory table. Here  is an example:
This is a record not only of the  exceptions that  directly led t o the execution’s failure  
but of all recent except ions, up to a limit of 100 by default, including those from which the  
execution was able to recover through a retry . From top to bottom the order is the reverse  
of the order in which calls were  started; the creation procedur e is on the last line.
The Routine column identifies, for each excep tion, the routine whose call w as 
interrupted by the exception. The Object column identifies the target of that call; here the  
objects have names such as O1, b ut in a real trace they will ha ve internal identifiers, useful  
t o  d e t e r m i n e  w h e t h e r  t w o  o b j e c t s  a r e  t h e  s a m e .  T h e  Class  column gives the object’s  
generating class.
The Nature of exception column indicates what happ ened. This is where, for a  
assertion violation as in the se cond entry from the top, the en vironment can take advantage  
of assertion labels, interval_big_enough  in the example, to identify the precise clause that  
was violated.
The last column indicates how the  exception was handled: Retry or Fail. The table  
consists of a sequence of sections separated by thick lines; ea ch section except the last led  
to a Retry. Since a Retry enable s the execution to restart norm ally, an arbitrary number of  
calls may have occurred between two calls separated by a thick line.
Ignoring any such intermediate c alls — successful and as such u ninteresting for the  
purposes of this discussion — he re is the call and return chain  corresponding to the above  
exception history table. To rec onstruct the action you should f ollow the arrows counter-
clockwise from the call to make at the top left.Object Class Routine Nature of exception Effect
O4 Z_FUNCTION split (from E_FUNCTION ) Feature interpolate : 
Called on void 
reference.Retry
O3 INTERVAL integrate interval_big_enough : 
Precondition violated.Fail
O2 EQUATION solve (from  GENERAL_EQUATION )Routine failure Fail
O2 EQUATION  filter Routine failure Retry
O2 MATH new_matrix (from BASIC_MATH )enough_memory : 
Check violated.Fail
O1 
(root)INTERF ACE make Routine failure FailAn exception 
history table
WHEN THE CONTRACT IS BROKEN : EXCEPTION HANDLING  §12.4 422
12.4  EXCEPT ION HANDLING  EXAMPLES
We now have the basic mechanism. Let us see how to apply it to common situations.
Fragile input
Assume that in an interactive system you need to prompt your sy stem’s user to enter an  
integer. Assume further that the  only procedure at your disposa l to read the integer,  
read_one_integer , leaving its result  in the attribute last_integer_read , is not robust: if  
provided with something else than  integer input, it may fail, p roducing an exception. Of  
course you do not want your own system to fail in that case, bu t since you have no  
control over read_one_integer  y o u  m u s t  u s e  i t  a s  i t  i s  a n d  t r y  t o  r e c o v e r  f r o m  t h e  
exception if it occurs. Her e is a possible scheme:
get_integer
-- Get integer from user a nd make it available in last_integer_read .
-- If input initially incorrect , ask again as many times as nec essary.
do
print ("Please enter an integer : ")
read_one_integer
rescue
retry
end
This version of the routine illust rates the retry strategy: we just keep retrying.
An obvious criticism is that if a  user keeps on entering incorr ect input, the routine  
will forever keep asking for a va lue. This is not a very good s olution. We might put an  
upper bound, say five, on the nu mber of attempts. Here is the r evised version:make
new_matrix
filter
solve
integrate
split Call Normal return
Failure return Retry (one or more times)A failed  
execution
§12.4   EXCEPTION HANDLING EXAMPLES 423
Maximum_attempts : INTEGER = 5
-- Number of attempts before g iving up getting an integer.
get_integer
-- Attempt to read integer in at most Maximum_attempts  attempts.
-- Set value of integer_was_read  to record wheth er successful.
-- If successful, make integer available in last_integer_read .
local
attempts : INTEGER
do
if attempts < Maximum_attempts then
print ("Please enter an integer : ")
read_one_integer
integer_was_read := True
else
integer_was_read := False
attempts := attempts + 1
end
rescue
retry
end
This assumes that the enclosing class has a boolean attribute integer_was_read  
which will record how the opera tion went. Caller s should use th e routine as follows to try  
to read an integer and assign it to an integer entity n:
get_integer
if integer_was_read  then
n := last_integer_read
else
“Deal with case in which it was impossible to obtain an integer ”
end
Recovering from hardware or operating system exceptions
Among the events that trigger ex ceptions are signals sent by th e operating system, some  
of which may have originated with the hardware. Examples includ e: arithmetic overflow  
and underflow; impossi ble I/O operations; “illegal instruction”  attempts (which, with a  
good object-oriented l anguage, will come not  from the O-O softw are but from companion  
routines, written in lower-level  languages, which may overwrite  certain areas of memory);  
creation or clone operations that fail because no memory is ava ilable; user i nterrupts (a  
user hitting the “brea k” key or equivalent during execution).
T h e o r e t i c a l l y  y o u  m a y  v i e w  s u c h  c o n d i t i o n s  a s  a s s e r t i o n  v i o l a t i ons. If a + b
provokes overflow, it means that  the call has no t observed the implicit precondition on the  
+ function for integer or real nu m b e r s ,  s t a t i n g  t h a t  t h e  m a t h e m a tical sum of the two  
WHEN THE CONTRACT IS BROKEN : EXCEPTION HANDLING  §12.4 424
arguments should be representable  on the computer. A similar im plicit precondition on the  
allocation of a new object (creat ion or clone) is that enough m emory is available; if a write  
fails, it is because the environment — files, devices, users — did not meet the applicability  
conditions. But in such cases it  is impractical or impossible t o express the assertions, let  
alone check them: the only solut ion is to attempt the operation  and, if the hardware or  
operating system signa ls an abnormal conditi on, to treat it as an exception.
Consider the problem of writing a function quasi_inverse  which for any real number  
x must return either its inverse  or, if that is impossib le to compute because x is too small,  
the value 0. This type of proble m is essentially impossible to solve without an exception  
mechanism: the only practical way to know whether x has a representable inverse is to  
attempt the division ; but if this provokes  overflow and you can not handle exception s, 
the program will crash and it will  be too late to return 0 as a  result.
On some platforms it may be possible to write a function invertible  such that invertible  (x)
is true if and only if the inverse of x can be computed. You can then use invertible  to write  
quasi_inverse . But this is usually not a practical solution since such a fun ction will not be  
portable across platforms, and in time-sensitive numerical comp utations will cause a  
serious performance overhead, a call to invertible  being at least as expensive as the  
inversion itself.
With the rescue -retry  mechanism you can easily so lve the problem, at least on  
hardware that triggers a signa l for arithmetic underflow:
quasi_inverse (x: REAL ): REAL
-- 1/x if possible, otherwise 0
local
division_tried : BOOLEAN
do
if not division_tried then
Result := 1/x
end
rescue
division_tried := True
retry
end
The initialization rules set division_tried  to false at the start of each call. The body  
does not need any else clause because these rules also initialize Result  to 0.
Retrying for software fault tolerance
Assume you have written a text editor and (shame on you) you ar e not quite sure it is  
entirely bug-free, but you alread y want to get some initial use r feedback. Your guinea pigs  
are willing to tolerate a system  with some remaining errors; th ey might accept for example  
that once in a while it will be unable to carry out a command t hat they have requested; but  1
x---
1
x---
§12.4   EXCEPTION HANDLING EXAMPLES 425
they will not use it to enter se rious texts (which is what you want them to do, to test your  
editor under realistic conditions) if they fear that a failure may result in a catastrophe, such  
as brutal exit and loss of the last half-hour’s work. With the Retrying mechanism you can  
provide a defense ag ainst such behavior.
Assume that the editor, as will usually be the case, contains a  b a s i c  c o m m a n d  
execution loop of the form
from … until exit loop
execute_one_command
end
where the body of routine execute_one_command  is of the form
“Decode user request”
“Execute appropria te command in resp onse to request”
The “Execute …” instruction chooses among a set of available routines (for  
example delete a line, change a w o r d  e t c . )  W e  w i l l  s e e  i n  a  l a t er chapter how the  
techniques of inheritance and d ynamic binding yield simple, ele gant structures for such  
multi-way decisions.
The assumption is that the diffe rent routines are not entirely safe; some of them may  
fail at unpredictable times. You  can provide a primitive but ef fective protec tion against  
such an event by writing the routine as
execute_one_command
-- Get a request from th e user and, if possible,
-- execute the cor responding command.
do
“Decode use r request”
“Execute appropriate command  in response to request”
rescue
message ("Sorry , this command failed ")
message ("Please try another command ")
message ("Please report this failure to the author ")
“Instructions to patch up the state of the editor”
retry
end
This scheme assumes in practice that the types of supported user request  include  
“save current state of my work” and “quit”, both of which had b etter work correctly. A  
user who sees the message Sorry , this command failed  will most likely want to save the  
results of the current  session and get out a s quickly as possib le.
Some of the routines implementin g individual operations may hav e their own rescue
clauses, leading to failure (so that the above rescue  clause of execute_one_command  takes 
over) but only after printing a m ore informative, command-speci fic message.Chapter 21 .
WHEN THE CONTRACT IS BROKEN : EXCEPTION HANDLING  §12.4 426
N-version programming
Another example of retrying for software fault tolerance is an implementation of the “N-
version programming” approach to improving software reliability .
N-version programming was inspir ed by redundancy techniques tha t have proved  
their usefulness in ha rdware. In mission-critical setups it is frequent to encounter  
redundant hardware configurations , where several devices — for example computers —  
perform an identical function, a nd an arbitrating mechanism com pares the results,  
deciding for the major ity in case of discrepancy. This approach  guards against single-
component failures and is common in aerospace applications. (In  a famous incident, an  
early space shuttle launch had to be delayed because of a bug i n the software for the  
arbitrating  computer itself.) N-version programming transposes this approa ch to software  
by suggesting that for a mission -critical development two or mo re teams, working in  
environments as distinct as poss ible, should produce alternativ e systems, in the hope that  
errors, if any, will be different.
This is a controversial idea; on e may argue that the money woul d be better spent in  
improving the correctness and r obustness of a single version th an in financing two or more  
imperfect implementations. Let u s, however, ignore these object ions and refrain from any  
judgment on the idea itself, but see how the retry  mechanism would support the idea of  
using several implementations wh ere one takes over if the other s fail:
do_task
-- Solve a problem by applying one of several possible implemen tations.
require
…
local
attempts : INTEGER
do
if attempts = 0 then
implementation_1
elseif  attempts = 1 then
implementation_2
end
ensure
…
rescue
attempts := attempts + 1
if attempts < 2 then
“Perhaps some instructions  to reset to s table state”
retry
end
end
The generalization to more than two alternative implementations  is immediate.See A . Avizienis , “The 
N-Version Approach to Fault-Tolerant Soft-ware” , IEEE Trans . on 
Soft. Eng., SE-11 , 12, 
Dec. 1985 , pp. 1491-
1501 .
§12.5   THE TASK OF A RESCUE CLAUSE 427
This example is typical of the use of retry . The rescue clause never  attempts to reach  
the original goal using a substitute implementation; reaching t his goal, as expressed by the  
postcondition if there is one, i s the privilege of the normal b ody. Note that after two  
attempts (or n in the general case) the ro utine simply executes its rescue  clause to the end  
and so fails.
Let us look more closely at what  happens when an exception is t riggered during the  
execution of r. The normal execution  (the body) stops; the  rescue clause is e xecuted  
instead. Then two cases may occur:
• The rescue clause may execute a retry , usually after some other instructions. In this  
case, execution of the routine wi ll start anew. This new attemp t may succeed; then  
the routine will termi nate normally and retu rn to its client. T he call is a success; the  
contract has been fulfilled. Ex ecution of the client is not aff ected, except of course  
that the call may have taken lon ger than normal. If, however, t he retry attempt again  
causes an exception, the process  of executing the rescue clause  will start anew. 
• If the rescue clause does not execute a retry , it will continue to its end. (This happens  
in the last example when attempts >= 2.) In this case the rout ine fails: it returns  
control to its caller, signaling an exception. Because the call er gets an exception, the  
same rule determin es how its own ex ecution continues.
This mechanism strictly adheres t o the Disciplined Exception Ha ndling principle:  
either a routine succee d s ,  t h a t  i s  t o  s a y  i t s  b o d y  e x e c u t e s  t o  the end and satisfies the  
postcondition, or it fails. When interrupted by an exception, y ou may either report failure  
or try your normal body again; in  no way can you exit through t he rescue clause and  
pretend to your caller that you succeeded.
12.5  THE TASK OF A RESCUE CLAUSE
The last comments get us started towards a better understanding  of the exception  
mechanism by suggesting the theo retical role of rescue clauses.  Some formal reasoning  
will help us obtain th e complete picture.
The correctness of a rescue clause
The formal definition of class co rrectness stated two requireme nts on the features of a  
class. One (C 1) requires creation pr ocedures to start things off properly. Th e other (C 2),  
more directly relevant for the p resent discussion, states that to satisfy its contract, every  
routine, started with its precondition and the class invariant both satisfied, must preserve  
the invariant and ensure its pos tcondition. This was illustrate d by the diagram depicting  
the typical object lifecycle:See“WHEN IS A 
CLASS COR-
RECT?”, 11.9, page 
369.
WHEN THE CONTRACT IS BROKEN : EXCEPTION HANDLING  §12.5 428
The formal rule read:
where prer is the precondition, INV the class invariant, Bodyr the body of the routine, and  
postr the postcondition. To keep thing s simple let us ignore the arg uments xr.
Let Rescuer be the rescue clause of a routin e, ignoring any branch that lea ds to a  
retry — that is to say keeping only those branches that will result i n failure if executed.  
Rule C 2 is a specificat ion of the body Bodyr of the routine, in terms of what initial states  
it assumes and what final states it can guarantee. Can we obtai n a similar specification for  
RESCUEr ? It should be of the form
{ ? }  Rescuer  { ? }
with the question marks replaced by actual assertions. (Here it  is useful to try answering  
the question for yourself before  reading on: how would you fill  in the question marks?)
C o n s i d e r  f i r s t  t h e  i n p u t  a s s e r t i o n  —  t h e  q u e s t i o n  m a r k  o n  t h e  l eft of Rescuer . 
Anything  non-trivial that we write there would be wrong! Remember the d iscussion of  
attractive job offers: for wh oever implements the task A in {P} A {Q}, the stronger the  
precondition P, the easier the job, since a pr econdition restricts the set of  input cases that  
you must handle. Any precondition for Rescuer would make the job easier by restricting  
the set of states in which Rescuer may be called to action. But  we may not assume any such  
restriction since exceptions, by their very nature, may happen at any time. If we knew when  
an exception will happen, it probably would not be an exception  any more. Think of  
hardware failures: we have no clue as to when a computer can st art to malfunction. Nor do  
we know, in an interactive system , when a user will feel like h itting the “break” key.
So the only P assertion that we can afford here (to replace the question mark  on the  
left) is the one that as serts nothing at all: True, the assertion that all states satisfy.
For a lazy Rescuer implementor — again in reference to the discussion of job offe rs 
in the previous chapter — this i s bad news; in fact the precond ition True is always the  
worst possible n ews for a supplier, the c ase in which “the cust omer is always right”!C2 • For every exported routine r and any set of valid arguments xr:
{prer (xr ) and INV}  Bodyr  {postr (xr) and INV} create  a  make (…)
S1
S2
S3
S4a  f (…)
a  g (…)
a  f (…)The life of an 
object
(Original page 365 .)
This rule appeared 
on page 370 .
See “Weak and 
strong conditions”, 
page 335 .
§12.5   THE TASK OF A RESCUE CLAUSE 429
What about the out put assertion (the Q)? As discussed earlier, a rescue clause that  
leads to a failure must, before returning contro l to its caller  with an exception, restore a  
stable state. This means reestablishing the invariant.
Hence the rule that we seek , with no more question marks:
Similar reasoning yiel ds the corresponding rule for any branch Retryr of the rescue  
clause leading to a retry instruction:
A clear separation of roles
It is interesting to contrast th e formal roles of the body and the rescue clause:
C2 • {prer and INV}  Bodyr  {postr (xr) INV}
C3 •  {True}  Rescuer  {INV}
The input assertio n is stronger for Bodyr : whereas the rescue c lause is not permitted  
to assume anything at all, the r outine’s body may assume the pr econdition and the  
invariant. This makes its job easier.
The output assertion, howev er, is also stronger for Bodyr : whereas the rescue clause  
is only required to restore the invariant, the normal execution  must also ensure the  
postcondition — the official job of the routine. This makes its  job harder.
These rules reflect the separation of roles between the body (t he do clause) and the  
rescue clause. The task of the b ody is to ensure the routine’s contract; not directly to handle  
exceptions. The task of the resc ue clause is to handle exceptio ns, returning control to the  
body or (in the failur e case) to the caller;  not to ensure the contract.
As an analogy — part of this boo k’s constant eff ort to provide readers not just with  
theoretically attractiv e concepts but also with practical skill s that they can apply to the  
pursuit of their careers — consi der the difficu lty of choosing between two noble  
professions: cook  and firefighter . Each has its grandeur , but each has its servitudes. A  
gratifying quality of the cook's job is that he may assume, whe n he shows up at work in  
the morning, that the restaurant  is not burning (satisfies the invariant); presumably his  
contract does not specify any coo king obligation under burning circumstances. But with a  
non-burning initial st ate the cook must prepare meals (ensure t he postcondition); it is also  
a component of his contract, alt hough perhaps an implicit one, that throughout this  
endeavor he should maintain the invariant, if he  can, by not se tting the restaurant on fire.Correctness rule for failure-inducing rescue clauses
C3 •          {True}  Rescuer  {INV}
Correctness rule for retry-inducing rescue clauses
C4 •          {True}  Retryr  {INV and prer}
WHEN THE CONTRACT IS BROKEN : EXCEPTION HANDLING  §12.5 430
The firefighter, for his part, m ay assume nothing as to the sta te in which he finds the  
restaurant when he is called for help at any time of day or nig ht. There is not even any  
guarantee that the restaurant is  indeed burning — no preconditi on of the form is_burning , 
or of any other form save for True — since any call may be a false alarm. In some cases,  
of course, the restaurant will be burning. But then a firefight er’s only duty is to return it to  
a non-burning state; his job desc ription does not require that he also serve a meal to the  
assembly of patientl y waiting customers.
When there is no rescue clause
Having formalized the role of res cue clauses we can take a seco nd look at what happens  
when an exceptio n occurs in a routine th at has no such clause. The rule introduced earlier  
— with a warning that it would h ave to be revised — stated that  an absent rescue clause  
was equivalent to a present but empty one ( rescue end ) .  I n li g ht  o f o ur  fo rm a l  r u le s,  
however, this is not always appropriate. C 3 requires that
{True}  Rescuer  {INV}
If  Rescuer  is an empty instruction and the invariant INV is anything other than True, 
this will not hold.
Hence the exact rule. The class ANY — mother of all classes — includes a procedure
default_rescue
-- Handle exception i f no Rescue clause.
-- (Default: do nothing)
do
end
A routine that does not have a R escue clause is considered to h ave one that, rather  
than being empty as first suggested, has the form
rescue
default_rescue
Every class can redefine default_rescue  (using the feature re definition mechanism  
studied as part of inheritance in a later chapter) to perform s ome specific action, instead  
of the default empty  effect defined in GENERAL .
Rule C 3 indicates the constraint on any such action: starting in any s tate, it must  
restore the class invariant INV. Now you will certainly reme mber that pro ducing a state  
that satisfies the invariant w as also the role of the creation procedures  of a class, as  
expressed by the rule labeled C 1. In many cases, you will be ab le to write the redefinition  
of default_rescue  so that it relies on a creation procedure.We will study ANY, 
whose features are 
present in all classes , 
in “THE GLOBAL INHERITANCE 
STRUCTURE”, 
16.2, page 580 .
See “The role of cre-
ation procedures”, page 371 . Rule C1 
was on page 370 .
§12.6   ADV ANCED EXCEPTION HANDLING 431
12.6  ADV ANCED EXCEPTION HANDLING
The extremely simple mechanism de veloped so far handles most of  t h e  n e e d s  f o r  
exception handling. But  certain applications may require a bit of fine-tuning:
• You may need to find out the nature of the latest exception, s o as to handle different  
exceptions differently.
• You may want to specify that certain signals should not trigge r an exception.
• You may decide to trigg er an exception yourself.
We could extend the language mech anism accordingly, but this do es not seem the  
right approach, for at least thr ee reasons: the facilities are needed only occasionally, so that  
we would be needlessly burdening  the language; some of them (in  particular anything that  
has to do with signals) may be p latform-dependent, whereas a la nguage definition should  
be portable; and when you select a set of these facilities it i s hard to be sur e that you will  
not at some later time think of other useful ones, which would then force a  new language  
modification — not a pleasant prospect.
For such a situation we should tu rn not to the language but to the supporting library.  
W e  i n t r o d u c e  a  l i b r a r y  c l a s s  EXCEPTIONS , which provides the necessary fine-tuning  
capabilities. Classes that need these capabilities will inherit  EXCEPTIONS , using the  
inheritance mechanism detailed i n later chapters. (Some develop ers may prefer to use the  
client relation rather than inheritance.)
Exception queries
Class EXCEPTIONS provides a number of queries for  obtaining some information abo ut 
the last exception. You can find out the integer code of that e xception:
exception : INTEGER
-- Code of last excep tion that occurred
original_exception : INTEGER
-- Original code of la st exception that trig gered current excep tion
The difference between exception  and original_exception  is significant in the case  
of an “organized panic” response: if a routine gets an exceptio n of code oc (indicating for  
example an arithmetic overflow) b ut has no rescue clause, its c aller will get an exception  
whose own code, given by the value of exception , indicates “failure of a called routine”.  
It may be useful at that stage, or higher up in the call chain,  to know what the original cause  
was. This is the role of original_exception .
The exception codes are integers.  Values for the predefined exc eptions are given by  
integer constants provided by EXCEPTIONS  (which inherits them  from another class  
EXCEPTION_CONSTANTS ). Here are some examples:
WHEN THE CONTRACT IS BROKEN : EXCEPTION HANDLING  §12.6 432
Check_instruction : INTEGER = 7
-- Exception code f or violated check
Class_invariant : INTEGER =…
-- Exception code for vio lated class invariant
Incorrect_inspect_value : INTEGER = …
-- Exception code for inspe ct value which is not one
-- of the inspect c onstants, if there is no Else_part
Loop_invariant : INTEGER = …
-- Exception code for v iolated loop invariant
Loop_variant : INTEGER = …
-- Exception code for non -decreased loop variant
No_more_memory : INTEGER = …
-- Exception code  for failed memo ry allocation
Postcondition : INTEGER = …
-- Exception code for v iolated postcondition
Precondition : INTEGER =…
-- Exception code for v iolated precondition
Routine_failure : INTEGER = …
-- Exception code f or failed routine
Void_assigne d_to_expanded : INTEGER …
Since the integer valu es themselves are irrelevant, only the fi rst one has been shown.
A few other self-expla natory queries provide further informatio n if needed:
meaning (except : INTEGER )
-- A message in English describing the nature of exceptions
-- of code except
is_assertion_violation : BOOLEAN
-- Is last exception originally  due to a violated assertion
-- or non-decreasing variant?
ensure
Result = (exception = Precondition ) or (exception = Postcondition ) or
(exception = Class_invariant ) or
(exception = Loop_invariant ) or (exception = Loop_variant )
is_system_exception : BOOLEAN
-- Is last exception originally d ue to external event (operatin g system error)?
is_signal : BOOLEAN
-- Is last exception originally d ue to an operating system sign al?
tag_name : STRING
-- Tag of last viola ted assertion clause
original_tag_name : STRING
-- Assertion tag for original for m of last asserti on violation.
§12.6   ADV ANCED EXCEPTION HANDLING 433
recipient_name : STRING
-- Name of routine whose execution  was interrupted by last exce ption
class_name : STRING
-- Name of class including r ecipient of la st exception
original_recipient_name : STRING
-- Name of routine whose ex ecution was interrupted by
-- original form of last exception
original_class_name : STRING
-- Name of class including recipient of original form of last e xception
W i t h  t h e s e  f e a t u r e s  a  r e s c u e  c l a use can handle d ifferent kinds of exception in  
different ways. For example you can write it, in a class inheri ting from EXCEPTIONS , as
rescue
if is_assertion_violation  then
“Process assertion violation case”
else if is_signal then
“Process signal case”
else
…
end
or, with an even finer grain of control, as
rescue
if exception = Incorrect_inspect_value then
“Process assertion violation case”
else if exception = Routine_Failure then
“Process signal case”
else
…
end
Using class EXCEPTIONS , we can modify the quasi_inverse example so that it will  
only attempt the retry  if the exception wa s overflow. Other ex ceptions, such as one  
generated when the interactive u ser presses the Break key, will  not cause the retry . The  
instruction in the res cue clause becomes:
if exception = Numerical_error  then
division_tried := True ; retry
end
Since there is no else clause, exceptions other than Numerical_error  will result in  
failure, the correct consequence since the routine has no provi sion for recovery in such  
cases. When writing a rescue clause specifically to process a c ertain kind of possible  
exception, you may use this styl e to avoid lumpi ng other, unexp ected kinds with it.quasi_inverse  was on 
page 424 .
WHEN THE CONTRACT IS BROKEN : EXCEPTION HANDLING  §12.6 434
How fine a degree of control?
One may express reservations about going to the level of specif ic exception handling  
illustrated by the last two extracts. This chapter has develope d a view of exceptions as  
undesired events; when one happens, the reaction of the softwar e and its developer is “I  
don’t want to be here!  Get me out as soon as  possible!”. This s eems incompatible with  
exerting fine control, depending  on the exception’s source, ove r what happens in a  
rescue clause.
For that reason, I tend in my ow n work to avoid using detailed case analysis on  
exception sources, and stick to e xception clauses that try to f ix things if they can, and then  
fail or retry.
This style is perhaps too auster e, and some deve lopers prefer a  less restricted  
exception handling scheme that ma kes full use of the query mech anisms of class  
EXCEPTIONS while remaining disciplined. If you want to use such a scheme y ou will  
find in EXCEPTIONS  all that you need. But do not lo se sight of the following prin ciple, a  
consequence of the discussion in the rest of this chapter:
Developer exceptions
All the exceptions stu died so far resulted from events caused b y agents external to the  
software (such as operating syst em signals) or from involuntary  consequences of the  
software’s action (as with asser tion violations). It may be use ful in some applications to  
cause an exception to  happen on purpose.
Such an exception is called a de veloper exception and is charac terized by an integer  
code (separate from the general exception code, which is the sa me for all developer  
exceptions) and an associated st ring name, which may be used fo r example in error  
messages. You can use the follow ing features to raise a develop er exception, and to  
analyze its properties in a rescue clause:
trigger (code : INTEGER ; message : STRING )
-- Interrupt execution of curr ent routine with exception
-- of code  code  and associated text message .
developer_exception_code : INTEGER
-- Code of last dev eloper exception
developer_exception_name : STRING
-- Name associate d with last developer exceptionException Simplicity principle
All processing done in a rescue clause should remain simple, an d focused on 
the sole goal of bringing the re cipient object back to a stable  state, permitting 
a retry if possible.
§12.7   DISCUSSION 435
is_developer_exception : BOOLEAN
-- Was last exception originally  due to a developer exception?
is_developer_exception_of_name (name : STRING ): BOOLEAN
-- Is the last exc eption originally due to a developer
-- exception of name  name ?
ensure
Result := is_developer_exception and then
equal (name , developer_exception_name )
It is sometimes useful to associ ate with a developer exception a context  — any object  
structure that may be useful to the software element handling t he exception:
set_developer_exc eption_context (c: ANY )
-- Define c as the context associated with subsequen t developer
-- exceptions (as caused by calls to trigger ).
require
context_exists : c /= Void
developer_exception_context : ANY
-- Context set by  last call to set_developer_ex ception_context
-- void if no such call.
These facilities enable a style of development t hat heavily rel ies on some software  
elements triggering exceptions tha t others will process. In one  compiler that I have seen,  
the developers took advantage of this mechanism, in the parsing  algorithm, to stick to a  
relatively linear control struct ure, recognizing the various el ements of the input text one  
after the other. Such sequential treatment is only possible if the elements parsed are the  
expected ones; any syntactical e rror disrupts the process. Rath er than complicating the  
control structure by ad ding possibly nested if … then  … else constructs, th e developers  
chose to raise a developer exception whenever encountering an e rror, then dealt with it  
separately in the calling routine. As hinted earlier, this is n ot my favorite style, but there  
is nothing inherently wrong with it, so the developer exception  mechanisms are there for  
those who want them.
12.7  DISCUSSION
We have now completed the design  of an exception mechanism for object-oriented  
software construction, compatibl e with the rest of the approach  and resulting directly from  
the ideas of Design by Contract d eveloped in the preceding chap ter. Thanks in particular  
to the retry  instructions the mechanism is mo re powerful than what you will find in many  
languages; at the same time it may appear stricter because of i ts emphasis on retaining the  
ability to reason precisely about the effect of each routine.
Let us explore a few alternative design ideas that could have b een followed, and why  
they were not retained.
WHEN THE CONTRACT IS BROKEN : EXCEPTION HANDLING  §12.7 436
Disciplined exceptions
Exceptions, as they have been pr esented, are a technique to dea l with erroneous conditions  
that may be arise at run time: assertion violations, hardware s ignals, attempts to access  
void references.
The approach we have explored is  based on the contracting metap h o r :  u n d e r  n o  
circumstances should a routine pr etend it has succeeded when in  fact it has failed to  
achieve its purpose. A routine ma y only succeed ( perhaps after experiencing some  
exceptions but recovering from  them through one or more retry , unbeknownst to the  
client) or fail.
Exceptions in Ada, CLU or PL/I do  not follow this model. Using the Ada model, and  
instruction
raise  exc
cancels the routine that executed  it and returns control to its  caller, which may handle the  
exception exc in a special handler clause or,  if it has no such handler, wil l itself return  
control to its caller. But there is no rule as to what a handle r may do. Hence it is perfectly  
possible to ignore an exception,  or to return an alternate resu lt. This explains why some  
developers use this exception mechanism simply to deal with cas es other than the easiest  
one for an algorithm. Such applic ations of except ions really us e raise  as a goto instruction,  
and a fairly dangerous one since  it crosses routine boundaries.  In my opinion, they are  
abuses of the mechanism.
T h e r e  h a v e  t r a d i t i o n a l l y  b e e n  t w o  v i e w p o i n t s  o n  e x c e p t i o n s :  m a n y practicing  
programmers, knowing how  e s s e n t i a l  i t  i s  t o  r e t a i n  c o n t r o l  a t  r un time whenever an  
abnormal condition is detected ( whether due to a programming er ror or to an  
unforeseeable hardware event, sa y numerical overflow or hardwar e failure), consider  
them an indispensable facility. Computing scient ists preoccupie d with correctness and  
systematic software construction  have often for their part view e d  e x c e p t i o n s  w i t h  
s u s p i c i o n ,  a s  a n  u n c l e a n  f a c i l i t y used to circumvent the standa rd rules on control  
structures. The mechanism develo ped above will, it is hoped, ap peal to both sides.
Should exceptions be objects?
An object-oriented zealot (and w ho, having discov ered and maste red the beauty of the  
approach, does not at times risk succumbing to zeal?) may criti cize the mechanism  
presented in this chapter for no t treating exceptions as first- class citizens o f our software  
society. Why is an exception not an object?
One recent language, t he object-oriented extension of Pascal fo r Borland’s Delphi  
environment has indeed  taken the attitude t hat exceptions shoul d be treated as objects.
It is not clear that such a solution would bring any benefit. T he reasoning is in part a  
preview of the more general disc ussion that will  help us, in a later chapter, tackle the  
q u e s t i o n  “ h o w  d o  w e  f i n d  t h e  o b j e c t s  a n d  c l a s s e s ? ”  A n  o b j e c t  i s  an instance of an  
abstractly defined data type, ch aracterized by features. An exc eption has some features, of  “No-command 
classes”, page 729 . 
See exercise E12.2, 
page 438 .
§12.8   KEY CONCEPTS INTRODUCED IN THIS CHAPTER 437
course, which we saw in class EXCEPTIONS : its type, which was given by an integer  
code; whether it is a signal, an  assertion viola tion, a develop er exception; its associated  
message if it is a developer exception. But these features are queries ; in most classes  
describing true “objects” there should also be commands changing the objects’ state.  
Although one migh t conceive of commands ap plicable to exception  objects, for example  
t o  d i s a r m  a n  e x c e p t i o n  a f t e r  i t  has occurred, th i s  s e e m s  i n c o m p atible with reliability  
requirements. Exception s are not under the control of the softw are system; they are  
triggered by event s beyond its reach.
Making their properties accessibl e through the simple queries a nd commands of the  
class EXCEPTIONS  seems enough to satisfy the needs of developers who want fine- grain 
access to the exception handling mechanism.
The methodological perspective
A final note and preview. Except ion handling is not the only an swer to the general problem  
of robustness  —  h o w  t o  d e a l  w i t h  s p e c i a l  o r  u n d e s i r e d  c a s e s .  W e  h a v e  g a i n e d  a few 
methodological insights, but a mo re complete answer will appear  in the chapter discussing  
the design of module interfaces,  allowing us to understand the place of exception handling  
in the broader arsenal of robus tness-enhancing techniques.
12.8  KEY CONCEPTS INTR ODUCED IN THIS CHAPTER
• Exception handling is  a mechanism for dealing with unexpected run-time conditions.
• A failure is the impossibility , for a routine execution, to fu lfill the contract.
• A routine gets an exception as a  result of the failure of a ro utine which it has called,  
of an assertion violation, of an abnormal condition signaled by  the hardware or  
operating system.
• It is also possible for a softwa re system to trigger a “develo per exception ” explicitly.
• A  r ou ti n e w i l l d ea l w it h a n e xc ep ti on  by  ei t he r R e t ry  or  O r g an ized Panic. Retry  
reexecutes the body; Organized Pa nic causes a routine failure a nd sends an exception  
to the caller.
• The formal role of an excepti on handler not ending with a retry  is to restore the  
invariant — not to ensure the rou tine’s contract, as that is th e task of the body (the  
do clause). The formal role  of a branch ending with retry  is to restore the invariant  
and the precondition s o that the routine body can try again to achieve its contract.
• The basic language mechanism for handling exceptions should re main simple, if  
only to encourage stra ightforward exception  handling — organize d panic or  
retrying. For applications that ne ed finer control over excepti ons, their properties and  
their processing, a library class called EXCEPTIONS is available; it provides a  
number of mechanisms for disting uishing between exception types , as well as for  
triggering developer- defined exceptions.“DEALING WITH 
ABNORMAL 
CASES”, 23.6, page 
797.
WHEN THE CONTRACT IS BROKEN : EXCEPTION HANDLING  §12.9 438
12.9  BIBLIOGRAPHICAL NOTES
[Liskov 1979]  and [Cristian 1985]  offer other viewpoints on e xceptions. Much of the work  
on software fault tolerance deri ves from the notion of “recover y block” [Randell 1975] ; a 
recovery block for a task is used when the original algorithm f or the task fails to succeed.  
This is different from rescue clauses which never by themselves  attempt to achieve the  
original goal, although they may restart the execution after pa tching up the environment.
[Hoare 1981]  contains a critiq ue of the Ada exce ption mechanism.
The approach to exception handling developed in this chapter wa s first presented  
in [M 1988e]  and [M 1988] .
EXERCISES
E12.1  Largest integer
Assume a machine that generates a n exception when an integer ad dition overflows. Using  
exception handling, wri te a reasonably efficient function that will return the largest  
positive integer representable on the machine.
E12.2  Exception objects
Notwithstanding the skeptical co mments expressed in the discuss ion section as to the  
usefulness of treating  exceptions as objects, press the idea fu rther and discuss what a class  
EXCEPTION  would look like, assuming an in stance of that class denotes an  exception that  
has occurred during execution. ( Do not confuse this class with EXCEPTIONS , the class,  
meant to be used through inherita nce, which provides general ex ception properties.) Try  
in particular to include c ommands as well as queries.
13  
Supporting mechanisms
Except for one crucial set of mec hanisms, we have now seen the b asic techniques of  
object-oriented software construc tion. The major m issing piece is inheritance and all that  
goes with it. Before moving to t hat last componen t of the appro ach, we should review a  
few mechanisms that will be impor tant to the writing of actual systems: exter nal routines  
and the encapsulation of non-O-O software; argument passing; co ntrol structures;  
expressions; string manipu lation; input and output.
These are technical aspects, not essential to the understanding  of the method; but we  
w i l l  n e e d  t h e m  f o r  s o m e  l a t e r  e x a m p l e s ,  a n d  t h e y  b l e n d  w e l l  w i t h the fundamental  
concepts. So even on your first r eading you shoul d spend some t ime getting at least  
generally famili ar with them.
13.1  INTERFACING WITH NON-O-O SOFTWARE
So far, we have expressed software elements entirely in the obj ect-oriented notation. But  
the software field grew up long b efore object technology became  popular, and you will  
often need to interface your soft ware with non-O- O elements, wr itten in such languages  
as C, Fortran or Pascal. The no tation should sup port this proce ss.
We will first look at the language mechanism, then reflect on i ts broader significance  
as a part of the object-oriented  software development process.
External routines
Our object-oriented systems are made of classes, consisting of features, particularly  
routines, that contain instructions. What is, among these three , the right level of  
granularity for integrat ing external software?
The construct must be common to both sides; this excludes class es, which exist only  
in object-oriented languages. (T hey may, however, be the right level of integration  
between two different O-O langua ges.) Instructions are too low- level; a sequence in which  
two object-oriented instructions brack et a C instruction:
create  x  make (clone (a))
(struct A) *x  = &y; /* A piece of C */
x  display
would be very hard to unders tand, validate and maintain.Warning : this style is 
neither supported nor recommended . 
For purposes of dis-
cussion only .
MORE O-O MECHANISMS  §13.1 440
This leaves the feature level, t he right one since encapsulatin g features is compatible  
with O-O principles: a class is an implementation of a data typ e protected by information  
hiding; features are the unit of interaction of the class with the rest of the software; since  
clients rely on the features’ official specification (the short  form) independe ntly of their  
implementation, it does not matt er to the outsid e world whether  a feature is internally  
written in the object-oriented not ation or in anot her language.
Hence the notion of external rou tine. An externa l routine will have most of the  
trappings of a normal routine: na me, argument list, result type  if it is a function,  
precondition and postcondition if appropriate. Instead of a do c l a u s e  i t  w i l l  h a v e  a n  
external  clause stating the language use d for the implementation. Here is an example,  
extracted from a c lass describing character files:
put (c: CHARACTER )
-- Add c to end of file.
require
write_open : open_for_write
external
 "C" alias "_char_write ";
ensure
one_more : count = old count + 1
end
The alias clause is optional, useful only if the name of the external rou tine, in its  
language of origin, is different from the name given in the cla ss. This happens for example  
when the external name would not be legal in the object-oriente d notation, as here with a  
name beginning with an underscore (legal in C).
Advanced variants
The mechanism just described cov ers most cases and will suffice  for the purposes of this  
book. In practice some r efinements a re useful:
• Some external software elements may be macros  rather than routines. They will  
appear to the O-O world as routi nes, but any call will be expan ded in-line. This may  
be achieved by varying t he language name (as in "C:[macro ]… ").
• It is also necessary to permit calls to routines of “Dynamic L ink Libraries” (DLL)  
available on Windows and other platforms. Instead of being a st atic part of the system,  
a DLL routine is loaded at run time, on the first call. It is e ven possible to define the  
routine and library names at run time. DLL support should inclu de both a way to  
specify the names statically (as in external "C:[dll]…") and a completely dynamic  
approach using library classes DYNAMIC_LIBRARY and DYNAMIC_ROUTINE
which you can instantiate at run time, to create objects repres enting dynamically  
determined libraries and routines.
• You may also need communication  in the reverse direction, lett ing non-O-O  
software create objects and call  features on them. For example you may want the  
callback mechanism of a non-O-O graphical  toolkit to call cert ain class features.
All these facilities are present  in the O-O environment describ ed in the last chapter.  
Their detailed presentation, how ever, falls beyond the scope of  this discussion.
§13.1   INTERFACING WITH NON-O-O SOFTWARE 441
Uses of external routines
External routines are an integral  part of the method, fulfillin g the need to combine old  
software with new. Any software design method emphasizing reusa bility must allow  
accessing code written in other languages. It would be hard to convince potential users that  
reusability begins this minute an d that all existing software m ust be discarded.
Openness to the rest of the world is a requirement for most sof tware. This might be  
termed the Principle of Modesty : authors of new tools shoul d make sure that users can  
still access previously  available facilities. 
External routines are also necess ary to provide access to machi ne-dependent or  
operating system capabilities. Th e file class is a typical exam ple. Another is class ARRAY , 
whose interface was pre sented in earlier ch apters but whose imp lementation will rely on  
external routines: the creation procedure make  use a memory allocation routine, the access  
function item will use an external mechanism for fast access to array elemen ts, and so on.
This technique ensures a clean interface between the object-ori ented world and other  
approaches. To clients, an exter nal routine is just a routine. In the example, the C routine  
_char_write has been elevated to the status of a feature of a class, comple te with  
precondition and postconditio n, and the standard name put. So even facilities which  
internally rely on non-O-O mecha nisms get repackaged in data ab stractions; the rest of the  
object-oriented software will se e them as legitimate members of  the group, their lowly  
origins never to be ment ioned in polite society.
Object-oriented re-architecturing
The notion of external routine fi ts well with the rest of the a pproach. The method’s core  
contribution is architectural: o bject technology tells us how t o devise the structure of our  
systems to ensure extendibility, reliability and reusability. I t also tells us how to fill that  
structure, but what fundamentall y determines whe ther a system i s object-oriented is its  
modular organization. It is often appropriate, then, to use an O-O architecture — what is  
sometimes called a wrapper  — around internal element s that are not all O-O.
One extreme but not altogether a bsurd way to use  the notation w ould rely solely on  
e x t e r n a l  r o u t i n e s ,  w r i t t e n  i n  s o m e  o t h e r  l a n g u a g e ,  f o r  a l l  a c t u al computation. Object  
technology would then serve as a  pure packaging tool, using its  powerful encapsulation  
mechanisms: classes, assertions, i nformation hiding, client, in heritance.
In general there is no reason to  go that far, since the notatio n is perfectly adequate to  
express computations of all kind s and execute them as efficient ly as older languages such  
as Fortran or C. But object-orie nted encapsulation of external software is useful in several  
cases. We have seen one of them:  providing access to platform-s pecific operations.  
Another is to address a problem t hat faces many organizations: managing so-called legacy  
software . During the sixties, seventies and eighties, companies have ac cumulated a legacy  “Polite society” is 
not classless .
MORE O-O MECHANISMS  §13.1 442
of Cobol, Fortran, PL/I and C co de, which is becoming harder an d harder to maintain, and  
not just because the original de velopers are gone or going. Obj ect technology offers an  
opportunity to re-engineer such systems by re-architecturing th em, without having to  
rewrite them completely.
Think of this process as the reverse of turkey stuffing: instea d of keeping the structure and  
changing the internals, you keep the entrails and replace the s keleton, as if repackaging  
the content of a turkey into the bones of a zebra or a mouse. I t must be noted, however,  
that such non-software applicatio ns of the idea appear neither useful nor appetizing.
This technique, which we may call object-oriented re-architecturing , offers an  
interesting solution for preserving the value of existing softw are assets while readying  
them for future extension and evolution.
It will only work, however, u nder specific conditions:
• You must be able to identify go od abstractions in the existing  software. Since you  
are not dealing with object-orie nted software, they will typica lly be function  
abstractions, not data  abstractions; but that is normal: it is your task to find the  
underlying data abstractions and repackage the old software’s r outines into the new  
software’s classes. If you cannot identify proper abstractions already packaged in  
routines, you are out of luck, a nd no amount of object-oriented  re-architecturing  
attempts will help.
• The legacy software must be of good quality. Re-architectured junk is still junk —  
possibly worse than the original , in fact, as the junkiness wil l be hidden under more  
layers of abstraction.
These two requirements are partl y the same, since quality in so ftware, O-O or not, is  
largely determined by quality of structure.
When they are satisfied, it is possible to use the external  mechanism to build some  
very interesting object -oriented software based on earlier effo rts. Here are two examples,  
both part of the environment d escribed in the last chapter.
•The Vision  library provides portable graphics and user interface mechanis ms, 
enabling developers to write gra phical applications that will r un on many different  
platforms, with the native look- and-feel, for the price of a re compilation. Internally,  
it relies on the native mechanis ms, used through external routi nes. More precisely,  
its lower level — WEL for Windows, MEL for Motif, PEL for OS/2 Presentation  
Manager — encapsulates the mechanisms of the corresponding plat forms. WEL,  
MEL, PEL and consorts are also u sable directly, providing devel opers who do not  
care about portability with objec t-oriented encapsulations of t he Windows, Motif  
and Presentation Manager Appli cation Programming Interfaces.
• Another library, Math , provides an extensive set of facilities for numerical  
computation in such areas as pro bability, statistics, numerical  integration, linear and  
non-linear equations, ordinary differential equations, eigenpro blems, fitting and  
interpolation, orthogonal factori zations, linear least squares,  optimization, special  
functions, Fast Fourier Transfor ms and time series analysis. In ternally, it is based  On these libraries 
see “PORTABILITY AND PLATFORM ADAPTATION”, 32.2, page 1066.
§13.1   INTERFACING WITH NON-O-O SOFTWARE 443
on a commercial subroutine libra ry, the NAG library from Nag Lt d. of Oxford, but  
it provides a completely object- oriented interface to its users . The library hides the  
underlying routines and instead i s organized arou nd such abstra ct concepts as  
integrator, matrix, discrete fun ction, exponenti al distribution  and many others; each  
describes “objects” readily unde rstandable to a mathematician, physicist or  
economist, and is represented i n  t h e  l i b r a r y  b y  a  c l a s s :  INTEGRATOR , BASIC_
MATRIX , DISCRETE_FUNCTION , EXPONENTIAL_DISTRIBUTION . The result  
builds on the quality of the ext ernal routines — NAG is the pro duct of hundreds of  
person-years of devising and imp lementing numeri cal algorithms — and adds the  
benefits of O-O ideas: classes, information hidi ng, multiple in heritance, assertions,  
systematic error handling throug h exceptions, simple routines w ith short argument  
lists, consistent naming conventions.
These examples are typ ical of how one can combine the best of t raditional software  
and object technology.
The compatibility issue: hybri d software or hybrid languages?
Few people would theoretically di sagree with the principle of m odesty and deny the need  
for some integration mechanism be tween O-O developments and old er software. The  
matter becomes more controversia l when it comes to deciding on the level of integration. 
A whole set of languages — the b est known are Objective-C, C++,  Java, Object  
Pascal and Ada 95 — have taken t he approach of a dding O-O const ructs to an existing  
non-O-O language (respe ctively C in the first three cases, Pasc al and Ada). Known as  
hybrid languages , they are discussed in varying degree of detail  in a later cha pter. 
The integration technique descri bed above, relying on external routines and object-
oriented re-architectu ring, follows from a different principle:  that the need for software
compatibility does not mean that we should burden the language  with mechanisms that  
may be at odds with the principl es of object tec hnology. In par ticular:
• A hybrid adds a new language le vel to the weight of an existin g language such as C.  
The result can be quite complex,  limiting one of  the principal attractions of object  
technology — the essential  simplicity of the ideas.
• Beginners as a result often have trouble mastering a hybrid la nguage, since they do  
not clearly see what is truly O-O  and what comes from the legac y.
• Some of the older mechanisms may be incompatible with at least  some aspects of  
object-oriented ideas. We have s een how the type  concepts inher ited from C make it  
hard to equip C++ environments w ith garbage collection, even th ough automatic  
memory management is part of the  appeal of object technology . T here are many  
other examples of clashes betwee n the C or Pascal type system a nd the O-O view.See chapter 35 .
MORE O-O MECHANISMS  §13.2 444
• The non-O-O mechanisms are stil l present, often in apparent co mpetition with their  
higher-level object-oriented coun terparts. For example C++ offe rs, along with  
dynamic binding, the ability to ch oose a function at run time t hrough arithmetic on  
function pointers. This is disco ncerting for the non-expert who  lacks guidance on  
which approach to choose in a pa rticular case. Th e resulting so ftware, although  
compiled by an O-O environment, is still, deep-down, C code, an d does not yield the  
expected quality and p roductivity benefits — giving object tech nology a bad name  
through no fault of its own.
If the aim is to obtain the best possible software process and products, co mpromising  
at the language level does n ot seem the right approach. Interfacing object-oriented tools  
and techniques with pr e v i o u s  a c h i e v e m e n t s  i s  n o t  t h e  s a m e  t h i n g  a s  mixing  w i d e l y  
different levels of technology.
With the usual precautions about attaching too much weight to a  metaphor, we can think  
of the precedent of electronics. It is definitely useful to com bine different technology  
levels in a single system, as in an audio amplifier which still  includes a few diodes  
together with transistors and integrated circuits. But the leve ls remain separate: there is  
little use for a basic component that would be half-diode, half -transistor.
O-O development should provide c ompatibility with software buil t with other  
approaches, but not at the expen se of the method’s power and in tegrity. This is what the  
external  mechanism achieves: separate worlds, each with its own consist ency and  
benefits, and clear interfa ces between these worlds.
13.2  ARGUMENT PASSING 
One aspect of the notation may re quire some clarification: what  may happen to values  
passed as arguments to routines?
Consider a routine call of the form
r (a1, a2, …, an)
corresponding to a routine 
r (x1: T1, x2: T2, …, xn: Tn) …
where the routine could be a function as well as a procedure, a nd the call could be  
qualified, as in b  r (…). The expressions a1, a2, …, an are called actual arguments, and  
the xi are called formal arguments. (R ecall that we reserve the term “parameter” for  
generic type parameters.) 
The relevant questions are: what  is the correspondence between actual and formal  
arguments? What operations are per mitted on formal arguments? W hat effect will they  
have on the corresponding actuals ? For all three we should stic k to simple and safe rules.
We already know the answer to th e first question: the effect of  actual-formal  
argument association is the same  as that of a corresponding ass ignment. Both operations  
are called attachments . For the above call we can cons ider that the routine’s executi on 
starts by executing instructions  informally equivalent to the a ssignments
§13.2   ARGUMENT PASSING 445
x1 := a1; x2 := a2; … xn := an
On the second question: within the routine body, any formal arg ument x is protected.  
The routine may not apply to it any direct modification, such a s: 
• An assignment to x, of the form x := … 
• A creation instruction with x as its target:  create  x  make (…)
Readers familiar with the passing mechanism known as  call by value will note that the  
restriction is harsher here: with call by value, formals are in itialized to actuals but may  
then be the target of arbitrary operations. 
The answer to the third question  — what can the routine actuall y do to the actuals?  
— follows from the use of attach ment to define the semantics of  actual-formal association  
Attachment means copyi ng either a reference or an object. As yo u will remember from the  
discussion of attachment, this de pends on whether the types inv olved are expanded:
• For reference types (the more common case), argument passing w ill copy a  
reference, either void or  attached to an object.
• For expanded types (which incl ude in particular the basic type s: INTEGER , REAL
and the like), argument passin g will actually copy an object.
In the first case, the prohibition of direct modification opera tions means that you  
cannot modify the reference  through reattachment or creatio n; but if the reference is not  
void you can modif y the attached object  through ap propriate  routines.
If xi is one of the formal arguments to routine r, the body of the routine could contain  
a call of the form 
xi  p (…)
where p is a procedure applicable to xi, meaning a procedure decl ared in the base class of  
xi’s type Ti. This routine may modify the fields of the object attached to xi at execution  
time, which is the object attache d to the corres ponding actual argument ai. “ATTACHMENT: 
REFERENCE AND VALUE SEMAN-TICS”, 8.8, page 261, in particular 
table on page 264 .
Permissible 
operations on a reference 
argument
xiThe routine may not change this  
reference (e.g. reattach it to  
another object ) O1
The routine may change fields of this  
object (through calls to other routines ).
MORE O-O MECHANISMS  §13.2 446
So although a call q (a) can never change the value of a — the corresponding object  
if a is expanded, the reference othe rwise — it can, in the referenc e case, change the  
attached object.
T h e r e  a r e  m a n y  r e a s o n s  f o r  n o t  p e r m i t t i n g  r o u t i n e s  t o  m o d i f y  t h eir arguments  
directly. One of the most striking is the Conflicting Assignments To Actual  trick. Assume  
a language that permits assignme nts to arguments, and a procedu re
dont_I_look_ innocuous (a, b: INTEGER )
-- But do not trust me too much.
do
a := 0; b := 1
end
Then consider the call dont_I_look_innocuous (x, x) for some entity x. What is the  
value of x on return: 0 or 1? The answer depends on how the compiler impl ements formal-
to-actual update on routine exit . This has foole d more than a f ew Fortran programmers,  
among others.
Permitting argument-modifying rou tines would also force us to i mpose restrictions  
on actual arguments: the actual corresponding to a modifiable f ormal must be an element  
that can change its value (a writable entity); this allows vari able attributes, but not constant  
attributes, Current , or general expre ssions such as a + b . By precluding argument-
modifying routines we can avoid imposing such restrictions and accept any expression as  
actual argument.
As a consequence of these rules, there are only three ways to m odify the value of a  
reference x: through a creat ion instruction  create  x…; through an assignment x := y; and 
through a variant o f assignment, assignment attempt x ?= y, studied in a later chapter .  
Passing x as actual argument to a rou tine will never modify x.
This also means that a routine returns at most one result: none  if it is a procedure; the  
official result (represented in the routine’s body by the entit y Result ) if it is a function. To  
achieve the effect of multipl e results, you can either:
• U s e  a  f u n c t i o n  t h a t  r e t u r n s  a n  o b j e c t  w i t h  s e v e r a l  f i e l d s  ( o r  more commonly a  
reference to s uch an object).
• Use a procedure that sets sever al fields of an object, corresp onding to attributes that  
the client may then query.
The first technique is appropria te when the result is truly mad e of several  
components; a function may not fo r example return two values co rresponding t o the title  
and publication year of a book, but it may return a single valu e of type BOOK , with  
attributes title and publication_  year. The second technique is applicable for a routine that,  
besides its principal job, sets some status indicators. We will  study it, as well as the more  
general question of side effects , in the discussion of mo dule design principles. WARNING : invalid 
routine text . For pur-
poses of illustration only.
On constant attrib-
utes see chapter 18.
See chapter 23 , espe-
cially “The a posteri-ori scheme”, page 800.
§13.3   INSTRUCTIONS 447
13.3  INSTRUCTIONS 
The object-oriented notation dev eloped in this book is imperati ve: we specify  
computations through commands, a lso called instructions. (The w ord “statement” is  
co m m on ly  us e d i n t hi s se ns e b ut  we  wi ll  s te ad fa s tl y a vo id  i t s i nce it is misleading: a  
statement is an expression  of facts, not a command.)
Except for some specific propert ies of loops, intended to make their verification  
easier, instructions will look f amiliar to anyone who has had s ome experience with a  
modern language of the Algol line such as Pascal, Ada or Modula , or even just with C  
or a derivative. They include: Procedure call; Assignment; Crea tion; Conditional;  
Multi_branch; Loop; Check; Debug; Retry; Assignment attempt.
Procedure call 
A routine call involves a routine , possibly with actual argumen ts. In a call instruction, the  
routine must be a procedure; if it is a function, the call is a n expression. Although for the  
moment we are interested in inst ructions, the fo llowing rules a pply to both cases.
A call is either qualified or unq ualified. An unq ualified call t o  a  r o u t i n e  o f  t h e  
enclosing class uses the current  instance as target; it appears  under the form
r (without arguments), or
r (x, y, …) (with arguments)
A qualified call explicitly name s its target, denoted by an exp ression: if a i s  a n  
expression of a certain type, C is the base class of that type, and q is one of the routines of  
C, then a qualified call is of the form a  q. Again, q may be followed by a list of actual  
arguments; a may be an unqualified function call with arguments, as in p (m)   q (n) where  
the target is p (m). Y ou may also use as target a m ore complex expr ession, provide d you 
enclose it in pare ntheses, as in (vector1 + vector2 )   count .
Multidot qualified calls, of the form a   q1   q2 …   qn are also permitted, where a as 
well as any of the qi may include a list of actual arguments. 
Export controls apply to qualified  calls. Recall that a feature  f declared in a class B is 
available  to a class A if the feature clause declaring f  begins with feature  (without further  
qualification) or feature {X, Y, …} where one of X, Y, … is A or an ancestor of A. Then:
To understand the reason for the second rule, note that a  q  r  s is a shorthand for Qualified Call rule
A qualified call of the form b  q1  q2 ….   qn appearing in a class C is valid  
only if it satisfies the  following conditions: 
R1 • The feature appearing  after the first dot, q1, must be available to C. 
R2 • In a multidot call, every feature after the second dot, that i s to say every  
qi for i > 1, must also be available to C. 
MORE O-O MECHANISMS  §13.3 448
b := a  q; c := b  r; c  s
which is only valid if q, r and s are all available to C, the class where this fragment appears.  
Whether r is available to the base class of q’s type, and s available to the base class of r’s 
type, is irrelevant. 
As you will remember it is also possible to express calls in in fix or prefix form; an  
expression such as a + b  is a different syntax for a call that would otherwise be writt en 
a  plus (b). The same validity rules apply to such expressions as to the dot form.
Assignment 
The assignment instr uction is written 
x := e
where x is a writable entity and e an expression of compatible type. A writable entity is either:  
• A non-constant attribute of the enclo sing class. 
• A local entity of the enc losing routine, including Result  for a function.
Other, non-writable kinds of entity include constant attributes  (introduced in  
declarations such as Zero: INTEGER = 0) and formal arguments o f a routine — to which,  
as we just saw, the routine may not assign  a new value. 
Creation instruction
The creation instruction was stu died in an earlier chapter in i ts two forms: without a  
creation procedure, as in  create  x, and with a creation procedure, as in  create  x  p (…). In 
both cases, x must be a writable entity.
Conditional 
A conditional instruct ion serves to specify that different form s of processing should be  
applied depending on certain c onditions. The basic form is
if boolean_expression then
instruction ; instruction ; …
else
instruction ; instruction ; …
end
where each branc h may have an arbitrary number of instructions (possibly none).
This will execute the instructio ns in the first branch if the boolean_expression
evaluates to true, and  those in the second branch otherwise. Yo u may omit the else part if  
the second instruction list is empty, giving: 
if boolean_expression then
instruction ; instruction ; …
endSee “Operator fea-
tures”, page 187 .
Chapter 18 dis-
cusses constant attributes.
See “The creation 
instruction”, page 232 and “CREATION PROCEDURES”, 8.4, page 236 . A vari-
ant will be seen in “Polymorphic cre-ation”, page 479 .
§13.3   INSTRUCTIONS 449
When there are more than two rel evant cases, you can avoid nest ing conditional  
instructions in else parts by using one or more elseif  branches, as in 
if c1 then
instruction ; instruction ; …
elseif  c2 then
instruction ; instruction ; …
elseif  c3 then
instruction ; instruction ; …
…
else
instruction ; instruction ; …
end
where the else part remains option al. This avoids the repeated nesting of 
if c1 then
instruction ; instruction ; …
else
if c2 then
instruction ; instruction ; …
else
if c3 then
instruction ; instruction ; …
…
else
instruction ; instruction ; …
end
end
end
For handling a set of cases defined by the possible values of a  certain expression, the  
multi-branch inspect , studied next, may be more convenient than the plain condition al.
The object-oriented method, in p articular throug h polymorphism and dynamic  
binding, tends to reduce the nee d for explicit conditional and multi-branch instructions by  
supporting an implicit  form of choice: you apply a feature to a n object, and if the feature  
has several variants the right o ne automatically gets selected at run time on the basis of the  
object’s type. When applicable, this implicit style is usually preferable. But of course some  
of your algorithms will still re quire explicit choice instructi ons.
Multi-branch
The multi-branch (also known as a Case instruction because of t he corresponding keyword  
in Pascal, where it was first in troduced based on a design by T ony Hoare) discriminates  
between a set of conditions that are all of the form e = vi where x is an expression and the  
vi are constants of the same type. Although a conditional instruc tion ( if e = v1 then …
MORE O-O MECHANISMS  §13.3 450
elseif e = v2 then …) would do the job, two reasons j ustify a special instruction, departing  
from the usual rule that if the notation offers one good way to  do something it does not  
need to offer two:
• This case is so common as to just ify specific syntax, which wi ll enhance clarity by  
avoiding the usele ss repetition of “ e =”.
• Compilers can use a particularly efficient implementation tech nique, the jump table , 
not applicable to general condit ional instructi ons and avoiding  explicit tests.
For the type of the discrimi nated values (the type of e and the vi), the multi-branch  
instruction only needs  to support two possibilities: integers a nd booleans. The rule will  
indeed be that e and the vi must be declared as either all INTEGER  or all CHARACTER . 
The general form of the instruction is:
inspect
e
when v1 then
instruction ; instruction ; …
when v2 then
instruction ; instruction ; …
…
else
instruction ; instruction ; …
end
All the vi values must be different. The else… part is optional. Each of the branches  
may have an arbitrary number of  instructions, possibly none.
The effect of the instruction is the following: if the value of  e is equal to one of the  
vi ( t h i s  c a n  b e  t h e  c a s e  f o r  a t  m o s t  o n e  o f  t h e m ) ,  e x e c u t e  t h e  i n structions in the  
corresponding branch; otherwise , execute the ins tructions in th e else branch if any.
If there is no else branch and the value of e does not match any of the vi, the effect is  
to raise an exception (of code Incorrect_inspect_value ). This policy may seem surprising,  
since the corresponding condition al instruction would simply do  nothing in this case. But  
it highlights the specificity of the multi-branch. When you wri te an inspect  with a set of  
vi values, you should include an else branch, empty or not, if you are prepared for run-time  
values of e that match none of the vi. If you do not include an else, you are making an  
explicit statement: that you expect the value of e always to be one of the vi. By checking  
this expectation and r aising an exception if  it is not met, the  implementation is providing  
a service. Doing nothing would be  the worst possi ble response, since this case usually  
reflects a bug (forgetting a possi ble case to be handled in its  own specific way), which in  
any case should be fixed  as early as possible.
A typical application of the mul ti-branch is to decode a single -character user input:
§13.3   INSTRUCTIONS 451
inspect
first_input_letter
when 'D' then
“Delete line”
when 'I' then
“Insert line”
…
else
message ("Unrecognized command ; type H for help ")
end
In the integer case, the vi can be Unique values, a concept detailed in a later chapter.  
This makes it possible to define  a number of abstract constants , in a declaration such as  
Do, Re, Mi, Fa, Sol, La, Si: INTEGER unique , and then discriminate among them in an  
instruction such as inspect note when Do then … when Re then … end.
Like conditionals, multi-branch instructions should not be used  as a substitute for the  
implicit discrimination techniqu es of object technology, based on dynamic binding. The  
restriction to integer and chara cter values helps avoid misuse;  t h e  D i s c r i m i n a t i o n  
principle, introduced together w ith unique values, will provide  further guidance.
Loop 
The syntax of loops was introduc ed in the presentation of Desig n by Contract: 
from
initialization_instructions
invariant
invariant
variant
variant
until
exit_condition
loop
loop_instructions
end
The invariant  and variant  clauses are optional. The from  clause is required (but  
may be empty); it specifies the l oop initialization instruction s. Leaving aside the optional  
clauses, the execution of such a loop consists of executing the  initialization_instructions
followed by the “loop process”, i tself defined as follows: if t he exit_condition  is true, the  
loop process is a null instruction; if it is false, the loop pr ocess is the execution of the loop_
instructions  followed (recursively) by a new loop process. This is an elementary 
scheme . See chapter 
21 for more sophisti-cated user command processing techniques .
“UNIQUE VALUES”,
18.6, page 654 . Do 
and Si are also known as Ut and Ti .
The Discrimination 
principle appears on page 655 .
See “LOOP INVARI-
ANTS AND VARI-ANTS”, 11.12, page 380.
MORE O-O MECHANISMS  §13.4 452
Check 
The check  instruction was also seen in th e discussion of assertions. It serves to express  
that certain assertions must be satisfied at certain points: 
check
assertion -- One or more clauses
end
Debug 
The debug  instruction is a faci lity for cond itional compilation. It is w ritten 
debug  instruction ; instruction ; … end
For every class, you may turn o n or off the corresponding debug option of the control  
file (the Ace). If on, any debug instruction in the class is eq uivalent to the instructions it  
contains; if off, it has n o effect on the execution.
You can use this instruction to include special actions that sh ould only be executed  
in debugging mode, for  example instructions  to print out some v alues of interest.
Retry 
The last instruction is retry , introduced in the discussion of exceptions. It may only appea r 
in a rescue  clause, and will restart the b ody of a routine that was interr upted by an exception.
13.4  EXPRESSIONS 
An expression serves to denote a  computation that yields a valu e — an object, or a  
reference to an object. Expressio ns include the following varie ties: 
• Manifest constants.
•Entities (attributes, l ocal routine entitie s, formal routine ar guments, Result ).
• Function calls.
• Expressions with operators (tec hnically are a s pecial case of function calls).
•Current .
Manifest constants 
A manifest constant is a value that denotes itself (such as the  integer value written 0) — as  
opposed to a symbolic constant, whose name is independent of th e denotation of the value.
There are two boolean manifest constants, written True and False . Integer constants  
follow the usual form and may be  preceded by a s ign. Examples a re 
453  –678   +66623
Real constants use a decimal point . Either the integer part or the fractional part may  
be absent; you may include a sig n, and specify an integer power  of 10 by e followed by  
the exponent value. Examples are:See “LOOP INVARI-
ANTS AND VARI-ANTS”, 11.12, page 380.
See “AN EXCEP-
TION MECHA-NISM”, 12.3, page 419.
Entities were defined 
on page 213.
§13.4   EXPRESSIONS 453
52.5   –54.44  +45.01  .983  –897 .  999.e12
Character constants consist of a  single character written in qu otes, as in  'A'; they 
describe single characters. For s trings of more than one charac ter we will use the library  
class STRING , discussed later in this chapter.
Function calls 
Function calls follow the same s yntax as procedur e calls studie d earlier in this chapter.  
They may be qualified or unqualif ied; in the qua lified case, mu ltidot notation is available.  
Assuming the proper class and fu nction declarations, examples a re: 
b  f
b  g (x, y, …)
b  h (u, v)  i  j (x, y, …)
The Qualified Call rule introduce d for procedures  applies to fu nction calls as well. 
Current object
The reserved word Current  denotes the current instance of  the class and may be used in a n 
expression. Note that Current  itself is an expression, not a writable entity; thus an  
assignment to Current , such as Current  := some_value , would be syntac tically illegal. 
When referring to a feature (attribute or routine) of the curre nt instance, it is not  
necessary to write Current    f; just f suffices. Because of this rule, we will use Current  less 
frequently than in object-orient ed languages where every featur e reference must be  
explicitly qualified. (In Smallt alk, for example, there is no s uch convention; a feature is  
always qualified, even when it a pplies to the current instance,  written self.) Cases in which  
you will need to name Current  explicitly include: 
• Passing the current instance as argument to a routine, as in a  f (Current ). A common  
application is to create a dupli cate of the current instance, a s in x := clone (Current ).
• Testing whether a reference is attached to the current instanc e ,  a s  i n  t h e  t e s t  
x = Current . 
•Using Current  as anchor in an “anchored declaration” of the form like Current , as 
will be seen in the st udy of inheritance. 
Expressions with operators 
Operators are available to con struct composite expressions. 
Unary operators are + and –, applicable to integer a nd real expressions, and not, 
applicable to bool ean expressions. 
Binary operators, which  take exactly two op erands, include the relational operators 
=   /=   <   >   <=   >=
where /= is “not equal”. The relational operators yield boolean results .“ANCHORED 
DECLARATION”, 16.7, page 598 .
MORE O-O MECHANISMS  §13.4 454
Multiary expressions involve one  or more operands, combined wit h operators.  
Numerical operands may  be combined using t he following operator s: 
+   –   ∗   /   ^   //   \\
where // is integer division, \\ is integer remainder and ^ is power (exponentiation).
Boolean operands may be co mbined with the operators and, or, xor, and then , 
or else, implies . The last three are expla ined in the next section; xor is exclusive or.
The precedence of operators, base d on the conventions of ordina ry mathematics, has  
been devised according to the “P rinciple of Least Surprise”. To  avoid any uncertainty or  
confusion, this book makes generous use of parentheses even whe re they are not needed,  
as in the examples of the next section.
Non-strict boolean operators 
The operators and then  and or else (whose names have been borrowed from Ada) as  
well as implies are not commutative, and are called non-strict boolean operators. Here  
is their semantics:
The boolean values from mathematics are written in regular font : true  and false;  True and
False  are predefined language consta nts and hence written in color it alics. 
The first two definitions at first seem to yield the same seman tics as and and or. But 
the difference is what happens when b is not defined. In that c ase the expressions using  
the standard boolean operators a re mathematically undefined, bu t the above definitions  
may still yield a result: if a is false, a and then  b is false regardless of b; and if a is true,  
a or else b is true regardless of b. Similarly, a implies b is true if a is false, even if b is 
undefined. So the non-strict oper ators may yield a result when the standard ones do not.
A typical application is the boolean express ion (using  integer division //)
(i /= 0) and then  (j // i  =  k)
which, from the above definition, has value false if  i is equal to zero (as the first operand is  
then false). If the expressi on had been written using and r a t h e r  t h a n  and then , then its  
second operand would be undefined when  i is zero, so that the status of the whole expression  
is unclear in th is case. This uncertainty is reflected in what may happen at run time: Non-strict boolean operators
• a and then  b has value false if a has value false, and otherwise has the  
value of b.
• a or else  b has value true if a has value true, and otherwise has the  
value of b.
• a implies b has the same value as: (not a) or else  b.For an explanation of 
the word “non-strict” see e.g. [M 1990]  or 
[M 1992].
§13.4   EXPRESSIONS 455
B1  • If the compiler generates code that evaluates both operands an d then takes their  
boolean “and”, a division by zer o will result at  run time, prod ucing an exception.
B2 • If, on the other hand, the gene rated code only evaluates the s econd operand when  
the first is true, otherwise ret urning false as the value of th e expression, then the  
expression will indeed  evaluate to false.
To guarantee interpretation B 2, use and then . Similarly, 
(i = 0) or else (  j // i  /=  k) 
will evaluate to true if i is zero, whereas the or variant could produce a run-time error.
An expression using and then  always yields the same value as the corresponding  
expression written using and if both are defined. But the and then  form may yield a value  
(false) in cases when the and form does not. Th e same holds with or else  (and the value true)  
with respect to or. In this sense, the non-commutati ve operators may be said to b e “more  
defined than or equal to” their respective counterparts. This a lso means that the non-strict  
interpretation — strategy B2 — is a correct implementation for the ordinary operators: a  
compiler writer may decide to implement and as and then and or as or else. But he does not  
have to, so the software developer may not rely on the assumpti on that and and or will be non-
strict; only and then  and or else  guarantee the correct behavior in cases such as the last two  
examples.
One might wonder why two new operators are needed; would it not  be simpler and  
safer to just keep the standard operators and and or and take them to mean and then  and 
or else ? This would not change the valu e of any boolean expression whe n both operands  
are defined, but would extend th e set of cases in which express ions may be given a  
consistent value. This is indeed  the way some programming langu ages, notably ALGOL  
W and C, interpret boolean opera tors. There are, however, both theoretical and practical  
reasons for keeping two se ts of distinct operators: 
• On the theoretical side, the standard mathematical boolean ope rators are  
commutative: a and b always has the same value as b and a, whereas a and then  b
may be defined when b and then  a is not. When the order of operands does not  
matter it is preferable to u se a commutative operator.
• In practice, some compiler optim izations become impossible if we require the  
compiler to evaluate the operands in a given sequence, as is th e case with the non-
commutative operators. So it is b etter to use the standard oper ators if both operands  
are known to be defined. 
Note that it is possible to simulate the non-strict operators t hrough conditional  
instructions in a language that does not include such operators . For example, instead of 
b := ((i /= 0) and then  (j // i  =  k))
one may write 
if i = 0 then  b := false  else b := (j // i = k) end
MORE O-O MECHANISMS  §13.5 456
The non-strict form is of course simpler. This is particularly clear when it is used as  
the exit condition of a loop, suc h as the following iteration o n an array:
from
i := a  lower
invariant
-- For all elements in the interval [ a  lower .. i –- 1 ], (a @ i ) /= x
variant
a  upper — i
until
i > a  upper or else (a @ i = x)
loop
i := i + 1
end;
Result  := (i <= a  upper )
whose purpose is to make Result  true if and only if the value x appears in the array a. The 
use of or would be incorrect here: a compi ler may generate code that wil l always evaluate  
both operands, so that for  the last index examined ( i > a  upper ) if no array value equals x, 
there will be an erroneous attem pt at run time to access the no n-existent array item a @ 
(a  upper + 1 ), causing a run-time error (a pr econdition violation if asserti on checking is on).
It is possible to program this example safely without non-stric t operators, but the  
result is heavy and inelegant (try it).
Another example is an assertion — appearing for example in a cl ass invariant —  
expressing that the first value of a certain list l of integers is non-negative — provided, of  
course, that the list is not emp ty. You may express this as
l  empty or else  l  first >= 0
Using or would have been incorrect. Here there is no way to write the c ondition  
without non-strict operators (ex cept by writing a special funct ion and calling it in the  
assertion). The Base libraries o f algorithms and data structure s contain many such cases.
The implies operator, describing i mplication, is also non-strict. Mathemati cal logic  
defines “ a implies b” as “ not a or b”; but in practical uses property b is often meaningless  
for false a, so that it is appropriate to use or else  rather than or; this is the official definition  
given above. In this case there is no need for a  strict variant .
The implies  form does not always come firs t to mind when you are not used to it, but  
it is often clearer; for example you might like t he last exampl e better under the form
(not l  empty ) implies (l  first >= 0)
13.5  STRINGS
Class STRING  describes character strings. It  enjoys a special status since the notation  
permits manifest  string constants, unders tood as denoting insta nces of STRING .
A string constant is written en closed in double  quotes, as in 
"ABcd Ef ~ ∗_ 01"
§13.6   INPUT AND OUTPUT 457
The double quote character m ust be preceded by a percent  % if it appears as one of  
the characters of the string. 
Non-constant charact er strings are also instances of class STRING , whose creation  
procedure make  takes as argument the expected initial length of the string, s o that 
text1 , text2 : STRING ; n: INTEGER ;
…
create  text1   make (n)
will dynamically allocate a string text1 , reserving the space for n characters. Note that n is 
only an initial size, n ot a maximum; any st ring can grow or shr ink to an arbitrary size.
Numerous features are available on instances of STRING : concatenation, character or  
substring extraction, comparison etc. (They may change the size  of the string, automatically  
triggering re-allocatio n if it becomes grea ter than the current ly allocated size.)
Assignment of a STRING  to another implie s sharing: after text2  := text1 , any 
modification to the contents of text1  will also affect the contents of text2  and conversely.  
To duplicate rather than share, use by text2  := clone (text1 ). 
You can declare a cons tant string attribute:
message : STRING = "Your message here "
13.6  INPUT AND OUTPUT
Two Kernel Library classes provide basic input and output facil ities: FILE  and STD_FILES . 
Among the operations defined on an object f declared of type FILE  are the following: 
create  f  make ("name ") --Associate f  with a file of name  name .
f  open_write -- Open f  for writing
f  open_read -- Open f  for reading
f  put_string ("A_STRING ") --Write the g iven string on f
For I/O operations on the standa rd input, output and error file s, you can inherit from  
STD_FILES , which defines the features input , output  and error . Alternatively you can use  
the predefined value io, as in io  put_string ("ABC "), bypassing inheritance.
13.7  LEXICAL CONVENTIONS 
Identifiers are sequences of characters, all of which must be l etters, digits  or underscore  
characters ( _); the first character of an iden tifier must be a letter. There  is no limit to the  
length of identifiers, and all the characters of identifiers ar e significant. This can be used  
to make both feature names and c lass names as clear as possible .
Letter case is not significant in identifiers , so that Hi, hi, HI and hI all denote the  
same identifier. The reason is t hat it would be dangerous to al low two identifiers that differ  
from each other by just one character, say Structure  a nd  structure , to denote different  
elements. Better ask dev elopers to use some imagination than ri sk mistakes. 
MORE O-O MECHANISMS  §13.8 458
T h e  n o t a t i o n ,  h o w e v e r ,  c o m e s  w i t h  a  s e t  o f  p r e c i s e  s t a n d a r d  s t y le conventions,  
detailed in a later chapter enti rely devoted to style: classes (INTEGER , POINT …) and 
formal generic parameters ( G i n  LIST [G]) in all upper case; predefined entities and  
expressions ( Result , Current …) and constant attributes ( Pi) start with an upper-case letter  
and continue in lower case; all other identifiers (non-constant  attributes, f ormal routine  
arguments, local entities) in al l lower case. Although compiler s do not enforce them since  
they are not part of t he notation’s specification, these rules are essential to the readability  
of software texts; the libraries  and this book a pply them consi stently.
13.8  KEY CONCEPTS INTRODUCED IN THIS CHAPTER 
• External routines are  accessible through a well-defined interf ace. 
• Object technology can serve as a wrapping mechanism for legacy  software.
• Routines may not directly modify  their arguments, although the y may change the  
objects  associated with these arguments. 
• The notation includes a small s et of instructions: assignment,  conditional, loop, call,  
debug, check. 
• Expressions follow common usage. Current  is an expression de noting the current  
instance. Not bei ng an entity, Current  may not be the target of an assignment. 
• Non-strict boolean operators yie ld the same values as the stan dard boolean operators  
when both operands are defined, but are defined in some cases w hen the standard  
operators are not. 
• Strings, input and output are c overed by simple  library classe s. 
• Letter case is not significant in identifiers, although the st yle rules include  
recommended conventions
EXERCISES
E13.1  External classes
The discussion of how to integrat e external software mentioned that although features are  
the right level of integration f or non-O-O softwa re elements, i nteraction with another  
object-oriented language might t ake place at the class level. D iscuss a notion of “external  
class” meant for that purpose, a nd its addition to the notation  of this book.
E13.2  Avoiding non-strict operators
Write a loop that determines if an element x appears in an array  a, similar to the algorithm  
given in this chapte r but not using any of  the non-strict opera tors.Chapter 26 .
Page 456 .
14  
Introduction to inheritance 
I nteresting systems are seldo m born into an empty world. 
Almost always, new software expands on previous developments; t he best way to  
create it is by imitation, refinement and combination. Traditio nal design methods largely  
ignored this aspect of system de velopment. In object technology  it is an essential concern. 
The techniques studied so far are not enough. Classes do provid e a good modular  
decomposition technique and possess many of the qualities expec ted of reusable  
components: they are homogeneous, coherent modules; you may cle arly separate their  
interface from their implementation according to the principle of information hiding;  
genericity gives them some flexibility; and you may specify the ir semantics precisely thanks  
to assertions. But more is needed to achieve the full goals of reusability and extendibility. 
For reusability , any comprehensive approach mus t face the problem of repetitio n and 
variation, analyzed in an earlie r chapter. To avoid rewriting t he same code over and over  
again, wasting time, introducing  inconsistencies and risking er rors, we need techniques to  
capture the striking commonalitie s that exist within groups of similar structures — all text  
e d i t o r s ,  a l l  t a b l e s ,  a l l  f i l e  h a n d l e r s  —  w h i l e  accounting for t he many differences that  
characterize individual cases. 
For extendibility , the type system described so far has the advantage of guarant eeing 
type consistency at compile time , but prohibits combination of elements of diverse forms  
even in legitimate cases. For example, we cannot yet define an array containing  
geometrical objects of  different but compa tible types such as POINT and SEGMENT .
Progress in either reusability or extendibility demands that we  take advantage of the  
strong conceptual relations that hold between classes: a class may be an extension,  
specialization or combination of others. We need support from t he method and the  
language to reco rd and use these relation s. Inheritance provide s this support. 
A central and fascinating compon ent of object technology, inher itance will require  
several chapters. In t he present one we discover the fundamenta l concepts. The next three  
chapters will describe more advanced consequences: multiple inh eritance, renaming,  
subcontracting, influence on the type system. Chapter 24 complements these technical  
presentations by providing the met hodological pers pective: how to use inheritance, and  
avoid misusing it.
INTRODUCTION TO INHERITANCE  §14.1 460
14.1  POLYGONS AND RECTANGLES 
To master the basic co ncepts we will use a simple example. The example is sketched rather  
than complete, but it shows the essential ideas well. 
Polygons 
Assume we want to build a graphi cs library. Clas ses in this lib rary will describe  
geometrical abstractions: points, segments, vectors, circles, e llipses, general polygons,  
triangles, rectangles , squares and so on. 
C o n s i d e r  f i r s t  t h e  c l a s s  d e s c r i b ing general polygons. Operation s will include  
computation of the perimeter, tra nslation, rotation. The class may look like this: 
note
description : "Polygons with an arbitrary number of vertices "
class  POLYGON creation
…
feature -- Access
count : INTEGER
-- Number of vertices
perimeter : REAL
-- Length of perimeter
do … end
feature -- Transformation
display
-- Display polygon on screen.
do … end
rotate (center : POINT ; angle : REAL )
-- Rotate by angle  around center .
do
… See next …
end
translate (a, b: REAL )
-- Move by a horizontally, b vertically.
do … end
… Other feature declarations …
feature  {NONE } -- Implementation
vertices : LINKED_LIST [POINT ]
-- Successive points making up polygon
invariant
same_count_as_i mplementation : count = vertices   count
at_least_three : count >= 3
-- A polygon has at least thr ee vertices (see exercise 14.2)
end
The attribute vertices  yields the list of vertices; th e choice of a linked list is on ly one  
possible implementation. ( An array might be better.)See also exercise 
E24.4, page 869.
§14.1   POLYGONS AND RECTANGLES 461
Here is a possible implementat ion for a typical procedure, rotate . The procedure  
performs a rotation by a certain  angle around a certain rotatio n center. To rotate a polygon,  
it suffices to rotate every vertex in turn:
rotate (center : POINT ; angle : REAL )
-- Rotate around center by angle .
do
from
vertices   start
until
vertices   after
loop
vertices   item  rotate (center , angle )
vertices   forth
end
end
To understand this procedure, note that feature item from  LINKED_LIST  yields the  
value of the currently active list element (where the cursor is ). Since vertices  is of type  
LINKED_LIST [POINT ], vertices   item denotes a point, to which we may apply procedure  
rotate defined for class POINT in an earlier chapter. It is v alid — and common — to give  
the same name, here rotate , to features of different classes, as the target of any featur e 
always has a clearly d efined type. (This is the O-O form of ove rloading.)
Another routine, more important f or our immediate purposes, is the function to  
compute the perimeter of a polyg on. Since our polygons have no special properties, the  
only way to compute their perime ter is to loop through their ve rtices and sum the edge  
lengths. Here is an implementation of perimeter : 
perimeter : REAL
-- Sum of edge lengths
local
this, previous : POINT
do
from
vertices   start; this := vertices   item
check not vertices   after end -- A consequence of at_least_three
until
vertices   is_last
loop
previous  := this
vertices   forth
this := vertices   item
Result  := Result + this   distance (previous )
end
Result  := Result + this   distance (vertices   first)
endThe text of class 
POINT  appeared on 
page 176 .
this
previous
(start)(is_last )
first
INTRODUCTION TO INHERITANCE  §14.1 462
The loop simply adds the successive distances between adjacent vertices. Function  
distance  was defined in class POINT . Result , representing the value to be returned by the  
function, is automatically initialized to 0 on routine entry. F rom class LINKED_LIST we 
use features first to get the first element, start to move the cursor to that first element,  
forth  to advance it to the next, item to get the value of the element at cursor position, is_
last to know whether the current element is the last one, after  to know if the cursor is past  
the last element. As recalled by the check  instruction the invariant clause at_least_three
will guarantee that the loop starts and terminates properly: si nce it starts in a not after
state, vertices   item is defined, and applying forth  one or more time is correct and will  
eventually yield a state satisfying is_last , the loop’s exit condition.
Rectangles 
Now assume we need a new class representing rectangles. We coul d start from scratch.  
But rectangles are a special kin d of polygon and many of the fe atures are the same: a  
rectangle will probably be translated, rotated or displayed in the same way as a general  
polygon. Rectangles, on the other hand, also have special featu res (such as a diagonal),  
special properties (the number of vertices is four, the angles are right angles), and special  
versions of some operations (to compute the perimeter of a rect angle, we can do better  
than the above general  polygon algorithm). 
We can take advantage of this mi x of commonality and specificit y by defining class  
RECTANGLE  as an heir to class POLYGON . This makes all the features of POLYGON  — 
called a parent  o f  RECTANGLE  — by default applicable to the heir class as well. It  
suffices to give RECTANGLE  an inheritance clause : 
class  RECTANGLE inherit
POLYGON
feature
… Features specifi c to rectangles … 
end
The feature  clause of the heir class does not repeat the features of the p arent: they  
are automatically available becau se of the inheritance clause. It will only list features that  
are specific to the heir. These may be new features, such as diagonal ; but they may also  
be redefinitions of inherited features.
The second possibility is useful  for a feature that was already  meaningful for the  
parent but requires a differen t form in the heir. Consider perimeter .  I t  h a s  a  b e t t e r  
implementation for rectangles: no need to compute four vertex-t o-vertex distances; the  
result is simply twice the sum of the two side lengths. An heir  that redefines a feature for  
the parent must announc e it in the inherita nce clause  through a  redefine  subclause: 
class  RECTANGLE inherit
POLYGON
redefine  perimeter end
feature
…
endThe list interface will 
be discussed in “ACTIVE DATA STRUCTURES”, 23.4, page 774.
§14.1   POLYGONS AND RECTANGLES 463
This allows the feature  c l a u s e  o f  RECTANGLE  to contain a new version of  
perimeter , which will supersede the POLYGON  version for rectangles. If the redefine
subclause were not present , a new declaration of perimeter  among the features of  
RECTANGLE  w o u l d  b e  a n  e r r o r :  s i n c e  RECTANGLE  a l r e a d y  h a s  a  perimeter  f e a t u r e  
inherited from POLYGON , this would amount to decl aring a feature twice.
The RECTANGLE  class looks like  the following: 
note
description : "Rectangles , viewed as a special case of general polygons "
class  RECTANGLE inherit
POLYGON
redefine  perimeter end
creation
make
feature -- Initialization
make (center : POINT ; s1, s2, angle : REAL )
-- Set up rectangle centered at center , with side lengths
-- s1 and s2 and orientation angle .
do … end
feature -- Access
side1 , side2 : REAL
-- The two side lengths
diagonal : REAL
-- Length of the diagonal
perimeter : REAL
-- Sum of edge lengths
-- (Redefinition of the POLYGON  version)
do
Result  := 2  (side1 + side2 )
end
invariant
four_sides : count = 4
first_side : (vertices   i_th (1))  distance (vertices   i_th (2)) = side1
second_side : (vertices   i_th (2))  distance (vertices   i_th (3)) = side2
third_side : (vertices   i_th (3))  distance (vertices   i_th (4)) = side1
fourth_side : (vertices   i_th (4))  distance (vertices   i_th (1)) = side2
end
Because RECTANGLE  is an heir of POLYGON , all features of the parent class are  
still applicable to the new class: vertices , rotate , translate , perimeter  (in redefined form)  
and any others. They do not need  to be repeated in the new clas s. 
This process is transitive: any class that inherits from RECTANGLE , say SQUARE , 
also has the POLYGON  features.123 4
side1side2
For a list , i_th (i) 
gives the element at position i (the i-th 
element , hence the 
name of the query ).
INTRODUCTION TO INHERITANCE  §14.1 464
Basic conventions and terminology
The following terms will be usef ul in addition to “heir” and “p arent”.
In the literature you will also e ncounter the terms “subclass” and “superclass”, but  
we will stay away from them becau se they are ambiguous; sometim es “subclass” means  
heir (immediate descendant), sometimes it is used in the more g eneral sense of proper  
descendant, and it is not always clear which. In addition, we w ill see that the “subset”  
connotation of this word is not always justified.
Associated terminology applies to  the features of a class: a fe ature is either inherited
(coming from a pro per ancestors) or immediate  (introduced in the class itself).
In graphical representations of object-oriented software struct ures, where classes are  
represented by ellipses (“yy-bub bles”), inheritance links will appear as single arrows. This  
distinguishes them from links fo r the other basi c inter-class r elation, client, which as you  
will recall uses a double arrow. (For further distinction this book uses black for client and  
color for inh eritance.)
A redefined feature is marked ++, a convention from the Business Object Notation  
(B.O.N.).
The arrow points upward, from the heir to the parent; the conve ntion, easy to  
remember, is that it represents the relation “inherits from”. I n some of the literature you  
will find the reverse practice; a lthough in general such choice s of graphical convention are  
partly a matter of taste, in thi s case one convention appears d efinitely better than the other  
—  i n  t h e  s e n s e  t h a t  o n e  s u g g e s t s  t h e  p r o p e r  r e l a t i o n s h i p  a n d  t h e other may lead to  
confusion. An arrow is not just an arbitrary pictogram but indi cates a unidirectional link,  
between the two ends  of the arrow. Here:Inheritance terminology
A descendant  of a class C is any class that inherits d irectly or indirectly from  
C, including C itself. (Formally: either C or, recursively, a descendant of an  
heir of C.)
A proper descendant  of C is a descenda nt other than C itself.
An ancestor  of C is a class A such that C is a descendant of A. A proper  
ancestor  of C is a class A such that C is a proper descendant of A. 
An inheritance 
linkPOLYGON
RECTANGLEperimeter
diagonal
perimeter++Inherits from
§14.1   POLYGONS AND RECTANGLES 465
• Any instance of the heir may be viewed (as we shall see in mor e detail) as an instance  
of the parent, but not conversely.
• The text of the heir will alway s mention the pa rent (as in the  inherit  clause above),  
but not conversely; it is in fact  an important property of the method, resulting among  
others from the Open-Closed principle, that a class does not “k now” the list of its  
heirs and other pr oper descendants.
Mathematically, the direction of the relationship is reflected in algebraic models for  
inheritance, which use a morphism  (a generalization of the notion of function) from the  
heir’s model to the parent’s model — not the other way around. One more reason for  
drawing the arrow from the heir to the parent.
Although with complex systems we cannot have an absolute rule f or class placement  
in inheritance diagrams, we should try whenever possible to pos ition a class above its heirs.
Invariant inheritance
You will have noticed the invariant of class RECTANGLE , which expresses that the number  
of sides is four and  that the successive  edge lengths are side1 , side2 , side1  and side2 .
Class POLYGON  also had an invariant, which  still applies to its heir:
Because the parents may themselv es have parents, this rule is r ecursive: in the end  
the full invariant of a class is obtained by anding the invariant clauses of all its ancestors.
The rule reflects one of the basic characteristics of inheritan ce: to say that B inherits  
from A is to state that one may view any instance of B also as an instance of A (more on  
this property later). As a resul t, any consistency constraint a pplying to instances of A, as 
expressed by the invariant, a lso applies to instances of B.
In the example, the second clause ( at_least_three ) invariant of POLYGON  stated that  
the number of sides must be at l east three; this is subsumed by  the four_sides subclause  in 
RECTANGLE ’s invariant clause , which requires it to be exactly four.
You may wonder what would happen if the heir’s clause, instead of making the parent’s  
redundant as here (since count = 4 implies count >= 3), were incompatible with it, as with  
an heir of POLYGON that would introduce the invariant clause count  = 2. The result is  
simply an inconsistent invariant, not different from what you g et if you include, in the  
invariant of a single class, two separate subclauses  that re ad count >= 3 and count = 2.
Inheritance and creation
Although it was not shown, a creation procedure for POLYGON  might be of the formInvariant inheritance rule
The invariant pr operty of a class is the boolean and of the assertions appearing  
in its invariant  clause and of the inv ariant properties of  its parents if any.
INTRODUCTION TO INHERITANCE  §14.1 466
make_  polygon (vl: LINKED_LIST [POINT ])
-- Set up with ver tices taken from vl.
require
vl  count >= 3
do
… Initialize polygon represen tation from the items of vl …
ensure
-- vertices and vl have the same items (can be expressed formally)
end
This procedure takes a list of po ints, containing at least thre e elements, and uses it to  
set up the polygon.
The procedure has been given a special name make_  polygon  to avoid any name conflict  
when RECTANGLE inherits it and introduces its own creation procedure make . This is  
not the recommended style; in the next chapter we will learn ho w to give the standard  
name make  to the creation procedure in POLYGON , and use renaming in the inheritance  
clause of RECTANGLE to remove any name clash.
The creation procedure of class RECTANGLE , shown earlier, took four arguments:  
a point to serve as ce nter, the two side l engths and an orienta tion. Note that feature vertices
is still applicable to rectangles ; as a consequen ce, the creati on procedure of RECTANGLE
should set up the vertices  list with the appropriate point  values (the four corners, to b e 
computed from the center, side le ngths and orientation given as  arguments). 
The creation procedure for general polygons is awkward for rect angles, since only  
lists of four elements satisf ying the invariant of class RECTANGLE  would be acceptable.  
Conversely, the creation procedur e for rectangles is not approp riate for arbitrary polygons.  
This is a common case: a parent’s  creation procedure is not nec essarily right as creation  
procedure for the heir. The prec ise reason is easy to spot; it follows from the observation  
that a creation procedure’s form al role is to es tablish the cla ss invariant. The parent’s  
creation procedure was required to establish the parent’s invar iant; but, as we have seen,  
t h e  h e i r ’ s  i n v a r i a n t  m a y  b e  s t r o nger (and usually is); we canno t then expect that the  
original procedure  will guarantee the  new invariant.
In the case of an heir adding new attributes, the creation proc edures might need to  
initialize these attributes and s o require extra arguments. Hen ce the general rule:
An inherited creation procedure is still available to the heir as a normal feature of the  
class (although, as we shall see, the heir may prefer to make i t secret); but it does not by  
default retain its status as a creation procedure. Only the pro cedures listed in the heir’s  
own creation  clause have that status.Creation Inheritance rule
An inherited feature’s creation status in the parent class (tha t is to say,  
whether or not it is a creation procedure) has no bearing on it s creation status  
in the heir.See “FEATURE 
RENAMING”, 15.2, page 535 .
§14.2   POLYMORPHISM 467
In some cases, of course, a pare nt’s creation procedure may sti ll be applicable as a  
creation procedure; the n you will simply list it in the creatio n clause:
class B inherit
A
creation
make
feature
…
where make  is inherited — withou t modification — from A, which also listed it in its own  
creation  clause.
An example hierarchy
For the rest of the di scussion it will be us eful to consider th e POLYGON -RECTANGLE
example in the context of a more general inheritance hierarchy of geometrical figure types,  
such as the one shown on the next page.
Figures have been classified into open and closed variants. Alo ng with polygons, an  
example of closed figure is the ellipse; a speci al case of the ellipse is the circle.
Various features appear next to the applicable classes. The sym bol ++, as noted,  
means “redefined”; the symbols + and * will be explained later.
In the original example, for simplicity, RECTANGLE  was directly an heir of  
POLYGON . Since the sketched classification of polygons is based on the  number of  
vertices, it seems preferable to introduce an intermediate clas s QUADRANGLE , at the  
same level as TRIANGLE , PENTAGON  and similar classes. Feature diagonal  c a n  b e  
moved up to the level of QUADRANGLE .
N o t e  t h e  p r e s e n c e  o f  SQUARE , an heir to RECTANGLE , characterized by the  
invariant side1 = side2 . Similarly, an ellipse   has two focuses (or foci), which for  
a circle  are the same point, giving CIRCLE  an invariant property of the form  
equal  (focus1 = focus2 ).
14.2  POLYMORPHISM
Inheritance hierarchies will giv e us considerable flexibility f or the manipulation of  
objects, while retaining the safe ty of static typing. The suppo rting techniques,  
polymorphism and dynamic binding , address some of the fundament al issues of software  
architecture discussed in part B of this book. Let us be gin with polymorphism.
Polymorphic attachment
“Polymorphism” means the ability to take several forms. In obje ct-oriented development  
what may take several forms is a  variable entity or data struct ure element, which will have  
the ability, at run time, to become attached to objects of diff erent types, all controlled by  
the static declaration.
INTRODUCTION TO INHERITANCE  §14.2 468
OPEN_
FIGURE
SEGMENT POLYLINE
POLYGON ELLIPSE
QUADRANGLECIRCLETRIANGLEdisplay *
rotate *extent *
…barycenter *
…
perimeter *
perimeter+
diagonal
SQUAREperimeter++perimeter++perimeter+CLOSED_
FIGUREFIGURE
RECTANGLE perimeter++
side1 , side2∗
∗ ∗Figure type 
hierarchy
§14.2   POLYMORPHISM 469
A s s u m e ,  w i t h  t h e  i n h e r i t a n c e  s t r u c t u r e  s h o w n  i n  t h e  f i g u r e ,  t h e  following  
declarations using short b ut mnemonic entity names:
p: POLYGON ; r: RECTANGLE ; t: TRIANGLE
Then the follo wing assignments are valid:
p := r
p := t
These instructions assign to an entity denoting a polygon the v alue of an entity  
denoting a recta ngle in the first case, a  triangle in the secon d.
Such assignments, in which the type of the source (the right-ha nd side) is different  
from the type of the target (the left-hand side), are called polymorphic assignments . An 
entity such as p which appears in some pol ymorphic assignment is a polymorphic entity .
Before the introduction of inheri tance, all our assignments wer e monomorphic (non-
polymorphic): we could assign — in the various examples of earl ier chapters — a point to  
a point, a book to a book, an ac count to an account. With polym orphism, we are starting  
to see more action on the attachment scene.
The polymorphic assignments take n  a s  e x a m p l e  a r e  l e g i t i m a t e :  t h e inheritance  
structure permits us t o view an instance of RECTANGLE  or TRIANGLE as an instance of  
POLYGON . We say that the type of the source conforms to  the type of the target. In the  
reverse direction, as with r := p, the assignment would not be valid. This fundamental type  
rule will be discussed i n more detail shortly.
Instead of an assignment, you may achieve polymorp hism through argument passing,  
as with a call of the form f (r) or f (t) and a feature declar ation of the form
f ( p: POLYGON ) do … end
As you will remember, assignment and argument passing have the same semantics,  
and are together called attachment ; we can talk of polymorphic  attachment when the  
source and target have different types.
What exactly happens during a polymorphic attachment?
All the entities appear ing in the preceding cases of polymorphi c  a t t a c h m e n t  a r e  o f  
reference types: the possible values for p, r and t are not objects but r eferences to objects.  
So the effect of an assignment such as p := r is simply to reattach a reference:
Polymorphic 
reference 
reattachment(POLYGON )O1
p
r
(RECTANGLE )O2(after )(before )

INTRODUCTION TO INHERITANCE  §14.2 470
So in spite of the name you shoul d not imagine, when thinking o f polymorphism,  
some run-time transmutation of obj ects. Once created, an object  never changes its type.  
Only references do so by getting  reattached to objects of diffe rent types. This also means  
that polymorphism does not carry any efficiency penalty; a refe rence reattachment — a  
very fast operation — costs the same regardless of the objects involved.
Polymorphic attachments will only be permitted for targets of a  reference type — not  
for the other case, expanded types. Since a descendant class ma y introduce new attributes,  
t h e  c o r r e s p o n d i n g  i n s t a n c e s  m a y  h a v e  m o r e  f i e l d s ;  t h e  l a s t  f i g u re suggested this by  
showing the RECTANGLE  object bigger than the POLYGON  object. Such differences in  
object size do not cause any problem if all we are reattaching is a reference. But if instead  
o f  a  r e f e r e n c e  p is of an expanded type (bei ng for example declared as expanded
POLYGON ), then the value of p is directly an object, and any assignment to p would  
overwrite the contents of that object. No polymorphism is possi ble in that case.
Polymorphic data structures
Consider an array of polygons:
poly_arr : ARRAY [POLYGON ]
When you assign a value x to an element of the array, as in
poly_arr   put (x, some_index )
(for some valid integer index value some_index ), the specification of class ARRAY
indicates that the ass igned value’s type must conform to the ac tual generic parameter:
class ARRAY [G] creation
…
feature  -- Element change
put (v: G; i: INTEGER )
-- Assign v to the entry of index i
…
end
Because v, the formal argument corresponding to x, is declared of type G in the class,  
and the actual generic parameter corresponding to G is POLYGON  in the case of poly_arr , 
the type of x must conform to POLYGON . As we have seen, this does not require x to be 
of type POLYGON : any descendant of POLYGON  is acceptable.
So assuming that the array has b ounds 1 and 4, t hat we have dec lared some entities as
p: POLYGON ; r: RECTANGLE ; s: SQUARE ; t: TRIANGLE
and created the correspondi ng objects, we may execute
poly_arr   put (p, 1)
poly_arr   put (r, 2)
poly_arr   put (s, 3)
poly_arr   put (t, 4)
yielding an array of references to objects of di fferent types:See “COMPOSITE 
OBJECTS AND EXPANDED TYPES”, 8.7, page 254 .
This is extracted 
from class ARRAY  as 
it appears on page 372.
§14.2   POLYMORPHISM 471
The graphical objects have been represented by the correspondin g geometrical shapes  
rather than the usual multi-field object diagrams.
Such a data structure, containing objects of different types (a ll of them descendants  
of a common type), are called polymorphic data structures . We will encounter many  
examples in later disc ussions. The use of ar rays is just one po ssibility; any other container  
structure, such as a list or sta ck, can be polymorphic in the s ame way.
The introduction of pol ymorphic data structures achieves the ai m, stated at the  
beginning of chapter 10, of combining genericity and in heritance for ma ximum flexibili ty 
and safety. It is worth recalling the figure that illustrated t he idea:
Types that were informally called SET_OF_BOOKS  and the like on the earlier figure  
have been replaced with generi cally derived types, such as SET [BOOK ].
This combination of genericity a nd inheritance is powerful. It enables you to  
describe object structures that are as general as you like, but  no more. For example:(POLYGON )(RECTANGLE )(SQUARE )(TRIANGLE )
134
2A polymorphic 
array
LIST [PERSON ] LIST [BOOK ] LIST [JOURNAL ]SET [BOOK ]
LINKED_LIST [BOOK ]Abstraction
SpecializationType parameterization Type parameterizationDimensions of 
generalization
(See page 317.)
INTRODUCTION TO INHERITANCE  §14.3 472
•LIST [RECTANGLE ]: may contain squares, but n ot triangles.
•LIST [POLYGON ]: may contain squares, rectangle s, triangles, but not circles.
•LIST [FIGURE ]: may contain instances of a ny of the classes in the FIGURE
hierarchy, but not boo ks or bank accounts.
•LIST [ANY]: may contain objects of arbitrary types.
The last case uses class ANY, which by convention is a n ancestor to all classes.
By choosing as actual generic parameter a class at a varying pl ace in the hierarchy,  
you can set the limits of what your container will accept.
14.3  TYPING FOR INHERITANCE
That the remarkable flexibility p rovided by inheritance does no t come at the expense of  
reliability follows from the use of a statically typed  approach, in which we guarantee at  
compile time that no incorrect ru n-time type combination can oc cur.
Type consistency 
Inheritance is consistent with th e type system. The basic rules  are easy to explain on the  
above example. Assume the following declarations: 
p: POLYGON
r: RECTANGLE
referring to the earlier inherit ance hierarchy, of which the re levant extract is this:We will study ANY in 
“Universal classes”, page 580 .
POLYGON
QUADRANGLEperimeter+
diagonal
RECTANGLEperimeter++
side1 , side2display *
rotate *extent *
…barycenter *
…FIGURE∗
§14.3   TYPING FOR INHERITANCE 473
Then the followi ng are valid: 
•p  perimeter : no problem, since perimeter  is defined for polygons. 
•p  vertices , p  translate (…), p  rotate (…) with valid arguments. 
•r  diagonal , r  side1 , r  side2 : the three features consi dered are declared at the  
RECTANGLE  or QUADRANGLE  level. 
•r  vertices , r  translate (…), r  rotate (…): the features considered are declared at the  
POLYGON  level or above, and so are applicable to rectangles, which inh erit all  
polygon features. 
•r  perimeter : same case as the previous one.  The version of the function to  be called  
here is the redefi nition given in RECTANGLE , not the original in POLYGON . 
The following feature calls, however, are illegal since the fea tures considered are not  
available at the polygon level:
p  side1
p  side2
p  diagonal
These cases all result from the first fundamental typing rule:
Recall that the ancestors of C include C itself. The phrasing “where the type of x is 
based on a class C   ” is a reminder that a type may involve more than just a class name if  
the class is generic: LINKED_LIST [INTEGER ] is a class type “base d on” the class name  
LINKED_LIST ; the generic parameters p lay no part in this rule. 
Like all other validity rules re viewed in this book, the Featur e Call rule is static; this  
means that it can be checked on the sole basis of a system’s te xt, rather than through run-
time controls. The compiler (whi ch typically is the tool perfor ming such checking) will  
reject classes containing invali d feature calls. If we succeed in defining a set of tight-proof  
type rules, there will be no ris k, once a system has been compi led, that its execution will  
ever apply a fea ture to an object that i s not equipped to handl e it. 
Static typing is one of object t echnology’s main resources for achieving the goal of  
software reliability, introduced  in the first chapter of this b ook.
It has already been mentioned that not all approaches to object -oriented software  
construction are statically typed; the best-known representativ e of dynamically typed
languages is Smalltalk, which has no static Feature Call rule b ut will let an execution  
terminate abnormally in the case of a “message not understood” run-time error. The  
chapter on typing will compare the various approaches further.Feature Call rule
In a feature call x  f, where the type of x is based on a class C, feature  f  must 
be defined in one of the ancestors of C. 
Chapter 17 dis-
cusses typing .
INTRODUCTION TO INHERITANCE  §14.3 474
Limits to polymorphism 
Unrestrained polymorph ism would be incompati b l e  w i t h  a  s t a t i c  n otion of type.  
Inheritance governs wh ich polymorphic attachments are permissib le.
The polymorphic attachments used as examples, such as p := r and p := t, all had as  
source type a descendant of the t arget’s class. We say that the  source type conforms  to the  
target class; for example SQUARE conforms to RECTANGLE  and to POLYGON  but not to  
TRIANGLE . This notion has already been u sed informally but we need a pr ecise definition:
Why is the notion of descendant not sufficient? The reason is a gain that since we  
encountered genericity we have ha d to make a technical distinct ion between types and  
classes. Every type has a base class , which in the absence of ge nericity is the type itself  
(for example POLYGON  is its own base class), but for a generically derived type is the 
class from which the type is built; for example the base class of LIST [POLYGON ] is LIST . 
The second part of the def inition indicates that B [Y] will conform to A [X] if B i s  a 
descendant of A and Y a descendant of X.
Note that, as every class is a d escendant of itself, so does ev ery type conform to itself.
With this generalizati on of the notion of de scendant we get the  second fundamental  
typing rule:
The Type Conformance rule express es that you can assign from th e more specific to  
the more general, but not conversely. So p := r is valid but r := p is invalid.
The rule may be illustrated like this. Assume I am absent-minde d enough to write just  
“Animal” in the order form I send to the Mail-A-Pet company. Th en, whether I receive a  
dog, a ladybug or a killer whale, I have no right to complain. (The hypothesis is that  
classes DOG  etc. are all descendants of ANIMAL .) If, on the other hand, I specifically  
request a dog, and the mailman brings me one morning a box with  a label that reads  
ANIMAL , or perhaps MAMMAL  (an intermediate ancestor), I am entitled to return it to  
the sender — even if from the box come unmistakable sounds of y elping and barking.  
Since my order was not fulfille d as specified, I shall owe noth ing to Mail-A-Pet. Definition: conformance
A type U conforms to a type T only if the b ase class of U is a descendant of  
the base class of T; also, for generically derived  types, every actual parameter  
of U must (recursively) co nform to the corresp onding formal paramet er in T.
Type Conformance rule
An attachment of target x and source y (that is to say, an assignment x := y, or 
the use of y as an actual argument to a routine call where the correspondin g 
formal argument is x) is only valid if the type of y conforms to the type of x.See “Types and 
classes”, page 324 .
§14.3   TYPING FOR INHERITANCE 475
Instances
With the introduction of polymor phism we need a more specific t erminology to talk about  
instances. Informally, the insta nces of a class are the run-tim e objects built according to  
the definition of a class. But now  w e  m u s t  a l s o  c o n s i d e r  t h e  o b jects built from the  
definition of its prope r descendants. Hence the more precise de finition:
The last part of this definition implies, since the descendants  of a class include the class  
itself, that a direct instance of C is also an instance of C.
So the execution of
p1, p2: POLYGON ; r: RECTANGLE
… 
create  p1 …; create  r …; p2 := r
will create two instances of POLYGON  but only one direct instance (the one attached to  
p1). The other object, to whic h the extract attaches both p2 and r, is a direct instance of  
RECTANGLE — and so an instance of both POLYGON  and RECTANGLE .
Although the notions of instance and direct instance are define d above for a class,  
they immediately extend to any ty pe (with a base class and poss ible generic parameters).
Polymorphism means that an entit y of a certain type may become attached not only  
to direct instances of that type , but to arbitrary instances. W e may indeed consider that the  
role of the type confo rmance rule is to ensu re the following pr operty:
Static type, dynamic type 
The name of the last property su ggests the concepts of “static type” and “dynamic type”.  
The type used to declare an entity is the static type  of the corresponding reference. If, at  
run time, the referenc e gets attached to an object of a certain  type, this type becomes the  
dynamic type of the reference.
So with the declaration p: POLYGON , the static type of the reference that p denotes  
is POLYGON ; after the execution of create  p, the dynamic type of that reference is also  
POLYGON ; after the assignment p := r, with r of type RECTANGLE  and non-void, the  
dynamic type is RECTANGLE .Definition: direct instance, instance
A direct instance of a class C is an object produced according to the exact  
definition of C, through a creation instruction create  x… where the target x
is of type C (or, recursively, by clon ing a direct instance of C).
An instance of C is a direct instance  of a descendant of C.
Static-dynamic type consistency
An entity declared of a type T may at run time only become attached to  
instances of T.The original discus-
sion was “The mold and the instance”, page 167 .
INTRODUCTION TO INHERITANCE  §14.3 476
The Type Conformance rule states  that the dynamic type must alw ays conform to the  
static type. 
To avoid any confusion remember that we are dealing with three levels: an entity  is 
an identifier in the class text; at run time its value is a reference  (except in the expanded  
case); the reference ma y get attached to an object . Then:
• An object only has a dynamic t ype, the type with which it has been created. That type  
will never change during the object’s lifetime.
•At any time during execution, a reference has a dynamic type, t he type of the object  
to which it is currently att ached (or the special type NONE  if the reference is void).  
The dynamic type may c hange as a result of reattachment operati ons.
• Only an entity has both a static  type and dynamic types. Its s tatic type is the type with  
w h i c h  i t  w a s  d e c l a r e d :  T if the declaration was x: T. Its dynamic type at some  
execution-time instant is the ty pe of its reference value, mean ing the type of the  
attached object.
In the expanded case there is no reference; the value of x is an object of type T, and x has 
T as both its static type and a s its only possible dynamic type.
Are the restrictions justified? 
T h e  t w o  t y p i n g  r u l e s  m a y  s o m e t i m e s  s e e m  t o o  r e s t r i c t i v e .  F o r  e x ample, the second  
instruction in both of  the following sequenc es will be statical ly rejected: 
R1 •p:= r; r := p
R2 •p := r; x := p  diagonal
In R1, we refuse to assign a polygon to a rectangle entity even thou gh that polygon  
happens at run time to be a rect angle (like refusing to accept a dog because it comes in a  
box marked “animal”). In R 2, we decide that diagonal  is not applicable to p even though  
at run time it would in fact b e — as it were by accident. 
But closer examination of these examples confirms that the rule s are justified. If you  
attach a reference to an object, better avoid later problems by  making sure that they are of  
compatible types. And if you wan t to apply a rectangle operatio n, why not declare the  
target as a rectangle? 
In practice, cases of the form R 1 and R 2 are unlikely. Assignments such as p := r
will normally occur as part of some control structure that depe nds on run-time conditions,  
such as user input. A more reali stic polymorphic scheme may loo k like this:
create  r  make (…); …
screen   display_icons -- Display icons represent ing various polygons
screen   wait_for_mouse_click -- Wait for the user to click the mouse button
x := screen   mouse_  position -- Find out at what position  
-- the mouse was clicked
chosen_icon  := screen   icon_where_is (x) -- Find out what ic on appears at the  
-- mouse’s positionSee “States of a refer-
ence”, page 240 .
NONE  will be seen in 
“The bottom of the pit”, page 582 .
§14.3   TYPING FOR INHERITANCE 477
if chosen_icon = rectangle_icon then
p := r
elseif  …
 p := “Some other type of polygon”  …
º
end
… Uses of p, for example p  display , p  rotate , …
On the last line, p can denote arbitrary polygons, so you should on ly apply genera l 
POLYGON features. Clearly, operations va lid for rectangles only, such a s diagonal , 
should be applied to r only (for example in the first clause of the if). Where p as such is  
going to be used, in the i nstructions following the if instruction, only operations defined  
for all variants of polygo ns are applicable to it.
In another typical case, p could just be a forma l routine argument:
some_routine (p: POLYGON ) is… 
and you execute a call some_routine (r), valid as per the Type Conformance rule; but when  
you write the r outine you do not know ab out this call. In fact a call some_routine (t) for t
or type TRIANGLE ,  o r  a n y  o t h e r  d e s c e n d a n t  o f  POLYGON  f o r  t h a t  m a t t e r ,  w o u l d  b e  
equally valid, so all you can assume is that p represents some kind of polygon — any kind 
of polygon. It is quite appropria te, then, that y ou should be r estricted to applying  
POLYGON  features to p.
I t  i s  i n  t h i s  k i n d  o f  s i t u a t i o n  — where you cannot predict the exact type of the  
attached object — that pol ymorphic entities such as p are useful.
Can ignorance be bliss?
I t  i s  w o r t h w h i l e  r e i n f o r c i n g  t h e  l a s t  f e w  p o i n t s  a  b i t  s i n c e  t h e concepts now being  
introduced will be so important in the rest of our discussion. (There will be nothing really  
new in this short section, but i t should help you understand th e basic concepts better,  
preparing you for the more a dvanced ones which follow.)
If you are still uneasy at the impossibility of writing p  diagonal  even after a call  
p :=r — case R 2 — you are not alone; this is a shock to many pe ople when they start 
grappling with these c oncepts. We know that p is a rectangle becaus e of the assignment,  
so why may we not access its diagonal? For one thing, that woul d be useless. After the  
polymorphic assignment, as shown  in the following extract from an earlier figure, the  
same RECTANGLE object now has two names, a polygon name p and a rectangle name r:
After a 
polymorphicattachmentp
r(RECTANGLE )O2
INTRODUCTION TO INHERITANCE  §14.3 478
In such a case, since you do know  that the object O2 is a recta ngle and have access  
to it through its rectangle name r, why would you write a diag onal access operation in the  
form p  diagonal ? This is uninteresting since you can just write it as r  diagonal ; using the  
o b j e c t ’ s  o f f i c i a l  r e c t a n g l e  n a m e  r e m o v e s  a n y  d o u b t  a s  t o  t h e  v a lidity of applying a  
rectangle operation. U sing the polygon name p, which could just as well denote a triangle  
object, brings nothing and introduces uncertainty.
Polymorphism, in fact, loses  information: when as a re sult of the assignment p := r
you are able to refer to the rectangle object O2 under its poly gon name p, you have lost  
something precious: the ability to use rectangle-specific featu res. What then is the  
purpose? In this case, there is none. The only interesting appl ication, as noted, arises when  
you do not know for su re what kind of polygon p is, as a result of a conditional instruction  
if some_condition  then  p:= r else p := something_else …, or because p is a formal routine  
argument and you do not know wha t the actual argument will be. But then in such cases it  
would be incorrect and d angerous to apply to p anything else than POLYGON  features.
To continue with the animal theme, imagine that someone asks “d o you have a pet?”  
and you answer “yes, a cat!”. This is similar to a polymorphic assignment, making a  
single object known through two names of different types: “ my_ pet” and “ my_cat ” 
now denote the same animal. But they do not serve the same purp ose; the first has less  
information than the second. You can use either name if you cal l the post-sales division  
of Mail-A-Pet, Absentee Owner Department (“ I am going on holiday ; what’s your price  
for keeping my_  pet [or: my_cat ] for two weeks ”); but if you phone their Destructive  
Control Department to ask “ Can I bring my_  pet for a de-clawing Tuesday ?”, you 
probably will not get an appointment until the employee has mad e you confirm that you  
really mean my_cat .
When you want to force a type
In some special cases there may b e a need to try an assignment going against the grain of  
inheritance, and accept that the  result is not guaranteed to yi eld an object. This does not  
normally occur, when you are pro perly applying the object-orien ted method, with objects  
that are internal to a certain s oftware element. But you might for example receive over the  
network an object advertized to be of a certain type; since you  have no control over the  
origin of the object, static type  declarations will guarantee n othing, and you must test the 
type before accepting it.
When we receive that box marked “Animal” rather than the expect ed “Dog”, we might  
be tempted to open the “Animal” box anyway and take our chances , knowing that if its  
content is not the expected dog we will have forfeited our righ t to return the package, and  
depending on what comes out of it we may not even live to tell the story.
Such cases require a new mechanism, assignment attempt , which will enable us to  
write instructions  of the form r ?= p (where  ?= is the symbol for assignment attempt,  
versus  := for assignment), meaning “do the assignment if the object ty pe is the expected  
one for r, otherwise make r void”. But we are not equipped  yet to understand how this  
instruction fits in th e proper use of the object-oriented metho d, so we will have to return  
to it in a subsequent chapter. ( Until then, you did not read ab out it here.)See “ASSIGNMENT 
ATTEMPT”, 16.5, page 591 .
§14.3   TYPING FOR INHERITANCE 479
Polymorphic creation
The introduction of inheritance an d polymorphism suggests a sma ll extension to the  
mechanism for creating objects, a llowing direct creation of obj ects of a descendant type.
The basic creation instruction, as you will recall, is of one o f the forms
create  x
create  x  make (…)
where the second form both assumes and requires that the base c lass of x’s type T contain  
a creation  clause listing make  as one of the creat ion procedures. (A creation procedure  
may of course have any name; make  is the recommended default.) The effect of the  
instruction is to create a new object of type T, initialize it to the default values, and attach  
it to x. In addition, the second form will apply make , with the arguments given, to the just  
created and initialized object.
Assume that T has a proper descendant U. W e may want to use x polymorphically  
and, in some cases, make it denote a newly created direct insta nce of U rather than T. A 
possible soluti on uses a local entity of type U:
some_routine (…)
local
u_temp : U
do
…; create  u_temp   make (…); x := u_temp ; …
end
This works but is cumbersome, es pecially in a multi-choice cont ext where we may  
want to attach x to an instance of one of severa l possible descendant types. Th e local  
entities, u_temp  above, play only a temporary pa rt; their declarations and assi gnments  
clutter up the software text. Hen ce the need for a variant of t he creation instruction:
create {U} x
create  {U} x  make (…)
The effect is the same as with the create  forms, except that the created object is a  
direct instance of U rather than T. The constraint on using th is variant is obvious: type U
must conform to type T an d,  i n t he  se co nd  f or m ,  make must be defined as a creation  
procedure in the base class of U; if that class indeed has one or more creation procedures,  
only the second form is valid. Note that whether T ’s own base class has creation  
procedures is irrelevant her e; all that counts is what U requires.
A typical use involves creation of an instance o f one of severa l possible types:See “The creation 
instruction”, page 232 ,
and “CREATION PROCEDURES”, 8.4,page 236 .
INTRODUCTION TO INHERITANCE  §14.4 480
f: FIGURE
…
“Display a set of figure icons”
if chosen_icon = rectangle_icon then
create  {RECTANGLE } f
else if chosen_icon = circle_icon  then
create  {CIRCLE } f
else
…
end
This new form of creation instru ction suggests introducing the notion of creation  
type of a creation instruction, denot ing the type of the object tha t will be created: 
• For the implicit-type form create  x …, the creation type is the type of x.
• For the explicit-type form create  {U} x …, the creation type is U.
14.4  DYNAMIC BINDING
Dynamic binding will complement redefinition, polymorphism and static typing to make  
up the basic tetralogy of inheritance.
Using the right variant
Operations defined for a ll polygons need not be implemented  identically for all variants.  
For example, perimeter  has different versions for general polygons and for rectangles ; let 
us call them perimeterPOL a n d  perimeterRECT . Class SQUARE will also have its own  
variant (yielding four times the side length). You may imagine further variants for other  
special kinds of polygon. This i mmediately raises a fundamental  question: what happens  
when a routine with more than one  version is applied to a polym orphic entity?
In a fragment such as 
create  p  make (…); x := p  perimeter
it is clear that perimeterPOL will be applied. It is j ust as clear that in 
create  r  make (…); x := r  perimeter
perimeterRECT  will be applied. But what if the polymorphic entity p, statically declared as  
a polygon, dynamically refers to  a rectangle? Assume you have e xecuted 
create  r  make (…)
p := r
x := p  perimeter
The rule known as dynamic binding  implies that the dynamic form of the object
determines which version of the operation to apply. Here it wil l be perimeterRECT .
§14.4   DYNAMIC  BINDING 481
As noted, of course, the more in teresting case arises when we c annot deduce from a  
mere reading of the software t ext what exact dynamic type p will have at run time, as in
-- Compute perimeter of figure built according to user choice
p: POLYGON 
… 
if chosen_icon = rectangle_icon then
{RECTANGLE } p  make (…)
elseif chosen_icon = triangle_icon then
create  {TRIANGLE } p  make (…)
elseif
…
end
… 
x := p  perimeter
or after a conditional polymorphic assignment if … then p := r elseif … then p := t…; or 
if p is an element of a polymorphic array of polygons; or simply if  p is a formal argument,  
declared of type POLYGON , of the enclosing routine — to which callers can pass actual  
arguments of any  conforming type. 
Then depending on what happens i n any particular execution, the  dynamic type of p
will be  RECTANGLE , or TRIANGLE , and so on. You have no way to know which of these  
cases will hold. But thanks to  dynamic bindi ng you do not need  to know: whatever p 
happens to be, the c all will execute the proper variant of perimeter .
This ability of operations to ad apt automatically to the object s to which they are  
applied is one of the most impo rtant properties of object-orien ted systems, directly  
addressing some of the principal  quality issues discussed at th e beginning of this book. We  
will examine its consequences in  detail later in this chapter. 
Dynamic binding also gives the f ull story about t he information -loss aspects of  
polymorphism discussed earlier. Now we really understand why it  is not absurd to lose  
information about an objec t: after an assignment p := q, or a call some_routine  (q) where  
p is the formal argument, we have  lost the type information spec ific to q but we can rest  
assured that if we apply an operation p  polygon_feature where polygon_feature  h a s  a  
special version applicable to q, that version will be the one selected.
It is all right to send your pets to an Absentee Owner Departme nt that caters to all kinds  
— provided  you know that when meal time comes your cat will get cat food and your dog  
will get dog food.
Redefinition and assertions 
If a client of POLYGON  calls p  perimeter , it expects to get the value of p’s perimeter, as  
defined by the specifi cation of function perimeter  in the definition of the class. But now,  
because of dynamic binding, the client may well be calling anot her routine, redefined in  
some descendant. In RECTANGLE , the redefinition, while impr oving efficiency, preserves  
the result; but what prevents you from redefining perimeter  to compute, say, the area?
INTRODUCTION TO INHERITANCE  §14.5 482
This is contrary to the spirit o f redefinition. Redefinition sh ould change the  
implementation of a routine, not  its semantics. Fortunately we have a way to constrain the  
s e m a n t i c s  o f  a  r o u t i n e  —  a s s e r t i o n s .  T h e  b a s i c  r u l e  f o r  c o n t r o l l i n g  t h e  p o w e r  o f  
redefinition and dynam ic binding is simple: the precondition an d postcondition of a  
routine will apply (informally s peaking) to any redefinition; a nd, as we have already seen,  
the class invariant automatically  carries over to all the desce ndants. 
The exact rules will b e given in chapter 16. But you should already note that  
redefinition is not arbitrary: o nly semantics-preserving redefi nitions are permitted. It is up  
to the routine writer to express the semantics precisely enough  to express his intent, while  
leaving enough freedom t o future reimplementers.
On the implementation of dynamic binding
One might fear that dynamic bindi ng could be a costly mechanism , requiring a run-time  
search of the inheritance graph and hence an overhead that grow s with the depth of that  
graph and becomes unacceptable w ith multiple inheritance (studi ed in the next chapter). 
Fortunately this is not  the case with a properly designed (and statically typed) O-O  
language. This issue will be dis cussed in more detail at the en d of this chapter, but we can  
already reassure ourselves that efficiency consequences of dyna mic binding should not be  
a concern for developers worki ng with a decent environment.
14.5  DEFERRED FEATURES AND CLASSES 
Polymorphism and dynamic binding mean that we can rely on abstr actions as we design  
our software, and rest assured t hat execution will choose the p roper implementations. But  
so far everything wa s fully implemented.
We do not always need everything to be fully implemented. Abstr act software  
elements, partially implemented or not implemented at all, help  us for many tasks:  
analyzing the problem and designing the architecture (in which case we may keep them in  
the final product to remind ours elves of the analysis and desig n); capturing commonalities  
between implementations; describ ing the intermediate nodes in a  classification. 
Deferred features and classes provide the needed abstraction me chanism.
Moving arbitrary figures 
To understand the need for defer red routines and classes, consi der again the FIGURE
hierarchy, reproduced for con venience on the facing page.
The most general notion is that of FIGURE . Relying on the mechanisms of  
polymorphism and dynamic binding , you may want to apply the gen eral scheme described  
earlier, as in: 
§14.5   DEFERRED FEATURES AND CLASSES 483
transform (f: FIGURE )
-- Apply a specific transformation to f.
do
f  rotate (…)
f  translate (…)
end
with appropriate values for the missing arguments. Then all the  following calls are valid:
transform (r)- -  w i t h  r: RECTANGLE
transform (c)- -  w i t h  c: CIRCLE
transform (figarray   item (i)) -- with figarray : ARRAY [POLYGON ]
In other words, you want to apply rotate and translate  to a figure f, and let the  
underlying dynamic binding mecha nism pick the appropriate versi on (different for classes  
RECTANGLE  and CIRCLE ) depending on the actual form of f, known only at run time. OPEN_
FIGURE
SEGMENT POLYLINE
POLYGON ELLIPSE
QUADRANGLECIRCLETRIANGLEdisplay *
rotate *extent *
…barycenter *
…
perimeter *
perimeter+
diagonal
SQUAREperimeter++perimeter++perimeter+CLOSED_
FIGUREFIGURE
RECTANGLE perimeter++side1 , side2∗
∗ ∗
*   deferred
+   effected
++ redefinedThe FIGURE  
hierarchy 
again
INTRODUCTION TO INHERITANCE  §14.5 484
This should work, and is a typical example of the elegant style  made possible by  
polymorphism and dynamic binding , applying the S ingle Choice pr inciple. You should  
simply have to redefine rotate  and translate  for the various c lasses involved.
But there is nothing to redefine! FIGURE  is a very general notion, covering all kinds  
of two-dimensional figure. You have no way of writing a general -purpose version of rotate  
and translate without more information o n the figures involved. 
So here is a situation where routine transform would execute correctly thanks to  
dynamic binding, but is st atically illegal since rotate and translate are not valid features  
of FIGURE . Type checking will catch f  rotate and f  translate  as invalid operations. 
You could, of course, introduce at the FIGURE  level a rotate procedure which would  
do nothing. But this is a dangerous road to follow; rotate (center , angle ) has a well-defined  
intuitive semantics, and “do not hing” is not a proper implement ation of it. 
Deferring a feature
What we need is a way to specify rotate  and translate  at the FIGURE  level, while making  
it incumbent on descendants to pro vide actual implementations. This is achieved by  
declaring the features as “defe rred”. We replace the whole inst ruction part of the body  
(do Instructions ) by the keyword deferred . Class FIGURE will declare:
rotate (center : POINT ; angle : REAL )
-- Rotate by angle  around center .
deferred
end
and similarly for translate . This means that the feature is known  in the class where this  
declaration appears, but implemented  only in proper descendants.  Then a call such as catch  
f  rotate  in procedure transform  becomes valid. 
With such a declaration, rotate  is said to be a deferred feat ure. A non-deferred feature  
— one which has an implementatio n, such as all t he features tha t we had encountered up  
to this one — is said to be effective .
Effecting a feature
In some proper d escendants of FIGURE  you will want to replace the deferred version by  
an effective one. For example:
class POLYGON inherit
CLOSED_FIGURE
feature
rotate (center : POINT ; angle : REAL )
-- Rotate by angle  around center .
do
… Instructions to rotate all vertices (see page 461) …
end
…
end
§14.5   DEFERRED FEATURES AND CLASSES 485
Note that POLYGON  inherits the features of FIGURE  n o t  d i r e c t l y  b u t  t h r o u g h  
CLOSED_FIGURE ; procedure rotate  remains deferred in CLOSED_FIGURE .
This process of providing an eff ective version of a feature tha t is deferred in a parent  
is called effecting . (The term takes some getting used to, but is consistent: to e ffect a  
feature is to make it effective.)
A class that effects one or more  inherited features does not ne ed to list them in its  
redefine subclause, since there was no tru e definition (in the sense of an implementation)  
in the first place. It simply pr ovides an effective declaration  of the features, which must be  
type-compatible with the  original, as in the rotate  example.
Effecting is of course close to redefinition, and apart from th e listing in the redefine
subclause will be governed by the same rules. Hence the need fo r a common term:
The examples used to introduce redefinition and effecting illus trate the difference  
between these two forms of redeclaration:
• When we go from POLYGON to RECTANGLE , we already had an implementation  
of perimeter in the parent; we want to offer a new implementation in RECTANGLE . 
This is a redefinition. Note tha t the feature ge ts redefined ag ain in SQUARE .
• When we go from FIGURE  to POLYGON , we had no implementation of rotate  in 
the parent; we want to offer an implementation in POLYGON . This is an effecting.  
Proper descendants of POLYGON  may of course redefine the effected version.
There may be a need to change so me properties of an inherited d eferred feature,  
while leaving it deferred. These  properties may not include the  feature’s implementation  
(since it has none), but they ma y include the signature of the feature — the type of its  
arguments and result — and its assertions; the precise constrai nts will be reviewed in the  
next chapter. In contrast with a  redeclaration from deferred to  e f f e c t i v e ,  s u c h  a  
redeclaration from deferred to d eferred is considered to be a r edefinition and requires the  
redefine  clause. Here is a summary of th e four possible cases of redecl aration:
This shows one case that we have not seen yet: undefinition , or redeclaration from  
effective to deferred — forgetti ng one’s original implementatio n to start a new life.Definition: redeclaration
To redeclare a feature is to redefine or effect it.
Redeclaring from →
                     to ↓Deferred Effective
Deferred  Redefinition Undefinition
Effective  Effecting Redefinition
“Conflicts under 
sharing: undefinition and join”, page 551 .
INTRODUCTION TO INHERITANCE  §14.5 486
Deferred classes
A feature, as we have seen, is either deferred or effective. Th is distinction extends to classes:
S o  f o r  a  c l a s s  t o  b e  e f f e c t i v e ,  a l l  o f  i t s  f e a t u r e s  m u s t  b e  e f f ective. One or more  
deferred features make the class  deferred. In the latter case y ou must mark the class:
So FIGURE  will be declared (ignoring the note clause) as:
deferred class  FIGURE feature
rotate (…)
… Deferred featur e declaration as shown earlier …
… Other feature declarations …
end
Conversely, if a class is marked as deferred  it must have at least one deferred  
feature. But a class may be deferred even if it does not declar e any deferred feature of its  
own: it might have a deferred pa rent, from which it inherits a deferred feature that it does  
not effect. In our e xample, the class  OPEN_FIGURE  most likely does not effect display , 
rotate  and other deferred features that it inherits from FIGURE , since the no tion of open  
figure is still not concrete enough to support default implemen tations of these operations.  
So the class is deferred, and will be declared as
deferred class  OPEN_FIGURE inherit
FIGURE
…
even if it does not itself in troduce any def erred feature.
A descendant of a deferred class is an effective class if it pr ovides effective  
definitions for all features sti ll deferred in its parents, and  does not introduce any deferred  
feature of its own. Effective classes such as POLYGON  a n d  ELLIPSE  must provide  
implementations of display , rotate  and any other routines tha t they inherit deferred. 
For convenience we will say that  a type is deferred if its base  class is deferred. So  
FIGURE , viewed as a type, is deferred; and if the generic class LIST  is deferred — as it  
should be if it represents gener a l  l i s t s  r e g a r d l e s s  o f  t h e  i m p l e m e n t a t i o n  —  t h e  t y p e  
LIST  [INTEGER ] is deferred. Only the base class counts here: C [X] is effective if class C 
is effective and deferred if C if is deferred, regardl ess of the status of X.Definition: deferred, effective class
A class is deferred if it has a deferred feature. A class is ef fective if it is not  
deferred.
Deferred class declaration rule
The declaration of a deferred cl ass must use the  juxtaposed key words  
deferred class  (rather than just class  for an effective class).
§14.5   DEFERRED FEATURES AND CLASSES 487
Graphical conventions
The graphical symbols that have i llustrated inheritance figures  can now be fully explained.  
An asterisk marks a defe rred feature or class:
FIGURE *
display *
perimeter * -- At the level of OPEN_FIGURE in the illustration of page 483
A plus sign means “effective” and  marks the effecting of a feat ure:
perimeter+ -- At the level of POLYGON  in the illustration of page 483
You may mark a class with a plus sign + to indicate that it is effective. This is only  
used for special empha sis; an unmarked class  is by default unde rstood as effective, like a  
class declared as just class C …, without the deferred  keyword, in the t extual notation.
You may also attach a single plu s sign to a feature, to indicat e that it is being effected.  
For example perimeter appears, deferred and hence in the form perimeter *, as early as  
class CLOSED_FIGURE , since every closed figure has a perimeter; then at the level of 
POLYGON  the feature is effected to indi cate the polygon algorithm for computing a  
perimeter, and so appears next to POLYGON as perimeter+.
Finally, two plus signs (informa lly suggesting double effecting ) mark redefinition:
perimeter++ -- At the level of RECTANGLE and SQUARE in the figure of page 483
What to do with deferred classes 
The presence of deferred element s in a system prompts the quest ion “what happens if we  
apply rotate  to an object of type FIGURE ?”; more generally, if we apply a deferred routine  
to a direct instance of a deferred class. The answer is draconi an: there is no such thing as  
an object of type FIGURE  — no such thing as a direct i nstance of a deferred class.
Recall that the creation type of a creation instruction is the type of x in the form create  x, 
and is U in the explicit-type form create {U} x. A type is deferred i f its base class is.
So the creation instruction create  f… is invalid, and will be r ejected by the compiler,  
if the type of f  is one of FIGURE , OPEN_FIGURE , CLOSED_FIGURE , all deferred. This  
rule removes any danger of cau sing erroneous f eature calls.
Note, however, that even though f ’s type is deferred you can still use f as target in the  
type-explicit form of the creation instruction, as in create {RECTANGLE } f, as long as  
the creation type, here RECTANGLE , is one of the effective descendants of FIGURE . We 
saw how to use this technique in a multi-branch instruction to create a FIGURE  object  
which, depending on the context, will be a direct instance of RECTANGLE , or of  
CIRCLE , etc.Deferred Class No-Instantiation rule
The creation type of a creation instruction may not be deferred
INTRODUCTION TO INHERITANCE  §14.5 488
At first the rule may appear to limit the useful ness of deferre d classes to little more  
t h a n  a  s y n t a c t i c  d e v i c e  t o  f o o l  the static type system. This wo uld be true but for  
polymorphism and dynamic binding. You cannot create an object  of type FIGURE , but 
you can declare a polymorphic entity of that type, and use it w ithout knowing the type  
(necessarily based on an effecti ve class) of the attached objec t in a particular execution:
f: FIGURE
…
f := “Some expression of an e ffective type, such as CIRCLE  or POLYGON  ”
…
f  rotate (some_  point , some_angle )
f  display
…
Such examples are the combinatio n and culmination of the O-O me thod’s unique  
abstraction facilities: classes, information hiding, Single Cho ice, inheritance, polymorphism,
dynamic binding, deferred classe s (and, as seen next, assertion s). You manipulate objects  
without knowing their exact types,  specifying only the minimum information necessary to  
e n s u r e  t h e  a v a i l a b i l i t y  o f  t h e  o p e r a t i o n s  t h a t  y o u  r e q u i r e  ( h e r e, that these objects are  
figures, so that they can be rotated and displayed). Having sec ured the type checker’s  
stamp of approval, certifying th at these operations are consist ent with your declarations,  
you rely on a benevolent power — dynamic binding — to apply the  correct version of each  
operation, without having to fin d out what that version will be .
Specifying the semantics of deferred features and classes
Although a deferred feature has no implementation, and a deferr ed class has either no  
implementation or a partial impl e m e n t a t i o n  o n l y ,  y o u  w i l l  o f t e n  need to express their  
abstract semantic properties. You  can use assertions for that p urpose.
Like any other class, a deferred class can have a class invaria nt; and a deferred  
feature can have a precondit ion, a postcondition or both.
Consider the example of sequential lists, described independent ly of any particular  
implementation. As with many oth er such structures, it is conve nient to associate with  
each list a cursor, indica ting a curre ntly active position:See also exercise 
E14.5, page 518 .
f could also be a for-
mal argument, as in some_routine
 
   (f: FIGURE ) … 
List with 
cursorbefore after
item
indexcount 1
Cursor
§14.5   DEFERRED FEATURES AND CLASSES 489
The class is deferred:
note
description : "Sequentially tr aversable lists "
deferred class
LIST [G]
feature -- Access
count : INTEGER
-- Number of items
deferred
end
 index : INTEGER
-- Cursor position
deferred
end
 item : G is 
-- Item at cursor position
deferred
end
feature  -- Status report
after : BOOLEAN
--Is cursor pa st last item?
deferred
end
before : BOOLEAN
--Is cursor before first item?
deferred
end
feature -- Cursor movement
forth
--Advance cursor b y one position.
require
not after
deferred
ensure
index = old index + 1
end
… Other features …
invariant
non_negative_count : count >= 0
offleft_by_a t_most_one : index >= 0
offright_by_at_most_one : index <= count + 1
after_definition : after = (index = count + 1 )
before_definition : before = (index = 0)
end
INTRODUCTION TO INHERITANCE  §14.5 490
The invariant expresse s the relations betwe en the various queri es. The first two  
clauses state that the cursor may only get off the set of items  by one position  left or right:
The last two clauses of the invariant could also be expressed a s postconditions:
ensure Result = (index = count + 1 ) in after  and ensure Result = (index = 0) in before . 
This choice always arises for a property involving argumentless  queries only. In such a  
case I prefer to use an invariant clause, treating the property  as applying globally to the  
class, rather than attaching it to any particular feature.
The assertions of forth  express precisely what this pr ocedure must do: advance the  
cursor by one position. Since we  want to maintain the cursor wi t h i n  t h e  r a n g e  o f  l i s t  
elements, plus two “sentinel” positions as shown on the last fi gure, application of forth 
requires not after ; the result, as stated by the postcondition, i s to increase index  by one.
Here is another example, our old friend the stack. Our library will need a general  
STACK [G] class, which we now know will be deferred since it should cover  all possible  
implementations; prope r descendants such as FIXED_STACK  and LINKED_STACK  will 
describe specific implementation s. One of the deferred procedur es of STACK is put:
put (x: G)
-- Add x on top.
require
not full
deferred
ensure
not_empty : not empty
pushed_is_top : item = x
one_more : count = old count + 1
end
The boolean functions empty  and full (also deferred at the STACK  level) express  
whether the stack is e mpty, and whether its representation is f ull. 
Only with assertions do deferred classes attain their full powe r. As noted (although  
the details will wait until two chapters from now), preconditio ns and postcon ditions apply  
to all redeclarations of a routin e. This is especially signific ant in the deferred case: these  
assertions, if present, will set the limits for all permissible  effectings. So the above  
specification constrains all variants of put in descendants of STACK .
Thanks to these asserti on techniques you can make deferred clas ses informative and  
semantics-rich, even th ough they do not pres cribe any implement ation.
At the end of this chapter we will come back to deferred classe s and explore further  
their many roles in the object-o riented process of analysis, de sign and implementation.Cursor 
positionsbefore after
count 1 0 count+1(Left (Right
sentinel) sentinel)Occupied positions
“THE ROLE OF 
DEFERRED CLASSES”, 14.8, page 500 .
§14.6   REDECLARATION TECHNIQUES 491
14.6  REDECLARATION TECHNIQUES
The possibility of redeclaring a feature — redefining or effect ing it — provides us with a  
flexible, incremental developmen t style. Two techniques add to its power:
• The ability to redeclare a function into an attribute.
• A simple notation for referring to the original version in the  body of a redefinition.
Redeclaring a function into an attribute
Redeclaration techniques provide  an advanced application of one  of the central principles  
of modularity that led us to the  object-oriented method: unifor m access.
As you will recall, the Uniform A ccess principle stated (origin ally in less technical  
terms, but we can af ford to be precise now) that there should n ot be any fundamental  
difference, from a client’s pers pective, between an attribute a nd an argumentless function.  
In both cases the feature is a q uery; all that d iffers is its i nternal representation.
The first example was a class de scribing bank accounts, where t he balance  feature  
can be implemented as a function ,  w h i c h  a d d s  a l l  t h e  d e p o s i t s  a nd subtracts all the  
withdrawals, or as an attribute,  updated whenever necessary to reflect the current balance.  
To the client, this makes no difference except possibly for per formance.
With inheritance, we can go further, and allow a class that inh erits a routine to  
redefine it as an attribute.
Our old example is directly a pplicable. Assume  an original ACCOUNT1  class:
class ACCOUNT1 feature
balance : INTEGER
-- Current balance
do
Result  := list_of_deposits   total – list_of_withdrawals   total
end
…
end
Then a descendant can choose the second implementation of our o riginal example,  
redefining balance  as an attribute:
class ACCOUNT2 inherit
ACCOUNT1
redefine balance end
feature
balance : INTEGER
-- Current balance
…
endSee “Uniform 
Access”, page 55 .
INTRODUCTION TO INHERITANCE  §14.6 492
ACCOUNT2  will likely have to redefine c ertain procedures, such as withdraw  and 
deposit , so that on top of their other duties they update balance , maintaining invariant the  
property balance = list_of_deposits   total – list_of_withdrawals   total.
In this example the redeclaratio n is a redefinition. An effecti n g  c a n  a l s o  t u r n  a  
deferred feature int o an attribute. For example a deferred LIST class may have a feature
count : INTEGER
-- Number of inserted items
deferred
end
Then an array implemen tation may effect this  feature as an attr ibute:
count : INTEGER
If we are asked to apply the classification that divides featur es into attributes and routines,  
we will by convention consider a deferred feature as a routine — even though, for a  
deferred feature with a result and no argument, the very notion  of deferment means that  
we have not yet chosen between routine and attribute implementa tions. The phrase  
“deferred feature” is suitabl y vague and hence preferable to “d eferred routine”.
Combined with polymorphism and dy namic binding, s uch redeclarat ions of routines  
i n t o  a t t r i b u t e s  c a r r y  t h e  U n i f o r m  Access principle to its extre me. Not only can we  
implement a client’s request of the form a  service through either stora ge or computation,  
without requiring the client to be aware of our choice (the bas ic Uniform Access idea): we  
now have a situation where the same call could, in successive e xecutions of the request  
during a single session, trigger a field access in some cases a nd a routine call in some  
others. This could for  example happen with  successive execution s of the same a  balance  
call, if in the meantime a is polymorphically reattached to different objects.
Not the other way around
You might expect to be able to r edefine an attribute into an ar gumentless function. But no.  
Assignment, an operati on applicable to attributes, makes no sen se for functions. Assume  
x is an attribute of a class C, and a routine of C contains the instruction 
a := some_expression
Were a descendant of C to redefine a, then the routine — assuming it is not also  
redefined — would become inappli cable, since one cannot assign to a function. 
The lack of symmetry (redeclaration permitted from function to attribute but not  
conversely) is unfortunate but inevitable, and not a real imped iment in practice. It makes the  
use of an attribute a final, non-reversible implementation choi ce, whereas using a function  
still leaves room for later storage-based (rather than computat ion-based) implementations.
§14.6   REDECLARATION TECHNIQUES 493
Using the original version in a redefinition
Consider a class that redefines a routine inherited from a pare nt. A common scheme for  
the redefinition is to perform what the original version did, p receded or followed by some  
other specific actions.
For example, a class BUTTON  inheriting from WINDOW  might redefine procedure  
display  to indicate that to display a button is to display it as a win dow, then draw the border:
class BUTTON inherit
WINDOW
redefine display end
feature -- Output
display
-- Display as a button.
do
“Display as a normal window”; -- See below 
draw_border
end
… Other features …
end
where draw_border is a procedure of the new class. What we need to “Display as a normal  
window”  is a call to the original, pre-redefinition version of display , known technically as  
the precursor  of draw_border .
This case is common enough to ju stify a specific  notation. The construct
Precursor
may be used in lieu of a feature  name, but only in the body of a redefined routine. A call  
to this feature, with arguments if required, is a call to the p arent’s version of the routine  
(the precursor).
So in the last example the “Display as a normal window”  part may be written as just
Precursor
meaning: call the version of this feature in class WINDOW . This would be illegal in any  
context other than the redefinit ion of a routine  inherited from  WINDOW , where WINDOW
is a direct parent. Precursor  is a reserved entity name, such as Result  or Current , and like  
them is written in italics wit h an upper-case first letter.
In this example the redefined ro utine is a procedure, and so a call to the Precursor
construct is an instruction. The  call would be an expression in  the redefinition of a function:
some_query (n: INTEGER ): INTEGER
-- Value returned by parent vers ion if positive, otherwise zero
do
Result  := (Precursor (n))  max (0)
end
INTRODUCTION TO INHERITANCE  §14.7 494
In cases of multiple inheritance studied in the next chapter, a  routine may have several  
precursors (enabling you to join several inherited routines int o one). Then you will need  
to remove the ambiguity by specifying the parent, as in Precursor {WINDOW }.
Note that the use of the Precursor  construct does not make the precursor feature a  
feature of the class; only the r edefined version is. (For one t hing, the precursor version  
might fail to maintain the new invariant.) The only effect of t he construct i s to facilitate  
the task of the redefiner if th e new job includes the old.
For any more complicated case, and in particular if you want to  use both the precursor  
and the redefined version as features of the class, you will re ly on a technique based on  
repeated inheritance, which actually duplicates  a parent feature, yielding two full-fledged  
features in the heir. This will be part of the discussion of re peated inheritance.
14.7  THE MEANING OF INHERITANCE 
W e have now seen the basic techniques of inheritance. More rema ins to be studied, in  
particular how to deal with multiple inheritance, and the detai l s  o f  w h a t  h a p p e n s  t o  
assertions in the context of inh eritance (the notion of subcont racting).
But first we must reflect on the fundamental concepts and under stand what they  
mean in the quest for software quali ty and an effective softwar e development process.
The dual perspective
Nowhere perhaps does t he dual role of classes as modules and ty pes, defined when we first  
encountered the notion  of class, appear more clearly than in th e study of inheritance. In  
the module view, an he ir describes an extension of the parent m odule; in the type view, it  
describes a subtype of the par ent type.
Although some aspects of inheritan ce belong more to the type vi ew, most are useful  
for both views, as sug gested by the followi ng approximate class ification (which refers to  
a  f e w  f a c i l i t i e s  y e t  t o  b e  s t u d i ed: renaming, descendant hiding , multiple and repeated  
inheritance). No aspect seems to belong exclusively to the module view.“Keeping the original 
version of a redefined feature”, page 555 .
Inheritance 
mechanisms and their roleAddition of features
RedefinitionRenaming
Descendant hiding
Multiple inheritanceRepeated inheritancePolymorphism
Dynamic bindingDeferred features,  
effecting
MODULE
VIEWTYPE
VIEW
§14.7   THE MEANING OF INHERITANCE 495
The two views reinforce each other, giving inheritance its powe r and flexibility. The  
power can in fact be intimidatin g, prompting proposals to separ ate the mechanism into  
two: a pure module extension fac ility, and a subtyping mechanis m. But when we probe  
further (in the chapter on the methodology of inheritance) we w ill find that such a  
separation would have many disadv a n t a g e s ,  a n d  b r i n g  n o  r e c o g n i z able benefit.  
Inheritance is a unifying princi ple; like many of the great uni fying ideas of science, it  
brings together phenomena that had hithe rto been treated as dis tinct.
The module view
From the module viewpoint, inher itance is particularly effectiv e as a reusability technique. 
A module is a set of services of fered to the outside world. Wit hout inheritance, every  
new module must itself define all the services it offers. Of co urse, the implementations  of 
these services may rely on servi ces provided by other modules: this is the purpose of the  
client relation. But there is no way to define a new module as simply adding new services  
to previously de fined modules. 
Inheritance gives tha t possibility. If B inherits from A, all the services  (features) of A
are automatically available in B, without any need to d efine them further. B is free to add  
new features for its own specifi c purposes. An extra degree of flexibility is provided by  
redefinition, which allows B to take its pick of the i mplementations offered by A, keeping  
some as they are while overridin g others by locally more approp riate versions. 
This leads to a style of software development which, instead of  trying to solve every  
new problem from scratch, encour ages building on previous accom plishments and  
extending their results. The sp irit is one of both economy — wh y redo what has already  
been done? — and humility, in line with Newton’s famous remark that he could reach so  
high only because he stood o n the shoulders of giants. 
The full benefit of this approac h is best understood in terms o f the Open-Closed  
principle  introduced in an earlier chapte r .  ( I t  m a y  b e  w o r t h w h i l e  t o  r e r ead the  
corresponding section now in lig ht of the concepts just introdu ced.) The principle stated  
that a good module structure sh ould be both closed and open: 
• C l o s e d ,  b e c a u s e  c l i e n t s  n e e d  t h e module’s services to proceed with their own  
development, and once they have settled on a version of the mod ule should not be  
affected by the introd uction of new services they do not need. 
• Open, because there is no gua rantee that we will include right  from the start every  
service potentially us eful to some client. 
This double requirement looks li ke a dilemma, and classical mod ule structures offer  
no clue. But inheritance solves it. A class is closed, since it  may be compiled, stored in a  
library, baselined, and used by client classes. But it is also open, since any new class may  
use it as a parent, adding new f eatures and redeclaring inherit ed features; in this process  
there is no need to change the o riginal or to disturb its clien ts. This property is fundamental  
in applying inheritance  to the construction  of reusable, extend ible software. See “ONE MECHA-
NISM, OR MORE?”, 24.6, page 833 .
“The Open-Closed 
principle”, page 57 .
INTRODUCTION TO INHERITANCE  §14.7 496
If the idea were driven to the extreme, every class would add j ust one feature to those of its  
parents! This, of course, is not recommended. The decision to c lose a class should not be  
taken lightly; it should be based on a conscious judgment that the class as it stands already  
provides a coherent set of services — a coherent data abstracti on — to potential clients.
Also remember that the Open-Closed principle does not cover lat e hacking of inadequate  
services. If bad judgment resulted in a poor feature specificat ion we cannot update the  
class without affecting its clients. Thanks to redefinition, ho wever, the Open-Closed  
principle remains applicable if the change is compatible with t he advertized specification. 
Among one of the toughest issues  in designing re usable module s tructures was the  
necessity to take advantage of co mmonalities that may exist bet ween groups of related  
data abstractions — all hash tab les, all sequent ial tables etc.  By using class structures  
connected by inheritance, we can benefit from the logical relat ionships that exist between  
these implementations. The diagram below is a rough and partial  sketch of a possible  
structure for a table management  library. The scheme naturally uses multiple inheritance,  
discussed in more de tail in the next chapter. 
This inheritance diagram is only a draft although it shows inhe ritance links typical of such  
a structure. For a systematic i nheritance-based classification of tables and other  
containers, see [M 1994a] .
With this view we can express the reusability requirement quite  concretely: the idea  
is to move the definition of every feature as far up  in the diagram as possible, so that it  
may be shared by the greatest po ssible number of  descendant cla sses. Think of the process  See “Single-routine 
classes”, page 728 .
“Factoring Out 
Common Behav-iors”, page 85 .
Draft structure 
for a table 
libraryTABLE
TABLE_WITH_
DELETION
BINARY_
SEARCH_TREEBINARY_
TREE
CLOSED_
HASH_TABLEBOUNDED_
TABLESEQUENTIAL_
TABLE
LINKED_
LISTARRAY_
TABLEARRAY
LIST
LINKED_
TABLE
§14.7   THE MEANING OF INHERITANCE 497
as the reusability game , played on boards that represen t inheritance hierarchies such as the 
one on the last figure, with tokens that represent features. He  who moves the most features  
the highest, as a result of disc overing higher-level abstractio ns, and along the way merges  
the most tokens, as a result of discovering commonalities, wins .
The type view
From the type perspective, inher itance addresses both reusabili ty and extendibility, in  
particular what an ea rlier discussion called  continuity. The ke y is dynamic binding. 
A type is a set of objects charac terized (as we know from the t heory of abstract data  
types) by certain operations. INTEGER  d e s c r i b e s  a  s e t  o f  n u m b e r s  w i t h  a r i t h m e t i c  
operations; POLYGON , a set of objects with operations vertices , perimeter  and others.
For types, inheritance represents the is relation, also known as is-a, as in “every dog  
is a mammal”, “every mammal is an animal” . Similarly, every rec tangle is a polygon. 
What does this relation mean? 
•If we consider the values in each  type, the relation is simply set inclusion: dogs make  
up a subset of the set of animals; similarly, instances of RECTANGLE  make up a  
subset of the instances of POLYGON . (This comes from the definition of “instance”  
earlier in this chapter; note  that a direct instance of RECTANGLE is not a direct  
instance of POLYGON ).
• If we consider the operations a pplicable to each  type, saying that every B is an A
means that every operation a pplicable to in stances of A is also applicab le to instances  
of B. (With redefinition, however, B may provide its own implementation, which for  
instances of B overrides the imple mentation given in A.) 
Using this relation, you can describe is-a networks representing many possible type  
variants, such as al l the variants of FIGURE . Each new version of a routine such as rotate
and display  is defined in the class that de scribes the corre sponding type variant. In the  
table example, each cl ass in the graph will provide its own imp lementation of search , 
insert , delete , except of course when the paren t’s version is s till appropria te.
A caveat about  the use of “ is” and “ is-a”. Beginners — but, I h ope, no one who has  
read so far with even a modicum of attention — sometimes misuse  inheritance to model  
the instance-to-mold relation, as with a class SAN_FRANCISCO  inheriting from CITY . 
This is most likely a mistake: CITY  is a class, which may have an instance representing  
San Francisco. To avoid such mistakes, it suffices to remember that the term is-a does not  
stand for “ x is an A” (as in “ San_francisco  is a CITY  ”), a relation betwe en an instance and  
a category, but for “every B is an A” (as in “Every CITY  is a GEOGRAPHICAL_UNIT   ”), 
a relation between two categorie s — two classes in software ter ms. Some authors prefer  
to call this relation “ is-a-kind-of   ” or, like [Gore 1996] , “can act as a” . This is partly a  
matter of taste (and partly a ma tter of substance, to be discus sed in the chapter on  
inheritance methodology); once we  have learned to avoid the tri vial mistake, we can  
continue to use the well-accepted “ is” or “ is-a” terminology, never forgetting that it  
describes a relation between categories.“Instances”, page 
475.
INTRODUCTION TO INHERITANCE  §14.7 498
Inheritance and decentralization
With dynamic binding we can produce the decentralized soft ware architectures
necessary to achieve the goals of  reusability and extendibility . Compare the O-O approach  
— self-contained classes each pr oviding its set of operation va riants — with classical  
approaches. In Pascal or Ada, you  may use a record type with va riants
type FIGURE =
record
“Common fields if any”
case figtype : (polygon , rectangle , triangle , circle , …) of
polygon : (vertices : LIST_OF_POINTS ; count : INTEGER );
rectangle : (side1 , side2 : REAL ; …);
… 
end
to define the various forms of f igures. But this means that eve ry routine that does  
something to figures ( rotate and the like) must discrimin ate between possibilities: 
case f  figure_type of
polygon : …
circle : …
…
end
Routines search  a n d  o t h e r s  i n  t h e  t a b l e  c a s e  w o u l d  u s e  t h e  s a m e  s t r u c t u r e .  T h e  
trouble is that all these rou tines possess far too much knowledge  about the overall system:  
each must know exactly w hat types of figure are allowed in the system. Any addition of a  
new type, or change in an existing one, wi ll affect every routi ne. 
Ne sutor ultra crepidam , the shoemaker should not l ook beyond the sandal, is a  
software design principle: a rot ation routine ha s no business k nowing the exhaustive list  
of figure types. It should be co ntent enough with the informati on necessary to do its job:  
rotating certain k inds of figure. 
This distribution of knowledge a mong too many routines is a maj or source of  
inflexibility in classical appro a c h e s  t o  s o f t w a r e  d e s i g n .  M u c h  of the difficulty of  
modifying software may be traced  to this problem. It also expla ins in part why software  
projects are so difficult to kee p under control, as apparently small changes have far-
reaching consequ ences, forcing developers to reopen modules tha t were thought to have  
been closed for good. 
Object-oriented techniques deal with the problem head-on. A cha nge in a particular  
implementation of an operation w ill only affect the class to wh ich the implementation  
applies. Addition of a new type v ariant will in m any cases leav e the others completely  
unaffected. Decentralization is the key: classes manage their o wn implementations and do  
not meddle in each other’s affa irs. Applied to h umans, this wou ld sound like V oltaire’s  
Cultivez votre jardin , tend your own garden. Applied t o modules, it is an essential  
requirement for obtaining decent ralized structures that will yi eld gracefully to requests for  
extension, modification, c ombination and reuse. See “Single 
Choice”, page 61 .
§14.7   THE MEANING OF INHERITANCE 499
Representation independence
Dynamic binding also addresses one of the princi pal reusability  issues: representation  
independence — the abi lity to request an op eration with more th an one variant, without  
having to know which v ariant will be applied . The discussion of  this notion in an earlier  
chapter used the example of a call 
present  := has (x, t)
which should use the appropriate  search algorithm depending on the run-time form of t. 
With dynamic binding, we have exactly that: if t is declared as a table, but may be  
instantiated as any of binary se arch tree, close d hash table et c. (assuming all needed  
classes are available), then the call 
present  := t  has (x)
will find, at run time, the appropriate version of has. Dynamic binding a chieves what the  
earlier discussion showed to be impossible with overloading and  genericity: a client may  
request an operation, and let th e underlying lan guage system au tomatically find the  
appropriate im plementation. 
So the combination of classes, i nheritance, redefinition, polym orphism and dynamic  
binding provides a remarkable se t of answers to the questions r aised at the beginning of  
this book: requirements for reus ability; criteria, principles a nd rules of modularity. 
The extension-specialization paradox
Inheritance is sometim es viewed as extension and sometimes as s pecialization. Although  
these two interpretations appear  contradictory, there is truth in both — but not from the  
same perspective.
It all depends, again, on whethe r you look at a class as a type  or a module. In the first  
case, inheritance, or is, is clearly specialization; “dog” is a more specialized notion  than 
“animal”, and “rectangle” than “ polygon”. This c orresponds, as noted, to subset inclusion:  
if B is heir to A, the set of run-time objects represented by B i s  a  s u b s e t  o f  t h e  
corresponding set for A. 
But from the module perspective, where a class is viewed as a p rovider of services, B
implements the services (features) of A p l u s  i t s  o w n .  Fewer  objects often allows more
features, since it implies a higher information value; going fr om arbitrary animals to dogs  
we can add the specific property of barking, and from arbitrary  polygons to rectangles we  
can add the feature diagonal . So with respect to features im plemented the subsetting goes  
the other way: the features applicable to instances of A are a subset of those for instances of B. 
Features implemented  rather than services offered  (to clients) because of the way  
information hiding combines w ith inheritance: as we will see, B may hide from its clients  
some of the features exported by A to its own.
Inheritance, then, is s pecialization from t he type viewpoint an d extension from the  
module viewpoint. This is the ex tension-speciali zation paradox:  more features to apply,  
hence fewer objects t o apply them to. “Representation 
Independence”, page 84.
INTRODUCTION TO INHERITANCE  §14.8 500
The extension-specialization para dox is one of the reasons for avoiding the term  
“subclass”, which sugges ts “subset”. Another, already noted, is  the literature’s sometimes  
confusing use of “subc lass” to indicate direct as well as indir ect inheritance. No such  
problem arises for the pr ecisely defined terms heir, descendant  and proper  descendant  and 
their counterparts parent , ancestor and proper  ancestor .
14.8  THE ROLE OF DEFERRED CLASSES
Among the inheritance-related m echanisms addressing the problem s of software  
construction presented  at the beginning of  this book, deferred classes are prominent.
Back to abstract data types 
Loaded with assertions, deferred  classes come close to represen ting abstract data types. A  
deferred class covering the noti on of stack provides an excelle nt example. Procedure put
has already been shown; here is a possible versi on for the full  class. 
note
description :
"Stacks (Last-in , First-Out dispenser structures ), independently of  %
%any representation choice "
deferred  class
STACK [G]
feature  -- Access
count : INTEGER
-- Number of elements inserted.
deferred
end
item: G
-- Last element pushed.
require
not_empty : not empty
deferred
end
feature  -- Status report
empty : BOOLEAN
-- Is stack empty?
do
Result  := (count = 0)
end
full: BOOLEAN
-- Is stack full?
deferred
end
§14.8   THE ROLE OF DEFERRED CLASSES 501
feature -- Element change
put (x: G)
-- Push x onto top.
require
not full
deferred
ensure
not_empty : not empty
pushed_is_top : item = x
one_more : count = old count + 1
end
remove
-- Pop top element.
require
not empty
deferred
ensure
not_full : not full
one_less : count = old count — 1
end
change_top (x: T)
-- Replace top  element by x
require
not_empty : not empty
do
remove ; put (x)
ensure
not_empty : not empty
new_top : item = x
same_number_of_items : count = old count
end
wipe_out
-- Remove all elements.
deferred
ensure
no_more_elements : empty
end
invariant
non_negative_count : count >= 0
empty_count : empty = (count = 0)
end
INTRODUCTION TO INHERITANCE  §14.8 502
The class shows how you can imple ment effective routines in ter ms of deferred ones:  
for example, change_top  has been implemented as a remove  followed by a put. (This  
implementation may be inefficien t in some representations, for example with arrays, but  
effective descendants of STACK  may redefine the routine.) 
If you compare class STACK  with the abstract data type specification given in the  
chapter on ADTs, you will find th e similarities striking. Note in particular how the ADT  
functions map to features of the  class, and the PRECONDITIONS p aragraph to routine  
preconditions. Axioms are reflec ted in routine po stconditions a nd in the class invariant. 
The addition of operations change_top , count  a n d  wipe_out  i s  n o t  a n  i m p o r t a n t  
difference since they could be specified as part of the abstrac t data type. Also minor is the  
absence of an explicit equivalen t of the abstract data type fun ction new, since creation  
instructions (which ma y rely on creation pro cedures introduced by effective descendants)  
will take care of objec t creation. There re main three significa nt differences.
The first is the introduction of a function full, accounting for imp lementations that  
will only accept a limited number of successive insertions, for  e x a m p l e  a r r a y  
implementations. This is typical of constraints that are irrele vant at the specification level  
but necessary in the d esign of practical systems. Note, however , that this is not an intrinsic  
difference between abstract data  types and deferred classes, si nce we may adapt the ADT  
specification to cover the notion  of bounded stack. Also, no ge nerality is lost since some  
implementations (linked, for example) may have a version of full that always returns false. 
The second difference,  mentioned in the discussion of Design by  Contract, is that an  
ADT specification is purely ap plicative (functional): it only i ncludes functions, without  
side effects. A deferred class is imperative (procedural) in sp ite of its abstractness; put, for 
example, is specified as a procedure that will modify a stack, not as a function that takes  
a stack and retur ns a new stack. 
Finally, as also noted in the ea rlier discussion, the assertion  mechanism is not  
expressive enough for some ADT ax ioms. Of the four  stack axioms  
all but A 2 have a direct equivalent in the assertions. (For A 3 we assume that descendants’  
creation procedures will state ensure  empty .) An earlier discussion  explained the reasons  
for this limitation, and hinted at possible ways  — formal speci fication languages, IFL —  
to remove it.     For any x: G, s: STACK [G]
A1 • item (put (s, x)) = x
A2 • remove  (put (s, x)) = s
A3 • empty  (new)
A4 • not empty  (put (s, x))Full specification page 
139; also “FROM 
ABSTRACT DATA TYPES TO CLASSES”, 6.5, page 142 .
See exercise E6.8, 
page 162 : “more 
stack operations” .
See exercise E6.9, 
page 162 : “bounded 
stacks” .
“The imperative and 
the applicative”, page 351.
“The expressive 
power of assertions”, page 399 , and subse-
quent section .
§14.8   THE ROLE OF DEFERRED CLASSES 503
Deferred classes as partial implementations: the notion of beha vior class
Not all deferred classes are as close as STACK  to an abstract data type. In-between a fully  
abstract class like STACK , where all the fundamental features are deferred, and an  
effective class such as FIXED_STACK , describing just one implementation of an abstract  
data type, there is room for all degrees of partial ADT impleme ntations or, said differently,  
groups of possible  implementations. 
The review of table implementati on variants, which helped us un derstand the role of  
partial commonality in our study of reusability issues, provide s a typical example. The  
original figure showing the rela tions between the variants can now be redrawn as an  
inheritance diagram:
The most general class, TABLE , is fully or almost fully deferred, since at that level  
we may specify a few features but not provide any substantial i mplementation. Among the  
variants is SEQUENTIAL_TABLE , representing tables in which elements are inserted  
sequentially. Examples of sequen tial tables include array, link ed list and sequential file  
implementations. The correspondi ng classes, in the lowest part of the figure, are effective.
Classes such as SEQUENTIAL_TABLE are particularly interesting. The class is still  
deferred, but its status is intermediate between full deferment , as with TABLE , and full  
effecting, as with ARRAY_TABLE . It has enough information to allow implementing some  
specific algorithms; for example we can implement  sequential se arch fully:
has (x: G): BOOLEAN
-- Does x appear in table?
do
from start until after or else equal (item, x) loop
forth
end
Result  := not after
endSee “Factoring Out 
Common Behaviors”, page 85 ; figure on 
page 86 .
Variants of 
the notion of table
SEQUENTIAL_
TABLE
ARRAY_
TABLELINKED_
TABLEFILE_
TABLETABLE∗
∗after * 
forth * 
item* 
start*
has+
after+ 
forth+ 
item+ 
start+after+ 
forth+ 
item+ 
start+after+ 
forth+ 
item+ 
start+
INTRODUCTION TO INHERITANCE  §14.8 504
This function is effective, alth ough it relies for its algorith m on deferred features. The  
features start (bring the cursor to the first position), forth (advance the cursor by one  
position), item (value of element at cursor position), after (is the cursor after the last  
element?) are deferred in SEQUENTIAL_TABLE ; each of the heirs of this class shown in  
the figure effects them in a dif ferent way, corresponding to it s choice of implementation.  
These various effectings were giv en in the discussion of reusab ility. ARRAY_TABLE , for 
example, can represent the cursor as an integer i, so that the procedure start is implemented  
as i := 1, item as t @ i  and so on.
Note how important it is to include the precondition and postco ndition of forth , as 
well as the invariant of the enc losing class, to make sure that  all future effectings observe  
the same basic specification. Th ese assertions appeared earlier  in this chapter (in a slightly  
different context, for a class LIST , but directly applicable here).
This discussion shows the corres pondence between classes and ab stract data types in  
its full extent:
• A fully deferred class such as TABLE  corresponds to an ADT.
• A fully effective class such as ARRAY_TABLE  corresponds to an  implementation of  
an ADT.
• A partially deferred class such as SEQUENTIAL_TABLE  corresponds to a family of  
related implementations (or, equ ivalently, a partial implementa tion) of an ADT.
A class such as SEQUENTIAL_TABLE , which captures a behavior common to  
several ADT variants, may be called a behavior class . Behavior classes provide some of  
the fundamental design patterns of object-oriented software con struction.
Don’t call us, we’ll call you
SEQUENTIAL_TABLE  is representative of how object  technology, through the notion  of 
behavior class, answers the last  one among the major reusabilit y issues still open from the  
discussion in chapter 4: Factoring out common behaviors .
Particularly interesting is the p ossibility for an effective ro utine of a behavior class  
to rely on deferred routines for  its implementation, as illustr ated by has. This is how you  
may use partially deferred classes to capture common behaviors in a set of variants. The  
deferred class only describes wh at is common; variations are le ft to descendants. 
Several of the d esign examples of later chapters rely on this t echnique, which plays  
a central role in the applicatio n of object-oriented techniques  to building reusable  
software. It is particularly use ful for domain-specific librari es and has been applied in  
many different contexts. A typical example, described in [M 1994a] , is the design of the  
Lex and Parse libraries, a general-purpose solution to the prob lem of analyzing languages.  
Parse, in particular, defines a general parsing scheme, which w ill process any input text  
whose structure conforms to a ce rtain grammar (for a programmin g language, some data  
format etc.). The higher-level behavior classes contain a few d eferred features such as  
post_action  describing semantic actions to be executed just after a certai n construct has  
been parsed. To define your own semantic processing, you just e ffect these features.See the table on page 
88 (which uses found  
in lieu of item).
“Specifying the 
semantics of deferred features and classes”, page 488.
“Factoring Out 
Common Behav-iors”, page 85 .
§14.8   THE ROLE OF DEFERRED CLASSES 505
This scheme is broadly applicabl e. Business applications, in pa rticular, often follow  
standard patterns — process all the day’s invoices, perform app ropriate validation on a  
payment request, ent er new customers … — with individual compo nents that may vary. 
I n  s u c h  c a s e s  w e  m a y  p r o v i d e  a  s e t  o f  b e h a v i o r  c l a s s e s  w i t h  a  m ix of effective  
features to describe the known p art and deferred features to de scribe the variable elements.  
Typically, as in the p receding example, the effective features call the deferred ones. Then  
descendants can provide the effe ctings that satisfy their needs .
Not all the variable elements need to be deferred. If a default  implementation is available,  
include it in the ancestor as an effective feature, which desce ndants may still redefine; this  
facilitates the work on the descendants, since they only need t o provide new versions for  
features that depart from the default. (Recall that to become e ffective, that is, directly  
usable, a class must effect all its parents’ deferred features.) Apply this technique only if  
a sound default exists; if not, as with display  for FIGURE , the feature should be deferred.
This technique is part of a general approach that we may dub don’t call us , we’ll call  
you: rather than an application sys tem that calls out reusable pri mitives, a general-purpose  
scheme lets applicati on developers “ plant” their own variants a t strategic locations.
The idea is not entirely new. IBM’s ancient and venerable datab ase management system,  
IMS, already relied on something of the sort. In more recent so ftware, a common structure for  
graphics systems (such as X for Unix) has an “event loop” which  at each iteration calls specific  
functions provided by each application deve loper. This is known  as a callback  scheme.
What the O-O method offers, than ks to behavior c lasses, is syst ematic, safe support  
for this technique, th rough classes, inheritance, type checking , deferred classes and  
features, as well as assertions that enable the developer of th e fixed part to specify what  
properties the variable replac ements must always satisfy.
Programs with holes
With the techniques just discuss ed we are at the heart of the o bject-oriented method’s  
contribution to reusability: offering not just frozen component s (such as found in  
subroutine libraries), but flexib le solutions that provide the basic schemes and can be  
adapted to suit the needs of  many diverse applications.
One of the central themes of the discussion of reusability was the need to combine  
this goal with adaptability — to get out of the reuse or redo  dilemma. This is exactly the  
effect of the scheme just descri bed, for which we can coin the name “programs with  
holes”. Unlike a subro utine library, where  all is fixed except for the values of the actual  
arguments that you can pass, pro grams with holes, using classes  p a t t e r n e d  a f t e r  t h e  
SEQUENTIAL_TABLE  model, have room for u ser-contributed parts.
These observations help to put in perspective the “Lego block” image often used to  
discuss reusability. In a Lego se t, the components are fixed; t he child's creativity goes  
towards arranging them into an i nteresting structure. This exis ts in software, but sounds  
more like the traditional idea o f subroutines. Often, software development needs to do  
exactly the reverse: keep the structure, but change the compone nts. In fact the components  
may not be there at all yet; in their place you find placeholde rs (deferred feat ures), useful  
only when you plug in your own variants. 
INTRODUCTION TO INHERITANCE  §14.8 506
In analogies with child games, we can go back to a younger age and think of those  
playboards where toddlers have to match shapes of blocks with s hapes of holes — to realize  
that the square block goes into the square hole and the round b lock into the round hole.
You can also picture a partially deferred behavior class (or a set of such classes, called  
a “library” or a “framework”) as having a few electrical outlet s — the deferre d features —  
into which the application develo per will plug co mpatible devic es. The metaphor nicely  
suggests the indispensable safeguards: the assertions, which ex press the requirements on  
acceptable pluggable devices, in t he same way that an outlet’s specification would prescribe  
a range of acceptable voltages, currents and  other electrical p arameters.
Deferred classes for analysis and global design 
Deferred classes are al so a key tool for using the method not j ust for implementation but  
also at the earliest and highest levels of system building — an alysis and global design. The  
aim is to produce a system spec ification and architecture; for design, we also need an  
abstract description of each mo dule, without implementation det ails. 
The advice commonly given is to use separate notations: some an alysis “method” (a  
term that in many cases just cov ers a graphical notation) and a  PDL  (Program Design  
Language, again often graphical) . But this approach has many dr awbacks:
•By introducing a gap between the  successive steps, it poses a g rave threat to software  
quality. The necessity of transla ting from one formalism to ano ther may bring in  
errors and endangers the integri ty of the system. Object techno logy, instead, offers  
the promise of a seamless, c ontinuous software process.
• The multi-tiered approach is pa rticularly detrimental to maint enance and evolution.  
It is very hard to guarantee tha t design and implementation wil l remain consistent  
throughout the sys tem’s evolution. 
• Finally, most existing approach es to analysis and design offer  no support for the  
formal specification of functional properties of modules indepe ndently of their  
implementation, in the form of as sertions or a si milar techniqu e.
The last comment gives rise to the paradox of levels : precise notations such as the  
language of this book are someti mes dismissed as “low-level” or  “implementation-
oriented” because they externally  look like programming languag es, whereas thanks to  
assertions and such abstraction mechanisms as deferred classes they are actually higher-
level  than most of the common analysis  and design approaches. Many p eople take a while  
to realize this, so early have t hey been taught the myth that h igh-level must mean vague;  
that to be abstract on e has to be imprecise.
The use of deferred classes for analysis and design allows us t o be both abstract and  
precise, and to keep the same language throughout the software process. We avoid  
conceptual gaps (“impedance mism atches”); the transition from h igh-level module  
descriptions to implementations can now proceed smoothly, withi n one formalism. But  
even unimplemented ope rations of design modu les, now represente d by deferred routines,  
may be characterized quite precisely by pr econditions, postcond itions and invariants. 
The notation which we have by now  almost finished developing co vers analysis and  
design as well as implementation.  The same concepts and constru cts are applied at all  
stages; only the level of abstraction and detail differs. “Seamless develop-
ment”, page 931 .
§14.9   DISCUSSION 507
14.9  DISCUSSION 
This chapter has intro duced the basic concepts of inheritance. Let us now assess the merits  
of some of the conventions intro duced. Further comments on the inheritance mechanism  
(in particular on multiple inherit ance) appear in the next chap ter.
Explicit redefinition 
The role of the redefine  subclause is to enhanc e readability and reliability. Compilers  do 
not really need it: since a clas s may have at most one feature of a given name, a feature  
declared in a class wi th the same name as an ancestor’s feature  can only be a redefinition  
of that feature — or a mistake.
The possibility of a mistake sh ould not be taken lightly, as a programmer may be  
inheriting from a class without b eing aware of all the features  declared in its ancestors. To  
avoid this dange rous case, any redefinition must be explicitly requested. This is the aim of  
the redefine  subclause, which is also help ful to a reader of the class.
Accessing the precursor of a routine
You will have note d the rule on the Precursor  (…) construct: it may only appear in the  
redefined version of a routine.
This ensures that the construct serves its purpose: enabling a redefinition to rely on  
the original implementation. The  explicit naming of the parent avoids any ambiguity (in  
particular with multip le inheritance). Allowing arbitrary routi nes to access arbitrary  
ancestor features could make a class text very hard to understa nd, all the tim e forcing the  
reader to go the text of many other classes.
Dynamic binding and efficiency
One might fear that dynamic bind ing, for all its power, would l ead to unacceptable run-
time overhead. The danger exists , but careful language design a nd good implementation  
techniques avert it.
The problem is that dynamic binding requires some more work to be done at run time.  
Compare the usual routine call of traditional programming langu ages (Pascal, Ada, C …)
[1]
f (x, a, b, c…)
with the object-oriented form
[2]
x  f (a, b, c…)
The difference between the two was explained, in the introducti on to the notion of  
class, as a consequence of the m odule-type identification. But now we know that more  
than style is at stake: there is  also a differen ce of semantics . In [1], it is known statically  “The Single Target 
principle”, page 184.
INTRODUCTION TO INHERITANCE  §14.9 508
— at compile time, or at worst at link time, if you use a linke r to combine separately  
compiled modules — what exact feature the name f denotes. With dy namic binding,  
however, no such information i s available statically for f  in [2]: the feature to be selected  
depends on the type of the object to which x will be attached during a particular execution.  
What that type will be cannot, i n the general case at least, be  predicted from the text of the  
software; this is the source of the flexibility of the mechanis m, touted earlier.
Let us think for a moment of a n aïve implementation. We keep at  run time a copy of  
the class hierarchy. Each object  contains information about its  type — a node in that  
hierarchy. To interpret x  f, the run-time environment look s at that node to see if the  
corresponding class has a feature f. If so, great, we have found what we need. If not, we  
look at the node’s parent, and re peat the operation. We may hav e to go all the way to the  
topmost class (or the topmost cl asses in the case of multiple i nheritance).
In a typed language we have the guarantee that somewhere along the way we will find a  
suitable feature; in an untyped language such as Smalltalk we m ay fail to do so, and have  
to terminate the execution with a “message not understood” diag nostic.
This scheme is still applied, wi th various optim izations, in ma ny implementations of  
non-statically typed languages. It implies a considerable perfo rmance penalty. Worse, that  
penalty is not predictable, and it grows with the depth of the inheritance structure , as the  
algorithm may have to go back all  the way to the root of the in heritance hierarchy. This  
means introducing a direct confl ict between reusability and eff iciency, since working  
harder at reusability often lead s to introducing more levels of  inheritance. Imagine the  
plight of the poor designer who, whenever tempted to add an inh eritance link, must assess  
whether it is really worth the re sulting performance hit. No so ftware develope r should be  
forced into such choices.
This approach is one of the prim ary sources of inefficiency in Smalltalk  
environments. It also explains w hy Smalltalk does not (in commo n commercial  
implementations at least) suppo rt multiple inheri tance, since t he penalty in this case would  
be enormous, due to the need to traverse an enti re graph, not j ust a linear chain.
Fortunately, the use of static t yping avoids such unpleasantnes s. With the proper type  
s y s t e m  a n d  c o m p i l i n g  a l g o r i t h m s ,  t h e r e  i s  n o  n e e d  e v e r  t o  t r a v e rse the inheritance  
structure at run time. Because in a statically typed O-O langua ge the possible types for x
are not arbitrary but confined to descendants of x’s original type, the compiler can prepare  
the work of the run-time system by building arra yed data struct ures that contain all the  
needed type information. With th ese data structures, the overhe ad of dynamic binding  
becomes very small: an index computation and an array access . Not only is this penalty  
small; even more importantly, it is constant  (more precisely, bounded by a constant), so  
that there is no need to worry a bout any reusabi lity-efficiency  tradeoff as discussed above.  
Whether the deepest inheritance structure in your system is 2 o r 20, whether you have 100  
classes or 10,000, the maximum overhead is exactly the same. Th is is true for both single  
and multiple inheritance.
The discovery, in 1985, of this property — that even in the pre sence of multiple  
inheritance it was possible to implement a dynamically-bound fe ature call in constant  
time — was the key impetus for the project that, among other th ings, yielded both the first  
§14.9   DISCUSSION 509
and the present editions of this book: to build a modern softwa re development  
environment, starting from the ideas brilliantly introduced by Simula 67 and extending  
them to multiple inheritance (prolonged experience with Simula having shown that the  
limitation to single inheritance was unacceptable, as explained  in the next chapter),  
reconciling them with modern principles of software engineering , and combining them  
with the most directly useful results of formal approaches to s oftware specification,  
construction and verification. The design of an efficient, cons tant-time dynamic binding  
mechanism, which may at first sight appear to be somewhat perip heral in this set of goals,  
was in reality an indispensable enabler.
These observations will be surprising to anyone who has been in troduced to object  
technology through the lens of O-O analysis and design presenta tions that treat  
implementation and efficiency as mundane issues to be addressed  after one has solved  
everything else. In the reality of industrial software developm ent — the reality of  
engineering tradeoffs — efficiency is one of the key factors th at must be considered at  
every step. (As noted in an earlier chapter, if you dismiss eff iciency, efficiency will  
dismiss you.) Object technology is much more than constant-time  dynamic binding; but  
without constant-time dynamic binding there can be no successfu l object technology.
Estimating the overhead
With the   techniques described so far, it  is possible to give rough figu res on the overhead  
of dynamic binding. Th e following figures a r e  d r a w n  f r o m  I S E ’ s  experience, using  
dynamic binding (that is to say, disabling the static binding o ptimization explained next).
For a procedure that does nothing — a procedure declared as p1 do end —  t h e  
penalty for dynamic binding over static binding (that is to say , over the equivalent  
procedure in C) is about 30%.
This is of course an upper boun d, since real-life  procedures do  something. The price  
for dynamic binding is the same f or any routine call regardless  of what it does; so the more  
a routine does, the sm aller the relative penalty. If instead of  p1 we use a procedure that  
performs some arbitrary but typical operations, as in
p2 (a, b, c: INTEGER ) is 
local
x, y
do 
x := a; y := b + c +1 ; x := x * y; p2
if x > y then x := x + 1 else x := x — 1 end 
end
then the overhead goes down to ab out 15%. For a routine that do es anything more  
significant (for example by execu ting a loop), it can become ve ry small.
Static binding as an optimization
In some cases you need the utmos t in efficiency, and even the s mall overhead just  
discussed may be undesirable. Th en you will notic e that the ove rhead is not always  
justified. A call x  f (a, b, c…) need not be dynamica lly bound when either:
INTRODUCTION TO INHERITANCE  §14.9 510
S1  •f  is not redeclared anyw here in the system ( it has only one decla ration).
S2  •x is not polymorphic, that is to say is not the target of any at tachment whose  
source has a d ifferent type.
In any such case — detectable by  a good compiler — the code gen erated for  
x  f (a, b, c…) can be identical to what a compiler for C, Pascal, Ada or Fort ran would  
generate for f (x, a, b, c…). No overhead of any  kind is necessary.
ISE’s compiler, part of the envi ronment described in the last c hapter of this book,  
currently applies optimization S 1; the addition of S 2 is planned. (S 2 analysis is in fact a  
consequence of the type analysis mechanisms described in the ch apter on typing.)
Although S 1 is interesting in itself, its direct benefit is limited by the  relatively low  
cost of dynamic binding given in the preceding statistics. The real payoff is indirect, since  
S1 enables a third  optimization:
S3  •A p p l y  automatic routine inlining  when appropriate
Routine inlining means expanding the body of a routine within t he text of its caller,  
eliminating the need for any act ual call. For exa mple, with a r outine
set_a (x: SOME_TYPE )
-- Make x the new value of attribute a.
do
a := x
end
the compiler may generate, for the call s  set_a (some_value ), the same code that a Pascal  
compiler would generate for the assignment s  a := some_value  (not permitted by our  
notation, of course, since it vi olates information hiding). In this case there is no overhead  
at all, since the gen erated code does not use a routine call.
Inline expansion has tr aditionally been viewed as an optimizati on that  
programmers  should specify. Ada inclu des the provision for an inline  pragma (directive  
to the compiler); C and C++ offer similar mechanisms. But this approach suffers from  
inherent limitations. Although f or a small, stati onary program a competent de veloper can  
have a good idea of what should b e inlined, this ceases to be t rue for large, evolutionary  
developments. In that case, a co mpiler with a decent inlining a lgorithm will beat the  
programmers’ guesses 100% of the time.
For any call to which automatic static binding (S 1) is applicable, an O-O compiler  
c a n  ( a s  i n  t h e  c a s e  o f  I S E ’ s )  d e t ermine whether automatic routi ne inlining (S 3) is 
worthwhile, based on an analysis of the space-time tradeoffs. T his is one of the most  
dramatic optimizations — one of the reasons why it is possible to match the efficiency of  
hand-crafted C or Fortran code and sometimes, especially on lar ge systems, exceed it.
To the efficiency advantage, which grows with the size and comp lexity of the  
software, the automatic approach  to inlining adds the advantage  of safety and flexibility.  
As you will have noted, inlining is semantically correct only f or a routine that can be  
statically bound, as in cases S 1 and S 2. It is not only common but also consistent with the  
§14.9   DISCUSSION 511
method, in particular the Open-Cl osed principle, to see a devel oper, midway through the  
development of a large system, a dd a redefinition of a feature which until then had only  
one implementation. If  that routine has been  i n l i n e d  m a n u a l l y ,  the result is erroneous  
semantics (since dynami c binding is now required, and inlining of course means static  
binding). Developers should conc entrate on building correct sof tware, not performing  
optimizations that are tedious, e rror-prone when done manually,  and automatable.
There are some other correctness requirements for inlining; in particular, it is only  
applicable to non-recursive calls. When correct, inlining shoul d only be applied when the  
space-time tradeoff makes sense: the inlined routine should be small, and should be called  
from only one place or a small number of places.
A final note on efficiency. Published statistics for object-ori ented languages show  
that somewhere between 30% and 60% of calls truly need dynamic binding, depending on  
how extensively the de velopers use the method’s specific facili ties. (In ISE’s software the  
proportion is indeed around 60%. ) With the optimizations just d escribed, you will only  
pay the price of dynam ic binding for calls that need it. For th e remaining dynamic calls,  
the overhead is not only small and constant-bounded, it is logically necessary ; in most  
cases, achieving the equivalent effect without O-O mechanisms w ould have required the  
use of conditional instructions ( if … then … or case … of …), which can be more costly  
than the simple array- indirection mechanism outlined above. So it is not surprising that O-
O software, processed by a good c ompiler, can compete with hand -produced C code.
A button by any other name: when static binding is wrong
By now the reader will have unde rstood a key consequence of the  principles of inheritance  
presented in this chapter:
In the call x  r, if x is declared of type A but ends up at run time attached to an object  
of type B, and you have redefined r in B, calling the original version (say rA) is not a  
choice; it is a bug!
No doubt you had a reason for redefining r. The reason may have  been optimization,  
as with perimeter  for RECTANGLE ; but it may have been th at the original version rA was 
simply incorrect for B. Consider the example, sk etched earlier, of a class BUTTON  that 
inherits from a class WINDOW  in a window system, because buttons are a special kind of  
window; the class redefines procedure display  because displaying a button is a little  
different from displaying an ordi nary window (for example you m ust display the border).  
Then if w is of type WINDOW  but dynamically attached, t hrough polymorphism, to an  
object of type BUTTON , the call w  display must  e x e c u t e  t h e  b u t t o n  v e r s i o n !  U s i n g  
displayWINDOW  would result in garbled  display on the screen.Dynamic Binding principle
Static binding is semantically i ncorrect unless its effect is i dentical to that of  
dynamic binding.
INTRODUCTION TO INHERITANCE  §14.9 512
As another example, assume a vid eo game with a data structure LIST [AIRCRAFT ]
— a polymorphic data structure, a s  w e  h a v e  l e a r n e d  t o  u s e  t h e m  — and a loop that  
executes item  land on each element of the list. Ea ch aircraft type may have a dif ferent  
version of land, the landing procedure. Executing the default version is not a n option but  
a mistake. (We may of course ima gine real flight control softwa re rather than just a game.)
We should not let the flexibilit y of the inheritance-based type  system — specifically,  
the type conformance rule — fool us here: the ability to declar e an entity at a level of  
abstraction ( WINDOW , AIRCRAFT ) higher than the actual ty pe of the attached object  
during one particular execution ( BUTTON  or BOEING_747_400 ) is only a facility for the  
engineering  of the software, at  system writing time. During program execution  the only  
thing that matters is the objects to which we apply features; e ntities — names in the text  
of the software — have long been  forgotten. A bu tton by any oth er name is still a button;  
whether the software called it a  button, or for generality trea ted it as a window, does not  
change its nature and properties.
Mathematical analysis supports a nd explains this  reasoning. Fro m the chapter on  
assertions you may remember the c orrectness condit ion for a rou tine:
{prer (xr) and INV}  Bodyr  {postr (xr) and INV}
which we can simplify for the benefit of this discussion (keepi ng the part relative to the  
class invariant only, ignoring t he arguments, and using as subs cript the name A of the  
enclosing class) as
[A-CORRECT]
{INVA}  rA  {INVA}
m e a n i n g  i n  p l a i n  E n g l i s h :  a n y  e x e c u t i o n  o f  r o u t i n e  r f r o m  c l a s s  A will preserve the  
invariant of class A. Now assume that we redefine r in a proper descendant B. The 
corresponding property will hold  if the new class is correct:
[B-CORRECT]
{INVB}  rB  {INVB}
As you will recall, invariants a ccumulate as we go down an inhe ritance structure: so  
INVB implies INVA, but usually not  the other way  around.From the definition 
of class correctness on page 370 .
A parent 
version may fail 
to satisfy the new invariantA
BrA
rB++rA preserves the invariant of A…
 
 
 
… and rB preserves the invariant of  B…
… but rA has no particul ar reason to  
preserve the invariant of  B!INVA
INVB = INVA and other_clauses
§14.9   DISCUSSION 513
Remember for example how RECTANGLE  added its own clauses  to the invariant of  
POLYGON . Another example, studied in th e presentation of invariants, i s a class  
ACCOUNT1 with features withdrawals_list and deposits_list ; then, perhaps for efficiency  
reasons, a proper descendant ACCOUNT2 adds an attribute balance  to store an account’s  
current balance at all time, wit h the new invariant clause give n in the earli er discussion:
consistent_balance : deposits_list   total – withdrawals_list   total = current_balance
As a result, we may have to redefine some of the routines of ACCOUNT1 ; for 
example a procedure deposit that merely used to add a list element to deposits_list  must  
now update balance  a s  w e l l .  O t h e r w i s e  t h e  c l a s s  i s  s i m p l y  w r o n g .  T h i s  i s  s i m i l a r  to 
WINDOW  ’s version of the display  procedure not being correct for an instance of BUTTON .
Now assume static bi nding applied to an object of type B, accessible through an  
entity of type A. Because the corresponding routine version, rA, will usually not preserve  
the needed invariant — as with depositACCOUNT1 for an object of type ACCOUNT2 , or 
displayWINDOW for an object of type BUTTON  —  t h e  r e s u l t  w i l l  b e  t o  p r o d u c e  a n  
inconsistent object, such as an ACCOUNT2  object with an incorrect balance  field, or a  
BUTTON  object improperly displayed on the screen.
Such a result — an object that d oes not satisfy the invariant o f its generating class,  
that is to say, the fundamental and universal constraints on al l objects of its kind — is one  
of the worst events that could o ccur during the execution of a software system. If such a  
situation can arise, w e can no longer hope to predict what exec ution will do.
To summarize: static binding is either an optimization or a bug . If it has the same  
semantics as dynamic binding (as in cases S 1 and S 2), it is an optimization, which  
compilers may perform. If it has  a different semantics, it is a  bug.
The C++ approach to binding
Given its widespread use and its influence on other languages, it is necessary to explain  
how the C++ language addresses so me of the issues discussed her e.
The C++ convention is surprising.  By default, binding is static . To be dynamically  
bound, a routine (function or met hod in C++ terms) must be spec ially declared as virtual .
Two decisions are involved here:
C1  • Making the programmer responsibl e for selecting static or dyna mic binding.
C2  • Using static bindi ng as the default.
Both are damaging to object-oriented software development, but there is a difference  
of degree: C 1 is arguable; C 2 is hard to defend.
Compared to the approach of this book, C 1 results from a different appreciation of  
which tasks shoul d be handled by humans ( software developers), and which by computers  
(more precisely, compilers). Thi s is the same debate that we en countered with automatic  
memory management. The C++ approach, in the C tradition, is to give the programmer  
full control over the details of what happens at run time, be i t object deallocation or routine  On the ACCOUNT 
example see “CLASS INVARIANTS”, 11.8, page 363.
Cases S1 and S2 
appeared were defined on page 510.
“PROGRAMMER-
CONTROLLED DEALLOCA-TION”, 9.4, page 294
INTRODUCTION TO INHERITANCE  §14.9 514
call. The spirit of object techno logy instead sug gests relying on compilers for tasks that  
are tedious and error-prone, if algorithms are available to han dle them. On a large scale  
and in the long run, compile rs always do a better job.
Developers are responsible for t he efficiency of their software , of course, but they  
should direct their efforts to th e area where they can make a r eal difference: the choice of  
proper software structures and a lgorithms. Language designers a nd compilers writers are  
responsible for the rest.
Hence the disagreement on decision C 1: C++ considers that static binding, as well  
as inlining, should be  specified by developers; the O-O approac h developed in this book,  
that it is the responsibility of  the compiler, which will optim ize calls behind the scenes.  
Static binding is an optimiza tion, not a semantic choice.
C1 has another negative consequence on the application of the met hod. Whenever  
you declare a routine you must s pecify a binding policy: virtua l or not, that is to say  
dynamic or static. This policy run s against the Open-Closed pri nciple since it forces you  
to guess from the start what wil l be redefinable and what will not. This is not how  
inheritance works in practice: y ou may have to redefine a featu re in a distant descendant,  
without having ever foreseen the need for such a redefinition i n the original. With the C++  
approach, if the original designe r did not have enough foresigh t, you need to go back to  
the ancestor class to change the declaration to virtual . (This assumes that you can modify  
its source text. If it is not available, or you are not entitle d to change it, tough luck.)
Because of all this, decision C 1 — requiring programmers to specify a binding  
policy — impedes the ef fectiveness of the object-oriented metho d. 
C2 — the use of static binding as the default in the absence of a  special “virtual”  
marker — is worse. Here it is ha rd to find justifications for t he language design. Static  
binding, as we have seen, is alwa ys the wrong choice when its s emantics differs from that  
of dynamic binding. The re can be not reason  for choosing it as the default.
M a k i n g  p r o g r a m m e r s  r a t h e r  t h a n  c o m p i l e r s  r e s p o n s i b l e  f o r  o p t i m i zation when  
things are safe (that is to say,  asking them to request static binding explicitly when they  
think it is appropriat e) is one thing; forc ing them to write so mething special to get the  
correct semantics  is quite another .  When the concern for ef ficiency , m isplaced o r not,  
starts to prevail over the basic  requirement of correctness, so mething is wrong.
Even in a language tha t makes the programmer responsible for ch oosing a binding  
policy (decision C 1), the default should be the reverse: instead of requiring dyna mically  
bound functions to be declared as virtual , the language should by default use dynamic  
binding and allow programmers to mark as static , or some such keywo rd, those features  
for which they want to request t he optimization — trusting them , in the C-C++ tradition,  
to ascertain that it is valid.
The difference is particularly important for beginners, who nat urally tend to stick  
with the default. Even with less  intimidating a language than C ++, no one can be expected  
to master all the details of inheritance right away; the respon sible policy is to guarantee  
§14.9   DISCUSSION 515
the correct semantics for novice s (and more generally for devel opers starting a new  
project, who will “want to make it right before making it faste r”), then provide an  
optimization facility for people  who need it and understand the  issues.
Given the software industry’s wi d e s p r e a d  c o n c e r n  f o r  “ u p w a r d  c o mpatibility”,  
getting the C++ committee to change the language’s binding poli cy, especially C 2, will be  
hard, but it is worth trying in l ight of the dangers of the cur rent conventions.
The C++ approach has regrettably influenced other languages; fo r example the dynamic  
binding policy of Borland’s Delphi  language, continuing earlier  Pascal extensions, is  
essentially that of C++. Note, however, that Java, a recent der ivative of C++, has adopted  
dynamic binding as its policy.
These observations call for some  practical advic e. What can the  developer do in C++  
or a language that follows its policy? The best suggestion — fo r developers who do not  
have the option of swi tching to better tools, or waiting for th e language to change — is to  
declare all functions as virtual , hence allowing for arbitrary redeclarati ons in the spirit of  
object-oriented software developm ent. (Some C++ compilers unfor tunately put a limit on  
the number of virtuals  in a system, but one may hope that such limitations will go away.)
The paradox of this advice is th at it takes you back to a situa tion in which all calls  
are implemented through dynamic binding and require a bit of ex tra execution time. In  
other words, language conventions (C 1 and C 2) that are promoted as enhancing efficiency  
end up, at least if one follows correctness-enhancing rules, wo rking against performance!
Not surprisingly, C++ experts have come to advise against becom ing “too much”  
object-oriented. Walter Bright, author of a best-selling C++ co mpiler, writes
It’s generally accepted  that the more C++ [mechanisms ] you use in a class , the 
slower your code will be . Fortunately , you can do a few thi ngs to tip the scales  
in your favor . First , don’t use virt ual functions [i.e. dynamic binding],  virtual  
base classes [deferred classes],  destructors , and the like , unless you need them .
[…] Another source of bloat is multiple inheritance […] For a complex class  
hierarchy with only one or two virtual functions , consider removi ng the virtual  
aspect , and maybe do the equivalent with a test and branch .
In other words: avoid using obje ct-oriented tech niques. (The sa me text also  
advocates “ grouping all the initialization code ” to favor locality of reference — an  
invitation to violate elementary  principles of modular design w hich, as we have seen,  
suggest that each clas s be responsible for taking care of its o wn initialization needs.)
This chapter has suggested a different approach: let the O-O so ftware developer rely  
on the guarantee that the semant ics of calls will always be the  correct one — dynamic  
binding. Then use a compiler soph isticated enough do generate s tatically bound or inlined  
c o d e  f o r  t h o s e  c a l l s  t h a t  h a v e  b een determined, on the basis of  rigorous algorithmic  
analysis, not to require a d yn amically bound implementation.[Bright 1995].
“Modular decom-
posability”, page 40 .
INTRODUCTION TO INHERITANCE  §14.10 516
14.10  KEY CONCEPTS INTRODUCED IN THIS CHAPTER 
• W i t h  i n h e r i t a n c e ,  y o u  c a n  d e f i n e new classes by extension, spe cialization and  
combination of previously defined ones. 
• A class inheriting from another is said to be its heir; the or iginal is the parent. Taken  
to an arbitrary number of levels (including zero),  these relati ons yield th e notion of  
descendant a nd ancestor. 
• Inheritance is a key technique for both reusability and extend ibility. 
• Fruitful use of inheritance re quires redefinitio n (the possibi lity for a class to override  
the implementation of some of it s proper ancestors’ features), polymorphism (the  
ability for a reference to become associated at run time with i nstances of different  
classes), dynamic binding (the d ynamic selection of the appropr i a t e  v a r i a n t  o f  a  
redefined feature), type consist ency (the requir ement that an e ntity be only attached  
to instances of descendant types).
• From the module perspective, an  heir extends the services of i ts parents. This  
particularly ser ves reusability.
• From the type perspective, the relation between an heir and a parent of the original  
class is the is relation. This serve s both reusability and extendibility.
• You may redefine an argumentless function into an attribute, b ut not the other  
way around. 
• Inheritance techniques, especial ly dynamic binding, permit hig hly decentralized  
software architectures where every variant of an operation is d eclared within the  
module that describes the corres ponding data structure variant.  
• With a typed language it is pos sible to achieve dynamic bindin g at low run-time cost.  
Associated optimizations, in par ticular compiler-applied static  binding and  
automatic in-line expansion, help O-O software execution match or surpass the  
efficiency of traditional approaches.
• Deferred classes contain one or more deferred (non-implemented ) features. They  
describe partial implementat ions of abstract data types.
• The ability of effect ive routines to call deferred ones provid e s  a  t e c h n i q u e  f o r  
reconciling reusability  with extendibility, through “behavior c lasses”.
• Deferred classes are a principal tool in the use of object-ori ented methods at the  
analysis and design stages. 
• Assertions are applicable to de ferred features, allowing defer red classes to be  
precisely specified. 
• When the semantics is different , dynamic binding is always the  right choice; static  
binding is incorrect. When they have the same abstract effect, using static binding as  
the implementation is an optimiz ation technique, best left to t he compiler to detect  
and apply safely, together wit h inlining when applicable.
§14.11   BIBLIOGRAPHICAL NOTES 517
14.11  BIBLIOGRAPHICAL NOTES 
The concepts of (single) inheritance and dynamic binding were i ntroduced by Simula 67,  
on which references may be found in chapter 35. Deferred routines  are also a Simula  
invention, under a different nam e (virtual procedures) and diff erent conventions. 
The is-a relation is studied, more with a view towards artificial intel ligence  
applications, in [Brachman 1983] . 
A formal study of inheritance and its semantics is given in [Cardelli 1984] .
The double-plus graphical conven tion to mark redefinition comes  from Nerson’s and  
Waldén’s Business Object Notation  for analysis an d design; refe rences in chapter 27.
Some elements of the discussion of the role of d eferred feature s come from [M 1996] .
The Precursor  c o n s t r u c t  ( s i m i l a r  t o  t h e  S m a l l t a l k  super  construct, but with the  
important difference that its use is limited to routine redefin itions) is the result of  
unpublished work with Roger Browne, James McKim, Kim Waldén and  Steve Tynor.
EXERCISES
E14.1  Polygons and rectangles
Complete the versions of POLYGON  and RECTANGLE  sketched at the b eginning of this  
chapter. Include t he appropriate creat ion procedures. 
E14.2  How few vertices for a polygon?
The invariant of class POLYGON requires every polygon to have at least three vertices; note  
that function perimeter  would not work for an empty polygon. Update the definition of the 
class so that it will cover the degenerate case of polygons wit h fewer than three vertices. 
E14.3  Geometrical objects with two coordinates
Write a class TWO_COORD  describing objects that are characterized by two real  
coordinates, having am ong its heirs classes POINT , COMPLEX  and VECTOR . Be careful  
to attach each feature to its pr oper level in the hierarchy. 
E14.4  Inheritance without classes
This chapter has presented two v iews of inheritance: as a modul e, an heir class offers the  
services of its parent plus some; as a type, it embodies the is-a relation (every instance of  
the heir is also an instance of each of the parents). The “pack ages” of modular but not  
object-oriented languages such as Ada or Modula-2 are modules b ut not types; inheritance  
in its first interpretation migh t still be applicable to them. Discuss how such a form of  
inheritance could be introduced in a modular language. Be sure to consider the Open-
Closed principle in  your discussion. 
INTRODUCTION TO INHERITANCE  §E14.5 518
E14.5  Non-creatable classes
It is not permitted to create an instance of a deferred class. In an earlier chapter we saw  
another way to make a class non-creatable: include an empty cre ation clause. Are the two  
mechanisms equivalent? Can you s ee cases for using one rather t han the other? ( Hint : a 
deferred class must have at least one deferred feature.)
E14.6  Deferred classes and rapid prototyping
Deferred classes may not be inst antiated. It was argued, on the  other hand, that a first  
version of a class design might leave all the features deferred .  I t  m a y  b e  t e m p t i n g  t o  
attempt the “execution” of such a design: in software developme nt, one sometimes wishes,  
early in the game, to execute inc omplete implementations, so as  to get an early hands-on  
experience of some aspects of th e system even th ough other aspe cts have not been  
finalized. Discuss the pros and c ons of having a “prototype” op tion in the compiler, which  
would allow instantiating a defe rred class and executing a defe rred feature (amounting to  
a null operation). Discuss the  details of such an option. 
E14.7  Table searching library (term project)
Based on the discussion of table s in this chapter and the chapt er on reusability, design a  
library of table classe s covering various categories of table r epresentations, such as hash  
tables, sequential tabl es, tree tables etc. 
E14.8  Kinds of deferred feature
Can an attribute be deferred?
E14.9  Complex numbers
(This exercise assumes that you have read up to at least chapte r 23.) An example in the  
discussion of module interfaces uses complex numbers with two p ossible representations,  
changes in representations being  carried out behind the scenes.  S t u d y  w h e t h e r  i t  i s  
possible to obtain equivalent re sults through inheritance, by w riting a class COMPLEX
and its heirs CARTESIAN_COMPLEX  and POLAR_COMPLEX . “Rules on creation 
procedures”, page 238.
“Legitimate side 
effects: an exam-ple”, page 759 .
15  
Multiple inheritance 
Full application of inheritance requires an important extension to the framework defined  
in the preceding chapter. In studying the basics of the mechani sm we have encountered the  
notion that a class may need more than one parent. Known as mul tiple inheritance (to  
distinguish it from the more restrictive case of single  inheritance), this possibility is  
necessary to build robust object-oriented architectures by comb ining different abstractions.
M u l t i p l e  i n h e r i t a n c e ,  i n  i t s  b a s i c  f o r m ,  i s  a  s t r a i g h t f o r w a r d  a pplication of the  
principles of inheritan ce already seen; you just allow a class to include an arbitrary number  
of parents. More detailed probi ng brings up two interesting iss ues:
• The need for feature renaming, which in fact has useful applic ations in single  
inheritance too.
• The case of repeated  inheritance, in which the ances tor relation links two classes in 
more than one way.
15.1  EXAMPLES OF MULTIPLE INHERITANCE 
The first task is to form a good idea of when multiple inherita nce is useful. Let us study a  
few typical examples from many d ifferent backgrounds; a few wil l be shown in some  
detail, others only sketched.
This review is all the more neces s a r y  t h a t  i n  s p i t e  o f  t h e  e l e g ance, necessity and  
fundamental simplicity of multipl e inheritance, obvious to anyo ne who cares to study the  
concepts, this facility has sometimes been presented (often, as  one later finds out, based  
solely on experience with languag es or environmen ts that cannot  deal with it) as complex,  
mysterious, error-prone — as the  object-oriented method’s own “ goto”. Although it has no  
basis in either fact or theory, this view has been promoted wid ely enough to require that we  
take the time to review a host of  cases in which multiple inher itance is indispensable.
As it will turn out, the problem is not to think of valuable ex amples, but to stop the  
flow of examples that will start  pouring in once  we open the ta p.
MULTIPLE INHERITANCE  §15.1 520
What not to use as an introductory example
To dispel a frequent confusion, we must first consider an examp le whose use (with some  
variants) by many introductory pa pers, books and lectures may a ccount for some of the  
common mistrust of multiple inher itance. Not that there is anyt hing fundamentally wrong  
with the example; it is simply i nadequate for an introductory p resentation, since it is not  
typical of simple, straightforward uses of multiple inheritance .
The standard form of this example involves classes TEACHER  and STUDENT , part 
of the model for some university  system; you will be invited to  note that some students are  
also teachers, prompting a new class TEACHING_ASSISTANT  that inherits from both  
TEACHER  and STUDENT .
Is this example an improper use of inheritance? Not necessarily . But as an  
introduction to multiple inheritance it is about as bad as they  can get. The problem is that  
TEACHER  a n d  STUDENT  are not separate abstractions but variations on a common  
theme: person, or more accurately UNIVERSITY_PERSON . So if we draw the full picture  
we see a case of not just multiple but repeated inheritance  — the scheme, studied later in  
this chapter, in which a class is a proper descendant of anothe r through two paths or more:
Repeated inheritance is a special case; as will be noted when w e get to it, using this  
facility requires good experience  with the more elementary form s of inheritance, single and  
multiple. So it is not a matter for beginners, if only because it seems to create conflicts (what  
about a feature name  or subscribe_to_health_plan  which TEACHING_ASSISTANT inherits  A case of 
multiple 
inheritance … 
TEACHING_
ASSISTANTSTUDENT TEACHER
… that is a case 
of repeated inheritance
TEACHING_
ASSISTANTUNIVERSITY_
PERSON
STUDENT TEACHER
For details see 
“REPEATED INHERITANCE”, 15.4, page 543 .
§15.1   EXAMPLES OF MULTIPLE INHERITANCE 521
from both of its parents, even t hough they are really in each c ase a single feature coming  
from the common ancestor UNIVERSITY_PERSON ?). With a well-reasoned approach we  
will be able to remove these conflicts simply. But it is a seri ous mistake to begin with such  
exceptional and seemingly trick y cases as if they  were typical of multiple inheritance.
The truly common cases do not raise any such problem. Instead o f dealing with  
variants of a single abs traction, they combine distinct abstractions . This is the form that  
you will need most often in buil ding inheritance structures, an d the one that introductory  
discussions should describe. The  following examples belong to t hat pattern.
Can an airplane be an asset?
Our first proper examp le belongs to system m odeling more than t o software construction  
in the strict sense. But it is t ypical of situat ions that requi re multiple inheritance.
A s s u m e  a  c l a s s  AIRPLANE  describing the abstractio n suggested by its name.  
Queries may include passenger_count , altitude , position , speed ; commands may include  
take_off , land, set_speed .
In a different domain, we may have a class ASSET  describing the accounting notion  
of an asset — something which a company owns, although it may s till be paying  
installments on it, and which it can depreciate or resell. Feat ures may include purchase_  price ,
resale_value , depreciate , resell , pay_installment .
You must have guessed where we ar e heading: companies may own c ompany planes.  
For the pilot, a company plane i s just a plane with its usual f eatures: it takes off, lands, has  
a certain speed, flies somewhere . From the viewp oint of the acc ountant (the one who  
grumbles that the money would ha ve been better kept in the bank  o r  s p e n t  o n  m o r e  
productive ventures) it is an as set, with a purchase value (too  high), an estimated resale  
value (too low), and t he need to pay interest on the loan each month.
To model the notion of company p lane we can resort to multiple inheritance:
class COMP ANY_PLANE inherit
PLANE
ASSET
feature
… Any feature that is spec ific to company planes
     (rather than applying  to all planes or all assets) …
endCompany 
planes
COMPANY_
PLANEASSET PLANE
MULTIPLE INHERITANCE  §15.1 522
To specify multiple parents in the inherit  clause, just list them one after the other.  
(As usual, you can use semicolons  as optional separators.) The order in which you list  
parents is not significant.
Cases similar to COMP ANY_PLANE  abound in system mode ling. Here are a few:
• Wristwatches (a special case of  the notion of watch, itself sp ecializing the general  
notion of clock — there are a few inheritance links here) provi de commands such as  
setting the time, and queries such as the current time and date . Electronic calculators  
provide arithmetic features. The re also exist some (quite handy ) watch-calculators,  
elegantly modeled through multiple inheritance.
• Boats; trucks; AMPHIBIOUS_VEHICLE . A variant is: boats; planes; HYDROPLANE . 
(There is a hint of repeated inheritance here, as with TEACHING_ASSISTANT , since  
both parents may themselves be descendants of some VEHICLE  class.)
• You eat in a restaurant; you tra vel in a train car. To make yo ur trip more enjoyable,  
the railway company may let you eat in an instance of EATING_CAR . A variant of  
this example is SLEEPING_CAR .
• On an instance of SOF A_BED  you may not only re ad but also sleep.
•A  MOBILE_HOME  is a VEHICLE  and a HOUSE .
And so on. Multiple inheritance is the natural tool to help mod e l  t h e  e n d l e s s  
combinations that astute peopl e never tire o f concocting.
For a software e ngineer the preceding ex amples may at first app ear academi c, since  
we get paid not to model the world but to build systems. In man y practical applications,  
however, you will encounter simi lar combinations of abstraction s. A detailed example,  
from ISE’s own graphic al development enviro nment appears later in this chapter.
Numeric and comparable values
The next example is much more di rectly useful to the daily prac tice of object-oriented  
software construction. It is esse ntial to the buildup of the Ke rnel library.
Some of the Kernel library’s classes — that is to say, classes describing abstractions  
of potential use to all applicat ions — require arithmetic featu res: operations such as  
infix  "+", infix "–", infix  "∗", prefix "–" as well as special values zero (identity element  
for "+") and one (identity element for "∗"). Kernel library classes that use these features  
include INTEGER , REAL  and DOUBLE ; but many non-predefined  classes may need them  
too, for example a class MATRIX  describing matrices of some application-specific kind. It  
is appropriate to capture the cor responding abstraction through  a deferred class  
NUMERIC , itself a part of the Kernel library:
deferred class NUMERIC feature
… infix  "+", infix "–", infix  "∗", prefix "–", zero, one …
end
§15.1   EXAMPLES OF MULTIPLE INHERITANCE 523
Mathematically, NUMERIC  h a s  a  p r e c i s e  s p e c i f i c a t i o n :  i t s  i n s t a n c e s  r e p r e s e n t  
members of a ring (a set equippe d with two operations, both of which separately give it  
the structure of a group, one commutative, with distributivity between the two operations).
S o m e  c l a s s e s  a l s o  n e e d  a n  o r d e r  relation, with features for com paring arbitrary  
elements: infix  "<", infix "<=" , infix  ">", infix  ">=" . Again this is useful not only to some  
Kernel library c lasses, such as STRING  whose instances are com parable through lexical  
ordering, but also to many application classes; for example you  may write a class  
TENNIS_CHAMPION which takes into accou nt the ranking of professional tennis pla yers, 
with a feature "<" such that tc1 < tc2 tells us whether tc2 is ranked ahead of tc1. So it is  
appropriate to capture the corre sponding abstraction through a deferred class  
COMP ARABLE , itself a part of the Kernel library:
deferred class COMP ARABLE feature
… infix  "<", infix "<=", infix  ">", infix ">="  …
end
COMP ARABLE has a precise mathematical model:  its instances represent membe rs 
of a set ordered by a total order relation.
Not all desc endants of COMP ARABLE  should be descendants of NUMERIC : in class  
STRING , we need the order features for  lexicographical  ordering but n ot the arithmetic  
features. Conversely, n ot all descendants of NUMERIC should be descendants of  
COMP ARABLE : the set of real matrices has a ddition, multipl ication, zero a nd one, giving  
it a ring structure, but no total order relation. So it is appr opriate that COMP ARABLE  and 
NUMERIC , representing completely differ ent abstractions, should remain  distinct classes,  
neither of them a desc endant of the other.
Objects of certain types, howeve r, are both comparable and nume ric. (In  
mathematical terms. the structures modeled by their generating classes are totally ordered  
rings.) Example classes include REAL  and INTEGER : integers and real numbers can be  
compared for "<="  as well as added and multiplied. These classes should be defin ed 
through multiple inheritance, as in (see the figur e on the next  page):
expanded class REAL inherit
NUMERIC
COMP ARABLE
feature
…
end
Types of objects that need to be both comparable and numeric ar e sufficiently common  
to suggest a class COMP ARABLE_NUMERIC , still deferred, covering the merged  
abstraction by multiply inheriting from COMP ARABLE and NUMERIC . So far this  
solution has not been adopted for the library because it does n ot bring any obvious  
advantage and seems to open the way to endless combinations: wh y not COMP ARABLE_
HASHABLE , HASHABLE_ADDABLE_SUBTRACTABLE ? Basing such deferred classes  
on well-accepted mathematical abstractions, such as ring or tot ally ordered set, seems to  
yield the right level of granularity. Related issues in the met hodology of inheritance are  
discussed in detail in chapter 16.Technically the 
exact model is that of a “preorder”.
MULTIPLE INHERITANCE  §15.1 524
Windows are trees and rectangles
Assume a window system that allows nes ting windows to an  arbitrary dep th:
In the corresp onding class WINDOW , we will find features of two general kinds:
• Some deal with a window as a member of a hierarchical structur e: list of  
subwindows, parent window, number of subwindows, add or remove a subwindow.
• Others cover its prope rties as a graphical object occupying a graphical area: height,  
width, x position, y position, display , hide, translate.INTEGERNUMERIC COMPARABLE
REAL
DOUBLE MATRIX STRINGMultiple 
structure inheritance
Windows and 
subwindows
§15.1   EXAMPLES OF MULTIPLE INHERITANCE 525
It is possible to write the clas s as a single piece, with all t hese features mixed  
together. But this would be bad design. To keep the structure m anageable we should  
separate the two aspects, treating class WINDOW  as the combination of two abstractions:
• Hierarchical structures, which  should be covered by a class TREE .
• Rectangular screen objec ts, covered by a class RECTANGLE .
In practice we may need more specific class names (describing s ome particular  
category of trees, and a graphica l rather than pur ely geometric al notion of rectangle), but  
the ones above will be conven ient for this discussion. WINDOW  will appear as:
class WINDOW inherit
TREE [WINDOW ]
RECTANGLE
feature
… Specific window features …
end
Note that class TREE will be generic, so we need to specify an actual generic  
parameter, here WINDOW  itself. The recursiv e nature of this def inition reflects the  
recursion in the situa tion modeled: a window is a tree of windo ws.
This example will, later on in the discussion, help us understa nd the need for a feature  
renaming mechanism associated with inheritance.
A further refinement might follow from the observation that som e windows are  
purely text windows. Although we might represent this property by introducing a class  
TEXT_WINDOW as a client of STRING  with an attribute
text: STRING
we may prefer to consider that each text window is also a string. In this case we will use  
multiple inhe ritance from WINDOW  a n d  STRING . (If all windows of interest are text  
windows, we might directly u se triple inheritance from TREE , RECTANGLE  and STRING , 
although even in that case it is  probably better  to work in two  successive stages.)
The general question of how to ch oose between heir and client r elations, as in the  
case of TEXT_WINDOW , is discussed in detail in the chapter on inheritance methodol ogy.
Trees are lists and list elements 
Class TREE  itself provides a striking exa mple of multip le inheritance.
A tree is a hierarchica l structure made of nodes, each containi ng some information.  
Common definitions tend to be of the form “A tree is either emp ty or contains an object  
called the root, together with (recursively) a list of trees, c alled the children of the root”,  
complemented by a definition of node , such as “An empty tree h as no nodes; the nodes of  
a non-empty tree comprise its roo t and (recursively) the nodes of its children”. Although  
useful, and reflective of the rec ursiveness inherent in the not ion of tree, these definitions  
fail to capture its es sential si mplicity.See “WOULD YOU 
RATHER BUY OR INHERIT?”, 24.2, page 812 .
MULTIPLE INHERITANCE  §15.1 526
To get a different perspective, observe that there is no signif icant distinction between  
the notion of tree and that of node, as we may identify a node with the subtree of which it  
is the root. This suggests aiming for a class TREE [G] that describes both  trees and nodes.  
The formal generic parameter G represents the type of information attached to every node;  
the tree below, for ex ample, is an instance of TREE [INTEGER ]. 
Now consider a notion of LIST , with a class that has been sketched in earlier chapters.  
A general implementation (linked,  f o r  e x a m p l e )  w i l l  n e e d  a n  a u x iliary class CELL to 
describe the individual  elements of a list.
These notions suggest a simple de finition of trees: a tree (or tree node) is a list, the  
list of its children; but it is a lso a potential list element, as it can be made into a subtree of  
another tree.
Although this definition would n eed some refinement to achieve full mathematical  
rigor, it directly yiel ds a class definition:
deferred class  TREE [G] inherit
LIST [G]
CELL [G]
feature
…
end
From LIST come the features to find out the number of children ( count ), add a child,  
remove a child and so on.
From CELL come the features having to do w ith a node’s siblings and paren ts: next  
sibling, add a sibli ng, reattach to a dif ferent parent node.Definition: tree
A tree is a list that i s also a list element.A tree of 
integers89
235 –2
0 –1 30 5 1000
(CELL )LIST
§15.1   EXAMPLES OF MULTIPLE INHERITANCE 527
This example is typical of the reusability benefits of multiple  inheritance. Writing  
specific features for subtree in sertion or removal would needle ssly replicate the work done  
for lists. Writing specific featu res for sibling and parent ope rations would needlessly  
replicate the work done for lis t elements. Only a facelift is n eeded in each case.
In addition you will have  to take care, in the feature  clause, of the specific features  
of trees and of the little mutua l compromises which, as in any marriage, are necessary to  
ensure that life together is har monious and prolific. In a clas s TREE  derived from these  
ideas, which has been used in ma ny different applications (from  graphics to structural  
editing), these specific feature s fit on little more than a pag e; for the most pa rt, the class is  
simply engendered as the legitimate fruit of the union between lists and list elements. 
This process is exactly that used in mathematics to combine the ories: a topological vector  
space , for example, is a vector space  that also is a topological space ; here too, some  
connecting axioms need to be added to finish up the merger. 
Composite figures
The following example is more than an example; it is a design p attern useful in many  
different contexts.
Consider an inheritance structur e containing classes for variou s graphical figures,  
such as the one used in the preceding chapter to introduce some  of the fundamental  
concepts of inheritance — FIGURE , OPEN_FIGURE , POLYGON , RECTANGLE , 
ELLIPSE  and so on. So far, as you may h ave noted, that structure used single inheritance.
Assume that we have included in this hierarchy all the basic fi gure patterns that we  
need. That is not enoug h yet: many figures are not basic. Of co urse we could build any  
graphical illustration from elem entary shapes, but that is not a convenient way to work;  
instead, we will want to build ourselves a library of figures, some basic, some constructed  
from the basic ones. For example , from basic segment and circle  figures
we may assemble a composite figure, representing a wheel
which someone may in turn use as  a predefined pattern to draw, say, a bicycle; and so on. Elementary 
figures
A composite 
figure
MULTIPLE INHERITANCE  §15.1 528
We need a general mechanism for adding a new figure type which will be built from  
previously defined ones but, once defined, will be on a par wit h them. Computer drawing  
tools provide a Group  command for this purpose.
Let us call the co rresponding notion COMPOSITE_FIGURE . A composite figure is  
clearly a figure; so COMPOSITE_FIGURE  should inherit from FIGURE , achieving the  
goal of treating composite figures “on a par” with basic ones. A composite figure is also  
a list of figures — its constitue nts; each of them may be basic  or itself composite. Hence  
the use of multiple  inheritance:
To get an effective class for COMPOSITE_FIGURE we choose an implementation  
of lists; LINKED_LIST  is just one possibility. The cl ass declaration will look like this:A composite 
figure is a 
figure and a list of figures
OPEN_
FIGURE
SEGMENT POLYLINE
POLYGON ELLIPSE
QUADRANGLECIRCLE TRIANGLEdisplay *
rotate *extent *
…barycenter *
perimeter *
perimeter+
diagonal
SQUAREperimeter++perimeter++perimeter+CLOSED_
FIGUREFIGURE
RECTANGLEperimeter++
side1, side2∗
∗ ∗ COMPOSITE_
FIGURELINKED_LIST
BASIC
FIGURES(see previous
chapter )
§15.1   EXAMPLES OF MULTIPLE INHERITANCE 529
class  COMPOSITE_FIGURE inherit
FIGURE
LINKED_LIST [FIGURE ]
feature
…
end
The feature  clause is particularly pleasant to write. An operation on a co mposite  
figure is, in many cases, an oper ation on all of its constituen ts taken in sequence. For  
example, procedure display  will be effected as follows in COMPOSITE_FIGURE :
display
-- Display figure by displayin g all its components in turn.
do
from
start
until
after
loop
item  display
forth
end
end
As in earlier discussions, we ass ume that our list classes offe r traversal mechanisms based  
on the notion of cursor: start moves the cursor to the first element if any (otherwise after 
is immediately true), after  indicates whether the cursor is past all elements, item gives the  
value of the element at cursor position, and forth  advances the cursor by one position.
I find this scheme admirable and hope its beauty will strike yo u too. Almost  
everything is concentrated here:  classes, multiple inheritance,  polymorphic data structures  
(LINKED_LIST [FIGURE ]), dynamic binding (the call item  display  will apply the proper  
variant of display  based on the type of each list element), recursion (note that any list  
element — any item — may itself be a composite figure, with no limit on the degre e of 
nesting). To think that some peo ple will live an  entire life an d never see this!
It is in fact possible to go further. Consider other COMPOSITE_FIGURE  features  
such as rotate and translate ; because they all must apply the corresponding operation to  
every member figure in turn, the ir body will look very much lik e display . For an object-
oriented designer this is cause for alert: we do not like repet ition; we transform it, through  
encapsulation, into reuse. (This  could yield a good motto.) The  technique to use here is to  
define a deferred “iterator” cla ss, whose instances are little machines able to iterate over  
a COMPOSITE_FIGURE . Its effective descendants may include DISPLAY_ITERATOR  
and so on. This is a s traightforward scheme and is left to the reader as an exercise.
The technique describing composi te structures through multiple inheritance, using a  
list or other container class as  one of the parents, is a gener al design pattern , directly  
useful in widely different areas . Make sure to look at the exer cise asking you to apply  
similar reasoning to the notion of submenu  in a window system: a  submenu is a menu, but  
it is also a menu entry. Another deals with composite commands in an interac tive system.For the details see 
“ACTIVE DATA STRUCTURES”, 23.4, page 774.
Exercise E15.4, 
page 567 .
Exercises E15.8, 
page 568, and E21.6, page 716 .
MULTIPLE INHERITANCE  §15.1 530
The marriage of convenience 
In the preceding examples the tw o parents played a symmetric ro le. This is not always the  
case; sometimes each pa rent brings a contribution of a differen t nature.
An important application of multi ple inheritance is to provide an implementation of  
an abstraction defined by a deferred class,  using facilities pr ovided by  effective class.
Consider the implementation of s tacks as arrays. Since classes are available to cover  
stacks as well as arrays (deferred for STACK , effective for ARRAY , both seen in earlier  
c h a p t e r s ) ,  t h e  b e s t  w a y  t o  i m p l e m e n t  c l a s s  ARRAYED_STACK , describing stacks  
i m p l e m e n t e d  a s  a r r a y s ,  i s  t o  d e f i n e  i t  a s  a n  h e i r  t o  b o t h  STACK  and ARRAY . This is  
conceptually right: an arrayed s tack is a stack (as seen by cli ents) and is also an array  
(internally). The general form is: 
note
description : "Stacks implemented as arrays "
class  ARRAYED_STACK [G] inherit
STACK [G]
ARRAY [G]
… A rename  subclause will be added here (see page 540) …
feature
… Implementation of the  deferred routines of STACK
    in terms of ARRAY  operations (see below) …
end
ARRAYED_STACK  offers the same  functionality as STACK , effecting its deferred  
features such as full, put, count  through implement ations relying on array operations.
Here is an outline of some typical features: full, count  and put. The condition under  
which a stack is full is given by A marriage of 
convenience
ARRAYED_
STACK∗STACK ARRAY
The deferred STACK 
class appeared on page 500 ; class 
ARRAY was sketched 
on page 372 .
§15.1   EXAMPLES OF MULTIPLE INHERITANCE 531
full: BOOLEAN
-- Is stack representation full?
do
Result  := (count = capacity )
end
Here capacity , inherited from class ARRAY , is the number of p ositions in the array.  
For count  we need an attribute:
count : INTEGER
This is a case of effecting a de ferred feature into an attribut e. Here finally is put:
put (x: G)
-- Push x on top.
require
not full
do
count  := count + 1
array_put (x, count )
end
Procedure array_put , inherited from ARRAY , assigns a new value to an array element  
given by its index. 
The array features capacity and array_  put had different names in class ARRAY : count  and 
put. The name change is explained later in this chapter.
ARRAYED_STACK  is representative of a common kind of multiple inheritance,  
called the  marriage of convenience . It is like a marriage uniting a rich family and a noble  
family. The bride, a deferred cl ass, belongs to the aristocrati c family of stacks: it brings  
prestigious functionality but no practical wealth — no implemen tation worth speaking of.  
(What good is an effective change_top  with a deferred put and remove ?) The groom comes  
from a well-to-do bourgeois fami ly, arrays, but needs some lust er to match the efficiency  
of its implementation. The t wo make a perfect match. 
Besides providing effe ctive implementations of routines deferre d in STACK , class  
ARRAYED_STACK  may also redefine some which were not deferred. In particular,  with 
an array representation, change_top (x: G), implemented in STACK  as remove followed by  
put (x), may be implemented more efficiently as 
array_put (x, count )
To make this redefinition valid,  do not forget to announce it i n the inheritance clause: 
class  ARRAYED_STACK [G] inherit
STACK [G]
redefine  change_top end
… The rest as before …
The invariant of the  class might readSee “Using a parent’s
creation procedure”, page 539 .
MULTIPLE INHERITANCE  §15.1 532
invariant
non_negative_count : count >= 0
bounded : count <=capacity
The two parts of the assertion are of a different nature. The f irst expresses a property  
of the abstract data type. (It w as in fact already present in t he parent class STACK , and so  
is redundant; it is included her e for pedagogical purposes, but  should not appear in a final  
version of the class.) The second line involves capacity ,  t h a t  i s  t o  s a y  t h e  a r r a y  
representation: it is an implementation invariant . 
You might take a minute to compare ARRAYED_STACK , as sketched here, with  
STACK2  of an earlier discussion, and see how dramatically inheritance  simplifies the class.  
This comparison will b e pursued in the discu ssion of the method ology of inheritance, which  
will also address some of the cr iticisms occasionally heard aga inst marriage-of-
convenience inheritance and, mor e generally, against what is so metimes called  
implementation inheritance .
Structure inheritance
Multiple inheritance is indispensable when you want to state ex plicitly that a certain class  
possesses some properties beyond  the basic abstraction that it represents. 
Consider for example a mechanism that makes object structures p ersistent (storable  
on long-term storage). You may hav e to request that the lead ob ject in a storable structure  
be equipped with the corresponding store and retrieve operation s: in addition to its other  
properties such an object is “storable”. In the Kernel library,  as we have seen, this property  
is captured by a class STORABLE , from which any other class can inherit. Clearly, such  
classes may have other parents as well, so this would not work without multiple inheritance.  
This form of inheritance, from a class that describes a general  structural property — often  
with a name that ends with -ABLE  — is similar to inhe ritance from classes COMP ARABLE
and NUMERIC  seen earlier in this chapter. T he discussion of inheritance me thodology will  
define it as inheritance of the structural kind.
Without multiple inheritance, th ere would be no way to specify that a certain  
abstraction must possess two structural properties — numeric an d storable, comparable  
and hashable. Select ing one of them as the parent would be like having to choose between  
your father and your mother.
Facility inheritance
Here is another typical case. Ma ny tools need “history” facilit ies, enabling their users to  
perform such operations as:
• Viewing the list of recent commands.
• Executing again a recent command.
• Executing a new command defined  by editing a recent one and ch anging a few  
details.“Implementation 
invariants”, page 376.
The methodological 
discussion is “It feels so good, but is it wrong?”, page 844 . 
STACK2  appeared 
on page 349 .
On STORABLE  see 
“Deep storage: a first view of per-sistence”, page 250 .
For a more detailed 
discussion of this form of inheritance: “Structure inheri-tance”, page 831.
§15.1   EXAMPLES OF MULTIPLE INHERITANCE 533
• Undoing the effect of the l ast command not yet undone
Such a mechanism makes any inter active tool nicer to use. But i t is a chore to write.  
As a result, only a few tools (such as certain “shells” under U nix and Windows) support it,  
often partially. Yet the general techniques are tool-independen t. They can be encapsulated  
in a class, from which a session-control class for any tool can  then inherit. (A solution  
based on the client relation may be possible, but is less attra ctive.) Once again, without  
multiple inheritance such an inheritance link would conflict wi th other possible parents.
A similar case is that of a class TEST encapsulating a number of mechanisms useful  
for testing a class: getting and storing user input, printing a nd storing output, comparing  
with expected values, recording all the results, comparing with  earlier test runs ( regression  
testing ), managing the testing process.  Although a client-based soluti on may be preferable  
in some cases, it is convenient to have the possibility, for te sting a class X, of defining a  
class X_TEST that inherits from X and from TEST .
In later chapters we will enc ounter other cases of such facility  inheritance, whereby  
a class F encapsulates a set of related fa cilities, such as constants or routines from a  
mathematical library, which any cl ass can then obtain by inheri ting from F.
Although the use of inheritance in such cases is sometimes view ed with suspicion, it  
is in fact a perfectly legitimate application of the concept. I t does differ in one respect from  
the other examples of multiple inheritance reviewed in this cha pter: in the cases just  
reviewed, we could achieve our g oals, albeit les s conveniently,  with a client rather than  
inheritance link.
Buttonholes
H e re  is  a  ca se  in  w h i ch ,  a s  i n  e ar li e r o n es ,  m u l t ip le  in h e ri t an ce is indispensable. It is  
s i m i l a r  i n  s p i r i t  t o  “ c o m p a n y  p l a n e s ” ,  “ s l e e p i n g  c a r s ”  a n d  o t h e r examples of the  
combination-of-abstract ions type encountere d earlier. Rather th an using concepts from  
some external model, however, th is one deals with genuine softw are abstractions. The  
reason why it has been moved to the end of this review of multi ple inheritance examples  
is that understa nding it requires a litt le background preparati on.
L i k e  o t h e r  g r a p h i c a l  a p p l i c a t i o n s , many tools of the developmen t environment  
presented in the last chapter of fer “buttons”, on which you can  click to trigger certain  
operations. They also use a “pick and throw” mechanism (a varia tion on traditional “drag-
and-drop”), through which you can  select a visual object, causi ng the mouse cursor to  
change into a “pebble” that indicates the type of the object, a nd bring it to a hole of a 
matching shape. You can “throw” the pebble into the hole by rig ht-clicking; this causes  
some operation to occur. For exa mple, a Class Tool, which you u se to explore the  
properties of a class in the dev elopment environment, has a “cl ass hole” into which you  
can drag-and-drop a cl ass pebble; this cause s the tool to retar get itself to the selected class.See chapter 24 .
See chapter 36 .
MULTIPLE INHERITANCE  §15.1 534
I n  t h e  f i g u r e ,  a  u s e r  h a s  p i c k e d  s o m e w h e r e  —  i n  a  F e a t u r e  T o o l  — the class  
INTEGER , by right-clicking on its name. He is moving it towards the cl ass hole of the  
Class Tool currently targeted to  (showing the text of) class ARRAY . Note the row of format  
buttons at the bottom; clicking on  one of them will show other information for ARRAY ; for 
example if you left-click on  you will get the short form . The pick-and-throw (unless  
canceled by a left-click) will en d when the user right-clicks o n the class hole, whose shape,  
representing Class, matches that  of the pebble. This will retar get the Class Tool on the  
right to the selected class — INTEGER .
In some cases it may be convenient to let a hole act as button too, so that you can not  
only throw an object into it but  also, independently of any pic k-and-throw, left-click on it  
to produce a certain effect. For example the class hole, in whi ch the small dot suggests the  
presence of a current target (first ARRAY , then INTEGER ) can serve as a button; left-clicking  
on it retargets the tool to its current target, which is useful  if the display was overwritten.  
Such holes which double up as b uttons are called buttonholes.
As you will have guessed, class BUTTONHOLE multiply inherits from BUTTON
and from HOLE . The new class simply combines the features and properties of its parents,  
since a buttonhole reacts like a button to the operations on bu ttons, and like a hole to the  
operations on holes.
An assessment
The examples accumulated so far are representative of the power  and usefulness of  
multiple inheritance. Experience  in building general-purpose li braries confirms that  
multiple inher itance is neede d throughout.
Whenever you must combine two ab stractions, not having multiple  inheritance  
would mean that you choose one of them as the official parent, and duplicate all the other’s  
features by copy-and-paste — maki ng the new class, as it were, an illegitimate child. On  
the illegitimate side, you lose polymorphism, the Open-Closed p rinciple, and all the  
reusability benefits of inheri tance. This is not acceptable.
The pebble being draggedThe class hole
Format buttonsINTEGERPick-and-
throw
See [M 1994a] on 
library design.
§15.2   FEATURE RENAMING 535
15.2  FEATURE RENAMING
Multiple inheritance raises an in teresting technical problem: n ame clashes. The solution,  
feature renaming, turns out to h ave applications far beyond tha t original problem, and  
leads to a better understanding of the nature of classes.
Name clashes
A  class has access to all the features of its parents. It can u se them withou t having to  
indicate where they come from: past the inherit  clause in class C inherit A …, a feature  
f of C is known just as f. The same is true of clients of C: for x of type C in some other  
class, a call to the feature is written just x  f, without any re ference to the A origin of f. If 
the metaphors were not so incompat ible, we could view inheritan ce as a form of adoption:  
C adopts all th e features of A.
It adopts them under their assigned names: the set of feature n ames of a class  
includes all of its pare nts’ feature name sets.
What then if two or more parents have used the same name for di fferent features? We  
have relied on the rule of no intra-class overloading: within a  class, a feature name denotes  
only one feature. This could now  be violated because of the par ents. Consider
class  SANTA_BARBARA inherit
LONDON
NEW_YORK 
feature
…
end-- class SANTA_BARBARA
What can we do if both LONDON and NEW_YORK had a feature named the same,  
say foo (for some reason a favorite na me in programming examples)?
Do not attach too much importance to the names in this example,  by the way. No useful  
abstraction is assumed behind the class names, especially none that would justify the  
inheritance structure. The names simply make the example easier  to follow and remember  
than if we called our classes A, B and C.
Under no circumstances should we renounce the no-overloading ru le, essential to  
keep classes simple and easy to understand. Within a class, a n ame should mean just one  
thing. So class SANTA_BARBARA as shown is invalid and th e compiler must reject it.
This rule seems rather harsh. In  an approach emphasizing constr uction-box-like  
combination of modules from seve ral sources, we may expect atte mpts to combine  
separately developed c lasses that contain identically named fea tures.
As an example, we saw earlier a version of class TREE  that inherits from CELL and LIST , 
both of which have a feature called item; for a cell, it returns the value stored in the cell,  
and for a list it returns the value at the current cursor posit ion. Both also have a feature  
called put. These choices of name are all reasonable, and we would not li ke to have to  
change the original classes just because someone got a clever i dea for defining trees by  
combining them.
MULTIPLE INHERITANCE  §15.2 536
What can be done? You should not  have to go back to the parents . You may not have  
access to the source text of LONDON and NEW_YORK ; you may have access to it, but not  
be permitted to change it; you may be permitted but unwilling, as LONDON  comes from  
an external supplier and you know  there will be new releases, w hich would force you to  
do the work all over again; and most importantly you know about  the Open-Closed  
principle, which says one should  not disturb modules when reusi ng them for new  
extensions, and you are rightly wary of changing the interface of classes ( LONDON  and 
NEW_YORK ) which may already have numerou s clients that rely on the old names.
It is a mistake to blame the parents for a name clash occurring  in inheritance: the  
problem is in the would-be heir.  There too should  the solution be.
The language solution to name clashes follows from these observ ations. A class that  
inherits different but identica lly named features from differen t parents is invalid, but will  
become valid by including one or more rename  subclauses in the inheritance clause. A  
rename  subclause gives a new local name to one or more inherited feat ures. For example:
class  SANTA_BARBARA inherit
LONDON
rename  foo as fog end
NEW_YORK
feature
…
end
Both within SANTA_BARBARA and in its clients, the foo feature from LONDON will 
be referred to as fog, and the one from NEW_YORK as foo. Clients of LONDON , of course,  
will still know the feature as foo. 
This is enough (assuming there i s no other clash, and no other feature of LONDON  
or NEW_YORK is called fog) to remove the clash. Of cour se, we could have renamed the  
NEW_YORK feature instead; or we could h ave renamed both for symmetry:
class  SANTA_BARBARA inherit
LONDON
rename  foo as fog end
NEW_YORK
rename  foo as zoo end
feature
…
end
The rename  subclause follows the name of a parent and comes before the redefine
subclause if any. It can of cour se rename several features, as in
§15.2   FEATURE RENAMING 537
class TREE [G] inherit
CELL [G]
rename item as node_item , put as put_right  end
which removes clashes between features of CELL and their namesakes in the other parent,  
LIST . The clause renames the item feature from CELL as node_item , since this feature  
denotes the item attached to the current node, and similarly re names put as put_right .
Effects of renaming
Let us make sure we fully unders tand the results of a renaming.  Assume the last form of  
class SANTA_BARBARA (the one that rena mes both inherited  versions of foo):
(Note the graphical symbol for renaming: .) Assume entities o f the three types:
l: LONDON ; n: NEW_YORK ; s: SANTA_BARBARA
Then l  foo a n d  s  fog are both valid; after a  polymorphic assignment l := s t h e y 
would have the same effect, sinc e the feature na mes represent t he same feature. Similarly  
n  foo and s  zoo are both valid, and after n := s they would have t he same effect.
None of the following, however, is valid:
•l  zoo, l  fog, n  zoo, n  fog s i n c e  n e i t h e r  LONDON  n o r  NEW_YORK has a feature  
called fog or zoo.
•s  foo since as a result  of the renaming SANTA_BARBARA has no feature called foo.
Artificial as the names are, this example also illustrates the nature of the name clash  
issue. Believe it or not, I have  heard it presented as a “deep semantic problem”. It is neither  
semantic nor deep; rather, a simple syntactical problem. Had on e of the class authors been  
led by the local context to choose the name fog in the first class or zoo in the second, no clash  
would have occurred; yet in each case the change is just one le tter. The name clash is, as it  
were, a case of bad luck; it does not reveal any intrinsic prob lem with the classes or their  
ability to be combined. If you think of multiple inheritance as  marriage, this is not a dramatic  
case, discovered at the last mi nute, of a rare blood incompatib ility; it is more like realizing  
that the spouses’ mothers are both called Tatiana, making life a little more complicated for  
their grandchildren to come, but easy to solve through proper n aming conventions.A name clash , 
removed foo
foo      fog
SANTA_
BARBARALONDONNEW_YORKfoo
foo      zoo
MULTIPLE INHERITANCE  §15.2 538
Renaming and redeclaration
In the last chapter we studied a nother inheritance mechanism: r edeclaration of an inherited  
feature. (Remember that redeclar ation includes t he redefinition  of an already effective  
feature, and the effecting of a d eferred one.) It is illuminati ng to compare the effect of  
renaming and redec laring a feature:
• Redeclaration changes the feature, but keeps its name.
• Renaming changes the name  but keeps t he feature.
With redeclaration you can ensure that the same  feature name refers to different
actual features depending on the type of the object to which it  is applied (that is to say, the  
dynamic type of the corresponding  entity). This is a semantic m echanism.
Renaming is a syntactic mechanis m, allowing you to refer to the  same  feature under  
different  names in different classes. 
In some cases you may want to do both:
class  SANTA_BARBARA inherit
LONDON
rename
foo as fog
redefine
fog
end
…
Then assuming l: LONDON ; s: SANTA_BARBARA as before , and the polymorphic  
assignment l := s, the calls l  foo and s  fog will both trigger the redefined version (whose  
declaration must appear in a feature  clause of the class).
You will have noted that the redefine  subclause uses the new name. This is normal  
since that name is the only one under which the feature is know n in the class. Accordingly,  
the rename  clause appears before all other inheritance subclauses ( redefine , and others  
yet to be studied: export , undefine , select ). Past the rename  clause, the feature — like an  
immigrant given a new identity a t Ellis Island by a customs off icer who found the old  
name too hard to pronounce — has shed its ancestral name and wi ll be known under its  
new one to class, clients  and descendants alike.
Local name adaptation
The ability to rename an inherited feature is interesting even in the absence of a name  
clash. It allows the designer of a class to define the appropri ate name for every feature,  
whether immediate (declared in t he class itself) or inherited.
The name under which a class inherits a facility from an ancest or is not necessarily  
the most telling one for its clients. The original name may hav e been well adapted to the  
ancestor’s clients, but the new class has its own context, its own abstraction, which may  
§15.2   FEATURE RENAMING 539
suggest its own naming convention s. To provide this abstraction  it finds the ancestor’s  
features useful, but not necessarily the feature names. Renaming, which enables us to  
distinguish features f rom feature names, pro vides the solution.
The construction of class WINDOW  as an heir of TREE  provides a good example.  
TREE  describes the hierarchical struc ture, common to general trees and windows; but the  
tree names may not be desirable for the interface that WINDOW  presents to its clients.  
Renaming provide s the ability to put these names in tune with t he local context:
class WINDOW inherit
TREE [WINDOW ]
rename
child as subwindow , is_leaf  as is_terminal , root as screen ,
arity as child_count , …
end
RECTANGLE
feature
… Specific window features …
end
Similarly, TREE  inheriting from CELL  may rename right  as right_sibling  and so on.  
Through renaming, a class may of fer its clients a consistent se t of names for the services  
it offers, regardless of how the se services were built from fac ilities provided by ancestors. 
The game of the name
The use of renaming for local na me adaptation highlights the im portance of naming —  
feature naming, but also class n aming — in object-oriented soft ware construction. A class  
is formally a mapping from feature names to features; the featu re names determine how it  
will be known to the rest of the world.
In a later chapter we will see a  number of systematic rules for  choosing feature  
names. Interestingly, they promo te a set of across-the-board na mes — count , put, item, 
remove , … — to emphasize commonalities bet ween abstractions over the ine vitable  
differences. This style, which i ncreases the likelihood of name  c l as he s u nd er  m ul t ip le  
inheritance, decreases the need for “vanity” renaming of the ki nd illustrated with  
WINDOW . But whatever general naming conventions we follow, we must ha ve the  
flexibility to adapt th e names to the local  needs of each class .
Using a parent’s creation procedure 
Let us see one more example of renaming, illustrating a typical  scheme where the renamed  
feature is a creation procedure. Remember ARRAYED_STACK , obtained by inheritance from  
STACK  and ARRAY ; the creation procedure of ARRAY  allocates an array with given bounds: See “Standard 
names”, page 882 .
MULTIPLE INHERITANCE  §15.2 540
make (minb , maxb : INTEGER )
-- Allocate array with bounds minb  and maxb
-- (empty if minb  > maxb )
do … end
To create a stack, we must allocate the array so that it will a ccommodate a given  
number of items. The i mplementation will rely on the creation p rocedure of ARRAY :
class  ARRAYED_STACK [G] inherit
STACK [G]
redefine  change_top end
ARRAY [G]
rename
count as capacity , put as array_put , make as array_make
end
creation
make
feature -- Initialization
make (n: INTEGER )
-- Allocate stack for at most n elements.
require
non_negative_size : n >= 0
do
array_make (1, n) 
ensure
capacity_set : capacity = n
empty : count = 0
end
… Other features (see “The marriage of conv enience”, page 530 ) …
invariant
count >= 0; count <= capacity
end
Note that here our naming conventions — the use of make  as the standard name for  
basic creation procedures — would  cause a name clash, which, ho wever, does not occur  
thanks to renaming.
We also need to remove ambiguities for count and put, both used for features of  
ARRAY as well as STACK . Query count , by convention, denotes the number of items in a  
structure; for ARRAYED_STACK , the relevant count is the number of elements pushed,  
that is to say, count  f r o m  STACK ; the other count , from ARRAY , becomes the stack’s  
capacity — the maximum number of pushable items — and so is ren amed capacity . 
Similarly, put for stacks is the push operation; we keep the array put (the operation that  
replaces the element at a certai n array position) under the new  name array_  put. It is used,  
as you will remember, in t he effecting of the other put, the stack pushing procedure.
§15.3   FLATTENING THE STRUCTURE 541
15.3  FLATTENING THE STRUCTURE
Renaming is only one of the tools that the inheritance craftsma n can use to build rich  
classes satisfying the needs of his clients. Another is redefin ition. Later in this chapter, and  
in the next one, we will see a few more mechanisms: undefinitio n, join, select , descendant  
hiding. The power of these combined mechanisms makes inheritanc e sometimes obtrusive,  
and suggests the need for a special, inheritance-free version o f a class: the flat form.
The flat form
In the view that we see emerging, inheritance is a supplier technique more than a client  
technique. It is primarily an internal tool for constructing cl asses effectively. True, the  
client side will need to know about the inheritance structure i f it is to use polymorphism  
and dynamic binding (with a1: A; b1: B you need to know that B is a descendant of A if 
you are to use the assignment a1 := b1 ); apart from that case, h owever, the inheritance  
structure that led to a particul ar class is none of the clients ’ business.
Like a good car mechanic, we are entirely led by the needs of o ur customers, but how we  
go about taking care of them in t he back of the garage is our r esponsibility.
As a consequence, it should be possible to present a class in a  self-contained manner,  
independent from any kn owledge of its ancest ry. This is particu larly important in the case  
of using inheritance to separate various components of a compos ite abstraction, such as  
the tree and rectangle par ts of the window concept.
The flat form of a class serves that purpose. It is not somethi ng you will ever write;  
instead, you will rely on a tool of the software development en vironment to produce it for  
you, through a command-line script ( flat class_name ) or when you click on a certain icon.
The flat form of a class C is a valid class  text which has exactly  the same semantics  
as C when viewed from a client, excep t for polymorphic uses, but inc ludes no inheritance  
clause. It is what the class would have looked like had its aut hor not been able to use  
inheritance. To produc e a flat form means:
• Removing the entire inherit  clause if any.
• Keeping all the feature declar ations or redeclarations of C.
• Adding declarations for all inherited features, copied from th e declarations in the  
applicable parents and taking int o account all th e inheritance transformations that  
were specified in the inheritance  clause: renaming, rede finition, und efinition,  
select , feature join.
• Adding to each inherited feature a comment line of the form from ANCESTOR
indicating the name of the prope r ancestor from which the curre nt version is derived:  
the closest one that declared or redeclared the feature (and, i n the case of a feature  
join, described later in this chapter, the winning side).
• Reconstructing the full precond itions and postconditions of in herited routines  
(according to the rules on assert ion inheritance explained in t he next chapter).
MULTIPLE INHERITANCE  §15.3 542
• Reconstructing the full invariant, by anding all the parents’ inv ariants, aft er applying  
the proper transformations if the y use any renamed or selected feature.
The resulting class text shows a ll the features of the class at  the same level, not  
making any difference  (except for the from ANCESTOR  comments) between immediate  
and inherited features. If prese nt, the labels of feature claus es — as in feature -- Access
— are retained; clauses with ide ntical labels, whether from par ents or the class itself, are  
merged. Within each feature clau se the features a ppear alphabet ically.
The illustration below shows the beginning of the flat form of the Base library class  
LINKED_TREE , produced in a Class Tool of ISE’s developm ent environment (an d 
scrolled past the note clause). To obtain this result, you target the Class Tool to t he class,  
and click on the Flat format button.
Uses of the flat form
T h e  f l a t  f o r m  i s  a  p r e c i o u s  t o o l  f o r  d e v e l o p e r s :  i t  e n a b l e s  t h e m  t o  s e e  t h e  f u l l  s e t  o f  
properties of a class, all together in one place, ignoring how these features were derived  
in the inheritance games. A pote ntial drawback o f inheritance i s that when reading a class  
text you may not immediately see what a feature name means, sin ce the declaration can  
be in any ancestor. The flat for m solves this pr oblem by giving  you the ful l picture.
The flat form may also be useful  to deliver a stand-alone versi on of a class, not  
encumbered by the class history.  That version will not be usabl e polymorphically.An “immediate” 
feature is one intro-duced in the class itself .
Displaying a 
flat form
Format buttons: flat flat-short short
§15.4   REPEATED INHERITANCE 543
The flat-short form
The flat form is a valid class text. So in its just mentioned r ole as documentation, it is of  
i n t e r e s t  f o r  t h e  s u p p l i e r  s i d e  —  f o r  d e v e l o p e r s  w o r k i n g  o n  t h e  class itself or a new  
descendant. The cl ient side needs more abstraction.
I n  a n  e a r l i e r  c h a p t e r  w e  s a w  t h e  t o o l  t h a t  p r o v i d e s  t h i s  a b s t r a ction: short
(corresponding in the last figur e to the second button to the r ight of flat.)
Combining the two notions yields  the notion of flat-short form.  Like the short form,  
the flat-short form of a class only includes public information , removing any non-exported  
feature and, for exported featur es, removing any implementation  aspects, do clauses in  
particular. But like the flat fo rm, it treats all features, imm ediate or inherit ed, as peers —  
whereas for a class with parents  the non-flat short form only s hows information about  
immediate features.
The flat-short form is the primar y mechanism for documenting cl asses, in particular  
reusable library classes, for th e benefits of their users (clie nt authors). The book presenting  
the Base libraries [M 1994a]  provides all the class sp ecifications in that form.
15.4  REPEATED INHERITANCE
Master Jacques:  Is it to your coachman or to your cook, Sir, that  
you would like to talk? For I am both the one and the other.
Molière, The Miser
As noted at the beginning of thi s chapter, repeated inheritance  arises whenever a class is  
a descendant of another in more than one way. This case causes some potential  
ambiguities, which we must resolve.
Repeated inheritance will only a rise explicitly in advanced dev elopment; so if you are  
only surveying the key components of the method you may skip di rectly to the next chapter.
Sharing ancestors 
As soon as multiple inheritance is allowed into a language, it becomes possib le for a class  
D t o  i n h e r i t  f r o m  t w o  c l a s s e s  B and C, both of which are hei rs, or more generally  
descendants, of the same class A. This situation is called repeated  inheritance.  See “Using asser-
tions for documen-tation: the short form of a class”, page 389 .
Repeated 
inheritanceA
DB CA
D(1) Indirect
(2) Direct
MULTIPLE INHERITANCE  §15.4 544
If B and C are heirs of proper descendants of A (case 1 in the figure), the repeated  
inheritance is said to be indirect. If A, B and C are all the same class (case 2), the repeated  
inheritance is direct; thi s is achieved by writing
class D inherit
A
A
…
feature
…
end
Intercontinental drivers 
The following system modeling ex ample will enable us to see und er what circumstances  
repeated inheritance may occur a nd to study the problem that it  raises. Assume a class  
DRIVER  with attributes such as 
age: INTEGER
address : STRING
violation_count : INTEGER -- The number of recor ded traffic violations
and routines such as 
pass_birthday do age := age + 1 end
pay_  fee
-- Pay the yearly license fee.
do … end
An heir of DRIVER , taking into account the specifi c characteristics of US tax ru les, 
may be US_DRIVER . Another may be FRENCH_DRIVER  (with reference to places where  
cars are driven, not  citizenship). 
Now we may want to con sider people who drive in both France and  the US, perhaps  
because they reside in each country for some part of the year. A simple way to express this  
situation is to use mult iple inherita nce: class FRENCH_US_DRIVER  will be declared as  
heir to both US_DRIVER  and FRENCH_DRIVER . As shown by the figure at the top of the  
facing page, this causes  repeated inheritance.
To make sure that the example is a proper use of inheritance we  assume that US_DRIVER
and FRENCH_DRIVER  are not just distinguished by the value of some attribute  
representing the country of driving, but are indeed distinct ab straction variants, each with  
its specific features. Chapter 24 discusses in depth the methodology of using inheritance.
Sharing and replication
The first and principal problem o f repeated inher itance appears  c l e a r l y  i n  t h e  
intercontinental driver example:
What is the meaning in the repeated descendant (FRENCH_US_DRIVER  in 
the example ) of a feature inherited from the repeated ancestor (DRIVER )? 
§15.4   REPEATED INHERITANCE 545
Consider a feature such as age. It is inherited from DRIVER  by both US_DRIVER
and FRENCH_DRIVER ; so at first sight the name clash rule seems to require renami ng. 
But this would be too stringent: there is no real conflict sinc e age from US_DRIVER  and 
age from FRENCH_DRIVER  are not really different features: they are one feature, from  
DRIVER . Unless you are trying to hide something from someone, you hav e the same age  
wherever you happen to be drivin g. The same applies to procedur e pass_birthday .
If you read carefully the rule ab out name clashes , you will hav e noted that it does not  
preclude such cases. It stated:
A class that inherits different but id entically named feat ures from different  
parents is invalid .
H e r e th e v er si on s of  age an d pass_birthday  th at  FRENCH_US_DRIVER  inherits  
from its two parents are not “ different  ” features, but a single feature in each case. So there  
is no real name clash. (An ambiguity could still exist if one o f the features was redeclared  
in an intermediate ancestor; we will see shortly how to resolve  it. For the moment we  
assume that nothing is redeclared.)
In such cases, when a feature co ming from a repeated ancestor i s inherited under the  
same name from two or more parents, the clear rule is that it s hould give a single feature  
in the repeated de scendant. This case will be called sharing .
Is sharing always appr opriate? No. Consider address , pay_  fee, violation_count : our 
dual drivers will most likely de clare two different addresses t o the respective Departments  
of Motor Vehicles; paying the ye arly fee is a separate process for each country; and traffic  
violations are distinct. For each  of these features inherited f rom DRIVER , class FRENCH_
US_DRIVER  needs not one but two different features. This case will be ca lled replication .FRENCH_US_
DRIVERDRIVER
US_
DRIVERFRENCH_
DRIVERpass_birthday  
pay_ feeage 
address  
violation_countKinds of driver
Page 536 .
MULTIPLE INHERITANCE  §15.4 546
What the example — and many others — also shows is that we coul d not get what  
w e  n e e d  w i t h  a  p o l i c y  t h a t  w o u l d  either share all features of a  repeated ancestor or  
replicate all of them. This is too coarse a level of granularit y. We need the ability to tune  
the policy separately for each repe atedly inherited feature .
We have seen how to obtain shari ng: just do nothing — inherit t he original version  
from both parents under the same name. How do we obtain replica tion? By doing the  
reverse: inheriting it und er two different names.
This idea is consistent with the general rule, simple and clear , that we apply to  
features and their names: within a class, a feature name denote s only one feature; two  
separate names denote two separate features. So to replicate a repeatedly inh erited feature  
we simply make sure that some renaming occurs along the way.
This rule applies to attributes as well as routines. It gives u s a powerful replication  
mechanism: from one feature of a  class, it is possible in a des cendant to get two or more  
features. For an attribute, this means an extra field in all th e instances; for a routine, it  
means a new routine, initial ly with the same algorithm.
Except in special cases involving redeclaration, the replicatio n can be conceptual only:  
no code actually gets duplicated , but the repeated descendant h as access to two features.
The rule gives us the desired fl exibility for combining classes . For example the class  
FRENCH_US_DRIVER  may look like this: 
class FRENCH_US_DRIVER inherit
FRENCH_DRIVER
rename
address as french_address ,
violation_count as french_violation_count ,
pay_  fee as pay_  french_  fee
end
US_DRIVER
rename
address as us_address ,
violation_count as us_violation_count ,
pay_  fee as pay_us_  fee
end
feature
…
endRepeated Inheritance rule
In a repeated descendant, versi ons of a repeatedly inherited fe ature inherited  
under the same name represent a single feature. Versions inheri ted under  
different names represent separa te features, eac h replicated fr om the original  
in the common ancestor.
§15.4   REPEATED INHERITANCE 547
The renaming occurs here at the last stage — in the repeated de scendant — but some  
or all of it could also have been  done by intermediate ancestor s FRENCH_DRIVER  and 
US_DRIVER ; all that counts is whether in the end a feature is repeatedly  inherited under  
one name or more.
The features age and pass_birthday , which have not been re named along any of the  
inheritance paths, will rema ined shared, as desired. 
A replicated attribute such as address  will, as noted, yield a n ew field in each of the  
instances of the repeated descen dant. So assuming there are no other features than the ones  
listed, here is how instances of the classes will look:
(Instances of FRENCH_DRIVER  and US_DRIVER  have the same composition as those of  
DRIVER  as shown.)
This is the conceptual picture, but with a good implementation it must be the concrete  
representation too. Particularly  important is the ability not t o replicate the fields for shared  
attributes such as age in FRENCH_US_DRIVER . A naïve implementation would replicate  
all fields anyway; some fi elds, such as the duplicate age field, would simply never be used.  
Such waste of space is not acceptable, since it would accumulat e as we go down inheritance  FRENCH_US_
DRIVERDRIVER
US_
DRIVERFRENCH_
DRIVERpass_birthday  
pay_ feeage 
address  
violation_count
pay_ fee  pay_ french_ fee  
violation_count  
     french_violations_count  
address  french_address pay_ fee  pay_us_ fee  
violation_count  
          us_violations_count  
address  us_address Sharing and 
replication
Attribute 
replication
violation_countaddressage
(DRIVER )
(FRENCH_US_DRIVER )french_violation_countfrench_addressage
us_violation_countus_address
MULTIPLE INHERITANCE  §15.4 548
hierarchies, and lead to catastrophic space inefficiency. (As a  general rule, one must be very  
careful with attributes, as every  attribute field will be prese nt at run time in each one of the  
potentially many instances of a class and its descendants.)
The compiling mechanism of the d evelopment environment describe d at the end of  
this book indeed makes sure tha t no attribute space is lost: co nceptually shared attributes  
are shared physically too. This is one of the most difficult pa rts of implementing  
inheritance and the calling machin ery of dynamic b inding, espec ially under the additional  
requirement that repeated inheritance must not affect the perfo rmance achievements  
described in earlier chapters:
• Zero cost for genericity.
• Small, constant-bound ed cost for dynamic binding (that cost mu st be the same  
whether or not a system incl udes repeated inheritance).
The implementation meets these go als, making repeated inheritan ce a technique that  
any system can use  at no extra cost.
Repeated inheritance in C++ follows a different pattern. The le vel of granularity for  
deciding to share or duplicate is the class. So if you need to duplicate one field from the  
repeated ancestor, you will need  to duplicate all. For that rea son, C++ users tend to stay  
away from this mechanism altogether. Java has eliminated the pr oblem — by eliminating  
multiple inheritance.
Unobtrusive repeated inheritance
Cases of repeated inheritance similar to the “transcontinental drivers”, with duplicated  
features as well as shared ones,  do occur in practice, but not frequently. They are not for  
beginners; only after you have r eached a good level of sophisti cation and practice in object  
technology should you encounter any need for them.
I f  y o u  a r e  w r i t i n g  a  s t r a i g h t f o r w a r d  a p p l i c a t i o n  a n d  e n d  u p  u s i ng repeated  
inheritance, you are probably ma king things more complicated than you need to. 
The figure shows a typical beginner’s (or absent-minded develop er’s) mistake: D is 
made an heir of B, and also needs facilities from A; but B itself inherits from A. Forgetting  
that inheritance is transit ive, the developer wrote Redundant 
inheritanceA
DB
§15.4   REPEATED INHERITANCE 549
class  D… inherit
B
A
…
T h i s  c a s e  c a u s e s  r e p e a t e d  i n h e r i t a n c e ,  b u t  w h a t  i t  r e a l l y  s h o w s  i s  redundant
inheritance. One of th e pleasant consequence s of the convention s discussed so far, and of  
the corresponding imple mentation, is that they will yield the e xpected behavior in such a  
case: in the absence of renaming , all features will be shared; no new features will be  
introduced, and there will be no performance overhead. Even if B renames some attributes,  
the only consequence wil l be some waste of space.
The only excep tion is the case in which B has redefined a feature of A, which causes  
an ambiguity in D. But then, as explained below, you will get an error message f rom the  
compiler, inviting you to select one of the two versions for us e in D.
A case of redundant but harmle ss inheritance m ay occur when A is a class  
implementing general-purpose f acilities like in put or output (s uch as the class STD_FILES
from the Kernel lib rary), needed by D as well as B. It is enough for D to inherit from B: 
this makes D a descendant of A, giving it access to all the needed features. Inheriting  
redundantly will not, h owever, have any harm ful consequences — in fact, it will have no  
consequences at all.
Such involuntary and innocuous cases of repeated inheritance ma y also occur as a result  
of inheritance from universal classes ANY and GENERAL , studied in the next chapter.
The renaming rule
(This section introduc es no new concept but gives a more precis e formulation of the rules  
seen so far, and an ex planatory example.)
We can now give a precise worki ng of the rule prohibiting name clashes:
Definition: final name
The final name of a feature in a class is:
• For an immediate feature (that is to say, a feature declared i n the class  
itself), the name under which it is declared.
• For an inherited feature that i s not renamed, its final name ( recursively)  
in the parent from whi ch it is inherited.
• For a renamed feature, the na me resulting from the renaming.
Single Name rule
Two different effective features  of a class may not have the sa me final name.See “THE GLOBAL 
INHERITANCE STRUCTURE”, 16.2, page 580.
MULTIPLE INHERITANCE  §15.4 550
A  name clash occurs if two dif fe rent features, both effective, still have the same  
name even after renaming subclau ses have been taken into accoun t. Such a name clash  
makes the class invalid, but is easy to correct by adding the p roper renaming subclause.
The key word is different  features. If a feature from a repeated ancestor is inherited  
from both parents under the same  name, the sharing rule applies : only one feature  is being  
inherited, so there is no name clash.
The prohibition of nam e clashes only applies to effective featu res. If one or more  
homonymous features are deferred, you can actually merge them since there is no  
incompatibility between  implementations; th e details will be se en shortly.
The rules are simple, intuitive a nd straightforwa rd. To check o ur understanding one  
final time, let us buil d a simple example s howing a legitimate case and an invalid case:
class A feature
this_one_OK : INTEGER
end
class B inherit A feature
portends_trouble : REAL
end
class C inherit A feature
portends_trouble : CHARACTER
end
class D inherit
-- This class is invalid!
B
C
end
That class D inherits this_one_OK twice — once from B, once from C — does not
cause a name clash, since the feature will be shared; it is ind eed the same feature, coming  
from A, in each case.
The two features called portends_trouble ,  ho w e ve r ,  de se rv e t he i r n am e :  th ey  ar e  
different features, and so they cause a name clash, making clas s D invalid. (They have  
different types, but giving them  the same type would not affect  this discussion.)
It is easy to make class D valid through renaming; for example:
class D inherit
-- This class is n ow quite valid.
B
rename portends_trouble as does_not_portend_trouble_any_more end
C
endA
DB Cthis_one_OK
portends_trouble portends_trouble
§15.4   REPEATED INHERITANCE 551
Conflicting redefinitions
In the cases seen so far only names could change along the vari ous inheritance paths. What  
if some intermediate ancestor, such as B or C on the last figure, redeclares a feature that is  
then repeatedly inherited? Under  dynamic binding t here may be a n ambiguity in D.
Two simple mechanisms, undefinit ion and selection, will solve t he issue. As usual  
you will be invited to participa te in the development of these mechanisms and will see that  
once a problem is stated clearly  the language so lution follows immediately.
Assume that somewhere along the way a repeatedly inherited feat ure gets redefined:
Class B redefines feature f (this is the conventional meaning of the ++ symbol, as you  
will recall). So now you  have two variants of f available in D: the redefined version from  
B, and the version from C, which here is the original version from A. (We might assume  
that C also redefines f in its own way, but this would bring nothing to the discussion  except  
more symmetry.) This is different from all the previous cases, in which there was only one  
version of the feature , possibly inherited under different name s.
What are the consequences? T he answer depends on whether D inherits the two  
versions of f under the same name or different names, that is to say whether  the repeated  
inheritance rule impli es sharing or replicat ion. Let us review the two cases in turn.
Conflicts under sharing: undefinition and join
Assume first that the two versio ns are inherited under the same  name. This is the sharing:  
case: with just one fea ture name, there must be exactly one fea ture. Three possibilities:
S1  • If one of the two versions is deferred and the other effective , there is no difficulty:  
the effective version will serve to effect the other. Note that  in the Single Name rule  
this case was explicitly permitted: the rule only prohibited na me clashes between  
two effective features.Redefinition 
causing 
potential 
ambiguityA
DB Cf
f++
MULTIPLE INHERITANCE  §15.4 552
S2  • If both versions are effective,  but each of them appears in a redefine subclause,  
there is no problem either: both inherited versions are merged into a new version,  
whose redefinition a ppears in the class.
S3  • But if the versions are both effective and not both redefined,  we have a true name  
clash: class D will be rejected as violating the Single Name rule.
Often S 3 will indeed reflect an error: y ou have created an ambiguity fo r a certain  
feature name, and you must resol ve it. The usual resolution is to rename  one of the two  
variants; then instead of sharin g you get replication — two dif ferent features. This is the  
other main case, replication, studied next.
In some situations, however, you  may want a more sophisticated resolution of the S3  
conflict: letting one of the two variants, say the one from B, take over. Then the obvious  
solution is to transform this case into S 1 by making one of the two variants deferred.
The rules on redefinition allow us to redefine an effective f into a deferred version;  
but they would force us to introdu ce an intermediate class, say  C', an heir of C whose only  
role is to redefine f  into a deferred version; then we would make D inherit from C' rather  
than C. This is heavy and inelegant. Instead, we need a simple langua ge mechanism:  
undefine . It will yield a new subclau se in the inheritance part:
class D inherit
B
C
undefine f end
feature
…
end
If more than one sub clause is present, undefine  naturally comes after rename (since  
any undefinition should apply to t he final name of a feature) b ut before redefine (since we  
should take care  of any undefinition bef ore we redefine anythin g).
A sign that a proposed  language mechanism is desirable is, almo st always, that it  
should solve several problems ra ther than just one. (Conversely , bad language  
m e c h a n i s m s  t e n d  t o  c a u s e  a s  m a n y  p r o b l e m s ,  t h r o u g h  t h e i r  i n t e r a ctions with other  
language traits, as they purport  to solve.) The undefinition me chanism satisfies this  
property: it gives us the ability to join features under multiple — not necessarily repeated  
— inheritance. Assume that we wi sh to combine two abstractions into one:
Two parents 
with features 
to be merged
DB C f g 
§15.4   REPEATED INHERITANCE 553
We want D to treat the two features f  and g as a single feature; this clearly requires  
that they have compatible signatures (number and types of argum ents and result if any), and  
compatible semantics. Assuming that they have different names, and that we want to keep  
the f name, we can achieve the desired  result by combining renaming with undefinition:
class D inherit
B
Crename
g as f
undefine
f
end
feature
…
end
Here the victory of B is total: it imposes both the fe ature and the feature name. All  
other combinations are  possible: we may get the feature from on e of the parents and the  
name from the other; o r we may rename both features to an entir ely new name for D.
Another way to join features is more symmetric: replace both in herited versions by a  
new one. To achieve this, simply make sure that the features ha ve the same final name,  
adding a rename  subclause if necessary, and list them both in redefine  subclauses, with a  
new declaration in the class. Then there is no illicit name cla sh (this is case S 2 above), and  
both features are joined into the new version.
Note the versatility of the renaming mechanism (showing that it  s a t i s f i e s  t h e  j u s t  
introduced criterion for good language traits): originally intr oduced as a technique for  
removing name clashes, it now enables us to introduce  name clashes — name clashes of a  
desirable kind, resolved by undefining one of the inherited ver sions to let the other take over.
Conflicts under replication: selection
There remains to consider the case of conflicting redefinitions  under replication, that is to  
say when the repeated descendant inherits the separately redefi ned features with different  
names, and they are both effective.
The need for 
selectionA
DB Cf
f  bf  ++
MULTIPLE INHERITANCE  §15.4 554
On the B branch in the figure, feature f is renamed bf and is also redefined. Favoring  
again simplicity over symmetry w e  a s s u m e  n o  c h a n g e  i n  t h e  C branch; renaming or  
redefining f in C would not affect the d iscussion. Also, note that the result wou ld be the  
same if B redefined the feature  without renaming it, the renaming then o ccurring at the D 
level. Let us assume this is not a case of join (which would ar ise if we redefined both  
features, under S 2 above, or undefined one of them).
Because the features are inhe rited under di fferent names bf and f, replication applies:  
D gets two separate features from the feature f of A. In contrast with previous cases of  
replication, these are not dupli cates of the same feature, but different features.
Here, unlike in the sharing case,  there is no name clash. But a s the careful reader will  
have noted, a different problem arises (the last issue of repea ted inheritance), due to  
dynamic binding. Assume that a polymorphic entity a1 of type A, the common ancestor,  
becomes attached at run time to an instance of D, the common descen dant. What then  
should the call a1  f do? 
The rule of dynamic binding states tha t the version of f to apply is the one deduced  
from the type of the target object, here D. But now for the first tim e that rule is ambiguous:  
D has two versions — known locally as bf and f — of the original f of A.
The observation made i n the case of name clashes, which led to the renaming  
mechanism, applies here too: we cannot, in an approach favoring  clarity and reliability, let  
the compiler make the choice be hind the scenes through some def ault rule. The author of  
the software must be in control.
This shows the need for a simple language mechani sm to resolve the ambiguity:
class D inherit
B
C select f end
feature
…
end
to trigger C’s version under dynamic bi nding for an entity of type  A, and
class D inherit
B select bf end
C
feature
…
end
to select B’s version instead. The select  clause will naturally appear after rename , 
undefine  and redefine  if present (you select variants  once everything has been named  and 
defined). Here is the rule governing its usage:
§15.4   REPEATED INHERITANCE 555
The select  resolves the ambiguity once and for all: proper descendants of  the class  
do not need to repea t it (and should not).
Selecting everything
Every redefinition conflict  must be resolved through select . When combining two classes  
that cause several such conflict s, you may want one of the clas ses to win all or most of  
these conflicts. This happens in particular with inheritance of  t h e  “ m a r r i a g e  o f  
convenience” form, as illustrated by ARRAYED_STACK  inheriting from STACK  a n d 
ARRAY , if the parents have a common ancestor. (In the Base libraries , both classes cited  
are indeed distant descendants of a general CONTAINER  class.) In such a case, since one  
of the p arents — wh at has been c alled the noble parent, here STACK — provides the  
specification, you will probably want to resolve all conflicts,  or most of them, in its favor.
The following important  notational facility simplifies your tas k in such cases, by  
avoiding the need to list all con flicting features individually . At most one of the parent  
listings in the inherit  clause may be of the form
SOME_P ARENT
select all end
The effect is simply, as suggested by the keyword all, to resolve in favor of  
SOME_P ARENT all redefinition conflicts — mor e precisely all the conflicts t hat might  
remain after the application of other select  subclauses. This last qualification means that  
you can still request some othe r parent’s version for certain f eatures.
Keeping the original version of a redefined feature
(This section describes a more s pecialized technique and may be  skipped on first reading.)
In the introduction to  inheritance we saw a simple construct al lowing a redefined  
feature to call the original version: Precursor . The repeated inh eritance mechanism,  
through its support for feature duplication, provides a more ge neral (but also heavier)  
solution in those rare cases for  which the basic mechanism does  not suffice.
C o n s i d e r  a g a i n  t h e  e a r l i e r  e x a m p l e :  BUTTON  inheriting from WINDOW  a n d 
redefining display  as
display
-- Display butto n on the screen.
do
window_display
special_button_actions
endSelect rule
A class that inherits two or more different effective versions of a feature from  
a repeated ancestor, and does not redefine them both, must incl ude exactly one  
of them in a select  clause.The case in which 
both are redefined corresponds to S2 , 
page 552 .
“Using the original 
version in a redefini-tion”, page 493 .
MULTIPLE INHERITANCE  §15.4 556
where window_display  takes care of displaying the bu tton as if it were a normal win dow, 
and special_button_actions  adds button-specific elements s uch as displaying the button’s  
border. Feature window_display  is exactly the same as the WINDOW  version of display .
W e have seen how to write window_display  simply as Precursor . (If there is any  
ambiguity, that is to say if two or more parents redefine their  display  routine into the new  
one, the selected parent will appear in double braces, as in Precursor {WINDOW }.) We 
can achieve the same goal, altho ugh less simply , through repeat ed inheritance:
note
WARNING : "This is a first attempt — this version is invalid !"
class  BUTTON inherit
WINDOW
redefine display end
WINDOW
rename display as window_display end
feature
…
end
Because one of the branches renames display , the repeated inheritance rule indicates  
that BUTTON will have two versions of that f eature, one redefined and keepi ng the  
original name, the other not r edefined but having the name window_display .
As indicated, this is almost valid but not quite: we need a select . If (as will usually  
be the case) we want to select the redefined version, this will  give:
note
note: "This the (valid !) repeated inheritance sche me for continuing to use  %
%the original version of a redefined feature "
class  BUTTON inherit
WINDOW
redefine
display
select
display
end
WINDOW
rename
display as window_display
export
{NONE } window_display
end
feature
…
endThe selection
§15.4   REPEATED INHERITANCE 557
If several features need this sc heme, you can list them togethe r (in other words, you  
do not need to inherit more than twice from the parent). Often you will want to resolve all  
conflicts in favor of the redefi ned versions; in  that case, use  select all .
The export  clause (studied only in the next chapter, although there is li ttle more to it than  
shown here) changes the export status of an inherited feature: WINDOW  probably  
exported the original display , now known as window_display , but BUTTON  makes it  
secret. Although window_display  is a full-fledged feature of t he class, which needs it for  
its internal purposes, clients have no use for it. As discussed  in earlier examples,  
exporting the original version of an inherited feature might ma ke the class formally  
incorrect if that version does not  satisfy the new class invari ant.
To apply hiding to all features inherited along a certain branc h you can, here too, use the  
keyword all, as in export {NONE } all.
This pattern of exporting only the redefined version, making th e original secret under  
a new name, is the most common. It is not universal; the heir c lass sometimes needs to  
export both versions (assuming the original does not violate th e invariant), or to hide both.
How useful is this technique using repeated inheritance to keep  the original version of  
a redefined feature? Usually you do not need it: the Precursor  construct suffices. You  
should use repeated inheritance when you do not just require th e old version for  
implementing the redefined one, but want to keep it, along with  the redefined version, as  
one of the features of the new class.
Remember that if both are exporte d they must both make sense fo r the corresponding  
abstraction; in particular, the y must preserve the invariant.
An advanced example
Here is an extensive e xample showing various  aspects of repeate d inheritance at work.
The problem, similar in spirit to the last example, comes from an interesting  
discussion in the basic book on C++ [Stroustrup 1991] .
Consider a class WINDOW  with its display  procedure and two heirs, WINDOW_
WITH_BORDER  and WINDOW_WITH_MENU  representing the abstractions suggested  
by their names. Each redefines display  so that it will first perform the standard window  
display, and then display the bo rder in the first case, and the  menu cells in the second.
We may want to describe windows that have both a border and a m enu; hence the use  
of repeated inheritance for class WINDOW_WITH_BORDER_AND_MENU .
MULTIPLE INHERITANCE  §15.4 558
In class WINDOW_WITH_BORDER_AND_MENU  we will again redefine display ; 
here the redefined version shoul d apply the standard window dis play, then display the  
border, then display the menu.
The original WINDOW  class has the following form:
class WINDOW feature
display
-- Display window ( general algorithm)
do
…
end
… Other features …
end
For an heir such as WINDOW_WITH_BORDER  we need to apply the original  
display  and add border display. We do not need repeated  inheritance he re, but can simply  
rely on the Precursor construct:
class WINDOW_WITH_BORDER inherit
WINDOW
redefine display end
feature -- Output
display
-- Draw window and its border.
do 
Precursor
draw_border
end
feature {NONE } -- Implementation
draw_border do … end
…
endWINDOW_WITH_
BORDER_AND_MENUWINDOW
WINDOW_
WITH_BORDERdisplay
WINDOW_
WITH_MENUWindow 
variants
§15.4   REPEATED INHERITANCE 559
Note the addition of a procedure draw_border  which displays the border. It has been  
hidden from clients (exported to NONE ), since from the outside it makes no sense to  
display the border only. Class WINDOW_WITH_MENU  is exactly symmetrical:
class WINDOW_WITH_MENU inherit
WINDOW
redefine  display end
feature  -- Output
display
-- Draw window and its menu.
do 
Precursor
draw_menu
end
feature {NONE } -- Implementation
draw_menu do … end
…
end
It remains to write the common heir WINDOW_WITH_BORDER_AND_MENU
of these two classes, a r epeated descendant of WINDOW . Here is a first attempt:
note
WARNING : "This is a first atte mpt — this version wi ll not work properly !"
class  WINDOW_WITH_BORDER_AND_MENU inherit
WINDOW_WITH_BORDER
redefine display end
WINDOW_WITH_MENU
redefine display end
feature
display
-- Draw window a nd its border.
do 
Precursor {WINDOW_WITH_BORDER }
Precursor {WINDOW_WITH_MENU }
end
…
end
Note the need to name the parent in each use of Precursor : each parent has a display
feature, each redefined into the same new display (otherwise we would have an invalid  
name clash, of course), so in ea ch case we must say which one w e want.
MULTIPLE INHERITANCE  §15.4 560
But, as Stroustrup notes (for a different solution), this is no t correct: both parent  
versions call the original WINDOW  version, which will end up being called twice, possibly  
producing garbled output. To get a correct form, we may among o ther solutions let the new  
class inherit directly from WINDOW , making it a triple descendant of that class:
note
note: "This is a correct version "
class  WINDOW_WITH_BORDER_AND_MENU inherit
WINDOW_WITH_BORDER
redefine
display
export {NONE }
draw_border
end
WINDOW_WITH_MENU
redefine
display
export {NONE }
draw_menu
end
WINDOW
redefine display end
feature
display
-- Draw window and its border.
do 
Precursor  {WINDOW }
draw_border
draw_menu
end
…
end
Note that for good measur e we have made features draw_border  and draw_menu  
hidden in the new class, as there does not seem to be any reaso n for clients of  
WINDOW_WITH_BORDER_AND_MENU  to call them directly.
In spite of its lavish use of re peated inheritance, this class does not need any select
since it redefines all inherited versions of display  into one. This is th e benefit of using  
Precursor  rather than feature replication.
A good way to test your understa nding of repeated inheritance i s to rewrite this  
example without making use of the Precursor  construct, that is to say by using repeated  
inheritance to obtain feature re plication at the level of the t wo intermediate classes. You  
will, of course, need select  subclauses.Exercise E15.10, 
page 568 .
§15.4   REPEATED INHERITANCE 561
In the version obtained above, t here is sharing only, no replic ation. Let us extend  
Stroustrup’s example by assuming that WINDOW  also has a query id (perhaps an integer)  
used to identify each window. If each window is identified at m ost once, then id will be  
shared and we do not need to cha nge anything. But if we want to  keep track separately of  
instances of each window type, an instance of WINDOW_WITH_BORDER_AND_MENU
will have three separa te identifiers. The new class combines sh aring with replication:
note
note: "More complete version with separate identifiers "
class  WINDOW_WITH_BORDER_AND_MENU inherit
WINDOW_WITH_BORDER
rename
id as border_id
redefine
display
export {NONE }
draw_border
end
WINDOW_WITH_MENU
rename
id as menu_id
redefine
display
export {NONE }
draw_menu
end
WINDOW
rename
id as window_id
redefine
display
select
window_id
end
feature
…. The rest as before …
end
Note the need for select ing one of the versions of id.
Repeated inheritance and genericity
To finish this review of repeate d inheritance, we must consider  a specific case which could  
cause trouble if left unchecked.  It arises for features involvi ng formal generic parameters.  
Consider the following scheme (w hich could also arise with indi rect repeated inheritance): The only changes are 
the additions marked with an arrow .
MULTIPLE INHERITANCE  §15.4 562
class  A [G] feature
f: G; …
end
class  B inherit
A [INTEGER ]
A [REAL ]
end
In class B, the repeated inheritanc e rule would imply that f  is shared. But this leaves  
an ambiguity on its type: does it return an integer or a real? The same problem would occur  
if f were a routine with a n argument of type G. 
Such an ambiguity is not a cceptable. Hence the rule:
You can remove the ambiguity by renaming the offending feature at the point of  
inheritance, to get duplicat ion rather than renaming. 
Rules on names
(This section only formalizes pr eviously seen rules, and may be  skipped on first reading.)
We have seen that name clashes are prohibited when they could c ause ambiguity, but  
that some cases are valid. To fi nish off this presentation of m ultiple and repeated  
inheritance without leaving any ambiguity, it is useful to summ arize the constraints on  
name clashes with a single rule:Genericity in Repeated Inheritance rule
The type of any feature that is shared under the repeated inher itance rule, and  
t h e  t y p e  o f  a n y  o f  i t s  a r g u m e n t s  i f  i t  i s  a  r o u t i n e ,  m a y  n o t  b e  a  g e n e r i c  
parameter of the  class from which the fe ature is repeatedly inh erited. 
Name clashes: definition and rule
In a class obtained through multiple inheritance, a name clash  occurs when  
two features inherited from different parents have the same fin al name.
A name clash makes t he class invalid except  in any of the following cases:
N1  •The two features are inherited f rom a common ancestor, and non e has 
been redeclared from the v ersion in that ancestor.
N2  •Both features have compatible signatures, and at least one of them is  
inherited in deferred form.
N3  •Both features have compatible s ignatures, and they are both re defined  
in the class.
§15.5   DISCUSSION 563
Case N 1 is the sharing case und er repeated inheritance.
In case N 2, a feature is “inherited in deferred form” if it was deferred in the parent,  
or if it was effective but the class undefine s it.
Cases N 2 and N 3 have been separated but can be merged into a single case, the join
case. Considering n features ( n >= 2) rather than just two, these cases arise when the class  
gets n features with the same name, an d compatible signatures, from i ts various parents.  
The name clash is valid if we can let the inheritance join all of these featu res into one,  
without any ambiguit y. This means that:
• You can have any number of deferred features among the lot sin ce they will not cause  
any conflicting definitions. (As  n o t e d ,  a  d e f e r r e d  f e a t u r e  i s  e ither one that was  
already deferred, or one t hat the class undefines.)
• If exactly one of the features is effective, it imposes its im plementation to the others.
• If two or more features are effective, the class must provide a common redefinition  
for all of them. (An example was the joining in WINDOW_WITH_BORDER_AND_
MENU of the display procedures of the three parents. ) The redefinition will also, o f 
course, serve as effecting for a ny deferred feature participati ng in the clash.
Here then is the precise rule on the Precursor  construct. If a re definition uses a  
precursor version, case N 3 is  t he  on ly  on e ca us in g a mbi g ui ty  as  t o w ho se  ve r si on  is  
intended. Then you must resolve t he ambiguity by writing the pr ecursor call as  
Precursor  {PA R E N T } (…) where PA R E N T  is the name of the desired class. In all other  
cases (simple inheritance , or multiple outside of N 3) naming the parent is optional.
15.5  DISCUSSION 
Let us probe further the consequ ences of some of  the decisions made in this chapter.
Renaming 
Any language that has multiple i nheritance must deal with the p roblem of name clashes.  
Since we cannot and should not r equire developers to change the  original classes, only two  
conventions are possible besides the solution described in this  chapter: 
• Require clients to r emove any ambiguity. 
• Choose a default interpretation. 
With the first convention, a class C inheriting two features called f, one from A and 
one from B, would be accepted by the compi ler, possibly with a warning me ssage. Nothing  
bad would happen u nless a client of C contained something like 
x: C
… x  f …
which would be invalid. The clie nt would have to qualify the re ference to f, with a notation  
such as x    f   | A or x    f   | B, to specify one of the variants. 
MULTIPLE INHERITANCE  §15.5 564
This solution, however, runs con trary to one of the principles emphasized in this  
chapter: that the inheritance st ructure leading to a class is a  private affair between the class  
and its ancestors, not relevant for clients except through its influence on polymorphic uses.  
When I use service f from C, I should not need to know whether C introduced it itself or  
got it from A or B. 
With the second convention, x  f  is valid; the underlying l anguage mechanisms select  
one of the variants, based on so me criterion suc h as the order in which C lists its parents;  
a notation may be available for r equesting another variant expl icitly.
This approach has been implemente d in several Lis p-based langua ges supporting  
multiple inheritance. But it is dangerous to let some underlyin g system choose a default  
semantics. The solution is also incompatible wit h static typing : there is no reason why two  
features with the same name in d ifferent parents should be type wise compatible. 
The renaming mechanism solves the se problems; it brings other b enefits, such as the  
ability to rename inherited feat ures with names that are meanin gful to clients. 
O-O development and overloading
This chapter’s discussion of the  role of names brings the final  perspective on the question  
of in-class name overloading, co mplementing the preliminary obs ervations made in  
earlier chapters.
Recall that in languages such as  Ada (83 and 95) you can give t he same name to  
different features w ithin the same synt actical unit, as in
infix "+" (a, b: VECTOR ) …
infix "+" (a, b: MATRIX ) …
which could both appear in the sa me Ada package. C++ and Java h ave made the same  
possibility available within a single class.
An earlier presentation called this facility syntactic overloading. It is a static  
mechanism: to disambiguate a given call, such as x + y, it suffices to look at the types of  
the arguments x and y, which are apparent from the program text.
Object technology in troduces a more powe rful of overloading: semantic (or 
dynamic ) overloading. If classes VECTOR  and MATRIX  both inherit a feature
infix  "+" (a: T ) …
from a common ancestor NUMERIC , and each redeclares it in the appropriate way, then a  
call x + y will have a different effect de pending on the dynamic type of x. (Infix features  
are just a notational convenienc e: with a non-infix feature the  call x + y would be written  
something like x  plus (y).) Only at run time will the ambiguity be resolved. As we know,  
this property is key to the fl exibility of O-O development.
Semantic overloading is the truly interesting mechanism. It all ows us to use the same  
name, in different cla sses, for variants of  what is essentially  the same operation  — such  
as addition from NUMERIC . The next chapter’s rules on as sertions will ma ke it even more  
clear that a feature r edeclaration must keep  the same fundament al semantics.“Syntactic over-
loading”, page 93 .
§15.5   DISCUSSION 565
Does this leave a role for syntac tic overloading in object tech nology? It is hard to  
find any. One can understand why  Ada 83, which does not have cl asses, should use  
syntactic overloading. But in an  object-oriented language, to l et developers choose the  
same name for two different operations is to create the possi bility of confusion.
The problem is that the syntactic form of overloading clashes w ith the semantic form  
provided by polymorphi sm and dynamic bindi ng. Consider a call x  f (a). If it follows the  
possibly polymorphic assignments x := y and a := b, the result is exact ly the same, in the  
absence of renaming, as that of y  f (b), even if y and b have other types than x and a. But 
with overloading this property is not true any more! f may be the overloaded name of two  
features, one for the type of a and one for the type of b. Which rule tak es precedence,  
syntactic overloading or the O-O concept of dynamic binding? (P robably the former, but  
not until it has fooled a few de velopers, novice or not.) To ma ke things worse, the base  
class of y’s type may redefine e ither or both of the o verloaded features.  The combinations  
are endless; so are the sour ces of confusion and error.
What we are witnessing here is t he unpleasant consequences of t he interaction  
between two separate language tra its. (A language addition, as noted earlier in this chapter  
on another topic, shou ld whenever possible solve  new problems beyond its original  
purpose — not create ne w problems through its interaction with other mechanisms.) A  
prudent language desig ner, having toyed with a possible new fac ility, and encountering  
such incompatibilities with more important properties of the de sign, quickly retreats.
What, against these risks, is th e potential benefit of syntacti c overloading? On  
careful examination it seems dub ious to start with. A simple pr inciple of readability holds  
that within the same module a re ader should have absolutely no hesitation making the  
connection between a name and the meaning of that name; with in -class overloading, this  
property collapses.
A typical example — sometimes me ntioned in favor of overloading  — is that of  
features of a STRING class. To append another string or a single character you will,  in 
the absence of overloading, use different feature names, as in s1  add_string  (s2) and 
s1  add_character ('A'), or perhaps, using infix operators, s := s1 ++ s2  and s   :=    s1   +   'A'. 
With overloading, you can use a single name for both operations . But is this really  
desirable? Objects of types CHARACTER  and STRING  have quite different properties; for  
example appending a character wi ll always increase the length b y 1; appending a string  
may leave the length unchanged (if the appended string was empt y) or increase it by any  
amount. It seems not only reasonable but desirable to use diffe rent names — especially  
since the confusions cited above  are definitely possible (assum e that CHARACTER
inherits from STRING and that another des cendant redefines add_string  b u t  n o t  add_
character .)
Finally, we have already encountered the observation that even if we wanted  
overloading we would in general need a different disambiguating  criterion. Syntactic  
overloading distinguis hes competing routines by looking at thei r signatures (numbers and  
types of arguments); but this is often not significant. The typ ical example was the creation  
procedures for points,  or complex numbers: make_cartesian  and make_polar  both take  
two arguments of type REAL  — to mean completely differ ent things. You cannot use  “Multiple creation 
and overloading”, page 239 .
MULTIPLE INHERITANCE  §15.6 566
overloading here! The routines’ signatures are irrelevant. To e xpress that two features are  
different, we should use the obvi ous technique, the same that w e apply in everyday life to  
express that two things or conce pts are different: give them di fferent names.
For creation operations (“c onstructors”) such as make_cartesian  a n d  make_polar  t h e 
Java and C++ solution is particularly ironic: you may not  give them different names but  
are forced to rely on overloading, using the class name. I have  been unable to find a good  
solution to this problem other than adding an artificial third argument.
In summary: syntactic (in-class) overloading appears in an obje ct-oriented context  
to create many problems for no vi sible benefit. ( Some methodolo gical advice to users of  
languages such as C++, Java and Ada 95: do not use this facilit y at all, except for cases  
such as multiple constructor fun ctions in which the language le aves no other choice.) In a  
consistent and productive applic ation of object technology we s hould stick to the rule —  
simple, easy to teach, easy to apply and easy to remember — tha t, within a class, every  
feature has a name and every f eature name denotes one feature.
15.6  KEY CONCEPTS INTRODUCED IN THIS CHAPTER
• The construction-box approach to software construction favored  b y  o b j e c t  
technology requires the ability t o  c o m b i n e  s e v e r a l  a b s t r a c t i o n s  into one. This is  
achieved by multiple inheritance.
• In the simplest and most common cases of multiple inheritance,  th e tw o pa re nt s  
represent disjoint abstractions.
• Multiple inheritance is frequent ly needed, both for system mod eling and for  
everyday software deve lopment, in particula r the construction o f reusable libraries.
• Name clashes under multiple inh eritance should be removed thro ugh renaming.
• Renaming also serves to provide  classes with lo cally adapted t erminology for  
inherited features.
• Features should be di stinguished from feature names. The same feature can be  
known under different names in different classes. A class defin es a mapping from  
feature names to features.
• Repeated inheritance, an advanced  technique, arises as a resul t of multiple  
inheritance when a class is a d escendant of anot her through two  or more paths.
• Under repeated inheritance, a f eature from the common ancestor  yields a single  
feature if it is inherited under  a single name, separate featur es otherwise.
• Competing versions from a common ancestor must be disambiguate d, for dynamic  
binding, through a select  subclause.
• The replication mechanism of re peated inheritance should not r eplicate any feature  
involving generic parameters.
• In an object-oriented framework , the semantic form of overload ing provided by  
dynamic binding is m ore useful than synt actic overloading.
§15.7   BIBLIOGRAPHICAL NOTES 567
15.7  BIBLIOGRAPHICAL NOTES 
The renaming mechanism and the repeated inheritance rules origi nated with the notation  
of this book. The undefinition m echanism is an invention of Mic hael Schweitzer, and the  
selection mechanism an invention  of John Potter, both in unpubl ished correspondence.
The walking menu example comes from [M 1988c] .
EXERCISES
E15.1  Windows as trees
Class WINDOW  inherits from TREE [WINDOW ]. Explain the generic parameter. Show  
that it yields an interesting cl ause in the class invariant. 
E15.2  Is a window a string?
A window has an associated text, described by an attribute text of type STRING . Rather  
than having this a ttribute, should WINDOW  be declared as an heir to STRING ? 
E15.3  Doing windows fully
Complete the design of the WINDOW  class, showing exactly what is needed from the  
underlying terminal handling mechanism. 
E15.4  Figure iterators
The presentation of class COMPOSITE_FIGURE  mentioned the possibility of using  
iterator classes for all operati ons that perform a certain oper ation on a composite figure.  
Develop the corresponding iterator classes. ( Hint : [M 1994a]  presents library iterator  
classes which provide  the basic pattern.)
E15.5  Linked stacks
Write the class LINKED_STACK  which describes a linked li st implementation of stacks,  
as an heir to both STACK  and LINKED_LIST . 
E15.6  Circular lists and chains
Explain why the LIST  c l a s s  m a y  n o t  b e  u s e d  f o r  c i r c u l a r  l i s t s .  ( Hint : a look at the  
assertions, benefiting from the d iscussion at the beginning of the next chapter , may help.).  
D e f i n e  a  c l a s s  CHAIN  t h a t  c a n  b e  u s e d  a s  p a r e n t  b o t h  t o  LIST  a n d  t o  a  n e w  c l a s s  
CIRCULAR  describing circular lists. Update LIST  a n d  i f  n e c e s s a r y  i t s  d e s c e n d a n t s  
accordingly. Complete the class structure to pro vide for variou s implementations of  
circular lists. Exercise E15.8, 
page 568.
See also “Itera-
tors”, page 848 .
MULTIPLE INHERITANCE  §E15.7 568
E15.7  Trees
One way to look at a tree is to see it as a recursive structure : a list of trees. Instead of the  
technique described in  this chapter, where TREE  is defined as heir to both LINKED_LIST
and LINKABLE , it seems possib le to define 
class  TREE [G] inherit
LIST [TREE [G]]
feature … end
Can you expand this definition i nto a usable class? Compare it with the method used in  
the discussion of this chapter.
E15.8  Walking menus
Window systems offer a notion of menu, which we can cover throu gh a class MENU , with 
a query giving the list of entrie s and commands to display the menu, move to the next entry  
etc. Since menus are made of entries we also need a class MENU_ENTRY  with queries  
such as parent_menu  a n d  operation (the operation to execute when a user selects the  
entry), and co mmands such as execute (which executes operation ).
Many systems offer cascading menu s, also called “walking menus” , where selecting an  
entry causes the display of a s ubmenu. The figure illustrates a  walking menu under Sun’s  
Open Windows manager, whe re selecting the entry Programs  brings up a submenu:
Show how to define the class SUBMENU . (Hint : a submenu is a menu and a menu entry,  
whose operation  must display the submenu.)
Could this notion be described e legantly in a language with no multiple inheritance?
E15.9  The flat precursor
What should the flat form of a class show for an instruction us ing the Precursor construct?
E15.10  Repeated inheritance for replication
Write the WINDOW_WITH_BORDER_AND_MENU  c l a s s  w i t h o u t  r e c o u r s e  t o  t h e  
Precursor construct, using replication und er repeated inheritance to gain  access to the  
parent version of a redefined feature. Make sure to use the pro per select  subclauses and to  
give each feature its p roper export status.Walking 
menus
(The last entry of the 
submenu , Demos , 
denotes in turn a  
submenu .)

16  
Inheritance techniques
From the last two chapters we hav e learned to appreciate inherit ance as a key ingredient  
in the object-oriented approach t o reusability and extendibilit y. To complete its study we  
must explore a few more facilities — something of a mixed bag, but all showing striking  
consequences of the beauty of the basic ideas:
• How the inheritance mechanism re lates to assertions and Design  by Contract.
• The global inheritance stru cture, where a ll classes fit.
• Frozen features: when the Open- Closed principle  does not apply .
• Constrained genericity: how to put requirements  on generic par ameters.
• Assignment attempt: how t o force a type — safely.
• When and how to change type pr operties in a redeclaration.
• The mechanism of anchored dec laration, avoiding  redeclaration avalanche.
• The tumultuous relationship bet ween inheritance and informatio n hiding.
Two later chapters will pursue i nheritance-related topics: the review of typing  issues  
in chapter 17, and a detailed methodological discussion of how to use inheritance  (and 
how not to misuse it) in chapter 24.
Most of the following sections p roceed in the same way: examini ng a consequence  
of the inheritance ideas of the l ast two chapters; discovering that it raises a challenge or an  
apparent dilemma; analyzing the problem in more depth; and dedu cing the solution. The  
key step is usually the next-to- last one: by taking the time to  pose the problem carefully,  
we will often be led d irectly to the answer.
16.1  INHERITANCE AND ASSERTIONS 
Because of its very power, inheri tance could be dangerous. Were  it not for the assertion  
mechanism, class developers could  use redeclaration and dynamic  binding to change the  
semantics of operations treachero usly, without much possibility  of client control. But  
assertions will do more: they w ill give us deeper  insights into  the nature of inheritance. It  
i s  i n  f a c t  n o t  a n  e x a g g e r a t i o n  t o state that only through the p rinciples of Design by  
Contract can one finally underst and what inheritance is really about.
INHERITANCE TECHNIQUES  §16.1 570
The basic rules governing the ra pport between inhe ritance and a ssertions have already  
been sketched: in a descendant class, all ancestors’ assertions  (routine preconditions and  
postconditions, class invariants) st ill apply. This section giv es the rules more precisely and  
uses the results obtained to tak e a new look at inheritance, vi ewed as subcontracting. 
Invariants 
We already encountered the r ule for class invariants:
The parents’ invariants are added to the class’s own, “addition ” being here a logical  
and then . (If no invariant is given in a class, it is considered to hav e True as invariant.)  
By induction the invariants of al l ancestors, direct or indirec t, apply. 
As a consequence, you should not repeat the parents’ invariant clauses in the  
invariant of a class (although su ch redundancy would be semanti cally harmless since  
a and then  a is the same thing as a).
T h e  f l a t  a n d  f l a t - s h o r t  f o r m s  o f  t h e  c l a s s  w i l l  s h o w  t h e  c o m p l e te reconstructed  
invariant, all ancestors’  clauses concatenated.
Preconditions and postconditions in the presence of dynamic bin ding
The case of routine preconditions  and postconditions is slightl y more delicate. The general  
idea, as noted, is that any redeclaration must satisfy the asse rtions on the original routine.  
This is particularly important if that routine was deferred: wi thout such a constraint on  
possible effectings, attaching a precondition and a postconditi on to a deferred routine  
would be useless or, worse, misleading. But the need is just as  bad with redefinitions of  
effective routines.
The exact rule will follow direc tly from a careful analysis of the consequences of  
redeclaration, polymorphism and dynamic binding. Let us constru ct a typical case and  
deduce the rule from that analysis.
Consider a class and o ne of its routines with a precondition an d a postcondition:
The figure also shows a client C of A. The typical way for C to be a client is to  
include, in one of its routines,  a declaration and call of the formParents’ Invariant rule
The invariants of all the parent s of a class apply to the class  itself. 
See “FLATTENING 
THE STRUCTURE”, 15.3, page 541 .
The routine , 
the client and 
the contractAr
require
α
…ensure
β
endC
§16.1   INHERITANCE AND ASSERTIONS 571
a1: A
…
a1  r
For simplicity, we ignore any arguments that r may require, and we assume that r is 
a procedure, although  the discussion appli es to a function just  as well.
Of course the call will only be correct if it satisfies the pre condition. One way for C
to make sure that it observes its part of the contract is to pr otect the call by a precondition  
test, writing it (instead of just a1  r) as
if a1  α then
a1  r
check  a1  β end -- i.e. the postcondition holds
… Instructions that may assume a1  β …
end
(As noted in the discussion of assertions, this is not required : it suffices to guarantee, with  
or without an if instruction, that α holds before the call.  We will assume the if form for  
simplicity, and ignore any else clause.)
Having guaranteed the precondition, the client C is entitled to th e postcondition on  
return: after the call , it may expect that a1  β will hold.
All this is the basics of Desi gn by Contract: the client must  ensure the precondition  
on calling the routine a nd, as a recompense, may count on the postcond ition being satisfied  
when the routine exits.
What happens when inheritance enters  the picture?
Assume that a new class A' inherits from A and redeclares r. How , if at all, can it  
change the precondition α into a new one γ and the postcondition β into a new one δ?
To decide the answer, consider t he plight of the client. In the  call a1  r the target a1
may now, out of polymorphism, be of type A' rather than just A. But C does not know about  
this! The only declaration for a1 may still be the original one:
a1: AThe routine , 
the client , the 
contract and the descendantAr
require
α
…ensure
β
endC
A'r++
require
γ
…ensure
δ
end
INHERITANCE TECHNIQUES  §16.1 572
which names A, not A'. In fact C may well use A' without its author ever knowing about  
the existence of such a class; the call to r may for example be in a routine of C of the form
some_routine_of_C (a1: A)
do
…; a1  r; …
end
Then a call to some_routine_of_C  from another class may use an actual argument of  
type A', even though the text of C contains no mention of class A'. Dynamic binding means  
that the call to r will in that case use the redefined A' version.
So we can have a situation where C is only a client of A but in fact will at run time  
use the A' version of some features. (We could say that C is a “dynamic client” of A' even 
though its text does not show it.)
What does this mean for C? The answer, unless we do something, is: trouble. C can 
be an honest client, observing its part of the deal, and still be cheated on the result. In
if a1  α then  a1  r end
if a1 is polymorphically attach ed to an object of type A', the instruction calls a routine that  
expects γ and guarantees δ, whereas the client has  been told to satisfy α and expect  β. So 
we have a potential discrepancy between the client’s and suppli er’s views of the contract.
How to cheat clients
To understand how to satisfy the clients’ expectations, we have  to play devil’s advocate  
and imagine for a second how we could fool them. It is all for a good cause, of course (as  
with a crime unit that tries to emulate criminals’ thinking the  better to fight it, or a  
computer security expe rt who studies the techniques of computer  intruders).
If we, the supplier, wanted to cheat our poor, honest C client, who guarantees α and 
expects  β, how would we proceed? There a re actually two ways to evil:
• We could require more  than the original precondition α. With a stronger precondition,  
we allow ourselves to exclude (th at is to say, no t to guarantee  any specific result) for  
cases that, according to the orig inal specification, were perfe ctly acceptable.
Remember the point emphasized repeatedly in the discussion of D esign by  
Contract: making a precondition stronger facilitates the task o f the supplier  
(“the client is more often wrong”), as illustrated by the extre me case of  
precondition false (“the client is always wrong”).
• We could ensure less than the original postcondition β. With a weaker postcondition,  
we allow ourselves to p roduce less than wha t the original speci fication promised.
As we saw, an assertion is said t o be stronger than another if it logically implies it,  
and is different; for example, x >= 5 is stronger than x >= 0. If A is stronger than B, B is 
said to be weaker than A.
§16.1   INHERITANCE AND ASSERTIONS 573
How to be honest
From understanding how to cheat we deduce how to be honest. Whe n redeclaring a  
routine, we may keep the origina l assertions, but we may also:
• Replace the precondition by a weaker  one.
• Replace the postcondition by a stronger  one.
The first case means being more generous than the original — ac cepting more cases.  
This can cause no harm to a client that satisfies the original precondition before the call.  
The second case means producing more than what was promised; th is can cause no harm  
to a client call that relies on the original postcondition bein g satisfied after the call.
Hence the basic rule:
The rule expresses that the new version must accept all calls t hat were acceptable to  
the original, and must guarantee at least as much as was guaran teed by the original. It may  
— but does not have to — accept m ore cases, or provide stronger  guarantees.
As its name indicates, this rule applies to both forms of redec laration: redefinitions  
and effectings. The second case is particularly important, sinc e  i t  a l l o w s  y o u  t o  t a k e  
seriously the assertion s that may be attach ed to a deferred fea ture; these assertions will be  
binding on all effective  versions in descendants.
The assertions of a routine, def erred or effective, specify the  essential semantics of  
the routine, applicable not only to the routine itself but to a ny redeclaration in descendants.  
M o r e  p r e c i s e l y ,  t h e y  s p e c i f y  a  range of acceptable behaviors  f o r  t h e  r o u t i n e  a n d  i t s  
eventual redeclarations. A redec laration may specialize this ra nge, but not violate it.
A consequence for the class author is the need to be careful, w hen writing the  
assertions of an effective routine, not to overspecify . The assertions must characterize the  
intent of the routine — its abstract semantics —, not the prope rties of the original  
implementation. If you overspeci fy, you may be closing off the possibility for a future  
descendant to provide a d ifferent implementation.
An example
A s s u m e  I  w r i t e  a  c l a s s  MATRIX  implementing line ar algebra opera tions. Among the  
features I offer to my clients i s a matrix invers ion routine. I t is actually a combination of a  
command and two queries: procedure invert  inverts the matrix, and sets attribute inverse  to 
the value of the inverse matrix , as well as a boolean attribute  inverse_valid . The value of  
inverse  is meaningful if and only if inverse_valid  is true; otherwise th e inversion has failed  
because the matrix was singular. F or this discussion we can ign ore the singularity case. Assertion Redeclaration rule (1)
A routine redeclaration may only  replace the original precondit ion by one  
equal or weaker, and the origin al postcondition by one equal or  stronger.
For a more rigorous 
definition see “A mathematical note”, page 580
INHERITANCE TECHNIQUES  §16.1 574
Of course I can only compute an approximation of the inverse of  a matrix. I am  
prepared to guarantee a certain precision of the result, but si nce I am not very good at  
numerical analysis, I shall only  accept requests for a precisio n not better than 10–6. The 
resulting routine will look like this: 
invert (epsilon : REAL )
-- Inverse of current ma trix, with precision epsilon
require
epsilon >= 10 ^ (–6)
do
“Computation of inverse”
ensure
((Current ∗ inverse ) |–| One ) <= epsilon
end
The postcondition assumes that  the class has a function infix  "|–|" such that m1 |–|  m2 
is |m1 — m2 |, the norm of the matrix difference of m1 and m2, and a function infix "∗"
which yields the pro duct of two matrices; One is assumed to denote the identity matrix. 
I am not too proud of myself, so for the summer I hire a bright  young programmer-
numerician who rewrites my invert  routine using a much be tter algorithm, which  
approximates the result more cl osely and accepts a smaller epsilon : 
require
epsilon >= 10 ^ (–20)
…
ensure
((Current ∗ inverse ) |–| One ) <= (epsilon  / 2)
The author of this new version i s far too clever to rewrite a f ull MATRIX  class; only  
a few routines need adaptation. T hey will be included in a desc endant of MATRIX , say 
NEW_MATRIX .
If the new assertions are in a redefinition, they must use a di fferent syntax than shown  
above. The rule will be given shortly.
The change of assertions satisfi es the Assertion Redeclaration rule: the new  
precondition  epsilon >= 10 ^ (–20) is weaker than (that is to say, implied by) the original  
epsilon >= 10 ^ (–6); and the new postcondition is  stronger than  the original.
This is how it should be. A client of the original MATRIX  may be requesting a matrix  
inversion but, through  dynamic binding, actually calling the NEW_MATRIX variant. The  
client could contain a routine
some_client_routine (m1: MATRIX ; precision : REAL )
do
… ; m1  invert (precision ); … 
-- May use either the MATRIX  or the NEW_MATRIX  version
end
to which one of its own clients passes a first a rgument of type  NEW_MATRIX .Warning : syntacti-
cally not valid as a redefinition . See 
next.
§16.1   INHERITANCE AND ASSERTIONS 575
NEW_MATRIX  must be able to accept and handle correctly any call that MATRIX  
would accept. If we made t he precondition of the new invert  stronger than the original (as  
in epsilon  >= ^ (–5)), calls which are correct for MATRIX would now be incorrect; if we  
made the postcondition weaker, the result returned would not be  as good as guaranteed by  
MATRIX . By using a weaker precondition  and a stronger postcondition w e correctly treat  
all calls from clients of MATRIX , while offering a better  deal to our own clients.
Cutting out the middleman
The last comment points to an interesting consequence of the As sertion Redeclaration  
rule. In our general scheme
the assertions of the redeclared version, γ a n d  δ, if different from α a n d  β, are more  
f a v o r a b l e  t o  t h e  c l i e n t s ,  i n  t h e  s e n s e  e x p l a i n e d  e a r l i e r  ( w e a k e r precondition, stronger  
postcondition). But a client of A w h i c h  u s e s  A' through polymorphism and dynamic  
binding cannot make good use of this improved contract, since i ts only contract is with A.
Only by becoming a direct client of A' (the shaded link with a question mark on the last  
figure) can you take advantage of the new contract, as in
a1: A'
…
if a1  γ then  a1  r end
check  a1  δ end -- i.e. the postc ondition holds
But then of course you have specialized a1 to be of type A', not the general A; you 
have lost the poly morphic generality  of going through A.
The tradeoff is clear. A client of MATRIX  must satisfy the original (stronger)  
precondition, and may only expect the original (weaker) postcon dition; even if its  
request gets served dynamically by NEW_MATRIX  it has no way of benefiting from the  
broader tolerance of inputs and tighter precision of results. T o get this improved  
specification it must declare the matrix to be of type NEW_MATRIX , thereby losing  
access to other implementations represented by descendants of MATRIX  that are not also  
descendants of NEW_MATRIX .The routine , 
the client and 
the sub-
contractorAr
require
α
…ensure
β
endC
A'r++
require
γ
…ensure
δ
end?
INHERITANCE TECHNIQUES  §16.1 576
Subcontracting 
The Assertion Redeclaration rule  fits nicely in the Design by C ontract theory introduced  
in the chapter bearing that title.
We saw that the assertions of a routine describe the contract a ssociated with that  
routine: the client is bound by the precondition and entitled t o the postcondition, and  
conversely for the c lass implementer.
Inheritance, with redeclaratio n and dynamic binding, means subcontracting. When  
you have accepted a contract, you do not necessarily want to ca r r y  i t  o u t  y o u r s e l f .  
Sometimes you know of somebody el se who can do it cheaper and p erhaps better. This is  
exactly what happens when a clie nt requests a routine from MATRIX  but, through dynamic  
binding, may actually call at run  time a version redefined in a  proper descendant. Here  
“cheaper” refers to routine rede finition for more efficiency, a s in the rectangle perimeter  
example of an earlier chapter, and  “better” to improved asserti ons in the sense just seen. 
The Assertion Redeclaration rule simply states that if you are an honest  
subcontractor and accept a contra ct, you must be willing to do the job originally requested,  
or better than the reque sted job, but not less.
The scheme described in the last section — declaring a1 of type A' to benefit from the  
improved contract — is similar to the behavior of a customer wh o tries to get a better deal  
by bypassing his contractor to work directly with the contracto r’s own subcontractor
In the Design by Contract view, c lass invariants are general co nstraints applying to  
both contractors and clients. Th e parents’ invariant rule expre sses that all such constraints  
are transmitted to subcontractors. 
It is only with assertions, and w ith the two rules just seen, t hat inheritan ce takes on  
its full meaning for object-orien ted design. The contracting-su bcontracting metaphor is a  
powerful analogy to gui de the develop ment of correct object-ori ented software; certainly  
one of the central deas.
Abstract preconditions
The rule on weakening preconditio ns may appear too restrictive in the case of an heir that  
restricts the abstraction provid ed by its parent. Fortunately, there is an easy workaround,  
consistent with the theory.
A typical example arises if you want to make a class BOUNDED_STACK  inherit  
from a general STACK  class. In BOUNDED_STACK  the procedure for pushing an element  
onto the stack, put, has a precondition, which requires count <= capacity , where count  is 
the current number of stack elements and capacity  is the physically available size.
For the general notion of STACK , however, there is no notion of capacity . So it seems  
we need to strengthen  the precondition when we move down to BOUNDED_STACK . How 
do we build this inheritance stru cture without violating the As sertion Redecl aration rule?
The answer is straightforward if we take a closer look at clien t needs. What needs to  
be kept or weakened is not necessarily the concrete preconditio n as implemented by the  
supplier (which is the supplier’ s business), but the preconditi on as seen by the client . 
Assume that we write put in STACK  as
§16.1   INHERITANCE AND ASSERTIONS 577
put (x: G)
-- Push x on top.
require
not full
deferred
ensure
…
end
with a function full defined always to return false, so that by default stacks are never full:
full: BOOLEAN
-- Is representation full?
-- (Default: no)
do Result := False  end
Then it suffices in BOUNDED_STACK  to redefine full:
full: BOOLEAN
-- Is representation full?
-- (Answer: if and only if number of i tems is capacity)
do Result := (count = capacity ) end
A precondition such as not full ,  b a s e d  o n  a  p r o p e r t y  t h a t  i s  r e d e f i n a b l e  i n  
descendants, is called an  abstract precondition.
This use of abstract preconditi ons to satisfy the Assertion Red eclaration rule may  
appear to be cheating, but it is  not: although the concrete pre condition is in fact being  
strengthened, the abstract prec ondition remains the same. What counts is not how the  
assertion is implemented, but how  it is presented to the client s as part of the class interface  
(the short or flat-short form) . A protected call of the form
if not s  full then s  put (a) end
will be valid regardless of the kind of STACK attached to s.
There is, however, a valid criticism of this approach: it goes against the Open-Closed  
principle. We must foresee, at the STACK  level, that some stacks will have a bounded  
capacity; if we have not exerted  such foresight, we must go bac k to STACK  and change its  
interface. But th is is inevitable. Of the  following two propert ies
• A bounded stack is a stack.
• It is always possible to add an element to a stack.
one must go. If we want the first property, permitting BOUNDED_STACK to inherit from  
STACK , we must accept that the genera l notion of stack includes the provision that a put
operation is not always possible , expressed abstractly by the p resence of the query full.
It would clearly be a mistake, in class STACK , to include Result  = False as a 
postcondition for full or (equivalently but following the recommended style) an invar iant 
clause not full. This would be a case of overspecification as mentioned earlie r, hampering  
the descendants’ freedom to adapt the feature.
INHERITANCE TECHNIQUES  §16.1 578
The language rule
The Assertion Redeclaration rule as given so far is a conceptua l guideline. How do we  
transform it into a safe, c heckable lan guage rule?
W e should in principle rely on a logical analysis of the old an d new assertions, to  
verify that the old precondition  l o g i c a l l y  i m p l i e s  t h e  n e w  o n e ,  and that the new  
postcondition implies the old one . Unfortunately, such a goal w ould require a  
sophisticated theorem prover  which, if at all feasible, is still far too difficult (in spit e of 
decades of research in artificial  intelligence) to be integrate d routinely among the checks  
performed by a compiler.
Fortunately a low-tech  solution is a vailable. We can enforce th e rule through a  
simple language convention, based  on the observat ion that for a ny assertions α and β:
•α implies α or γ, regardless of what γ is.
•β and δ implies β, regardless of what δ is.
So to be sure that a new precondition is weaker than or equal t o an original α, it 
suffices to accept it only if it is of the form α or γ; and to be sure that a new  
postcondition is stronger than or equal to an original β, it suffices to accept it only if it  
is of the form β and δ. Hence the language rule implementing the original  
methodological rule:
Note that the operators used for  or-ing and for and-ing are the  non-strict boolean  
operators or else and and then  rather than plain or and and, although in most cases the  
difference is irrelevant.
Sometimes the resulting assertio ns will be more complicated tha n strictly necessary.  
For example in our matrix rou tine, where the  original readAssertion Redeclaration rule (2)
In the redeclared version of a routine, it is not permitted to use a require  
or ensure  clause. Instead you may:
• Use a clause introduced by require else , to be or-ed with the original  
precondition.
• Use a clause introduced by ensure then , to be and-ed with the  
original postcondition.
In the absence of such a clause,  the original assertion is reta ined.
See “Non-strict 
boolean operators”, page 454
§16.1   INHERITANCE AND ASSERTIONS 579
invert (epsilon : REAL )
-- Inverse of current matrix, with precision epsilon
require
epsilon >= 10 ^ (–6)
…
ensure
((Current ∗ inverse ) |–| One ) <= epsilon
the redefined version may not use require  and ensure  but will appear as
…
require else
epsilon >= 10 ^ (–20)
…
ensure then
((Current ∗ inverse ) |–| One ) <= (epsilon  / 2)
so that formally the precondition is (epsilon >= 10 ^ (–20)) or else  (epsilon >= 10 ^ (–6)), 
and similarly for the postcondition. But this does not really m a t t e r ,  s i n c e  a  w e a k e r  
precondition or a stronger po stcondition takes over: if α implies γ, then α or else γ has the  
s a m e  v a l u e  a s  γ; and if δ implies β, then β and then δ has the same value as δ. So 
mathematically the preconditi on of the redefined version is epsilon >= 10 ^ (–20) and its  
postcondition is ((Current ∗ inverse ) |–| One ) <= (epsilon  / 2), even though the software  
assertions (and probably, in the absence of a symbolic expressi on simplifier, their  
evaluation at run time  if assertion checki ng is enabled) are mo re complicated.
Redeclaring into attributes
The Assertion Redeclaration rule  needs a small c omplement becau se of the possibility of  
redeclaring a function into an a ttribute. What happens to the o riginal’s precondition and  
postcondition, if any?
An attribute is always accessibl e, and so may be considered to have precondition  
True. This means that we may consider the precondition to have been  weakened, in line  
with the Assertion Redeclaration rule.
An attribute, however, does not h ave a postcondition. Since it is necessary to  
g u a r a n t e e  t h a t  t h e  a t t r i b u t e  s a t i s f y  a n y  p r o p e r t y  e n s u r e d  b y  t h e original function, the  
proper convention (an addition to the Assertion Redeclaration r ule) is to consider that the  
postcondition is  automatically a dded to the class invariant. Th e flat form of the class will  
include the condition  in its invariant.
When expressing a property of the value of a function without a rguments, you always  
have the choice between including it in the postcondition or in  the invariant. As a matter  
of style it is considered preferable to use the invariant. If y ou follow this rule there will  
not be any change of assertions i f you later redeclare the func tion as an attribute.See “Redeclaring a 
function into an attri-bute”, page 491 .
INHERITANCE TECHNIQUES  §16.2 580
A mathematical note
An informal comment on the Assertion  Redeclaration rule stated: “A  redeclaration may  
specialize the range of acceptable  behaviors, but not violate i t”. Here, to conclude this  
discussion, is a rigor ous form of that property (for mathematic ally inclined readers only).
Consider that a routine impl ements a partial function r from the set of possible input  
states I to the set of possible output states O. The routine’s assertions define rules as to  
what r and its possible redeclar ations may and may not do:
• The precondition specifies the domain DOM of r (the subset of I in which r is 
guaranteed to yield a result).
• The postcondition specifies, for each element x of DOM , a subset RESULTS (x) of O 
such that r (x) ∈ RESULTS (x). This subset may have more than one element, since  
a postcondition does not have t o define the r esult uniquely.
The Assertion Redeclaration rule means that a redeclaration may  broaden the domain  
and restrict the result sets; wr iting the new sets in primed fo rm, the rule requires that
DOM' ⊇ DOM
RESULTS' (x) ⊆ RESULTS (x) for any x in DOM
A routine’s precondition specifies that the routine and its eve ntual redeclarations  
must at least accept certain inputs ( DOM ), although redeclaratio ns may accep t more. The  
postcondition specifies that the  outputs produced by the routin e and its eventual  
redeclarations may at most  include certain values ( RESULTS (x)), although redeclarations’  
postconditions may include fewer.
In this description a state of a  system’s execution is defined by the contents of all  
reachable objects; in addition,  input states (elements of I) also include the values of the  
arguments. For a more detailed introduction to the mathematical  description of programs  
and programming languages see [M 1990] .
16.2  THE GLOBAL INHERITANCE STRUCTURE
A few references have been made in earlier discussions to the u niversal classes GENERAL
and ANY and to the objectless class NONE . It is time to clarify their role and present the  
global inheritance structure.
Universal classes
It is convenient to use t he following convention.
Universal Class rule
Any class that does not include an inheritance clause is consid ered to  
include an implicit clause of the form
inherit ANY
referring to a Kernel library class ANY.Page 573.
§16.2   THE GLOBAL INHERITANCE STRUCTURE 581
This makes it possible to define a certain number of features t hat will be inherited by  
all classes. These features provi de operations of universal int erest: copy, clone,  
comparison, basic i nput and output.
For more flexibility, we wil l not put these features in ANY but in a class GENERAL
of which ANY itself is an heir. ANY, in its default form, will have no features (being simply  
of the form class ANY inherit  GENERAL end); but then a project leader or corporate reuse  
manager who wants to make a certain number of features availabl e across the board can  
adapt ANY for local purposes without touching GENERAL , which should b e the same in  
Versailles, Vanuatu, Venice and Veracruz.
To build a non-trivial ANY, you may want to use inheritance. You can indeed make ANY
inherit from some class HOUSE_STYLE , or several such classes, without introducing any  
cycles in the inheritance hierarchy or violating the universal class rule: just make  
HOUSE_STYLE  and its consorts explicit heirs of GENERAL . In the following figure, “All  
developer-written classes” means more precisely: all developer- written classes that do  
not explicitly inherit from GENERAL .
Here then is a picture of the  general structure:
The global 
inheritance 
structureGENERAL
ANY
NONE… All developer-written classes … 
INHERITANCE TECHNIQUES  §16.2 582
The bottom of the pit
Also included in the figure is a class NONE , the nemesis of ANY : it inherits from any class  
that does not have any other heir and makes the global inherita nce class a lattice. You  
probably do not want to see the rename  subclauses of NONE  and, be relieved, you will  
not. (It changes anyway each time someone writes a new class.) NONE  is just a convenient  
fiction. But its theoretical exist ence serves two practical pur poses:
• The type of Void, the void reference used among other things to terminate linke d 
structures, is by convention NONE . (Void is in fact one of the features of GENERAL .)
• To hide a feature from al l clients, export it to NONE  only (in a feature clause of the  
form feature  {NONE }, equivalent in practice to feature {  } but more explicit, or in  
an inheritance subclause export {NONE }, also with the same practical effect as  
export {  }). This will make it unavailable to any developer class, since NONE  has 
no proper descendants. Note that NONE  hides all i ts features.
On the first property , note that you may assign the value Void to an entity of any  
r e f e r e n c e  t y p e ;  s o  u n t i l  n o w  t h e  s t a t u s  o f  Void was a little mysterious, since it had  
somehow to be compatible to all types. Making NONE  the type of Void makes this status  
clear, official, and consistent with the type system: by constr uction, NONE  is a descendant  
of all classes, so that we can use Void as a valid value of any r eference type without any  
need to tamper with the type rules.
On the second property note that, symmetrically, a feature clau se beginning with just  
feature , which exports its features to all developer classes, is consi dered a shorthand for  
feature  {ANY}. To reexport to all classes a p arent feature which had tighter  availability,  
you may use export {ANY}, or the less exp licit shorthand export .
ANY and NONE  ensure that our type system is closed and our inheritance stru cture 
complete: the latt ice has a top and it has a bottom.
Universal features
Here is a small sampling o f the features found in GENERAL  and hence available to all  
classes. Several of them were in troduced and used in earlier ch apters:
•clone  for duplicating an object , and its deep variant deep_clone  for recursively  
duplicating an entir e object structure.
•copy  for copying the contents of an object into another.
•equal  for field-by-field object comparison, a nd its deep variant deep_equal .
Other features include:
•print and print_line to print a simple default re presentation of any object.
•tagged_out , a string containing a default representation of any object, e ach field  
accompanied by its tag (the co rresponding attribute name).
•same_type  and conforms_to , boolean functions that comp are the type of the current  
object to the type of another.
•generator , which yields the name of an object’s generating class — the c lass of  
which it is a d irect instance.See “Object cloning 
and equality”, page 245, and subsequent 
sections .
§16.3   FROZEN FEATURES 583
16.3  FROZEN FEATURES
The presentation of inheritance has repeatedly emphasized the O pen-Closed principle: the  
ability to take any feature from an ancestor class and redefine  it to do it something different.  
Can there be any reason for s hutting off this possibility?
Prohibiting redefinition
The discussion of assertions at the beginning of this chapter h as provided us with the  
theoretical understanding of rede finition: the “open” part of t he Open-Closed principle —  
the ability to change features i n descendants — is kept in chec k by the original assertions.  
The only permitted redefinitions change the implementation whil e remaining consistent  
with the specification  given by the preco ndition and postcondit ion of the original.
In some rare cases, you may want to guarantee to your clients, and to the clients of  
your descendants, not only that a  feature will satisfy the offi cial specification, but also that  
it will use the exact original i mplementation. The only way to achieve this goal is to forbid  
redeclarations altoget her. A simple languag e construc t provides  this possibility:
frozen  feature_name … The rest of the feature declaration as usual …
With this declaration, no descendant’s redefine  or undefine subclause may list the  
feature, whether under its original name or (since renaming rem ains of course permitted)  
another. A deferred feature — meant, by definition, for redecla ration — may not be frozen.
Fixed semantics for copy, clone and equality features
The most common use of frozen fe atures is for general-purpose o perations of the kind just  
reviewed for GENERAL . For example there are two vers ions of the basic copy procedur e:
copy , frozen standard_copy (other : …)
-- Copy fields of other  onto fields of current object.
require
other_not_void : other /= Void
do
…
ensure
equal (Current , other )
end
This declares two features as sy nonyms. (A general convention a llows us to declare  
two features together so that th ey can share the same declarati on; just separate their names  
with commas as here. The effect is as if there had been two sep arate declarations with  
identical declaration bodies.) But only one  of the features is redefinable. So a descendant  
class can redefine copy ; this is necessary for example for classes ARRAY  and STRING , 
which redefine copy so as to compare actual array a nd string contents, not the arra y or 
string descriptors. It is convenient in such cases to have a fr ozen version as well, so that  
we can use the default operation, standard_copy , guaranteed to be the original.
INHERITANCE TECHNIQUES  §16.3 584
In class GENERAL , feature clone also has a similar doppelgänger standard_clone , 
but here both versions are frozen. Why should clone  be frozen? The reason is not to  
prevent the definition of a different cloning operation, but to  ensure that clone and copy  
semantics remain compatible, and as a side benefit to facilitat e the redefiner’s task. The  
declaration of clone is of the general form
frozen clone (other : …): …
-- V oid if other is void; otherwise new objec t with contents copied from other .
do
if other /= Void then
Result := “New object of the same type as other ”
Result   copy (other )
end
ensure
equal (Result , other )
end
“New object of the same type as other ” informally denotes a call to some function  
that creates and retur ns such an object, a s provided by the imp lementation.
So even though clone  is frozen, it will foll ow any redefinition of copy , for example  
in ARRAY  and STRING . This is good for safety, as it would be a mistake to have dif ferent  
semantics for these operations, and convenience, as you will on ly need to redefine copy  to 
change the copy-clone se mantics in a descendant.
Although you need not (and cannot) redefine clone , you will still need, in step with  
a redefinition of copy ,  t o  r e d e f i n e  t h e  s e m a n t i c s  o f  e q u a l i t y .  A s  i n d i c a t e d  b y  t h e  
postconditions given for copy and clone , a copy must yield equ al objects. Function equal
itself is in fact frozen in the same way that clone  is — to ensure its dependency on another,  
redefinable feature:
frozen equal (some , other : …): BOOLEAN
-- Are some  and other  either both void
-- or attached to obj ects considered equal?
do
Result := ((some = Void ) and (other = Void )) or else some   is_equal (other )
ensure
Result = ((some = Void ) and (other = Void )) or else some   is_equal (other )
end
Function equal  is called under the form equal (a, b), which does not quite enjoy the  
official O-O look of a  is_equal (b) b u t  h a s  t h e  i m p o r t a n t  p r a c t i c a l  a d v a n t a g e  o f  b e i n g  
applicable when a or b is void. The basic feature, however, is is_equal , not frozen, which  
you should redefine in any class that redefines copy, to keep equality semantics compatible  
with copy and clone semantics — s o that the postconditions of copy and clone  remain correct. 
Besides equal  there is a function standard_equal  whose semantics is not affected by  
redefinitions of is_equal . (It uses the above algorithm but using standard_is_equal , 
frozen, rather than is_equal .)If other  is void the 
default initializations yield Void for Result .
The matter was dis-
cussed in “The form of clone and equality operations”, page 274.
§16.4   CONSTRAINED GENERICITY 585
Freeze only when needed
The examples of freezing that ha v e  j u s t  b e e n  g i v e n  a r e  t y p i c a l  o f  t h e  u s e  o f  t h i s  
mechanism: guaranteeing the ex act semantics of the original.
I t  i s  n e v e r  a p p r o p r i a t e  t o  f r e e z e  a  f e a t u r e  o u t  o f  e f f i c i e n c y  c oncerns. (This is a  
mistake sometimes made by devel opers with a C++ or Smalltalk ba ckground, who have  
been told that dynamic binding is  expensive and that they must manually avoid it if  
possible.) Clearly, a call to a frozen feature will never need dynamic binding; but this is a  
side effect of the frozen  mechanism rather than its purpose. As discussed in detail in a n 
earlier chapter, applying static  binding safely is a compiler o ptimization, not a concern for  
software developers. In a well-d esigned language the compiler w ill have all it needs to  
perform this optimization when a ppropriate, along with even mor e far-reaching  
optimizations such as routine inlining. Determining the appropr iate cases is a job for  
machines, not humans. Use frozen  in the rare although import ant cases in which you need  
it for conceptual purposes — to guarantee the exact semantics o f the original  
implementation — and let the la nguage and the compiler do their  job.
16.4  CONSTRAINED GENERICITY
Inheritance and genericity have been presented as the two partn ers in the task of extending  
the basic notion of class. We have already studied how to combi ne them through the notion  
of polymorphic data structure :  i n t o  a  c o n t a i n e r  o b j e c t  d e s c r i b e d  b y  a n  e n t i t y  o f  t y p e  
SOME_CONTAINER_TYPE [T] for some T, we can insert objects whose type is not just T
but any descendant of T. But there is another interesti ng combination, in which inheri tance 
serves to define what is and is not acceptable as actual generi c parameter to a certain class.
Addable vectors
A simple and typical example wil l allow us to see the need for constrained genericity —  
and, as everywhere else in this book, to deduce the method and language construct as a  
logical consequence of t he problem’s  statement.
Assume we want to declare a class VECTOR  to describe vectors of elements, with  
an addition operation. There are  vectors of elements of many di fferent types, so we clearly  
need a generic class. A fi rst sketch may look like
note
description : "Addable vectors "
class
VECTOR [G]
feature -- Access
count : INTEGER
-- Number of items
item, infix "@" (i: INTEGER ): G
-- Vector element of index i (numbering s tarts at 1)
require … do
…
endSee “Static binding 
as an optimization”, page 509 .
“Polymorphic data 
structures”, page 470.
INHERITANCE TECHNIQUES  §16.4 586
feature -- Basic operations
infix "+" (other : VECTOR [G]): VECTOR
-- The sum, element by elem ent, of current  vector and other
require … do
…
end
… Other features …
invariant
non_negative_count : count >= 0
end
The use of an infix feature is c onvenient for this class, but d oes not otherwise affect  
the discussion. Also for convenience, we have two synonyms for the basic access feature,  
so that we can denote the i-th element of a v ector (as in the ARRAY  class, which could be  
used to provide an implementation) as either v  item (i) or just v @ i .
Now let us see how we could write the "+" function. At first it seems  
straightforward: to add two vectors, we just add one by one the ir elements at  
corresponding positions. The general scheme is
infix "+" (other : VECTOR [G]): VECTOR
-- The sum, element by elem ent, of current  vector and other
require
count = other   count
local
i: INTEGER
do
“Create Result  as an array of count  items”
from i := 1 until i > count loop
Result   put ( , i)
i := i + 1
end
end
The boxed expression is the sum of the items at index i in the current vector and  
other , as illustrated by the figure on the facing page. The enclosin g call to put assigns its  
value to the i-th item of Result . (Procedure put has not been shown in class VECTOR , but 
must obviously appear there,  like its coun terpart in ARRAY .)
But this does not work! The + operation in the boxed exp ression is an addition of  
vector elements (not vectors); i t is intended to add values of type G, the generic parameter.  
By definition a generic paramete r represents an unknown type — the actual generic  
parameter, to be provided only wh en we decide to use the generi c class for good, through  
what has been called a generic derivation . If the generic derivation uses, as actual generic  item (i) + other  item (i)
§16.4   CONSTRAINED GENERICITY 587
parameter, a type such as INTEGER , or some other class which includes a function infix
"+" with the right signature, everything will work fine. But what i f the actual generic  
parameter is ELLIPSE , or STACK [SOME_TYPE ], or EMPLOYEE , or any other type that  
does not have an a ddition operation?
We did not have such a problem with the generic classes encount ered previously —  
general container classes such as STACK , LIST  and ARRAY — since the only operations they  
needed to apply to container elements (represented by entities of type G, the formal generic  
parameter) were univers al, type-independent  operations: assignm ent, comparison, use as  
argument in feature calls. But for an abstraction such as addab le vectors we need to restrict  
the permissible actual generic p arameters to make sure certain operations are available.
This is by no means an exceptional example. Here are two other typical ones:
• Assume you want to describe sor table structures, with a proced ure sort that will  
order the elements acco rding to some criter ion. You need to ens ure the availability  
of a comparison operation infix "<=" , representing a total order, on the  
corresponding objects.
• In building basic data structur es such as dictionaries, you ma y want to use a hash-
table , where the position of each element is determined by a key der ived from the  
value of the element. This assum es the availability of a “hashi ng function” which  
computes the key (also known as the “hash value”) of any elemen t.
A non-O-O approach
Although there have bee n enough hints in the preceding paragrap hs to suggest the almost  
inevitable solution to our problem, it is useful to pause for a  moment and examine how  
another approach, not o bject-oriented, has addressed the same p roblem. 
Ada does not have classes, but h as packages which serve to grou p related operations  
and types. A package may be gene ric, with generic parameters re presenting types. So the  
same problem arises: a package VECTOR_PROCESSING  might include a declaration of  
type VECTOR and the equivalent of our infix "+" function.other  item (i) item (i)
1count
iCurrent other
1countAdding two 
vectors , item 
by item
The hurried reader 
may skip directly to the O-O solution in the next section , 
“Constraining the generic parameter”, page 588 .
INHERITANCE TECHNIQUES  §16.4 588
The solution in Ada is to treat t he needed operations, such as infix "+", as generic  
parameters themselves. The param eters of a package may include not only types, as in the  
object-oriented approach, but als o routines (call ed subprograms ). For example:
generic
type G is private ;
with  function  "+" (a, b: G) return  G is <>;
with  function  "∗" (a, b: G) return  G is <>;
zero: G; unity : G;
package VECTOR_HANDLING
… Package interface …
end VECTOR_HANDLING
N o t e  t h a t  a l o n g  w i t h  t h e  t y p e  G and the subprograms the package also uses, as  
generic parameter, a value zero representing the zero element  of addition. A typical use of  
the package will be
package BOOLEAN_VECTOR_HANDLING
new VECTOR_HANDLING (BOOLEAN , "or", "and", false , true);
which uses boolean “or” as the a ddition and boolean “and” as th e multiplication, with  
corresponding values for zero a nd unity. We will study a more c omplete solution to this  
example in a later chapter, as p art of a systema tic discussion of genericity vs. inheritance.
Although appropriate for Ada, th is technique is not acceptable in an O-O context.  
The basic idea of object technology is the primacy of data type s over operations in  
software decomposition, implying that there is no such thing as  a stand-alone operation.  
Every operation belongs to some data type , based on a class . So it would be  inconsistent  
with the rest of the approach to let a function such as infix "+", coming out of nowhere,  
serve as actual generic parame ter along with types such as INTEGER  and BOOLEAN . The 
same holds for values such as zero and unity , which will have to find their place as features  
of some class — respectable members of object-oriented society.
Constraining the generic parameter
These observations yield the sol ution. We must work entirely in  terms of classes and types.
What we are requiring is that any actual parameter used for VECTOR  (and similarly  
for the other examples) be a typ e equipped with a set of operat ions: infix "+", perhaps zero
to initialize sums, and possibly a few others. But since we stu died inheritance we know  
how to equip a type w ith certain operations: just make it a des cendant of a class, deferred  
or effective, that has these operations.
A simple syntax is
class  C [G –> CONSTRAINING_TYPE ] … The rest as for any other class …
where CONSTRAINING_TYPE is an arbitrary type. The –> symbol, made of a hyphen and  
a “greater than”, evokes the a rrow of inheritance diagrams. CONSTRAINING_TYPE is 
called the generic constraint. Th e consequences of such a decla ration are two-fold:See “Constrained 
genericity”, page 
1170 .
§16.4   CONSTRAINED GENERICITY 589
•Only types that conform to CONSTRAINING_TYPE  will be acceptable as actual  
generic parameters; remember tha t a type conform s to another if , roughly speaking,  
it is based on  a descendant.
• Within the text of class C, the operations permitt ed on an entity of type G are those  
which would be permitted on an entity of CONSTRAINING_TYPE , that is to say  
features of the base  class of that type.
In the VECTOR case, what should we use as a generic constraint? A class intro duced  
in the discussion of multiple inheritance, NUMERIC , describes the notion of objects to  
which basic arithmetic operation s are applicable: addition and multiplication with zero  
and unity. (The underlying mathematical structure, as you may r ecall, is the ring.) This  
seems appropriate even though for our immediate purposes we onl y need addition. So the  
class will be declared as
note
description : "Addable vectors "
class
VECTOR [G –> NUMERIC ]
… The rest as before (but now valid!) …
Then within the class text, the loop instruction  that was previ ously invalid
Result   put ( , i)
has become valid since item (i) and other   item (i) are both of type G, so that all NUMERIC  
operations such as infix "+" are applicable to them.
Generic derivations such as the following are all correct, assu ming the classes given  
as actual generic paramete rs are all des cendants of NUMERIC :
VECTOR [NUMERIC ]
VECTOR [REAL ]
VECTOR [COMPLEX ]
If, however, you try  to use the type VECTOR [EMPLOYEE ] you will get a compile-
time error, assuming class EMPLOYEE  is not a descendant of NUMERIC .
NUMERIC  is a deferred class; this cause s no particular problem. A gene ric 
derivation can use an effective actual parameter, as in the pre ceding examples, or a  
deferred one, as in VECTOR [NUMERIC_COMP ARABLE ], assuming the cl ass given is a  
deferred heir of NUMERIC .Conformance was 
defined in “Limits to polymorphism”, page 474 .
See “Numeric and 
comparable val-ues”, page 522 .
item (i) + other  item (i)
INHERITANCE TECHNIQUES  §16.4 590
Similarly, a dictionary cl ass could be declared as
class DICTIONARY [G, H –> HASHABLE ] …
where the first parameter repres ents the type of the elements a nd the second represents the  
type of their keys. A class supp orting sorting m ay be declared as 
class SORTABLE [G –> COMPARABLE ] …
Playing it recursively
A nice twist of the VECTOR  example appears if we ask whether it is possible to have a  
vector of vectors. Is the type VECTOR [VECTOR [INTEGER ]] valid?
The answer follows from the preceding rules: only if the actual  generic parameter  
conforms to NUMERIC . Easy — just make VECTOR itself inherit from NUMERIC :
note
description : "Addable vectors "
class
VECTOR [G –> NUMERIC ]
inherit
NUMERIC
… The rest as before …
It is indeed justified to consid er vectors “numeric”, since add ition and multiplication  
operations give them a ring structure, with zero being a vector of G zeroes and unity  a 
vector of G ones. The addition operation  is precisely the vector infix "+" discussed earlier.
We can go further and use VECTOR [VECTOR  [VECTOR [INTEGER ]]] and so on  
— a pleasant recursive  application of constrained genericity.
Unconstrained genericity revisited
Not all cases of genericity are constrained, of course. The ori ginal form of genericity, as  
in STACK [G] or ARRAY [G], is still available and is calle d unconstrained genericity. As  
the example of DICTIONARY [G, H – > HASHABLE ] shows, a class can have both  
constrained and unconstrained generic parameters.
The discussion of constrained genericity enables us to understa nd the unconstrained  
case better. You have certainly come up with the rule by yourse lf as you were reading the  
above: from now on, class  C [G] will be understood as a shorthand for class  C [G –> ANY ]. 
So if G is an unconstrained generic parameter (say in STACK ) and x is an entity of type G, 
we know exactly what we can do with x: assign to or from it, compare it through = and /=, 
pass it as argument, and apply to it any of the universal featu res clone , equal , deep_clone  
and the like.Exercise E16.2, page 
610.
§16.5   ASSIGNMENT ATTEMPT 591
16.5  ASSIGNMENT ATTEMPT
Our next techniq u e  a d d r e s s e s  r e g i o n s  o f  O b j e c t  L a n d  i n  w h i c h ,  f or fear of tyrannical  
behavior, we cannot let simplistic type rules reign without opp osition.
When type rules become obnoxious
T h e  a i m  o f  t h e  t y p e  r u l e s  i n t r o d u c e d  w i t h  i n h e r i t a n c e  i s  t o  y i e ld statically  verifiable  
dynamic behavior, so that a syst em that passes the compiler’s c h ec ks  w i ll  n ot  en d u p  
applying inadequat e operations to objects at run time.
The two basic rules we re introduced in the f irst inheritance ch apter:
•T h e  Feature Call rule : x  f  is only valid if the base class of x’s type includes and  
exports a feature f.
•T h e  Type Conformance rule : to pass a as argument to a routine, or to assign it to a  
certain entity, requires that a’s type conform to the expec ted type, that is to say, be  
based on a des cendant class.
The Feature Call rule will not cause any problem; it is the fun damental condition for  
d o i n g  b u s i n e s s  w i t h  o b j e c t s .  C e r t a i n l y ,  i f  w e  c a l l  a  f e a t u r e  o n  a n  o b j e c t ,  w e  n e e d  t h e  
reassurance that the correspondi ng class offers and exports suc h a feature.
The Type Conformance rule requires more attention. It assumes t hat we have all the  
type information that we need ab out the objects that we manipul ate. Usually that is the  
case; after all, we create the o bjects, so we know who they are . But sometimes part of the  
information may be missing. In particular:
• In a polymorphic data structure  we are only supposed to know t he information that  
is common to all objects in the structure; but we may need to t ake advantage of some  
specific information that applie s only to a parti cular object.
• If an object comes to our software from the outside world — a file, a network — we  
usually cannot trust tha t it has a certain type.
Let us explore examples of these two cases. First consider a po lymorphic data  
structure such as a list of figures:
figlist : LIST [FIGURE ]
This refers to the figure inheritance hierarchy of earlier chap ters. What if someone  
asks us to find out what is the longest diagonal of all rectang les in the list (with some  
convention, say –1, if there are  no rectangles)? We have no eas y way of answering the  
request, since the expression item (i)  diagonal , where item (i) is the i-th list element for  
some integer i, violates the Feature Call rule; item (i) is of type FIGURE , and there is no  
feature diagonal  in class FIGURE — only in its pr oper descendant RECTANGLE .
The only solution with what we ha ve seen so far is to change th e class definitions so  
as to associate with each FIGURE  class a code, different for each class, indicating the  
figure type. This is not  an attractive approach.See “TYPING FOR 
INHERITANCE”, 14.3, page 472 .
INHERITANCE TECHNIQUES  §16.5 592
Now for an example of the second  kind. Assume a mechanism to st ore objects into  
a file, or transmit them over a network, such as the general-pu rpose STORABLE  facility  
described in an earlier chapter.  To retrieve an object or objec t structure you would use
my_last_book : BOOK
…
my_last_book := retrieved (my_book_file )
The result of function retrieved  is of the Kernel library type STORABLE , but it might  
just as well be of type ANY ; in either case it is only an anc estor of the object’s generat ing 
t y pe  (t h at  i s to  sa y ,  th e ty pe  o f which it is a direct instance ), presumably BOOK  or a 
descendant. But you ar e not expecting an ANY o r  a  STORABLE : you are expecting a  
BOOK . The assignment to my_last_book  violates the Type Conformance rule.
Even if instead of a gen eral-purpose mechanism retrieved were a retrieval function  
specific to your application and declared with the intended typ e, you could still not trust  
its result blindly. Unlike an obj ect that the software creates and then uses during the same  
session, guaranteeing type consis tency thanks to the type rules , this one comes from the  
outside world. You may have chosen the wrong file name and retr ieved an EMPLOYEE
object rather than a BOOK  object; or someone ma y have tampered with the file; or, if thi s 
is a network access, the transmi ssion may have corrupted the da ta.
The challenge
It is clear from such examples th at we may need a way to ascert ain the type of an object.
The challenge is to satisfy this  need — which arises only in sp ecific cases, but in  
those cases is crucial — without sacrificing the benefits of th e object-oriented style of  
development. In particular, we do not want to go back to the de cried scheme
if “f is of type  RECTANGLE ” then
…
elseif “f is of type  CIRCLE ” then
…
etc.
the exact antithesis of such prin ciples of modularity as Single  Choice and Open-Closed.  
Two insights will help  us avoid this risk:
• We do not need a gene ral mechanism to determine the type of an  object, at least not  
for the purposes described. In  the cases under discussion we  know the expected type
of the object. So all we require  is a way to test our expectati on. We will check an  
o b j e c t  a g a i n s t  a  d e s i g nated type; this is much more specific th an asking for the  
object’s type. It als o means that we do not need to introduce into our language any  
operations on types, s uch as type comparison s — a frightening t hought.
• As already noted, we should not tamper with the Feature Call r ule. Under no  
circumstances is there any justi fication for app lying a feature  (“sending a message”)  
to an object unless we have statically ascertained that the cor responding class is  
equipped to deal with it. All th at we will need is a looser ver sion of the other rule,  
type conformance, allowi ng us to “try a type” and check the res ult.See “Deep storage: a
first view of per-sistence”, page 250 .
WARNING : type-
invalid assignment .
§16.5   ASSIGNMENT ATTEMPT 593
The mechanism
Once again the notati onal mechanism follows directly from the a nalysis of the issue. We  
will use a new form of  assignment, called assignment attempt , and written
target ?= source
to be compared with th e usual assignment, target := source . The question mark indicates  
the tentative nature of the assignment. The effect of the assig nment attempt, assuming that  
the entity target has been declared with type T, is the following:
•I f  source  is attached to an object of a type conforming to T, attach that object to target
exactly as a normal assignment would do.
• Otherwise (that is to say if the value of source  is void, or is a reference to an object  
of a non-conforming type), make target  void.
There is no type constraint on t he instruction, except that the  type T of the target must  
be a reference type. (Assignment attempt is polymorphic by natu re, so an expanded target  
would not make sense.)
This instruction immediately and elegantly solves problems of t he kind mentioned  
above. First, type-specific access to objects of a polymorphic structure:
maxdiag ( figlist : LIST [FIGURE ]): REAL
-- Maximum value of diagonals of  rectangles in list; –1 if none
require
list_exists : figlist /= Void
local
r: RECTANGLE
do
from
figlist   start; Result := –1.0
until
figlist   after
loop
r ?= figlist   item
if r /= Void then
Result := Result   max (r  diagonal )
end
figlist   forth
end
end
This routine uses the usual iter ation mechanisms on sequential structures: start to 
position the traversal on the first element if any, after  to determine whether there is any  
element left to examine, forth  to advance by o ne position, item (defined if not after ) to 
yield the element at the current cursor position.The assignment attempt
See “ACTIVE DATA 
STRUCTURES”, 23.4, page 774 .
INHERITANCE TECHNIQUES  §16.5 594
The assignment attempt uses a local entity r of the appropriate type RECTANGLE . 
We know whether it succeeded by testing r against Void. Only if r is not void do we have  
a rectangle; then we can safely access r  diagonal . This scheme of testing for Void right  
after an assignment attempt is typical.
Note again that we never violate the Feature Call rule: any cal l of the form r  diagonal  
is guarded, statically, by a compiler check that diagonal is a feature of class RECTANGLE , 
and, dynamically, by a guarantee that r is not void — has an  attached object. 
A  list element of type SQUARE , or some other descendant of RECTANGLE , will 
make r non-void, so that  its diagonal will, rig htly, participate in th e computation.
The other example, using a gener al-purpose object retrieval fun ction, is immediate:
my_last_book : BOOK
…
my_last_book ?= retrieved (my_book_file )
if my_last_book /= Void then
… “Proceed normally w ith operations on my_last_book  ” …
else
… “What we expected is not what we got” …
end
Using assignment attempt properly
Assignment attempt is an indispe nsable tool for those cases — t ypically of the two kinds  
shown: elements of polymorphic d ata structures, and objects com ing from the outside  
world — in which you cannot trust the statically declared type of an entity but need to  
ascertain at run time the type o f the object actually attached to it.
Note how carefully the mechanism has been designed to discourag e developers from  
using it to go back to the old case-by-case style. If you reall y want to circumvent dynamic  
binding, and test sepa rately for each type variant, you can — b ut you have to work really  
hard at it; for example instead of the normal f  display , using the O-O mechanisms of  
polymorphism and dynamic  binding, you would write
display ( f: FIGURE )
-- Display f, using the algorithm adapt ed to its exact nature.
local
r: RECTANGLE ; t: TRIANGLE ; p: POLYGON ; s: SQUARE
sg: SEGMENT ; e: ELLIPSE ; c: CIRCLE ; …
do
r ?= f; if r /= Void then “Apply the rectangle display algorithm” end
t ?= f; if t /= Void then “Apply the triangle d isplay algorithm” end
c ?= f; if c /= Void then “Apply the circle display algorithm” end
… etc …
endCompare with := in the first try (page 592)
Warning : this is not 
the recommended style!
§16.6   TYPING AND REDECLARATION 595
This scheme will in practice be even worse than it seems becaus e the inheritance  
structure has several levels; for example an object of type SQUARE  w i l l  m a k e  a n  
assignment attempt x ?= f succeed for x of type POLYGON  and RECTANGLE  as well as  
SQUARE . So you must complicate the cont rol structure to avoid multipl e matches.
Because of the difficulty of writing such contorted uses of the  assignment attempt,  
there is little risk that novice developers will mistakenly use  it instead of the normal O-O  
scheme. But even advanced develope rs must remain a lert to the p ossibility for misuse.
Java offers a mechanism called “narrowing” similar in some resp ects to assignment  
attempt. But in case of a type mismatch, instead of yielding a void value, it produces an  
exception. This looks like overkill, since an unsuccessful assi gnment is not an abnormal  
case, simply one of several possi ble and expected cases; it doe s not justify adding  
exception-handling code and setting in motion the exception mac hinery. Java also offers  
the instanceof  operator to test for type conformance.
These mechanisms are used particularly extensively in Java beca use of the absence of  
genericity: you may have to rely on them, when retrieving eleme nts from container data  
structures (even single-type), to check the elements’ type agai nst an expected type. Part  
of the reason may be that, in the absence of multiple inheritan ce, Java has no NONE  class 
and hence no easy way to give the equivalent of Void a stable place in the type system.
16.6  TYPING AND REDECLARATION
When you redeclare a feature, yo u are not constrained to keep e xactly the same signature.  
The precise rule will give us a f urther degree of flexibility.
So far we have seen redeclarati on as a mechanism for substituti ng an algorithm for  
another — or, in the case of eff ecting a previously deferred ro utine, providing an algorithm  
where only a specification was originally given.
But we may also need to change t he types involve d, to support t he general idea that  
a class may offer a more special ized version of an element decl ared in an ancestor. Let us  
study two typical examples, which  will suggest the precise Type  Redeclaration rule.
Devices and printers
Here is a simple example of type redefinition. Consider a notio n of device including the  
provision that for every device there is an alternate, to be us ed if for some reason the first  
one is not available:
class DEVICE feature
alternate : DEVICE
set_alternate (a: DEVICE )
-- Designate a as alternate.
do
alternate := a
end
… Other features …
end
INHERITANCE TECHNIQUES  §16.6 596
P r i n t e r s  a r e  a  s p e c i a l  k i n d  o f  d e v i c e ,  j u s t i f y i n g  t h e  u s e  o f  i n heritance. But the  
a l t e r n a t e  o f  a  p r i n t e r  c a n  o n l y  b e  a  p r i n t e r  —  n o t  a  C D - R O M  r e a der or a network  
transceiver! — so we mu st redefine the types:
class PRINTER inherit
DEVICE
redefine alternate , set_alternate
feature
alternate : PRINTER
set_alternate (a: PRINTER )
-- Designate a as alternate.
… Body as in DEVICE …
… Other features …
end
These redefinitions reflect the s pecializing nature of inherita nce.
Linkable and bi-linkable elements
Here is another example, involvi ng fundamental data structures.  Consider the library class  
LINKABLE  describing the linked l ist elements used in LINKED_LIST , one of the  
implementations of lists. A partial view of the class is: 
note
description : "Cells to be linked in a list "
class  LINKABLE [G] feature
item: G
right : LINKABLE [G]
put_right (other : LINKABLE [G])
-- Put other  to the right of  current cell.
do right := other end
… Other features …
end
Some applications need lists chained both ways (each element li nked to its  
successor and its predecessor). The corresponding class, TWO_WAY_LIST , is an heir of  
LINKED_LIST , and will need an heir BI_LINKABLE  of LINKABLE :DEVICE
PRINTERalternate
alternate
item right
§16.6   TYPING AND REDECLARATION 597
A bi-l inkable element is like a link able but with one more field:
In a two-way list, bi-linkables should only be chained to bi-li nkables (although it is  
harmless to introduce bi-linkabl es in a one-way list: this is p olymorphism). So we should  
redefine right  and put_right  to guarantee that two-way l ists remain homogeneous. 
note
description : "Cells to be linked both ways in a list "
class  BI_LINKABLE [G] inherit
LINKABLE [G]
redefine  right , put_right end
feature
left, right : BI_LINKABLE [G]
put_right (other : BI_LINKABLE [G])
-- Put other  to the right of c urrent element.
do
right := other
if other /= Void then other   put_left (Current ) end
end
put_left (other : BI_LINKABLE [G])
-- Put other  to the left of current element
… Left to the reader …
… Other features …
invariant
right = Void or else  right   left = Current
left = Void or else  left  right = Current
end
(Try writing put_left . There is a pitfall! See appendix A.)LINKED_
LISTLINKABLE
BI_
LINKABLETWO_WAY_
LIST
A bi-linkable 
cellParallel 
hierarchies
item right left
INHERITANCE TECHNIQUES  §16.7 598
The Type Redeclaration rule
Although addressing abstractions  of widely different kinds, the  two examples show the  
same need for type redeclaration . Going down an inheritance hie rarchy means  
specializing, and some types will  follow that change pattern: t ypes of routine arguments,  
such as a in set_alternate and other in put_right ; types of queries, su ch as the attributes  
alternate and right , as well as functions.
The following rule cap tures this type aspect of redeclaration:
Here “conforms to” refers to the notion of type conformance, as  defined on the basis  
of the descendant relation. The rule uses “or” non-exclusively:  a function redeclaration  
may change both the ty pe of the function’s r esult and the type of one or more arguments. 
The permitted forms of redeclara tion all go in the same directi on: the direction of  
specialization. As illustrated by  the last inheritance diagram,  when you go down from  
LINKED_LIST to TWO_WAY_LIST , arguments and results will concomitantly go down  
from LINKABLE  to BI_LINKABLE . In the first example, when you go from DEVICE  to 
PRINTER , the attribute alternate and the argument of set_alternate  follow. This explains  
the name often use to characterize this type redeclaration poli cy: covariant typing , where  
the “co” indicates that as we de scend the inheri tance diagram a ll the types go down in step.
Covariant typing, as we will see in the next chapter, creates f or the compiler writer a  
few headaches which, fortunately,  he can often avoid passing on  to the software developer.
16.7  ANCHORED DECLARATION
The Type Redeclaration rule coul d make life quite unpleasant in  some cases, and even  
cancel some of the benefits of in heritance. Let us see how and discover the solution —  
anchored declaration. 
Type inconsistencies 
As an example of the problems th at may arise with the Type Rede claration rule, consider  
the following example from LINKED_LIST . Here is the procedure for inserting a new  
element with a given value to the right of the current cursor p osition. Although there is  
nothing mysterious with the details, all you need to note at th is stage is the need for a local  
entity new of type LINKABLE , representing the list cell to b e created and added to the lis t.Type Redeclaration rule
A redeclaration of a feature may  replace the type of the featur e (if an  
attribute or function), or the t ype of a formal argument (if a routine), by  
any type that conforms to the original.
The diagram is on 
page 597 .
§16.7   ANCHORED DECLARATION 599
put_right (v: G)
-- Insert an element of value v to the right of cursor position.
-- Do not move cursor.
require
not after
local
new: LINKABLE [T]
do
create  new  make (v)
put_linkable_right (new)
… 
ensure
… See appendix A …
end
To insert a new item of value v, we must create a cell of type LINKABLE [G]; the 
actual insertion is carried o ut by the secret procedure put_linkable_right , which takes a  
LINKABLE  as argument (and chains it to the cursor item using the put_right  procedure of  
class LINKABLE .) This procedure performs the ap propriate reference manipulati ons. 
In proper descendants of LINKED_LIST , such as TWO_WAY_LIST  o r  LINKED_
TREE , procedure put_right  should still be applicable. Unf ortunately, it will not work as  
given: although the algorithm i s still correct, the entity new should be declared and created  
as a BI_LINKABLE  or a LINKED_TREE  rather than a LINKABLE . So we must redefine  
and rewrite the whole procedure for each descendant — a particu larly wasteful task since  
the new body will be identical t o the original except for a sin gle declaration (for new). For 
an approach meant to s olve the reusability  issue, this is a ser ious deficiency.
Application-oriented examples
It would be a mistake to believe that the spurious redefinition  problem only arises for  
implementation-oriente d structures such as LINKED_LIST . With any scheme of the form
some_attribute : SOME_TYPE
set_attribute (a: SOME_TYPE ) do … end
a redefinition of some_attribute  will imply the correspo nding redefinition of set_attribute . 
In the case of put_right  for BI_LINKABLE , the redefinition actually changed the algorithm  
(because of the nece ssity, if you chain O1  right to O2, also to  chain O2 left t o O1), but in  
many other cases, such as set_alternate , the new algorithm is identical to the original. This  
pattern is so common that we may expect to have to write many r edundant routine bodies.
Here is one more example, showing how general the problem is (a nd not just tied to  
set_xxx  procedures, themselves a result  of information hiding principl es). Assume we add  
to class POINT  a function yielding the conjugate of a point, that is to say i ts mirror image  
across the hor izontal axis:  new Cursor
elementv
BI_LINKABLE ’s put_
right (not to be con-
fused with put_right  for 
LINKED_LIST ) was 
on page 597 .
INHERITANCE TECHNIQUES  §16.7 600
The function may appear as follows in POINT : 
conjugate : POINT
-- Conjugate of current point
do
Result := clone (Current ) -- Get a copy of current point
Result   move (0, –2∗y) -- Translate result vertically
end
Now consider a descendant of POINT , perhaps P ARTICLE , where particles have  
attributes other than x and y: perhaps a mass and a speed. Conceptually, conjugate  is still  
applicable to particles; it should yield a particle result when  applied to a particle argument.  
The conjugate of a particle is i dentical to that particle excep t for the y coordinate. But if  
we leave the func tion as it stands, it wi ll not work for partic les, since instructions such as  
the following violate the conformance rule: 
p1, p2: P ARTICLE ; create  p1  make (…); … 
In the underlined  assignment, the source (rig ht-hand side) is of type POINT , but the  
target is of type PA R T I C L E ; the Type Conformance rule wo uld require the reverse. So we  
must redefine conjugate in PA R T I C L E , for no purposes but type conformance.
Assignment attempt is not the solution here: although valid, it  will result in a void p2, 
since the source object’s type will, at execution time, be of t ype POINT , not P ARTICLE .
A serious problem 
If you look more closely at class LINKED_LIST in appendix  A you will realize that the  
problem is of even greater scope. LINKED_LIST  contains more than a few declarations  
referring to type LINKABLE [G], and most will need to be redefined for two-way lists. For  
example a possible representatio n of a list keep s four referenc es to linkable elements: 
first_element , previous , active , next : LINKABLE [G]
A l l  o f  t h e s e  m u s t  b e  r e d e f i n e d  i n  TWO_WAY_LIST , and similarly for other  
descendants. Many routines such as put_right  take linkables as arguments, and must also  
be redefined. It seems that we will end up repeating in TWO_WAY_LIST , for purposes of  
declaration only, most of t he features written for LINKED_LIST . xy
p
The conjugate of  pA point and its 
conjugate
p2 := p1 conjugate
§16.7   ANCHORED DECLARATION 601
The notion of anchor
Unlike other type-rela ted problems so lved earlier in this chapt er — such as the problems  
whose analysis led to constraine d genericity and assignment att empt — the Case of the  
Useless Code Duplicati on is not that the type system prevents u s from doing something  
that we need: thanks to the covariant Type Redeclaration rule w e can redefine types to our  
heart’s content, but this forces  us to perform tedious code dup lication.
To obtain a solution, we may note that the examples do require a type redefinition,  
but only one: all others ensue f rom it. The answ er follows: pro vide a mechanism to declare  
an entity’s type not  absolutely, but relative  to another entity.
This will be called an anchored declaration. An anchored type h as the form
like anchor
where anchor , called the anchor of the declaration, is either a query (attr ibute or function)  
of the current class or the predefined expression Current . To declare my_entity : like anchor  
in a class A, where anchor  is a query, means to declare it as being of the same type as  
anchor , but with the provision that any redefinition of anchor  in a proper descendant will  
implicitly cause the same redefinition for my_entity .
So, assuming that anchor  has been declared of some type T, the anchored declaration  
will cause my_entity  to be treated within the text of class A as if it too had been declared  
of type T. If you only consider A there is no difference bet ween the two declarations 
•my_entity : like anchor  
•my_entity : X 
The difference only comes up  in descendant classes of A. Being declared “like”  
anchor , my_entity will automatically follow any redefinition of the type of anchor , 
without the need for explicit re definition by the author of the  descendant class. 
So if you find that a class incl udes a group of entities — attr ibutes, function results,  
formal routine arguments, local en tities — which descendants wi ll have to redefine  
identically, you can dispense wi th all but one of the redefinit ions: just declare all elements  
like the first one, and red efine only that first one. All others wi ll automatically follow. 
Let us apply this technique to LINKED_LIST . We can choose first_element  as anchor  
for the other entities of type LINKABLE [G]. The attribute declarations become: 
first_element : LINKABLE [G]
previous , active , next : like first_element
In the put_right procedure of LINKED_LIST , the local entity new should also be  
declared of type like first_element ; this is the only  change to the procedure. With these  
declarations, it suffices to redefine first_element  as a BI_LINKABLE  in class TWO_WAY_
LIST , as a LINKED_TREE  in class LINKED_TREE  etc.; all entities declared like it follow  
automatically and need not be listed in the redefine  clause. Neither  is redefinition  
necessary any more for procedure put_right . 
Anchored declarations are an esse ntial tool to preserve reusabi lity in a statically  
typed object-orie nted context.put_right  from 
LINKED_LIST  is on 
page 599 .
INHERITANCE TECHNIQUES  §16.7 602
Current  as anchor 
Instead of the name of a query you can use Current  as anchor. The expression Current , as 
you know, denotes the current instance. An entity declared like Current  in a class A will 
be treated within the class as being of type A and, in any descendant B of A, as being of  
type B — without any need for redefinition. 
This form of anchored declaration addresses the remaining examp les. To get the  
correct type f or function conjugate in class POINT , amend its declaration to read
conjugate : like Current
… The rest exactly as before …
Then the result type of conjugate  gets automatically redefined, in every descendant,  
to the associated type, for example type PA R T I C L E  in class PA R T I C L E .
In class LINKABLE , you should similarly, in the earlier declarations
right : LINKABLE [G]
put_right (other : LINKABLE [G]) is…
replace LINKABLE [G] by like Current . Feature left in BI_LINKABLE  should also be  
declared as like Current . 
This scheme applies to many set_attribute  procedures. In the DEVICE case we get:
class DEVICE feature
alternate : like Current
set_alternate (a: like Current )
-- Designate a as alternate.
do
alternate := a
end
… Other features …
end
No redefinition is then necess ary in a descendant such as PRINTER .
Base classes revisited
With the introduction of anchored types, we need to extend the notion of base class of a type.
You will remember the idea. At t he beginning, classes and types  were a single  
concept. That property, the star ting point of the object-orient ed method, remains  
essentially  t r u e ,  b u t  w e h av e h a d  t o  ex te n d  t h e  ty p e  s y s t em  a l it t le  b y  a d ding generic  
parameters to classes. Every typ e is still fundamentally based on a class; for a generically  
derived type such as LIST [INTEGER ] you obtain the base class by removing the actual  
generic parameters, giving LIST  in this example. We also a dded expanded types, again  
based on classes; the base type of expanded  SOME_CLASS […] is SOME_CLASS .See “The current 
instance”, page 181 .
Original: page 600.
Class DEVICE , fol-
lowed by PRINTER , 
appeared on page 595.
See “Types and 
classes”, page 324 .
§16.7   ANCHORED DECLARATION 603
With anchored types we have anot her extension of the type syste m which, like the  
previous two, leaves intact the property that each type directl y follows from a class. The  
base class of like anchor is the base class of the type of anchor in the current class; if  
anchor is Current , the base class is the enclosing class.
Rules on anchored types
There is no theoretical obstacle to accepting like anchor  for an anchor  that is itself of an  
anchored type; we must simply ad d a rule that pr ohibits cycles in declaration chains. 
Initially the notation disallowed anchored anchors; although th is rule is acceptable, the  
more liberal one that only prohibits anchor cycles allows more flexibility.
Let T  be the type of anchor (given by the current class if anchor  is Current ). The  
type like anchor conforms to itself, and to T.
In the other direction, the only type that  conforms to like anchor  i s  i t s e l f .  I n  
particular T does not conform to like anchor . If we allowed
anchor , other : T; x: like anchor
…
create  other
x := other
then in a descendant class where anchor  is redefined to be of type U (conforming to T but 
based on a proper descendant) the assignment would attach x to an object of type T, 
whereas we should only a ccept objects of type U or conforming to U.
Of course you may assign to and from the anchor, as in x := anchor and anchor := x, 
and more generally between ancho r-equivalent elements, defining  x to be anchor-
equivalent to y if it is y or declared as like z where z is (recursively) anchor-equivalent to y.
In the case of anchoring a formal  argument or result of a routi ne, as in
r (other : like Current )
the actual argument in a call, such as b in  a  r (b), must be anchor-equivalent to the target a.
The discussion of typing issues in chapter 17 will further explore the conformance  
properties of anchored types.
When not to use anchored declaration
Not every declaration of the form x: A within a class A should be replaced by x: like Current , 
and not every pair of features w ith the same type should be dec lared like one another.
A n  a n c h o r e d  d e c l a r a t i o n  i s  a  c o m m i t m e n t :  i t  i n d i c a t e s  t h a t  w h e n ever the anchor  
changes types in the future, the  anchored entity must change to o. As we just saw with the  
type rules, this commitment is n ot reversible: once you have de clared an entity of type  
like anchor you cannot redefine its type any further (since the new type wo uld have to  
conform to the original, and no type conforms to an anchored ty pe but itself). As long as  WARNING : invalid 
assignment .
INHERITANCE TECHNIQUES  §16.7 604
you have not chosen an anchored type, everything is still possi ble: if x is of type T, you 
can redeclare x as being of a conforming type U in a descendant; and you can in fact  
redeclare it as like anchor  for some compatible anchor  to close off further variations.
The pros and cons are clear. Anch oring an entity guarantees tha t you will never have  
to redeclare it for type purposes; but it binds it irrevocably to the type of the anchor. It is  
a typical case of trad ing freedom for convenience — like signin g up with the military, or  
taking vows. (In a certain s ense Faust declared himself like Mephistopheles .)
As an example of when anchoring may not be desirable, consider a feature first_
child  of trees, describing the first child of a given tree node. (In  the construction of trees  
explained in the last chapter it comes from first_element  of lists, originally of type  
CELL  [G] or LINKABLE [G].) In a tree class it must be de clared or redeclared to denote a 
tree. It may seem appropriate to  use an anchored declaration: 
first_child : like Current
This may, however, be too restrictive in practice. The tree cla ss may have  
descendants, representing various kinds of tree (or tree node).  Examples may include  
UNARY_TREE  (nodes with just one child), BINARY_TREE  (nodes with two children) and  
BOUNDED_ARITY_TREE  (nodes with a bounded n umber of children). If first_child  is 
anchored to Current , every node must have children of the same type: unary if it i s unary,  
and so on. 
This is probably not the desired effect, since you may want mor e flexible structures,  
permitting for example a binary node to have a unary child. Thi s is obtained by declaring  
the feature not by an anchore d declaration but simply as 
first_child : TREE [G]
This solution is not restrictive : if you later need trees with nodes guaranteed to be all  
of the same type, you may leave TREE  as it is and give it a new descendant  
HOMOGENEOUS_TREE which redefines first_child  as 
first_child : like Current
ensuring consistency of all the nodes in a tree.
To facilitate such a redefini tion the other features of TREE  representing nodes, such  
as parent  and current_child , may and probably sh ould be declared as like first_child ; but 
first_child  itself is not anchored in TREE . 
A static mechanism 
One last comment on anchored dec laration, to dispel any possibl e misunderstanding that  
might remain about this mechanism: it is a purely static rule, not implying a ny change of  
object forms at run-time. The co nstraints may be checked at com pile time. 
Anchored declaration may be viewed as a syntactic device, avoid ing many spurious  
redeclarations by having the comp iler insert them. As it stands , it is an essential tool for  
reconciling reusabilit y and type checking. 
§16.8   INHERITANCE AND INFORMATION HIDING 605
16.8  INHERITANCE AND INFORMATION HIDING 
One last question needs to be an swered to complete this panoram a of inheritance issues:  
how inheritance interacts with the principle of information hid ing.
For the other intermodule relati on, client, the answer is clear : the author of each class  
is responsible for gra nting access p rivileges to the clients of  the class. He specifies a policy  
for every feature: exported (gen erally available); selectively available; secret.
The policies
W h a t  h a p p e n s  t o  t h e  e x p o r t  s t a t u s  o f  a  f e a t u r e  w h e n  i t  i s  p a s s e d on to a descendant?  
W h a t e v e r  y o u  w a n t  t o  h a p p e n .  I n f ormation hiding and inheritance  are orthogonal  
mechanisms. A class B is free to export or hide any feature f that it inherits from an  
ancestor A. All possible combina tions are ind eed open: 
•f exported in both A and B (although not necessarily  to the same clients).
•f secret in both A and B. 
•f secret in A, but exported, genera lly or selectively, in B. 
•f exported in A, but secret in B. 
The language rule is the followi ng. By default — reflecting the  most common case  
— f will keep the export status it had in A. But you may change this by adding an export
subclause to the inheritance  clause for A, as in
class B inherit
A
export  {NONE } f end -- Makes f secret (it may have been exported in A)
…
or
class B inherit
A
export  {ANY} f end -- Makes f exported (it may ha ve been secret in A)
…
or
class B inherit
A
export  {X, Y, Z} f end -- Makes f selectively availab le to certain classes
…
Applications
A typical application of this fl exibility is to provide several  views of a certain basic notion.
INHERITANCE TECHNIQUES  §16.8 606
Imagine a class GENERAL_ACCOUNT  c o n t a i n i n g  a l l  t h e  n e c e s s a r y  t o o l s  f o r  
dealing with bank accounts , with procedures such as open , withdraw , deposit , code  (for 
withdrawal from automatic teller machines), change_code  etc.; but this class is not meant  
to be used directly by clients an d so does not export anything.  Descendants provide  
various views: they do not add any features, but simply differ in their export clauses. One  
will export open  and deposit  only, another will also include withdraw and code , and so  on. 
This scheme belongs to what the discussion of inheritance metho dology will call  
“facility inheritance”.
The notion of view is a classical one in databases, where it is  often necessary to  
provide different users  with different abstr act notions of an u nderlying set of data. 
Classes sketched the discussion o f multiple inheritance provide  another application.  
Feature right  of class CELL is secret in this class or, more precisely, is exported only to  
LIST ; this is in fact true of all the features of CELL , since this class was  initially designed  
only for the purpose of lists. But in class TREE , implemented as heir to CELL as well as  
LIST , right now denotes access to the right s ibling of a node, a respectabl e public feature  
which should be exported.
Why the flexibility?
The policy of letting each descendant choose its own export pol icy (only by overriding the  
default, which keeps the parent’s  policy) makes type checking m ore difficult, as discussed  
in the next chapter, but provides the necessary flexibility to the class developer. Anything  
more restrictive hinders the goa ls of object-orie nted software development.
Other solutions have b een tried. Some O-O la nguages, b eginning with a revision of  
Simula, let a class specify not only whether a feature will be exported to its clients, but  
whether it will be ava ilable to its descenda nts. The benefits a re not clear. In particular:
• I am not aware of any published  methodological advice on how t o use this facility:  
when to bequeath a feature to de scendants, when to hide it from  them. A notational  
mechanism with no accompanying t heory is of dubi ous value. (In comparison, the  Views of a 
basic 
abstractionGENERAL_
ACCOUNT
MANAGER_
ACC_VIEWCLERK_
ACC_VIEWCUSTOMER_
ACC_VIEW
See “Facility inheri-
tance”, page 832 .
“Trees are lists and list 
elements”, page 525 .
§16.8   INHERITANCE AND INFORMATION HIDING 607
methodological rule g overning information hiding policy for cli ents is limpid: what  
belongs to the underlying ADT sh ould be exported; the rest shou ld be secret.)
• More pragmatically, it seems that few developers in Simula and  languages offering  
similar descendant restriction mechanisms bother to use them.
On closer examination, the lack of clear methodological guideli nes is not surprising.  
Inheritance is the embodiment of  the Open-Closed principle: a m echanism that enables  
you to pick an existing class, written yesterday or twenty year s ago by you or by someone  
else, and discover that you can d o something useful with it, fa r beyond what had been  
foreseen by the original design. Letting a class author define what eventual descendants  
may or may not use would elimina te this basic pr operty of inher itance.
The example of CELL and TREE  is typical: in the design of CELL , the only goal was  
to satisfy the needs of LIST  classes, so right  and put_right  served only int ernal purposes.  
Only later did these features su ddenly find a new application f or a descendant, TREE . 
Without such openness, inheritanc e would lose much of its appea l.
If a class designer ha s no basis for deciding which features th e class should pass on  
to its descendants, it would be e ven more preposterous for him to predict what they may  
or may not export to their own clients . Any such attempt is gues swork, with the knowledge  
that a wrong guess will make the  descendant deve lopers’ task im possible.
These descendant devel opers have only one ta sk: to provide thei r clients with the  
best possible class. I n such an effort, inheritance is only a t ool, enabling the developers to  
get a good result faster and bet ter. The only rules of the game  are the typing constraints  
and the assertions. Beyond that, anything goes. A useful ancest or feature is a godsend;  
whether the ancestor exported it or not is a matter between the  ancestor and its own clients:  
the descendant develop er could not care less.
In summary, the only policy comp atible with the fundamental ope nness of  
inheritance seems to b e the one described: l et every descendant  developer take its pick of  
ancestor features, and decide on its own export p olicy in the i nterest of its own clients.
Interface and implementation reuse
If you have read some of the mor e superficial O-O presentations , or follow newsgroup  
d i s c u s s i o n s ,  y o u  m a y  h a v e  b e e n  s u b j e c t e d  t o  w a r n i n g s  a g a i n s t  “ i nheriting  
implementation”. But (as we shall see in more detail in the inh eritance methodology  
chapter) there is noth ing wrong about using  inheritance for imp lementation.
There are two forms of reuse: re use through interface, and reus e of implementation.  
We can understand them as follow s from the theoretical picture.  Any class is an  
implementation (possibl y partial) of an abstract data type. It contains both the interface,  
as expressed by the ADT specificat ion — the tip of the iceberg,  if you remember the  
pictures that accompanied the pr esentation of in formation hidin g and ADTs — and a set  
of implementation choices. Inter face reuse means  that you are c ontent to rely on the  
specification; implementation re use, that you need to rely on p roperties that belong to the  
class but not to the ADT.See the figure on page 
144.
INHERITANCE TECHNIQUES  §16.8 608
You will not use these two possibilities for the same purposes.  If you can reuse a  
certain set of facilities through their abstract properties onl y , and want to be protected  
against future c hanges in the reused ele ments, go for interface  reuse. But in some cases  
you will just fall in love with a certain impleme ntation becaus e it provides th e right basis  
for what you are building.
These forms of reuse are complem entary, and are both perfectly legitimate.
The two inter-module relations of  object-oriented software cons truction cover them:  
client provides interface reuse , inheritance supports implement ation reuse.
Reusing an implementation is, of  c o u r s e ,  a  m o r e  committing deci sion than just  
reusing an interface: you cannot  reasonably expect, as in the o ther case, to be protected  
against changes in implementation! For that reason, inheriting i s  a  m o r e  c o m m i t t i n g  
decision than just being a clien t. But in some cases it is what  you need.
It is not always easy in practice to determine which one of the  client and inheritance  
relations is appropriate in a certain case. A later chapter con tains a detailed discussion of  
how to choose between them.
Rehabilitating implementation
Why the distrust of implementati on inheritance? I have come to think that the answer is  
less technical than psychological. A thirty-year legacy of less -than-pristine programming  
has left us with a distrust of the very idea of implementation.  The word itse lf has in some  
circles come to take on an almost indecent character, as if it were an insult to abstraction.  
(H.L. Mencken, in The American Language , similarly tells of how words such as leg came 
to be banished from late-ninetee nth-century polite conversation  for fear of the immodest  
connotations they evoke, even wh en the matter was limbs of a pi ano or of a chicken.) So  
we talk of analysis an d design, and when we mention implementat ion at all we make sure  
to precede it by “but”, “just” or  “only”, as in “ this is just a n implementation issue”.
Object technology, of course, is the reverse of all that: produ cing implementations  
that are so elegant, useful and clearly correct that we do not have to watch our language.  
What for us is a program is ofte n more abstract, more high-leve l, more understandable  
than much of what the analysis a nd design view presents as the highest of the high.
The two styles
I n  t h e  p i c t u r e  t h a t  c o m e s  o u t  o f  t h i s  d i s c u s s i o n ,  w e  m e r g e  a  s e t of originally  
separate distinctions.
We have two relations, client an d inheritance; two forms of reu se, interface and  
implementation; information hidi ng, or not; protection against internal changes in  
provider modules, or not.
In each case the existence of a choice is not controversial, an d both of the opposing  
options are defensible depending on the context. The slightly b older step is to treat all  
these oppositions as just one:“WOULD YOU 
RATHER BUY OR INHERIT?”, 24.2, page 812 .
§16.9   KEY CONCEPTS INTRODUCED IN THIS CHAPTER 609
Other approaches may be possible.  But I do not know of any that  is as simple, easy  
to teach and practical.
Selective exports
As a consequence of the  information hiding properties of inheri tance we must clarify the  
effects of selective exports. A class A which exports f selectively to B, as in 
class  A feature  {B, …}
f …
…
makes f a v a i l a b l e  t o  B for the implementation of B’ s  o w n  f e a t u r e s .  W h a t  a b o u t  t h e  
descendants of B? As we have just seen, they have access to B’s implementa tion; so they  
should be able to access w hatever is acc essible to B — for example f.
Experimental obs ervation confirms this t heoretical reasoning: w hat a class needs, its  
descendants tend to need too. But we do not want to have to com e back and modify A (to 
extend its export clause) whenev er a new descendant is added to  B. 
Here the principle of information hiding should be combined wit h the Open-Closed  
principle. The designer of A is entitled to decide whether or not to make f available to B; 
but he has no right to limit the freedom of the designer of the  B line of classes to provide  
new extensions and implementatio n variants. In f act, what desce ndants B has, if any, is  
none his business . Hence the rule: 
16.9  KEY CONCEPTS INTR ODUCED IN THIS CHAPTER 
• Invariants of parents are autom atically added to a class’s inv ariant. 
• In the Design by Contract appro ach, inheritance, redefinition and dynamic binding  
introduce the concep t of subcontracting.
• A routine redeclaration (redefini tion or effecting) may keep o r weaken the  
precondition; it may keep or strengthen the postcondition. 
• An assertion redecla ration may only use require else  (for or-ing of preconditions)  
and and then  (for and-ing of postconditio ns). It may not use just require  or ensure . 
In the absence of these clauses the routine keeps the original assertions.Client ::Inheritance
Reuse through interface ::Reuse of implementation
Information hiding ::No information hiding
Protection against changes in  
original implementation::No protection ag ainst original’s  
changes
Selective Export Inheritance rule
A feature selectively exported t o a class is available to all i ts descendants.Merging four 
oppositions
INHERITANCE TECHNIQUES  §16.10 610
• The universal class GENERAL  and its customizable heir ANY provide redefinable  
features of intere st to all developer-defined classes. NONE  closes down the lattice.
• It is possible to fre eze a feature to guara ntee eternal semant ic uniqueness.
• To entrust generic parameters with spec ific features, use cons trained genericity.
• Assignment attempt makes it pos sible to verify dynamically tha t an object has the  
expected type. It shou ld not be used as a substitute for dynami c binding.
• A descendant may rede fine the type of any entity (attribute, f unction result, formal  
routine argument). The redefinit ion must be covariant, that is t o  s a y  r e p l a c e  t h e  
original type with a  conforming one, bas ed on a descendant.
• Anchored declaration ( like anchor ) is an important part of the type system.  
facilitating the application of covariant typing and avoiding r edundant redeclarations. 
• Inheritance and information hiding are orthogonal mechanisms. Descendants may hide  
features that were exported by t heir ancestors, and export feat ures that were secret.
• A feature available to a class is available to its descendants .
16.10  BIBLIOGRAPHICAL NOTE 
See [Snyder 1986]  for a different viewpoint on the relationship between inherita nce and  
information hiding. 
EXERCISES
E16.1  Inheriting for simplicity and efficiency
Rewrite and simplify the protected stack example of an earlier chapter, making class  
STACK3  a descendant rather than a client of STACK  to avoid unneeded indirections. ( Hint : 
see the rules governing the rela tionship between inheritance an d information hiding.) 
E16.2  Vectors
Write a class VECTOR  describing vectors of a numer i c  t y p e  ( r i n g ) ,  w i t h  t h e  u s u a l  
mathematical operations, and its elf treated recursively as a nu meric type. You may have  
to complete class NUMERIC  for yourself (or get a version from [M 1994a] ).
E16.3  Extract?
The assignment y1 := x1 is not permitted if x1 is of a type X, y1 of type Y, and X is a proper  
ancestor of Y. It might seem useful, however, to include a universal feature  extract  such that  
the instruction y1  extract (x1) copies the values of the fields of the object attached to x1 to 
the corresponding fields in the object attached to y1, assuming neither reference is void.
Explain why the notation does not include such an extract  f e a t u r e .  ( Hint : examine  
correctness issues, in  particular the notion  of invariant.) Exa mine whether it is possible to  
design a satisfactory mechanism that achieves the same general goal in a different way.“A tolerant mod-
ule”, page 359 .
17  
Typing
E  ffective use of object technology requires that we clearly spec ify, in the texts of our  
systems, the types of all objects that they will manipulate at run time. This rule, known as  
static typing — a notion defined  precisely in the next sections  — makes our software:
•M o r e  reliable , by enabling compilers and other tools to suppress discrepanci es 
before they have had t ime to cause damage.
•M o r e  readable , by providing precious informat ion to authors of client system s, 
future maintainers of our own software, and other readers.
•M o r e  efficient , since this inf ormation helps a good co mpiler generate better code.
Although the typing is sue has been extensively discussed in non -O-O contexts, and  
static typing applied to many n on-O-O languages, the concepts a re particularly clear and  
relevant in object technology since the approach as a whole is largely based on the idea of  
type, merged with the idea of mod ule to yield the  basic O-O con struct, the class.
The desire to provide static typ ing has been a major influence on the mechanisms  
discussed in earlier chapters. H ere we need to take a comprehen sive look at  typing and  
devise solutions to the remainin g difficulties raised by this c oncept.
17.1  THE TYPING PROBLEM
One nice thing can be said about the typing issue in object-ori ented software construction:  
it may not be an easy problem, but it is a simple  problem — simple , that is, to state.
The Basic Construct
The problem’s simplicity comes f rom the simplicity of the objec t-oriented model of  
computation. If we put aside som e of the details, only one kind  of event ever occurs during  
the execution of an ob ject-oriented system : feature call, of th e general form
x    f (arg)
which executes on the object attached to x the operation f, using the argument arg, with 
the understanding th at in some cases arg stands for several arguments, or no argument at  
all. Smalltalk programmers wou ld say “pass to the object x the message f  with argument  
arg”, and use another synt ax, but those are dif ferences of style, not substance.
That everything relies on this Basic Construct accounts in part  for the general feeling  
of beauty that object -oriented ideas arou se in many people.
TYPING  §17.1 612
From the Basic Constru ct follows the basic kind of abnormal eve nt that might occur  
at execution time:
The typing problem is the need to avoid such events:
The key word is when . If the feature or arguments do  not match, you will find out  
sooner or later: applying the feature “raise salary” to an inst ance of SUBMARINE or “fire  
the torpedoes” to an instance of EMPLOYEE will not work; somehow  the execution will  
fail. But you may pre fer to find out soone r rather than later.
Static and dynamic typing
Although intermediate variants a re possible, two  main approache s present themselves:
•Dynamic typing : wait until the  last possible moment, the  execution of each ca ll.
•Static typing : rely on a set of rules that determine, from the text of a sys tem, whether  
its executions may cause type vi olations. Only execute systems for which the rules  
guarantee that no violation will ever occur.
The names are easy to explain: w ith dynamic typing, type verifi cation occurs at  
execution time (dynamically); with  static typing, it is perform ed on the text of the software  
(statically, that is to sa y before any execution).
The terms “typed” and “untyped” a re sometimes used for “statica lly typed” and  
“dynamically typed”. To avoid any c onfusion we will stick to th e full names.
Static typing is only interestin g if the rules can be checked a utomatically. Since  
software texts are usually proce ssed by a compiler before being  executed, it is convenient  
to have the compiler, rather tha n a separate too l, take care of  these checks. The rest of the  
discussion will indeed assume fo r simplicity tha t the compiler and the type checker are the  
same tool. This assumption y ields a simple definition:Definition: type violation
A run-time type violation (or ju st type violation for short) oc curs in the  
execution of a call x    f (arg), where x is attached to an object OBJ, if either:
V1 • There is no feature corresponding to  f and applicable to OBJ.
V2 • There is such a feature, but arg is not an acceptable argument for it.
Object-oriented typing problem
When do we know whether the execution of an object-oriented sys tem may  
produce a type violation?
Definition: statically typed language
An object-oriented language is s tatically typed i f it is equipp ed with a set of  
consistency rules, enforceable b y compilers, whose observance b y a system  
text guarantees that no execution of the  system can cause a typ e violation.
§17.1   THE TYPING PROBLEM 613
In the literature you will encounter the term “ strong  typing”. It corresponds to the  
all-or-nothing nature of this de finition, which demands rules t hat guarantee the absence of  
type violations. Weak  forms of static typing, whose rules eliminate certain type vio lations  
but not all, are also possible, and some O-O languages are inde ed weakly-statically-typed  
in this sense. We shall strive, however, for the strongest poss ible form.
Some authors also talk about strong forms of dynamic typing. Bu t this is a contradiction.
In a dynamically typed language (also known as an “untyped” lan guage), there are  
no type declarations; entities s imply become associated with wh atever values the  
execution of the software attach es to them. No static type chec king is possible.
Typing rules
Our object-oriented notation is statically typed. Its type rule s have been introduced in  
earlier chapters; they boil down  to three simple constraints:
• Every entity or function must b e  d e c l a r e d  a s  b e i n g  o f  a  c e r t a i n type, as in  
acc: ACCOUNT ; every routine declares zero or more formal arguments, with a type 
for each, as in put (x: G; i: INTEGER ).
•In any assignment x := y, and in any routine call using y as the actual argument for  
the formal argument x, the type of the source y must conform to the type of the target  
x. The definition of conformanc e is based on inheritance — B conforms to A if it is  
a descendant of A — complemented by rules  for generic parameters.
•In a call of the form x    f (arg), f must be a feature of the base class of x’s type, and  
must be available to the class  in which the call appears.
Realism
Although the definition of “statically typed language” is precise, it al so highlights the need  
for informal criteria in devisi ng type rules. Consider the foll owing two extreme cases:
•A n  all-valid language  in which every syntactically correct system is also typewise-
valid, with no need for type rul es. Such languages are possible  (imagine for example  
a small notation for Polish-style additions and subtractions wi th integers);  
unfortunately, as readers familiar with the theory of computati on will know, no  
useful general-purpose langu age can meet that criterion.
•A n  all-invalid language , easy to devise: just take an y existing language and add a  
type rule that makes any system invalid! This makes the language typed according  
to the definition: since no system passes the rules, no system that passes the rules can  
cause a type violation.
We may say that an all-valid language is usable , but not useful  for general-purpose  
development; an all-invalid langu age may be useful, but it is n ot usable.
What we need in practice is a type system that makes the langua ge both useful and  
usable: powerful enough to expres s the computations we need; co nvenient enough not to  
force us into undue complicatio ns to satisfy th e type rules.Type Conformance 
rule, page 474 . 
Feature Call rule , 
page 473 .
TYPING  §17.1 614
W e will say that a language is realistic  if it is both useful and usable. Unlike the  
definition of static typing, whi ch always yields an indisputabl e answer to the question “ Is 
language X stat ically typed ?”, the definition of realism is partly subjective; reasonable  
people may disagree on whether a  language, equippe d with certai n type rules, is  still useful  
and usable.
In this chapter we will check th at the typed notation defined i n the preceding chapters  
is rea listic.
Pessimism
In discussing approaches to O-O typing we should  keep in mind a nother general property  
of static typing: it is always, by nature, a pessimistic policy . Trying to guarantee that no 
computation shall ever fail , you disallow some computations that might succeed .
To see this, consider a trivial no n-O-O language, Pascal-like, with distinct types  
INTEGER  and REAL . With the declaration n: INTEGER , the assignment n := r will be  
rejected as violating the type rules. So all the following will  be considered type-invalid  
and rejected by the compiler:
n := 0.0 [A]
n := 1.0 [B]
n := —3.67 [C]
n := 3.67 — 3 .67 [D]
Of these invalid operations, [A] , if permitted to execute, woul d always work since  
any number system will provide an exact representation for the floating-point number 0.0,  
which can be transformed unambig uously to the integer 0. [B] wo uld almost certainly  
work too. [C] is ambiguous (do w e want the rounde d version, the  truncated version of the  
number?) But [D] wou ld work. So would
if n ^ 2 < 0 then n := 3.67 end [E]
because the assignment will never be executed ( n ^ 2  d en ot es  th e s qua r e o f n). If we  
replace n ^ 2 by just n, where n is read from user input just before the test, some executions  
would work (those for which n is non-negative), others would not. A ssigning to n a very  
large real number, not  representable as an i nteger, would not w ork. 
In a typed language, all these ex amples — those which would alw ays work, those  
which would never work, and thos e which would work some of the time — are equally  
and mercilessly considered violations of the type rules, and an y compiler will reject them.
The question then is not whether  to be pessimistic but how pessimistic we can afford  
to be. We are back to the realism requirement: if the type rule s are so pessimistic as to bar  
us from expressing in a simple wa y the computations that we nee d, we will reject them. But  
if they achieve type safety with  little loss of expressive powe r, we will accept them and  
enjoy the benefits. For example making n := r invalid turns out to be good news if the  
environment provides functions such as round  and truncate , enabling you to convert a real  
into an integer in exactly the w ay you want, without the ambigu ity of an implicit conversion.
§17.2   STATIC TYPING: WHY AND HOW 615
17.2  STATIC TYPING: WHY AND HOW
Although the advantages of static  typing seem obvious, it is ne cessary to review the terms  
of the debate.
The benefits
The reasons for using a statical ly typed form of object technol ogy were listed at the very  
beginning of this chapter: relia bility, readability and efficie ncy.
The reliability  value comes from the use of sta tic typing to detect errors tha t would  
otherwise manifest themselves only at run time, and only in cer tain runs. The rule that  
forces you to declare entities and functions — the first of our  three type rules above —  
introduces redundancy into the s oftware text; this enables the compiler, through the other  
two rules, to detect inconsisten cies between the purpose and ac tual use of an entity, feature  
or expression.
Catching errors early is essential, as correction cost grows qu ickly with the detection  
delay. This property, intuitivel y clear to all software profess ionals, is confirmed  
quantitatively, for specific ation errors, by Boehm’s well-known studies, plotting the cost  
of correcting an error against the time at which it is found (b ase 1 if found at requirements  
time), for both a set of large i ndustrial projects and a contro lled small project experiment :
The readability  benefit is also appreciable. As  the examples appearing through out 
this book should show convincingly, declaring every entity and function with a certain  
type is a powerful way of convey ing to the software reader some  information about its  
intended uses. This is  particularly preciou s for maintainers of  the software.
If readability were not part of the goal we might be able to ob tain some of the other  
benefits of typing without explicit declarations. It is possibl e indeed, under certain  
conditions, to use an implicit form of typing in which the comp iler, instead of requiring  
software authors to declare en tity types, attempts to determine  the type of each entity  
automatically from its uses. This is known as type inference . But from a software  
engineering perspective explicit declarations are a help, not a  penalty; types should be  
clear not just to the compiler but to the human reader.Relative cost of 
correcting 
errors
After [Boehm 1981]. 
Reproduced with permission.1000
500
20
Require-
mentsDesign Code Accep-
tance testOpera-
tionDevelop-
ment  testLARGE
PROJECTS
SMALL PROJECT
1 Time error
foundCorrection cost
TYPING  §17.2 616
Finally, the efficiency  benefit can make the difference  between success and failure of  
object technology in practice. Without static typing, the execu tion of x    f (arg) can take an  
arbitrary long time: as we saw i n the discussion of inheritance , the basic algorithm looks for  
a feature f in the base class C of x’s type; if it does not find it, it looks in C’s parents, and so  
on. This is a fatal source of in efficiency. It can be mitigated  by improvements to the basic  
algorithm, and the authors of the Self language have done exten sive work to enable better  
code generation for a dynamicall y typed language. But it is thr ough static typing that O-O  
software has been able to approach or equal the efficiency of t raditional software.
The key idea was explained in t he earlier discussion. When the compiler generates  
the code for x    f (arg), it knows the type of x. Because of polymorphism, this is not  
n e c e s s a r i l y  t h e  t y p e  o f  t h e  attached run-time object OBJ, and so does not uniquely  
determine the proper version of f. But the declaration restrict s the set of possible types,  
enabling the compiler to generat e tables providing run-time acc ess to the right f a t 
minimum — and constant-bounded — expense. Further optimizations of static binding
and inlining , also facilitated by typing, el iminate the expense altogether in applicable cases.
Arguments for dynamic typing
In spite of these benefits of st atic typing, dynamic typing kee ps its supporters, found in  
particular in the Smalltalk commu nity. Their argument mainly fo llows from the realism  
issue cited above: the y contend that static typing is too const raining, preventing the  
unfettered expression o f software ideas. Te rms such as “strangl ehold” and “chastity belt”  
are often heard in such discussions.
This argument can be correct, but only for a statically typed l anguage that misses  
some important facilities. It is  indeed remarkable that all the  type-related concepts  
introduced in pr eceding chapters are necessary; remove any of t hem, and the straitjacket  
comment becomes valid in at leas t some cases. But by including t h e m  a l l  w e  o b t a i n  
enough flexibility to make static typing both practical and ple asurable.
The ingredients of successful typing
Let us review the mechanisms which permit realistic static typi ng. They have all been  
introduced in earlier chapters, so that we only need a brief re minder for each; listing them  
all together shows the consistenc y and power of their combinati on.
Our type system is entirely based on the notion of class . Even basic types such as  
INTEGER  are defined by classes. So we d o not need special rules for pr edefined types.  
(Here the notation departs from “ hybrid” languages  such as Obje ct Pascal, Java and C++,  
which retain the type system of an older language along with th e class-based system of  
object technology.)
Expanded types  give us more flexibility by allowing types whose values denote  
objects along with types whose v alues denote object references.
Crucial flexibility is afforded by inheritance  and the associated notion of  
conformance . This addresses the major limita tion of tradition al typed lang uages such as  
Pascal and Ada, wh ere an assignment x := y requires the types of x and y to be identical.  For more details on 
the implementation 
techniques discussed 
in this section see “Dynamic binding 
and efficiency”, page 
507. On Self , see the 
bibliographical notes .
“COMPOSITE 
OBJECTS AND 
EXP ANDED TYPES”,8.7, page 254 ..
§17.2   STATIC TYPING: WHY AND HOW 617
This rule is too strict: it prevents you from using an entity t hat may denote objects of  
various related types, such as a SAVINGS_ACCOUNT  and a CHECKING_ACCOUNT . 
With inheritance, all we re quire is that the type of y conform to the type of x; this is the  
case if x is of type ACCOUNT , y of type SAVINGS_ACCOUNT , and the latter class is a  
descendant of the former.
To be practical, a statically typed language requires its inher itance scheme to support  
multiple inheritance . A principal part of common obje ctions against static typing i s that 
it prevents you from looking at o bjects in different ways. For example an object of type  
DOCUMENT  might need to be transmitted over a network, and so will need the features  
associated with objects of type MESSAGE . But this is only a problem with a language that  
is restricted to single inherita nce; with multiple inheritance you can introduce as many  
viewpoints as  you need.
We also need genericity , to define flexible yet type-sa fe container data structures.  
For example a list class will be defined as class  LIST [G] … Without this  mechanism,  
static typing would force us to declare a different class for e ach type of list element — an  
obviously unsustainable solution.
Genericity needs in some cases to be constrained ,  a l l o w i n g  u s  t o  a p p l y  c e r t a i n  
operations to entities of a generic type. For example if a gene ric class SORTABLE_LIST  
has a sort operation, it require s a comparison operation on ent ities of type G, the generic  
parameter. This is achie ved by associating with G a generic constraint COMP ARABLE :
class  SORTABLE_LIST [G –> COMP ARABLE ] …
meaning that any actual generic parameter used for SORTABLE_LIST  m u s t  b e  a  
descendant of class COMP ARABLE , which has the require d comparison features.
Another indispensa ble mechanism is assignment attempt , to access objects whose  
type the software does not control. If y denotes an object obtai ned from a database or a  
network, you cannot be sure it ha s the expected type; the assig nment attempt x ?= y will 
assign to x the value of y if it is of a compatible type, but otherwise will make x void.  
Without assignment attempt we coul d not abide by the type rules  in such cases.
Assertions — associated, as part of the idea of Design by Cont ract, with cla sses and  
features in the form of precondi tions, postcondi tions and class  invariants — allow you to  
describe semantic constraints which cannot be captured by type specifications. Although  
with the “interval types” of such languages as Pascal and Ada y o u  c a n  d e c l a r e ,  f o r  
example, that a certain entity ta kes its values between 10 and 20, no type mechanism will  “Limits to polymor-
phism”, page 474 .
Chapter 15 .
Multiple 
inheritanceMESSAGE
MAILABLE_DOCUMENTDOCUMENT
Chapter 10 .
“CONSTRAINED 
GENERICITY”, 16.4,page 585 .
“ASSIGNMENT 
ATTEMPT”, 16.5, page 591 .
Chapter 11 .
TYPING  §17.2 618
enable you to state that i must be either in that interval  or negative, and  always twice as 
much as j. Here class invariants come to the rescue, by letting you spec ify exactly what  
you need, however sophisticated the constraint.
Anchored declarations  are essential in practice to avoid redeclaration avalanche.  
By declaring y: like x you make sure that y will follow any redeclaration of the type of x
in a descendant. With out this mechanism developers would be end lessly redeclaring  
routines for type  purposes only.
Anchored declarations are a spec ific case of our  last required language mechanism:  
covariance , which will be discussed in mor e detail later in this chapter.
A practical property of the environment is also essential: fast incremental  
recompilation . When you write a system or (more  commonly) modify an existing  system,  
you will want to see the effect s oon. With static typing you mu st first let the compiler re-
typecheck the system. Traditional compiling techniques require recompiling the whole  
system (and going through a linking process); the time may be painfully long, especially  
for a proportionally small change to a large system. This pheno menon has been a major a 
contrario  argument for interpreted  approaches, such as those of early Lisp and Smalltalk  
environments, which ex ecute systems with no or little processin g, hence no type checking.  
But modern compiler technology r emoves this argument. A good co mpiler will detect  
what has changed since the last compilation, and reprocess only  that part, keeping the  
recompilation time small — and p roportional to the size of the change, not of the system.
The Melting Ice Technology  described in the last chapter of this book achieves this goal,  
typically permitting recompilation in a matter of seconds after  a small change even to a  
large system.
“A little bit typed”?
It was noted above that we should aim for a strong  form of static typing. This means that  
we should avoid any l oopholes in the static requirements — or, if any such loopholes  
remain, identify them clearly, if  possible providing tools to f lag any software using them.
The most common loophol e, in languages that  are otherwise stati cally typed, is the  
presence of conversions that disguise the type of an entity. In  C  a n d  i t s  d e r i v a t i v e s ,  
conversions are called “casts”  and follow a simple syntax: (OTHER_TYPE ) x denotes the  
value of x presented to the compiler as if it were of type OTHER_TYPE ; there are few  
limitations on what  that type may be, regardless of x’s actual type.
Such mechanisms evade the constr aints of type checking; casting  i s  i n d e e d  a  
pervasive feature of C programmi ng, including in the ANSI C var iant (which is “more”  
typed than its precursor, the so -called Kernigha n and Ritchie v ersion). Even in C++,  
examination of published softwar e shows that casts, although le ss frequent, remain an  
accepted and possibly indispen sable occasional practice.
It seems difficult to accept cla ims of static typing if at any stage the developer can  
eschew the type rules through casts. Accordingly, the rest of t his chapter wi ll assume that  
the type system is stric t and allows no casts.“ANCHORED 
DECLARATION”, 16.7, page 598 .
§17.2   STATIC TYPING: WHY AND HOW 619
You may have noted that assignment attempts, mentioned above as  an essential  
component of a realistic type system, superficially resemble ca sts. But there is a  
fundamental difference: an assignment attempt does not blindly force a different type; it  
tries a candidate type, and enables the software to check whether th e object actually  
matches that type. This is safe, and indispensable in some circ umstances. The C++  
literature sometimes includes as signment attempts (“downcasts”)  in its definition of  
casts; clearly, the above prohib ition of casts only covers the harmful variant, and does not  
extend to assignment attempts.
Typing and binding: avoiding the confusion
Although as a reader of this b ook you will have no difficulty d istinguishing static typing  
from static binding , you may meet people who confuse the two notions. This may be due 
i n  p a r t  t o  t h e  i n f l u e n c e  o f  S m a l l t a l k ,  w h o s e  a d v o c a c y  o f  a  d y n a mic approach to both  
typing and binding may l eave the inattentive  observer with the incorrect impression that  
the answer to both questions mus t be the same. (The analysis de veloped in this book  
s u g g e s t s  t h a t  t o  a c h i e v e  r e l i a b i l i t y  a n d  f l e x i b i l i t y  i t  i s  p r e f erable to combine dynamic  
binding with static ty ping.) Let us carefull y compare the two c oncepts.
Both have to do with the semantics of the Basic Construct x    f (arg); they cover the  
two separate questio ns that it raises:
Typing addresses the existence of a t  l e a s t  o n e  operation; binding addresses the  
choice of the right one  among these operations, if ther e is more than one candidate. 
In object technology:
• The typing question follows from polymorphism : since x may denote run-time  
objects of several possible types, we must make sure that an op eration representing  
f  is available in  all cases.
• The binding question follows from redeclaration : since a class can change an  
inherited feature — as with RECTANGLE  redefining perimeter  i n h e r i t e d  f r o m  
POLYGON  — there may be two or more oper ations all vying to be the one  
representing f for a particular call.
Both answers can be dynamic, mea ning at execution time, or stat ic, meaning before  
execution. All four possibilities appear in actual languages:
• Some non-O-O languages, such as Pascal and Ada, have both stat ic typing and static  
binding. In these languages each entity represents objects of o nly one type, specified  
statically; the approach yields reliability at the expense of f lexibility.Typing and binding
•Typing question : When do we know for sure that at run time there will be  
an operation cor responding to f and applicable to the object attached to x 
(with the argument arg)? 
•Binding question : Which operation will  the call execute? 
TYPING  §17.2 620
• S m a l l t a l k  a n d  o t h e r  O - O  l a n g u a g es influenced by it have dynami c binding and  
dynamic typing. This i s the reverse choice: favoring flexibilit y at the expense of  
reliability enforcement.
• Some non-O-O languages  a r e  u n t y p e d  ( r e a l l y  m e a n i n g ,  a s  w e  h a v e  s e e n ,  
dynamically typed) and statically  bound. They include assembly languages and  
some scripting languages.
• The notation developed in this book supports static typing and  dynamic binding.
Note the peculiarity of C++ which supports static typing (altho ugh in a non-strong  
form because of the pr esence of casts) and, for binding, a stat ic policy by default, while  
permitting dynamic binding at the price of explicit virtual  declarations.
The reason choosing static typi ng and dynamic binding is clear.  To the first question,  
“when do we know we have a featu re?”, the most attractive answe r for reliabl e software  
engineering is the static one: “ at the earliest possible time ” — compilation time, to catch  
errors before they catch you. To the second question, “what fea ture do we use?”, the most  
attractive answer is the dynamic one: “ the right feature ” — the feature directly adapted to  
the object’s type. As discussed in detail in the presentation o f inheritance, this is the only  
acceptable solution unl ess static and dynamic binding have the same effect.
The following fictitious inherita nce hierarchy helps make these  notions more vivid.
For a call of the form
my_aircraft    lower_   landing_  gear
the typing quest ion is when to ascertain that there will be a f eature lower_   landing_  gear
applicable to the object (for a COPTER  there would not be any); the binding question is  
which version to choose (since we  have several ve rsions, as sho wn).
Static binding would mean that we disregard the object type and  believe the entity  
declaration, leading us for example to apply to a Boeing 747-40 0 the version of a feature,  The C++ policy was
discussed in “The C++ approach to binding”, page 513 .
Kinds of flying 
objectAIRCRAFT
PLANECOPTER
BOEING AIRBUS
B_737
B_747
B_747_400A_320**
*
lower_landi ng_gear+lower_landing_gear *
lower_landing_gear++* deferred
+ effected
++ redefined*
§17.3   COV ARIANCE AND DESCENDANT HIDING 621
such as lower_landing_gear , that has been defined for the standard Boeing 747 planes,  
instead of the version specially redefined for the 747-400 vari ant; this is clearly wrong if  
the object is of the latter type . Dynamic binding will apply th e operation that the object  
demands, based on its type; th is is the righ t approach.
With static typing we will refus e the call at compile time unle ss we can guarantee  
that whatever happens to my_aircraft  at run time the type of t he attached object will be  
equipped with a feat ure corresponding to lower_landing_gear . The basic technique for  
obtaining this guarantee is si mple: since we must declare my_aircraft , we require that its  
type’s base class include such a feature. This means that the d eclared type cannot be  
AIRCRAFT  since there is no lower_landing_gear  at that level; helicopters, for example,  
have no landing gears, for the p urpose of this example at least . With such a declaration the  
compiler would reject our software with no possibility of appea l. But if we declare the  
entity as being of type PLANE , which has the required  feature, all is well.
Smalltalk-style dynamic typing would mean waiting until executi on to find out if there  
is an applicable feature; accept able perhaps for prototypes and  experimental software, but  
not for production systems. Run t ime is a little l ate to ask wh ether you have a landing gear.
17.3  COV ARIANCE AND DESCENDANT HIDING
In a simple world a discussion of typing would stop here: we ha ve defined the goals and  
advantages of static typing; exa mined the constr aints that a re alistic type system must  
meet; and reviewed the typing te chniques of the object-oriented  framework developed in  
the preceding chapters, checking  that they satis fy the stated c riteria.
The world is not simple. The com bination of static typing with some of the software  
engineering requirements of obje ct technology makes the issues more difficult than they  
appear at first. Two techniques raise difficulties: covariance,  the change of argument types  
in redefinitions; and descendant  hiding, the ability for a clas s to restrict th e export status  
of an inherited feature.
Covariance
The principal problem is what happens to arguments when we rede fine a feature’s type.  
We have encountered several cases  already: devices and printers , linkable and  bi-linkable  
elements, points and their conjugates.
To understand the general nature  of the issue let us use a fres h example. Being non-
technical, it carries the usual risks of metaphors; but the clo seness to software schemes is  
obvious, and we will frequently come back to actual software ex amples.
The example involves a  high-school ski team preparing for a tri p to a minor-league  
championship, and the team member s’ concerned parents. For brev ity and simplicity it  
uses the class names GIRL as an abbreviation for “member of the girls’ ski team” and BOY 
as an abbreviation for “member of the boys’ ski team”. Some ski ers on each team are  
ranked, that is to say have alre ady recorded good results in ea rlier championships. This is  
an important notion: ranked skiers will start first in a slalom , thus gaining a considerable  See the original 
discussions in “TYPING AND REDECLARATION”16.6, page 595 and “ANCHORED DECLARATION”, 16.7, page 598 .
TYPING  §17.3 622
advantage over the others since a slalom run is much harder to negotiate after too many  
competitors have already worked it. (This rule that ranked skie rs go first is a way to  
privilege the already privileged , and may be the reason why ski ing exerts such a  
fascination over many people: th at it serves as an apt metaphor  for life itself.) We get two  
new classes, RANKED_GIRL  and RANKED_BOY .
Some rooms are reserved for boys only, girls only, ranked girls  only; we may use a class  
hierarchy parallel to the one above: ROOM , GIRL_ROOM , RANKED_GIRL_ROOM  etc.  
The discussion will omit RANKED_BOY  which is parallel to RANKED_GIRL .
Here is an outline of class SKIER :
class SKIER feature
roommate : SKIER
-- This skier’s roommate
share (other : SKIER )
-- Choose other  as roommate.
require
other /= Void
do
roommate := other
end
… Other possible features omitted  in this class a nd the followin g ones …
end
We have two features of interest: the attribute roommate ; and the procedure share , 
which assigns a certain skier as  roommate to the current skier,  as in
s1, s2: SKIER
…
s1   share (s2)
Rather than SKIER , you may have thought of using for other the anchored type  
like roommate  (or like Current for both roommate  and other ). If so, you are most likely  
right, but let us forget for a while that we know about anchore d types: this will enable us  
to understand the covariance problem in its bare form; anchored  types will soon come back. Kinds of skier
BOYSKIER
GIRL
RANKED_BOY RANKED_GIRL
§17.3   COV ARIANCE AND DESCENDANT HIDING 623
How does type redefinition get into the picture? Assume the rul es require girls to  
share rooms only with girls, a nd ranked girls only with other r anked girls. We will redefine  
the type of feature roommate , as shown below (in this class text and the next, the redefine d 
elements appear underlined ).
class GIRL inherit
SKIER
redefine  roommate  end
feature
roommate : GIRL
-- This skier’s roommate.
end
We should correspondingly redefine the argument to procedure share , so that a more  
complete version of the class text is:
class GIRL inherit
SKIER
redefine  roommate , share  end
feature
roommate : GIRL
-- This skier’s roommate.
share (other : GIRL )
-- Choose other  as roommate.
require
other /= Void
do
roommate := other
end
end
All proper descendants must be ad apted in this way (remember, w e are depriving  
ourselves from anchored types f or the moment). The general picture is this:
Skier 
hierarchy and 
redefinitionsroommate : SKIER
share (other : SKIER )
roommate++
share++roommate++
share++
roommate++
share++BOYSKIER
GIRL
RANKED_GIRL++ Redefined
TYPING  §17.3 624
Since inheritance is sp ecialization, the typ e rules require tha t if we redefine the result  
of a feature, here roommate , the new type must always be a descendant of the original one.  
This also applies to the rede fined type for the argument other  of routine share . This policy,  
as we know, is called covariance, where the “co” indicates that  the argument and result  
vary together; the rev erse policy is termed contravariance .
Covariance is, according to all available evidence, what we nee d in practice. Our  
earlier software examples  illustrate t his clearly:
•A LINKABLE  list element may be chained to any other linkable; a BI_LINKABLE
must be chaine d to another BI_LINKABLE . So the argument of procedure put_right
should be redefin ed covariantly.
•In the same example, any routine of LINKED_LIST  that uses an argument of type  
LINKABLE  will most likely need it to be of type BI_LINKABLE in TWO_WAY_LIST .
• Procedure set_alternate  takes a DEVICE  argument in class DEVICE , a PRINTER  
argument in class PRINTER .
Covariant redefinition is particu larly common because of the O- O method’s  
emphasis on information hiding, which leads to procedures of th e form
set_attrib (v: SOME_TYPE )
-- Set attrib to v.
…
with attrib  of type SOME_TYPE ; such procedures ar e naturally covariant (and in practice,  
as we know, will usually rely on anchored types) since any clas s that changes the type of  
attrib  will need to redefine set_attrib ’s argument in the same wa y. The preceding examples  
mostly belonged to this scheme, but it is by no means the only one requiring covariance.  
Think for example of a procedure or function for concatenating a LINKED_LIST  to another:  
its argument will have to be re defined as a two-way-list in TWO_WAY_LIST . The general  
addition operation, infix "+", takes a NUMERIC  argument in NUMERIC , a REAL  argument  
in REAL , an INTEGER  argument in INTEGER . In the parallel hierarchies
procedure start, which starts a phone service, may need an argument of type ADDRESS  
representing the billing address;  for a corporate account you w ill need a corporate address.
What about a contravariant solution? In the skier example, cont ravariance would  
mean that if we go to class RANKED_GIRL , where the result of roommate  is redefined to  
be of type RANKED_GIRL , we may for the argument of routine share  use type GIRL , or 
SKIER  of the most general kind. One type that is not permitted under contravariance is  
RANKED_GIRL ! Enough to justify the parents’ worst fears.Type Redeclaration 
rule, page 598 .
“Type inconsisten-
cies”, page 598 .
Figure “Parallel hier-
archies” , page 597 .
Phone service 
and billing addressesPHONE_
SERVICEADDRESS
CORPORATE_
ADDRESSCORPORATE_
SERVICEstart
§17.3   COV ARIANCE AND DESCENDANT HIDING 625
Parallel hierarchies
To leave no stone unturned, it is useful to consider a variant of the SKIER  example with  
two parallel hierarchies, rather  than just one. This will model  the situation evidenced in  
software  examples   already  cited:  TWO_WAY_LIST   →  LINKED_LIST parallel  to 
BI_LINKABLE → LINKABLE , or the PHONE_SERVICE  hierarchy. Just assume that we  
have a ROOM  hierarchy with descendants such as GIRL_ROOM (BOY  variants omitted):
Then instead of roommate  a n d  share , the skier classes will have features  
accommodation and accommodate :
note
description : "New variant with pa rallel hierarchies "
class SKIER1 feature
accommodation : ROOM
accommodate (r: ROOM ) require  … do
roommate := other
end
end
Here too we need covariant redefinition: in class GIRL1 both accommodation  and 
the argument of accommodate  should be redeclared of type GIRL_ROOM , in BOY1  they 
should be of type BOY_ROOM , and so on. (Remember again that for the time being we  
are working without anchored typ es.) A contravariant policy wou ld be as useless as in the  
preceding form of the example.
Polymorphic perversity
Enough covariant examples. Why wo uld anyone consi der contravari ance, which goes  
against what we need in practice (not to mention proper behavio r for young people)? To  
understand, we have to consider the problems that polymorphism may cause under a  
covariant policy. A harmful scheme is easy to make up, and you may have thought of it  
yourself already:SKIER1 ROOM
GIRL_ROOM GIRL1
RANKED_
GIRL_ROOMRANKED_
GIRL1accommodate++
accommodate++accommodateaccommodation
accommodation++
accommodation++
TYPING  §17.3 626
s: SKIER ; b: BOY ; g: GIRL
…
create  b; create  g;-- Creation of a BOY  and GIRL  objects.
s := b; -- Polymorphic assignment.
s   share (g)
The effect of the last call, alt hough possibly t o the boys’ lik ing, is exactly what the  
type definitions were attempting to exclude. A room assignment makes a boy object,  
known as b but also disguising itself polymorphically under the SKIER  pseudonym s, the 
roommate of the GIRL  object attached to g. Yet the call appears type-correct, since share
is an exported feature of class SKIER , and GIRL , the type of argument g, conforms to  
SKIER , the type declared for the formal argument of share  in SKIER .
The corresponding scheme with the  parallel hierarchy variant is  just as simple: just  
replace SKIER by SKIER1 etc., and the call to share by a a call s   accommodate (gr), where  
gr is of type GIRL_ROOM : at run time this will as sign a boy to a girl room.
With contravariance one would no t have these problems: as you s pecialize the target  
of a call ( s in the example), you would gener alize the argument. Contravaria nce, as a  
result, leads to simpler mathe matical models of the inheritance -redefinition-
polymorphism mechanism. For that reason a number of theoretical  articles have advocated  
contravariance. But the argument  is not very convincing, since,  as we have seen and as the  
literature readily admits, contr avariance is of essentially no practical use.
An argument often encountered in the programming literature is that one should strive for  
techniques that have simple mathematical models. Mathematical e legance, however, is  
only one of several design criteria; we should not forget to ma ke our designs realistic and  
useful too. In computing science as in other disciplines, it is  after all much easier to devise  
dramatically simple theories if w e neglect to make them agree w ith reality.
So rather than trying to force a covariant body into a contrava riant suit, we should  
accept the reality for what it is , covariant, and study ways to  remove the unpleasant effects.
Descendant hiding
Before looking for solutions to the covariance problem, let us examine the other  
mechanism that can cause type vi olations through polymorphism. Descendant hiding is  
the ability for a class not to e xport a feature that was export ed by one of i ts parents.
POLYGON
RECTANGLEadd_vertex
§17.3   COV ARIANCE AND DESCENDANT HIDING 627
A typical example is a feature add_vertex , which class POLYGON  exports but its  
descendant RECTANGLE  hides, because it would violate the invariant of the class:
class RECTANGLE  inherit
POLYGON
export  {NONE } add_vertex end
feature
…
invariant
vertex_count = 4
end
A non-software counterpart is  the well-known example of OSTRICH  inheriting from  
a class BIRD equipped with a feature fly, which OSTRICH  should not export.
Let us for the moment accept this scheme at face value, setting  aside the question,  
discussed in detail later, of wh ether such forms of inheritance  are methodologically  
legitimate. The modeling power of descendant hiding, like that of covariance, clashes with  
the tricks made possib le by polymorphism. An  example is trivial  to build:
p: POLYGON ; r: RECTANGLE
…
create r ; -- Creation of a RECTANGLE object.
p := r; -- Polymorphic assignment.
p   add_vertex (…)
Since add_vertex  is an exported feature of POLYGON , the call appears type-correct; if  
accepted, it would on execution add a vertex to a rectangle, pr oducing an inconsistent object.
Class and system validity
Some terminology will be useful to discuss the issues raised by  covariance and descendant  
hiding. A system is class-valid if it satisfies the type rules summarized at the beginning of  
t h i s  c h a p t e r :  e v e r y  e n t i t y  d e c l a r e d  w i t h  a  t y p e ;  e v e r y  a s s i g n m e n t  a n d  a c t u a l - f o r m a l  
argument association s atisfies conformance; and every call uses  a feature of the target’s  
type, exported to the caller.
The system is system-valid  if no type violation c an occur at run time.
Ideally these two notions (whose  names will be justified later in this chapter) should  
be equivalent. What we have seen  through the pre ceding examples  is that with covariance  
and descendant hiding a system can be class-valid without being  system-valid. Such an  
error — making a system invalid although it is class-valid — wi ll be called a system  
validity error .
Practical scope
The simplicity of the examples of system validity error, result ing from covariance or  
descendant hiding, makes up what  we may call the static typing paradox. On being  “SUBTYPE INHER-
ITANCE AND DESCENDANT HIDING”, 24.7, page 835 .
For an explanation of 
the names see end of 17.6, page 636 .
TYPING  §17.4 628
introduced to object-oriented t yping, an inquisitive newcomer c an make up such a  
counter-example in a few minutes; yet in actual development, wh ile violations of class-
level validity rules are common (and, caught by the compiler, p rovide tremendous help in  
getting the software right), sys tem validity errors are exceedi ngly rare, even in large,  
multi-year projects.
This is not an excuse for ignoring them. The rest of this chapt er investigates three  
possible solutions.
A n  i m p o r t a n t  n o t e :  b e c a u s e  t h e  p roblems discussed next are both  delicate and  
infrequent, it is reasonable and indeed suggested, if this is y our first reading, that you skip  
the rest of this chapter unless you are already well-versed in the practical and theoretical  
aspects of object technology. If you are relatively new to the approach, you will  
understand the discussion much better after reading the methodo logical chapters of part  
D, in particular chapter 24 on the methodolog y of inheritance.
17.4  FIRST APPROACHES TO SYSTEM V ALIDITY
Let us concentrate first on the covariance issue, the more chal lenging of the two. There is  
an abundant literature on the su bject and we can take a look at  various proposed solutions.
Contravariance and novariance
Adopting a contravariant policy removes the theoretical problem  of system val idity errors.  
But this approach makes the type  system unrealistic, so we need  not examine it further.
C++ is original in using a novariant  policy: when you redefi ne a routine, you cannot  
change the types of its arguments! If C++ were a strongly typed  language, this would make  
the type system quite unusable. The easiest solution, as with o ther such limitations of C++  
(such as the absence of constrained genericity), is to use cast s, and so to bypass the typing  
mechanism altoge ther. This solution is not particularly attract ive. Note, however, that  
some of the proposals discussed n ext rely on a form of novarian ce, made meaningful by  
the introduction of ne w type mechanisms to r eplace covariant re definition.
Using generic parameters
An interesting idea, originally i ntroduced by Franz Weber, reli es on genericity. We can  
declare our class SKIER1  with a generic parameter representing the room:  
class  SKIER1  [G] or rather, using cons trained genericity,
class  SKIER1  [G –> ROOM ] feature
accommodation : G
accommodate (r: G) require … do accommodation := r end
end
Then class GIRL1  will inherit from SKIER1 [GIRL_ROOM ] and so on. The same  
technique may be applied to the variant without parallel hierar chies, although it seems  
stranger at first: class SKIER [G –> SKIER ].SUGGESTED 
SHORTCUT : skip to 
next chapter .
§17.4   FIRST APPROACHES TO SYSTEM V ALIDITY 629
This approach so lves the covariance prob lem. In any use of the class you need to  
specify an actual generic parameter — such as ROOM  or GIRL_ROOM  —, so the invalid  
combinations become impossible. The language would become novar iant, and systems  
would satisfy their co variance needs  entirely through generic p arameters.
Unfortunately, the generic parameter technique is not really ac ceptable as a general  
solution. It will lead to inflate d generic parameter lists, wit h one paramete r for each type  
of a possibly covariant argument.  To use the class, a developer  will have to provide as  
many types as there are parameter s; this will mak e classes hard  to understand.
Worse, adding a covari ant routine with an argument of a type no t yet covered would  
require adding a generic paramet er to the class, and hence chan ging its interface, thereby  
invalidating all client clas ses. This is not acceptable.
Type variables
Several authors (including Kim B ruce, David Shang, Tony Simons)  have proposed  
solutions based on the introduction of type variables. Although  it is impossible to  
summarize these sophisticated proposals without being unfair, t he basic idea is simple:  
instead of covariant redefinitio n, permit type d eclarations to use type variables rather than  
actual types; extend the conformance rules to handle type varia bles; make the language  
otherwise novariant; p rovide a facility to a ssign a type value to a type variable. 
Instead of ROOM , the declarations for attribute accommodation  and for the  
argument of accommodate would use a type variable, to wh ich an actual type value can be  
assigned separately.
These proposals are worth conside ring, and the interested reade r should consult the  
corresponding articles, as well as complementary publications b y Cardelli, Castagna,  
Weber and others, starting from the paper and Web references ci ted in the bibliographical  
notes to this chapter. We will n ot, however, purs ue this line, for two reasons:
• The type variable mechanism, if  designed properly, should subs ume genericity and  
anchored declarations, the two e xisting mechanisms for using a type without fully  
specifying it. At first this can be construed as an argument in  favor of type variables,  
as they might enable us to repla ce two language constructs by o ne, and solve other  
problems at the same time. But the result may not be satisfacto ry in practice since  
both genericity and anchored typ es are simple, widely accepted and easy to explain;  
it is not clear that an all-enco mpassing type var iable mechanis m can do as well.
• Assuming we can indeed devise a type variable mechanism that s olves the technical  
difficulties of combining covaria nce and polymorphism (still ig noring descendant  
hiding for the moment), it will require perfect foresight  from the class designer:  
knowing in advance which feature s are subject to type redefinit ion in descendants,  
and which are not. The following section will further discuss t his problem, which  
arises from a practical software engineering concern and, unfor tunately, hampers the  
credibility of many theoreti cally satisfying schemes.
TYPING  §17.5 630
These considerations suggest try ing a different approach: exami ning the  
mechanisms that we alr eady have at our disposal — constrained a nd unconstrained  
genericity, anchored t ypes, and of course inheritance — to see how they can be further  
constrained to remove the possibi lity of system v alidity errors .
17.5  RELYING ON ANCHORED TYPES
We can actually find an almost s atisfactory solution to the cov ariance problem by taking  
a closer look at a mechanism tha t we already know well: anchore d declarations.
You must indeed have been itching, in the SKIER and SKIER1  examples, to use  
anchored declarations, removing most of the need for type redef initions. Anchoring is  
the covariant mechanism  par excellence : by declaring y: like x, you make y vary with x
whenever x gets redefined to descendant-ba sed types in descendant classes . Our  
examples become:
class SKIER feature
roommate : like Current
share (other : like  Current ) require … do
roommate := other
end
…
end
class SKIER1  feature
accommodation : ROOM
accommodate (r: like accommodation ) require  … do
accommodation := r
end
end
Then descendants need no redefinition in the SKIER version, and in the SKIER1
version they only need to redefine attribute accommodation . The anchored entities —  
roommate  and the arguments of share  and accommodate — will automatically follow the  
anchors’ redefinitions. This t remendous simplification, in line  with what we saw in the  
original examples of anchored declaration, confirms that withou t anchoring (or some  
alternate mechanism such as type  variables) it would be impossi ble to write realistic typed  
object-oriented software.
But does this eliminate system va lidity violations? No! At leas t not without a further  
restriction. We can still cheat the type checker into letting p ass polymorphic assignments  
that will cause run-time type violations.
True, the original exampl es will be rejected. InUnderlining  indi-
cates the change from earlier versions .
§17.5   RELYING ON ANCHORED TYPES 631
s: SKIER ; b: BOY ; g: GIRL
º
create  b;create  g;-- Creation of a BOY  and GIRL  objects.
s := b; -- Polymorphic assignment.
s   share (g)
the argument g to share  is not valid, since we need something of type like s, and GIRL 
does not conform to like s. The conformance rule for anc hored types stated that no type  
conforms to like s other than this type itself.
The relief is short-lived, however, The same rule stated that, in the other direction of  
conformance, like s conforms to the type of s. So we can fool the type checker, although  
we have to be pretty devious, by  using polymorphism not just on  the target s of the call but  
on its argument g:
s: SKIER ; b: BOY ; g: like s;
º
create  b; -- Creation of a BOY  and GIRL  objects.
-- Go through s to attach g to the GIRL  object.
s := b -- Polymorphic assignment.
s   share (g)
The effect is exactly the same as before.
There is a way out. If we are se rious about usin g anchored decl arations as the sole  
covariance mechanism, then we can get rid of system validity er rors by prohibiting  
polymorphism altogether on ancho red entities. Thi s requires a l anguage change: we would  
introduce a new keyword anchor , used in such declarations as
anchor  s: SKIER
Then we would permit a d eclaration of the form like s only if s is declared in this form,  
and adapt the conformance rule to make sure that s as well as elements of type like s can 
be attached (assigned or argument-passed) only to each other.
In the original rule there was a notion of anchor-equivalent  elements: with x declared of  
some non-anchored type T and y declared like x, then x and y are anchor-equivalent to  
each other and to any other entity  anchor-equivalent to either of them. An attachment to  
an anchored target was valid only if the source was anchor-equi valent to  the target (which  
makes the assignment g:= s valid even though g is anchored and s is not); but there was  
no such restriction the other way around: z := y was valid for any z of type T. With the new  
approach this would not be permitted any more; in any attachmen t involving an entity that  
is either anchor or anchored, the source and the target must be  anchor-equivalent.
With this approach, we would rem ove from the language the possi bility of redefining  
the type of any routine argument . (We could also prohibit redef ining the result type, but  
this is not necessary. We must retain, of course, the possibili ty of redefining an attribute  
type.) All such redefinitions will now be obtained indirectly, through th e anchoring  
mechanism, which enforces covari ance. Where with the earlier ap p r o a c h  a  c l a s s  D 
redefined an inherited feature as“Rules on anchored 
types”, page 603 .
actual _g: GIRL ;
create  actua
s := actual_g ; g := s
Warning : hypotheti-
cal construct , for 
purposes of discus-sion only .
TYPING  §17.5 632
r (u: Y) …
from an original version , in a proper ancestor C of D, that read
r (u: X) …
with Y conforming to X, you should now defin e the original in C as
r (u: like your_anchor ) …
and only redefine in D the type of your_anchor .
This solution to the covariance- polymorphism issue will be call ed the Anchoring  
approach (short for the more acc urate “Covariance through ancho ring only”). Its  
properties make it part icularly attractive:
• It is based on a clear concept: strictly separating the covariant elements from the  
potentially polymorphic ones (just “polymorphi c” for short). Any e ntity declared as  
anchor  or as like some_anchor  is covariant; any other is polymorphic. You can have  
attachments within each category ; but no entity or expression w ill cross the  
boundary. For example you cannot assign a polymorphic source to  a covariant target.
• The solution is simpl e, elegant, easy to e xplain even to relat ive beginners.
• It appears completely tight, re moving any possibility of covar iance-related system  
validity violation.
• It retains the framework define d in the preceding chapters, in  particular the notions  
of genericity, constrained or not. (As a result it is, in my op inion, preferable to the  
introduction of type variables c overing both covariance and gen ericity, since these  
two mechanisms address clearly distinct practical needs.)
• It entails a small language cha nge — adding one keyword, reinf orcing a  
conformance rule — and  no foreseeable impl ementation difficulty .
• It is, at least in a theoretical sense, realistic : any system that was previously possible  
can be rewritten using the trans formation just outlined, replac ing covariant  
redefinitions by anchored redecla rations in the original. True,  some attachments will  
become invalid as a result; but they correspond to cases that c ould have led to type  
violations, and can be replaced by assignment at tempts, whose r esult the software  
can then check to ascertain at run time that everything is fine .
With such arguments we would seem to be at the end of the discu ssion. Why then is  
the Anchoring solution  not fully satisfactory? First, it still leaves us with the descendant  
hiding issue. But the fundamental reason is the software engine ering concern already voiced  
during our brief encounter with the notion of type variables. T he Yalta-like division of the  
world into a polymorph ic part and a covariant part assumes that  the designer of a class  
always has perfect foresight: for every entity that he introduc es, in particular every routine  
argument, he must decide once and for all between one of two po ssibilities:
• The entity is potentially polym orphic: now or later, it may be come attached (through  
argument passing if it is a formal  a r g u m e n t  o f  a  r o u t i n e ,  t h r o u gh assignment  
otherwise) to objects of types ot her than its declared type. Th en no descendant will  
be permitted to redefine that type.
• The entity is subject to type r edefinition: then it is either anchored or an anchor itself.
§17.6   GLOBAL ANALYSIS 633
But how can the designer be sure in each case? Much of the attr action of the object-
oriented method, captured at the beginning of this book by the Open-Closed principle,  
comes from its support for late adaptation of original choices;  from the way it accepts that  
designers of general-purpose modules need not have infinite wisdom, since authors of  
descendants can adapt so me of their decisions.
In this imperfection-tolerant ap proach, both type redefinition and descendant hiding  
are a safety valve, which enables  us to reuse an existing, almo st-suitable class:
• With type redefinition, you can adapt the type declaration in the descendant without  
touching the original (to which, of course, you may lack source  a c c e s s  o r  
modification privileges). With the covariance-only solution you  w o u l d  n e e d  t o  
change the original , using the transforma tion outlined earlier.
•Descendant hiding similarly prese rves you from suffering too mu ch from the bumps  
of the design process. True, one may criticize a design which h as RECTANGLE
inherit from POLYGON  and still want add_vertex in POLYGON ; instead, you may  
devise an inheritance structure that removes this problem, sepa rating fixed polygons  
from variable ones. It  is indeed preferable to stay away from taxonomy exceptions  in 
designing inheritance structures. But can we eliminate them alt ogether? The  
discussion of descendant hiding in a later chapter (where we wi ll encounter  
examples that cannot be restruct ured as easily as polygons and rectangles) suggests  
that we cannot, for two reasons.  First, various classification criteria may compete:  
for example we may prefer to cla ssify our polygons into regular  and irregular ones.  
Second, we have to accept that e ven where an ideal solution is possible some  
designers will not have seen it, although we may still try to i nherit from their classes.
If we want to preserve the flexi bility of descen dant adaptation , we will need to  
permit covariant type redefinition — not j ust through  anchoring  — and descendant hiding.  
The next sections describe how.
17.6  GLOBAL ANALYSIS
(This section describe s an intermediate appr oach; readers inter ested in an overview of the  
main practical solutions may  skip to the next section.)
In studying the Anchoring soluti on we noted that the basic idea  was to separate the  
covariant part from the polymo rphic part. Inde ed, if you consid er the two instructions in
s := b …
s   share (g)
e a c h  i s  a  l e g i t i m a t e  a p p l i c a t i o n  o f  a n  i m p o r t a n t  O - O  m e c h a n i s m :  t h e  f i r s t  a p p l i e s  
polymorphism; the second uses ty pe redefinition. Things start t o go wrong when you  
combine these operat ions for the same s. Similarly, in 
p := r …
p  add_vertex (…)
the problem arises from the combi nation of two individually bla meless operations. Here too  
you can use eith er instruction by itself without a hitch; inclu de both and you are in trouble.Page 57 .
See “SUBTYPE 
INHERITANCE ANDDESCENDANT HID-ING”, 24.7, page 835 ,
which discusses tax-onomy exceptions .
Skip to “BEWARE 
OF POLYMOR-PHIC CAT-CALLS!”, 17.7, page 636.
TYPING  §17.6 634
The type violations follow from erroneous calls. In the first e xample, the  
polymorphic assignment attaches s to a BOY  object, making  g an illegal argument to share 
since g is attached to a GIRL object. In the second exampl e the assignment attaches r to a 
RECTANGLE object, making  add_vertex a non-exported feature.
Hence an idea for a new solution : determine in advance — static ally, as part of the  
type checking performed by the c ompiler or set of tools — the typeset  of each entity, short  
for “dynamic type set”, comprisin g the types of all objects to which the entity might  
become attached at run time. Then  verify, still statically, tha t each call is valid for each  
element of the typesets of  the target and arguments.
I n  o u r  e x a m p l e s ,  t h e  a s s i g n m e n t  s := b indicates that BOY  i s  i n  t h e  t y p e s e t  o f  s
(because BOY is in the typeset of b as a result of the creation instruction create  b); GIRL
is in the typeset of g because of the instruction create  g; but then the call to share would  
n o t  b e  v a l i d  f o r  a  t a r g e t  s o f  t y p e  BOY  a n d  a n  a r g u m e n t  g of type GIRL . Similarly,  
RECTANGLE  is in the typeset of p because of the polymorphic assignment, but the call to  
add_vertex would not be valid for p of type RECTANGLE .
These observations lead to what we may call the Global  approach, based on a new  
typing rule:
In this definition a call is “class-valid” if it is valid accor ding to the Feature Call rule  
recalled at the beginnin g of this chapter: if C is the base class of x’s type, f  must be an  
exported feature of C, and the type of arg must conform to the type of the formal argument  
of f. (Remember that for simplicity we assume that each routine has  exactly one argument;  
the rule is trivially transposed  to an arbitrary number of argu ments.)
System validity is the same thing as ordinary class validity, e xcept that we do not just  
consider the type declared for the target x and the arguments arg: we apply class validity  
to every possible type  in their typesets.
Here is the basic rule  for determining the typeset of all entit ies:
T1  • Start out with an empty t ypeset for every entity.
T2  • For every creation in struction of  the form create  {SOME_TYPE } a, add SOME_
TYPE to the typeset of a. (For simplicity, assume  that any instruction create  a has 
been replaced by create  {ATYPE } a, where ATYPE  is the type d eclared for a.)
T3  • For every assignment of the form a := b, add all the elements  of the typeset of b
to the typeset of a.
T4  • If a is a formal argument of a routi ne, for every co rresponding act ual argument b 
in a call, add all the elements of the typeset of b to the typeset of a.
T5  • Repeat steps T 3 and T 4 until no typeset changes.System Validity rule
A call x    f (arg) is system-valid if and only if it is class-valid for x having any  
type in its own typeset, and arg having any type i n its own typeset.
§17.6   GLOBAL ANALYSIS 635
This description does not take g enericity into account, but the  extension is not hard.  
The repetition (T 5) is necessary because  of the possibility o f attachment chains (an 
attachment of b to a, of c to b and so on). It is easy to see, however, that the process will  
terminate after a fini te number of steps.
The number of steps is bounded by the maximum length of attachm ent chains, that is to  
say the maximum n such that the system c ontains attachments of xi+1 to xi for i = 1, 2, …
n–1. The repetition of T 3 and T 4 is known as a “fixpoint” technique.
As you may have noted, the rule does not consider instruction s equencing. For  
example, in
create  {TYPE1 } t;    s := t;    create  {TYPE2 } t
we will include both TYPE1  and TYPE2  into the typeset of s, even though s can only, with  
the instructions given, become  attached to an object of type TYPE1 . Taking instruction  
sequencing into accoun t would force the comp iler to perform ext ensive flow analysis,  
leading to undue complexity. Ins tead, the rules are more pessim istic: they will flag any  
occurrence of all three operations
create  b
s := b
s   share (g)
as system-invalid, even if their possible run-tim e sequencing c annot possibly lead to a type  
violation.
The global analysis approach was presented (with more details) in chapter 22 of  
[M 1992] . It solves both the covariance p roblem and the descendant hidi ng problem. It  
suffers, however, from an annoying practical deficiency: althou gh it does not require flow  
analysis, it assumes that you are checking an entire system  at once, rather than each class  
incrementally. The killer rule is T 4, which for any call x    f (b) corresponding to a routine  
f (a: ARG_TYPE ), adds the typeset of b to that of a. If  f  is a routine from a library class,  
this means that adding a call to f in a new client can affect the typesets of f  ’s formal  
arguments, and ripple over to existing calls in other clients.
Although there have been proposa ls for incremental algorithms [M 1989b] , their  
practicality has not been establi s h e d .  T h i s  m e a n s  t h a t  i n  a  d e v elopment environment  
supporting incre mental compilation the g lobal analysis techniqu e would need to be  
implemented as a check  on an entire system, rather than as part  of the local (and fast)  
operations that the compiler performs each time a user changes a few classes. Even though  
there are precedents for such an approach — C developers, for e xample, sometimes rely  
on a tool called lint, separate from the compilation p rocess, to look for inconsiste ncies —  
it is not really attractive, esp ecially in today’s sophisticate d environments whose users  
expect the tools to provide fast and complete responses.
As a result, the global validity approach has not to my knowled ge been implemented.  
(Another reason is probably that  the rule may ap pear difficult to teach, especially when  
given with all the detai ls of genericity etc.)
TYPING  §17.7 636
In passing we have seen the reas on for some termi nology used si nce the beginning  
of this discussion. A system was said to be class-valid  if it satisfied the basic type rules  
according to each entity’s type de claration; the name indicates  that, as we just saw, this can  
be checked (and checked fast) by  an incremental compiler workin g class-by-class. A  
system may be class- valid but not yet system-valid  if its execution ca n still cause type  
violations. With the t echniques seen so far, detecting this pos sibility seems to require a  
global (system-wi de) analysis.
In spite of the name, however, it is in fact possible to avoid system validity errors  
through completely incremental ch ecking. This will be our final  tack on the issue.
17.7  BEWARE OF POLYMORPHIC CATCALLS!
The System Validity rule of glob al analysis, it was noted, is p essimistic: to simplify type  
rules and their enforcement, it may reject harmless combination s. Paradoxical as this may  
seem, we will obtain our last solution by turning to an even more pessimistic rule. This  
will of course raise th e question of how rea listic the result i s.
Back to Yalta
The gist of the Catcall  solution — the name, to be ex plained shortly, for the new  
approach — is to come back to th e Yalta-like character of the A nchoring solution,  
dividing the worl d into a polymorphic pa rt and a covariant part  (the latter also having, as  
its satellite, a descendant hidi ng part), but to remove the nee d for perfect foresight.
As before we narrow down the covariance issue to two operations : in our main  
example, the polymorphic assignment, s := b, and the call to a covariant routine,  
s   share  (g). Analyzing what is truly wron g, we note that the argument g is not an issue in  
itself; any other argument, which has to be of type SKIER or a descendant, would be just  
as bad since s is polymorphic and share  covariantly redefines i ts argument. So with other
statically declared of type SKIER  and dynamically attached to a SKIER  object, the call  
s   share (other ), which would seem to be ideally  valid on its static face, will  cause a type  
violation if s has been polymorphicall y assigned the value of b.
The fundamental problem, then, is that we are trying to use s in two incompatible  
ways: as a polymorphic entity; and as the target of a call to a  covariant routine. (In the  
other working example, the problem is that we use p as both polymorphic entity and target  
of a call to a descend ant-hidden routine add_vertex .)
The Catcall solution is drastic, in line with the Anchoring sol ution: it prohibits using  
an entity both polymorphically a nd covariantly. Like the Global  solution, it will determine  
statically which entities can be  polymorphic, but it will not t ry to be smart: instead of  
finding out the typeset, it just  treats any polym orphic entity as suspect eno ugh to warrant  
lifetime exclusion from any covari ance or descendant hiding est ablishment.“Class and system 
validity”, page 627 .
Pessimism in type 
checking was dis-cussed in “Pessi-mism”, page 614 .
§17.7   BEWARE OF POLYMORPHIC CATCALLS! 637
Rule and definitions
The type rule of the Catcall approach is simple:
This is based on equa lly simple definition s. First, polymorphic  entity:
The aim of the definition is to capture as polymorphic (“potent ially polymorphic”  
would be more accurate) any enti ty that may at run time become attached to objects of  
more than one type. The definiti on only applies to reference ty pes, since exp anded entities  
cannot by nature be polymorphic.
In our examples, the skier s and the polygon p are both polymorp hic from rule P 1, 
since they appear in assignm ents, the first with a boy b and the second w ith a rectangle r.
If you have read the definition of the typeset concept in the G lobal approach, note  
how much more pessimistic the no tion of polymorph ic entity is, and simpler to check.  
Instead of trying to find out al l the possible dynamic types of  an entity, we settle for a  
binary property: can it be polymo r p h i c ,  o r  c a n  i t  n o t ?  M o s t  s t r ikingly (rule P 3), we 
consider that any formal argument of a routine is polymorphic (unless it is expanded,  
as with integers and the like). W e do not even bother to consid er the calls to a routine: if  
you are an argument, you are at the beck and call of any client , so we cannot trust your  
type. This rule is closely tied to the reusability goal of obje ct technology, where any class  
has the potential, ultimately, to become part of a reusable lib rary where any client software  
will be able to call it.
The distinctive feature of this rule is that it does not requir e any global check. To  
determine whether an e ntity is polymorphic, it suffices to exam ine the text of a class.  
There is not even any need to ex amine proper ancestors’ texts, provided we record, for  
each query (attribute or function) of each class, whether it is  polymorphic. (We need this  Catcall type rule
Polymorphic catcalls are invalid.
Definition : Polymorphic entity
An entity x of reference (non-expanded) type  is polymorphic if it satisfies  
any of the follo wing properties:
P1 • It appears in an assignment x := y where y is of a different type or  
(recursively) polymorphic.
P2 • It appears in a creation instruction create  {OTHER_TYPE } x where  
OTHER_TYPE  is not the type declared for x.
P3 • It is a formal routine argument.
P4 • It is an external function.
TYPING  §17.7 638
information since under P 1 t h e  a s s i g n m e n t  x := f will make x polymorphic if f i s 
polymorphic, whether or not it comes from the same class.) Unli ke the computation of  
typesets in the Global approach,  the detection of polymorphic e ntities can proceed class  
by class, as part of the checks performed by an incremental com piler.
As discussed in the presentation of inheritance, this analysis can also be precious for  
optimization purposes
Calls, as well as entities, may be polymorphic:
The calls of both examples are polymorphic: s   share (g) since s is polymorphic, and  
p   add_vertex (…) since p is polymorphic. The definition im plies that only qualified call s 
a   f (…) can be polymorphic. (Writ ing an unqualified call f (…) as Current    f (…) changes  
nothing since Current , to which no assignment is pos sible, cannot be polymorphic.)
Next we need the notion of catca ll, based on the notion of CAT.  A routine is a CA T  
(short for Changing Availability  or Type) if some redefinition of the routine, in a  
descendant, makes a change of one of the two kinds we have seen  as potentially  
troublesome: retyping an argument (covariantly), or hiding a pr eviously exported feature.
This property is again increment ally checkable: any argument ty pe redefinition or  
change of export status makes a routine a CAT. It yields the no tion of catcall: any call that  
a CAT change could make invalid. T his completes the set of defi nitions used by the Catcall  
type rule:
The Catcall type rule promotes o ur Yalta view by  separating cal ls into two disjoint  
categories: polymorphic calls and catcalls. Polymorphic calls y ield some of the expressive  
power of the O-O method; catcalls yield the ability to redefine  types and hide features.  
Using terminology introduced at the beginning of this chapter: polymorphism enhances  
the usefulness  of the approach; type red efinition enhances its usability .
The calls of our examples are catcalls since share  redefines its arg ument covariantly,  
and add_vertex , exported in RECTANGLE , is hidden in POLYGON . Since they are also  
polymorphic, they are prime examples of polymorphic catcalls an d hence made invalid by  
the Catcall type rule.Definition: Polymorphic call
A call is polymorphic if i ts target is polymorphic.
Definition : CAT (Changing Availability or Type)
A routine is a CA T if some redef inition changes its export stat us or the type  
of any of its arguments.
Definition : Catcall
A call is a catcall if some redefinition of the routine would m ake it invalid  
because of a change of expor t status or argument type.See optimization S2 , 
page 510 .
Page 637 .
§17.8   AN ASSESSMENT 639
17.8  AN ASSESSMENT
Before trying to summarize what we have learned on the covarian ce and descendant  
hiding issues, we should recall o nce more that system validity violations arise extremely  
rarely. The most important prope rties of static O-O typing are the ones summarized at the  
beginning of this chapter: the i mpressive array of type-related  mechanisms which, with  
class-level validity, open the wa y to a safe and flexible metho d of software construction.
We have seen three solutions to the covariance problem, two of them also addressing  
descendant hiding. W hich one is right?
The answer may not be final. The  consequences of subtle interac tions between O-O  
typing and polymorphism are not as well understo od as the topic s of the preceding  
chapters. The past few years have seen the appearance of numero us publications on the  
question, to which the bibliogra phical notes give the basic poi nters. I hope that the present  
chapter has provided t he elements for a definitive solution or something close to it.
The Global solut ion seems impractical be cause of the implied ne ed for system-wide  
checking. But it helps understand the issue.
The Anchoring solution is extremely tempting. It is simple, int uitive, easy to  
implement. We must all the more regret its failure to support s ome of the key software  
engineering requirements of the object-oriented method, as summ arized by the Open-
Closed principle. If y ou have perfect fores ight, then the Ancho ring solution i s great; but  
what designer can promise to have  perfect foresight, or assume perfect foresight from the  
authors of the libra ry classes he reuses  through inheritance?
This assumption limits the usefulness of many of the published approaches, such as those  
relying on type variables. If we can be assured that the develo per always knows in advance  
which types may change, the theoretical problem becomes much ea sier, but it does not  
accurately model the practical problem of typed object-oriented  software construction.
If we must give up the Anchoring  approach, the Catcall type rul e seems to be the  
appropriate one, easy enough to explain and enforce. Its pessim ism should not exclude  
useful combinations. If a case th at appears legiti mate yields a  polymorphic catcall, it is  
always possible to let it through safely  by introducing an assi gnment attempt; this is a way  
to transfer some of the checks to  run time. This should only ha ppen in a marginal number  
of cases.
As a caveat, I should note that at the tim e of writing the Catc all solution has not yet  
been implemented. Until a compil er has been adapted to enforce the Catcall type rule and  
applied successfully to many rep resentative syst ems, small and l a r g e ,  w h e r e  s u c c e s s  
means evidence that the rule is realistic (that all useful syst ems will pass muster, possibly  
a t  t h e  e x p e n s e  o f  a  f e w  e a s i l y  j ustifiable changes) and that ch ecking it imposes no  
significant penalty on increment al recompilation times, we must  refrain from proclaiming  
that on the problem of reconcilin g static typing and polymorphi sm with covariance and  
descendant hidin g we have heard the last word.
TYPING  §17.9 640
17.9  THE PERFECT FIT
As a complement to the discussion of covariance it is useful to  study a general technique  
addressing a common problem. This technique was devised as a re sult of the Catcall  
theory, but it can be used in the basic language framework with out any new rule.
Assume that we have two lists of skiers, where the second list includes the roommate  
choice of each skier at the corr esponding position in the first  list. We want to perform the  
corresponding share  operations, but only if they are permitted by the type rules, that is to  
say girls with girls, ranked girl s with ranked girls and so on.  Problems of this kind are  
presumably frequent.
A simple solution is p ossible, based on the preceding discussio n and on assignment  
attempt. Consider the followi ng general-pur pose function:
fitted (other : GENERAL ): like other
-- Current object if its type c onforms to that of object attach ed to 
-- other ; void otherwise.
do
if other /= Void  and then  conforms_to (other ) then
 Result ?= Current
end
end
Function fitted returns the curre nt object, but known thr ough an entity of a ty pe 
anchored to the argument; if thi s is not possible, that is to s ay if the type of the current  
object does not conform to that of the object attached to the a rgument, it returns void. Note  
the role of assignment attem pt. The function relies on conforms_to , a feature of class  
GENERAL  that determines whether the type  of an object conforms to that  of another.
Replacing conforms_to by same_type , another GENERAL  feature, yiel ds a function  
perfect_   fitted that returns void unless the t ypes are exact ly the same. 
Function fitted gives us a simple solu tion to the problem of matching skiers wi thout 
violating type rules. We can for example add the following proc edure to class SKIER  and 
use it in lieu of share  (perhaps making share a secret proce dure for more control):
safe_share (other : SKIER )
-- Choose other as roommate if permissible.
local
gender_ascer tained_other : like Current
dogender_ascerta ined_other :=   other     fitted (Current )
if gender_ascertained_other /= Void then
share (gender_ascer tained_other )
else
“Report that matching is impossible for other ”
end
endOn GENERAL , con-
forms_to and same_
type, see “Universal 
features”, page 582 .
§17.10   KEY CONCEPTS STUDIED IN THIS CHAPTER 641
For other of arbitrary SKIER  type — not just like Current — we define a version  
gender_ascer tained_other  which has a type anchored to Current . To enforce identical  
types — so that a RANKED_GIRL  goes only with another RANKED_GIRL , not with a  
mere GIRL — use perfect_   fitted  instead of fitted .
If you have two parallel lists o f skiers, representing planned roommate assignments:
occupant1 , occupant2 : LIST [SKIER ]
you can iterate ove r the lists, applying at each stage 
occupant1     item    safe_share (occupant2     item)
to match elements at correspondi ng positions if and only if the ir types are compatible.
I find this technique elegant; I hope you will too. And of cour se parents anxious  
about what really happens during  the ski trip should breathe a sigh of relief.
17.10  KEY CONCEPTS STUDIED IN THIS CHAPTER
• Static typing is essential for reliability, readability and ef ficiency.
• Static typing, to be realistic, requires a combination of mech anisms, including  
assertions, multiple i nheritance, assignment attempt, constrain ed and unconstrained  
genericity, anchored declarations. The type system must not all ow loopholes (“casts”).
• Practical rules for routine red eclarations should  permit covar iant redeclaration: both  
results and arguments may be red efined to types conforming to t he originals.
• Covariance, as well as the ability to hide in a descendant a f eature that was exported  
in an ancestor, raise the rare but seri ous possibility of type violations when combined  
with polymorphism. 
• Such type violations can be avo ided through global analysis (i mpractical), limiting  
covariance to anchored types (conf licting with the Open-Closed principle), or the  
“catcall” technique wh ich bars any covariance or descendant hid ing for any routine  
used with a polymorphic target.
17.11  BIBLIOGRAPHICAL NOTES
Some of the material of this chap ter originated with a keynote talk given at the OOPSLA  
9 5  a n d  T O O L S  P A C I F I C  9 5  c o n f e r e n c e s  a n d  p u b l i s h e d  a s  [M 1996a] . Some of the  
overview material has been dra wn from a journal article, [M 1989e] .
The notion of automatic type inference was introduced by [Milner 1989] , which  
describes an inference algorithm for the functional language ML . The connection between  
polymorphism and type checki ng is further explored in [Cardelli 1984a] .
Techniques for improving the effi ciency of dynamically typed la nguage  
implementations are described, in  the context of the Self langu age, in [Ungar 1992] .
TYPING  §17.11 642
Luca Cardelli and Peter Wegner ar e the authors of an influentia l theoretical article  
on types in programming languages [Cardelli 1985] ; using lambda calculus as the  
mathematical framework, it has served as a basis for much of th e subsequent work. It  
followed another foundatio nal article by Cardelli [Cardelli 1984] .
An ISE manual [M 1988a]  included a brief presentation of the issues raised by the  
combination of polymorphism with  covariance and descendant hidi ng. The absence of such  
an analysis in the first edition  of this book led to some criti cal discussions (predated by  
comments in a student’s bachelor thesis report by Philippe Élin ck), notably [Cook 1989]
and [America 1989a] . Cook’s paper showed several examples of the covariance proble m 
and attempted a solution. At TOOLS EUROPE 1992, Franz Weber pro posed a solution  
based on the use of generic parameters for covariant entities [Weber 1992] . [M 1992]
defines precisely the notions of  class-level and  system-level v alidity, and proposes a  
solution based on system-wide ana lysis. The Catcall solution de scribed in the present  
chapter was first presented in [M 1996a] ; see also on-line material [M-Web] .
The Anchoring solution was presented in a talk I gave at a TOOL S EUROPE 1994  
workshop. I had, however, overlooked the need for anchor  declarations and  the associated  
restriction on conformance. Paul  Dubois and Amiram Yehudai imme diately pointed out  
that the covariance problem coul d still arise un der these condi tions. Along with others  
including Reinhardt Budde, Karl-H einz Sylla, Kim Waldén and Jam es McKim, they  
provided many further comments th at were fundamental to the wor k leading to the present  
chapter (without being com mitted to its conclusions).
There is an abundant literature on the covariance issue; [Castagna 1995]  a n d 
[Castagna 1996]  provide both a bibliography and  a mathematical overview. For a  list of  
links to on-line articles on O-O type theory and researchers’ W eb pages, see Laurent
Dami’s page [Dami-Web] . The terms “covariance” and “contravariance” come, by the  
way, from category theory; it ap pears that their introduction i nto discussion s of software  
typing is due to Luca Cardelli, w ho started to use them in talk s in the early eighties,  
although they seem not to have a ppeared in print until the end of that decade.
Techniques based on type va riables are described in [Simons 1995] , [Shang 1996] , 
[Bruce 1997] .
The Sather language us es contravariance. [Szypersky 1993]  presents the rationale. For an introduction 
to lambda calculus see [M 1990].
Ph. Élinck : “De la 
Conception-Prog-rammation par Objets” , Mémoire de 
licence , Université 
Libre de Bruxelles (Belgium ), 1988 .
18  
Global objects and constants
L ocal knowledge is not always enou gh; components of a software s ystem may need to  
access global informat ion. It is easy to think of examples: a s hared value, such as the size  
of available memory; an error wi ndow, to which all the componen t s  o f  a n  i n t e r a c t i v e  
system must be able to output me ssages; the gate way to a databa se or network.
I n  c l a s s i c a l  a p p r o a c h e s ,  i t  i s  n o t  d i f f i c u l t  t o  p r o v i d e  f o r  g l o bal objects; you just  
declare them as global variables , owned by the main program. In  the modular style of  
design made possible b y object-oriented tech niques, there is ne ither a main program nor  
global variables. But even if ou r software texts do not include  global variables our  
software execution s may still need to share objects. 
Such global objects pose a challenge to the method. Object tech nology is all about  
decentralization, all about modul a r i t y ,  a l l  a b o u t  a u t o n o m y .  I t  has developed from the  
beginning of this presentation a s a war of independence for the  modules, each fighting for  
its freedom from the excesses of central authority. In fact, th ere is no central authority any  
more. How then do we satisfy the  need for common institutions? In other words, how do  
we allow components to share data in a simple way, without jeop ardizing their autonomy,  
flexibility and reusability?
It will not work, of course, to pass shared objects as argument s to the modules that  
need them. This would soon becom e clumsy if too many components  need them. Besides,  
argument passing assumes that one  module owns the value and the n passes it on to others;  
in the case of a truly shared va lue no one module  can claim own ership.
To find a better answer we will start from a well-known notion,  which we need in  
object-oriented software construction just as much as we did in  more traditional  
approaches: constants. What is, after all, a constant such as Pi if not a simple object shared  
by many modules? Gener alizing this notion to more complex objec ts will provide a first  
step towards fully  general constant a nd shared objects.
18.1  CONSTANTS OF BASIC TYPES
Let us start with a simple nota tion to denote c onstant values.
GLOBAL OBJECTS AND CONSTANTS  §18.1 644
Using symbolic constants
A rule of software style, the  Symbolic Cons tant principle , states that when an algorithm  
refers to a certain value — a number, a character, a string … — it should almost never use  
i t  d i r e c t l y .  I n s t e a d ,  a  d e c l a r a t i o n  s h o u l d  a s s o c i a t e  a  n a m e  w i t h the value, so that the  
algorithm can use th e name (known as a symbolic  constant) rather tha n the value (known  
as a manifest  constant). Two reasons ju stify this principle:
• Readability: someone who reads your software may not understan d what the value 50  
is doing in a certain algorithm; if instead you us e the symboli c constant US_states_
count  everything is clear.
• Extendibility: in practice, wit h a few exceptions (such as the  value of π, unlikely to  
change soon), the only  constant thing about  constants is change . To update the value  
of a constant it suffices, if you have been using symbolic cons tants, to change one  
declaration. This is much nicer than having to chase throughout  the software for all  
the places that ma y have relied on t he earlier value.
The principle permits using manifest consta nts (hence the word “almost” above) for  
zero elements of various operations, as in a loop from i := 1 until i > n … iterating over  
the elements of an array whose numbering follows the default co nvention of starting at 1.  
(But n should be symbolic, not manifest.)
Although few software developers apply the Symbolic Constant pr inciple as  
systematically as they should, the benefits of declaring a symb olic constant are well worth  
the small extra effort. So we need a clear and simple way of de fining symbolic constants  
in an O-O framework.
Constant attributes
A symbolic constant, like everythi ng else, will be defined in a  class.We will simply treat  
a constant value as an attribute which happens to have a fixed value, the same for all  
instances of the class.
For the syntax, we use the “ =” symbol, followed by a value of the appropriate type.  
The following examples  include one for each of the basic types INTEGER , BOOLEAN , 
REAL and CHARACTER : 
Zero: INTEGER = 0
Ok: BOOLEAN =True
Pi: REAL = 3.1415926524
Backslash : CHARACTER = ' \ '
Backslash is of type CHARACTER , its value a single character. Constants of string type,  
denoting character s trings of arbitrary length, will be discuss ed below. 
A s  t h e s e  e x a m p l e s  i l l u s t r a t e ,  t h e recommended style convention for names of  
constant attributes is to start with a capital letter, with the  rest in lower case.
A descendant may not r edefine the value of a  constant attribute .“Manifest and sym-
bolic constants”, page 884 . See also 
“Modular continu-ity”, page 44 .
§18.2   USE OF CONSTANTS 645
Like other attributes, constant  attributes are e ither exported or secret; if they are  
exported, clients of the class may access them through feature calls. So if C is the class  
containing the above  declarations and x, declared of type C, has a non-void value, then  
x   Backslash denotes the backslash character. 
Unlike variable attributes, cons tant attributes do not occupy a ny space at run time in  
i n s t a n c e s  o f  t h e  c l a s s .  S o  t h e r e  is no run-time penalty for add ing as many constant  
attributes as you need. 
18.2  USE OF CONSTANTS 
Here is an example sho wing how clients may  use constant attribu tes defined in a class: 
class  FILE feature
error_code : INTEGER ; -- Variable  attribute
Ok: INTEGER = 0
Open_error : INTEGER = 1
…
open (file_name : STRING )
-- Open file of name file_name
-- and associate it wi th current file object
do
error_code  := Ok
…
if “Something went wrong”  then
error_code  := Open_error
end
end
… Other features …
end
A client may call open  and compare the resulting erro r code to any of the constants  
to test how the operation went: 
f: FILE ; …
f   open
if f   error_code = f   Open_error then
“Appropriate action”
else
…
end
Often, however, a group of constants is needed without being at tached to any  
particular object. For  example, a system pe rforming physics com putations may use some  
numerical constants; or a text editor may need character consta nts describing the character  
GLOBAL OBJECTS AND CONSTANTS  §18.3 646
keys associated with various commands. In such a case, the cons tants will still be grouped  
in a class (where else could they be?), but there will not be a ny instances of that class; it  
is simply used as parent for the classes that need to access th e constants, as in 
class  EDITOR_CONSTANTS feature
Insert : CHARACTER is 'i'
Delete : CHARACTER is 'd'; -- etc.
…
end
class  SOME_CLASS_FOR_THE_EDITOR inherit
EDITOR_CONSTANTS
… Other possible parents …
feature  …
… Routines of the class have  access to the constants
     declared in EDITOR_CONSTANTS  …
end
A class such as EDITOR_CONSTANTS  i s  u s e d  o n l y  t o  h o s t  a  g r o u p  o f  r e l a t e d  
constants, and its role as an “ab stract data type implementatio n” (our working definition  
of the notion of class) is less obvious than in earlier example s. But it definitely serves a  
useful purpose. We wil l examine its theore tical justification i n a later chapter.
The scheme shown would not work without multiple inheritance, s ince SOME_
CLASS_FOR_THE_EDITOR  may need other parents, either for access to other constants  
or for more standard uses of inheritance.
18.3  CONSTANTS OF CLASS TYPES
Symbolic constants, allowing you  to use identifiers to denote c ertain constant values, are  
not just useful for pred efined types such as INTEGER ; the need also arises for types that  
developers have defined, through  classes. Here the solution is less obvious. 
Manifest constants are inappropriate for class types 
A typical example in which you m ay need to define a constant fo r a non-basic types is that  
of a class describin g complex numbers:
class  COMPLEX creation
make_cartesian , make_  polar
feature
x, y: REAL
-- Real and imaginary partsSee “F ACILITY 
INHERITANCE”, 24.9, page 847 .
§18.3   CONSTANTS OF CLASS TYPES 647
make_cartesian (a, b: REAL )
-- Initialize with real part a, imaginary part b.
do
x := a; y := b
end
… Other ro utines ( x and y are the only attributes) …
end
You may want to define the complex number i, with real part 0 and imaginary part  
1. The first idea that  comes to mind is a manifest constant not ation such as
i: COMPLEX is “Expression sp ecifying the complex number (0, 1)”
How can you write the expression after is? For simple types, the  manifest constants  
were self-evident: 345 is a constant of type integer,  'A' of type character. But no such  
predefined notation is available  for developer-defined class ty pes. 
One could imagine a notation base d on the attributes of the cla ss; something like
i: COMPLEX is COMPLEX (0, 1)
But such an approach (although present in some O-O languages) i s incompatible  
with the principles of modularity which serve as the basis for object technology. It would  
mean requiring clients of COMPLEX to describe constants in terms of the implementation.  
This breaks information hiding. You could not add an attribute,  even a secret one, without  
invalidating client code; neithe r could you re-implement an att ribute such as x a s  a 
function (to switch internally  to a polar representation). 
Besides, how could you m ake sure that such manifest constants w ill satisfy the class  
invariant if there is one? 
This last remark opens the way t o a correct solution. An earlie r chapter noted that it  
is the responsibility of the creation procedures  to make sure that every object satisfies  
the invariant immediately upon creation. Creating objects in an y other way (apart from the  
safe companion mechanism, clone ) would lead to error situations. So we should look for  
a mechanism that, rather than manifest objects in the above sty le, will rely on the usual  
technique for object creation.
Once functions 
We may view a constant object as a function. For example i could be defined within class  
COMPLEX  itself as 
i: COMPLEX
-- Complex number with real p art 0 and imaginary part 1
do
create  Result    make_cartesian (0, 1)
endNot a retained nota-
tion. For purposes of 
illustration only .
GLOBAL OBJECTS AND CONSTANTS  §18.4 648
This almost does the job, since the function will always return  a reference to an  
object of the desired form. Since we rely on normal creation pr ocedures, the invariant will  
be satisfied, so we will only  produce consi stent objects.
The result, however, is not exact ly what we need: each client u se of i in the client  
produces a new object, identical to all the others. This is a w aste of time and space: 
To get the proper behavior, we need a special kind of function:  one which executes  
its body only the first time it is called. We can call this a once function . A once function  
is otherwise similar to a normal function; syntactically , it wi ll be distinguished by the  
keyword once , replacing the usual do, to introduce the body:
i: COMPLEX
-- Complex number w ith real part 0 an d imaginary part 1
once 
create  Result    make_cartesian (0, 1)
end
The first time a once function is called during a system’s exec ution, it executes its  
body. In the example this creates an object representing the de sired complex number, and  
returns a reference to that obj ect. Every subseq uent call execu tes no instruction at all, but  
terminates immediately, returning the result computed the first  time around. 
Regarding efficiency: a call to i other than the first should take only marginally  
longer than an attribute access. 
The result computed by the first  call to a once function is app licable to all instances  
of a class, in the general sense of the word “instance” coverin g instances of descendants  
as well, except of course for an y descendant that redefines the  function. As a consequence  
you can freely redefine functions from once to non-once and con versely. Here if a  
descendant COMPLEX1 of COMPLEX  redefines i, a call to i on an instance of  
COMPLEX1  will use the redefined version (whether once or non-once); a c all on a direct  
instance of COMPLEX  or a descendant other than COMPLEX1  will use the once function,  
that is to say the v alue computed by the first such call.
18.4  APPLICATIONS OF ONCE ROUTINES
The notion of once routine extends beyond examples such as i to more general applications:  
shared objects, globa l system parameters,  initialization of com mon properties.
Shared objects 
For reference types such as COMPLEX , as you may have noted, the “once” mechanism  
actually offers constant references , not necessarily constant objects . It guarantees that the  
body of the function is executed  only once, to compute a result , which later calls will also  
return without further computation.
If the function returns a value of a reference type, its body w ill usually contain a  
creation instruction, as in the example of i. All calls will return a reference to the object  The only change
§18.4   APPLICATIONS OF ONCE ROUTINES 649
created by the first. Although the creation  will never be execu ted again, nothing prevents  
callers from modifying the object  through the reference. Theref ore the mechanism  
provides shared  objects rather th an constant ones. 
An example of a shared object, cited at the beginning of this c hapter, is a window  
showing error messages  in an interactive system. Assume we have  decided that any  
component of the system that det ects a user error may output a message to that window,  
through a call of the form 
Message_window    put_text ("Appropriate error message ")
Here message_window  is of type WINDOW , with class WINDOW  declared as
class  WINDOW creation
make
feature
make (…)
-- Create window at size and position indicated by arguments.
do … end
text: STRING
-- Text to be displayed in window
put_text (s: STRING )
-- Make s the text to be di splayed in window.
do
text := s
end
… Other features …
end
Obviously Message_window  must be the same for all components of the system.  
This is achieved by declaring the  corresponding fe ature as a on ce function: 
Message_window : WINDOW
-- Window where error messages will be output
once
create  Result    make ("…Size and positi on arguments …")
end
In this case the message window object must be shared by all it s users, but it is not a  
constant object: each call to put_text  changes the  object by putting its own chosen text in  
it. The best place to declare Message_window  is a class from which all system components  
needing access to the me ssage window will inherit.
In the case of a shared object that denotes a constant, such as  i, you may want to disallow  
calls of the form i   some_  procedure  that might change the fields. To achieve this, simply  
include clauses i   x = 0 and i   y = 1 in the class invariant.
GLOBAL OBJECTS AND CONSTANTS  §18.4 650
Once functions returning r esults of basic types 
Another application of once functions is to represent global va lues — “system  
parameters” — used by several classes in a system. Such values will usually be constant  
over a given system ex ecution; they are initially computed from  user input, or from some  
information obtained from th e environment. For example: 
• The components of a low-level s ystem may need to know the avai lable memory  
space, obtained from the environment at initialization time. 
• A terminal handler may start by  querying the environment about  t h e  n u m b e r  o f  
terminal ports: once o btained, these data el ements are then use d by several modules  
of the application. 
Such global values are simil ar to shared objects such as Message_window ; but in  
general they are values of basic types rather than class instan ces. You may represent them  
through once functions . The scheme is: 
Const_value : T
-- A system paramete r computed only once
local
envir_  param : T  ' -- Any type  (T or another)
once
“Get the value of envir_  param  from the environment”
Result  := “Some value co mputed from envir_  param ”
end
Such once functions of basic type s describe dynam ically compute d constants. 
Assume the above declaration is in a class ENVIR . A class needing to use Const_value  
will get it simply by listing ENVIR  among its parents. There is no need here for an  
initialization routine as might be used in classical approaches  to compute Const_value , 
along with all other global parameters, at the beginning of sys tem execution. As was seen  
in an earlier chapter, such a routine would have to access the internal details of many other  
modules, and hence would violate the criteria and principles of  modularity:  
decomposability, few interfaces, information hiding etc. In con trast, classes such as  
ENVIR may be designed as coherent modules, each describing a set of l ogically related  
global values. The first component that requests the value of a  global parameter such as  
Const_value  at execution time will trigger its computation from the enviro nment. 
Although Const_value  is a function, components that use it may treat it as if it we re 
a constant a ttribute. 
The introduction to this chapter mentioned that none of the mod ules that use a shared  
value has more claim to own it than any of the others. This is especially true in the cases  
just seen: if, depending on the order of events in each executi on of the system, any one  
among a set of modules may trigge r the computation of the value , it would be improper to  
designate any single one among th em as the owner. The modular s tructure reflects this.See “Modular 
decomposability”, page 40 .
§18.4   APPLICATIONS OF ONCE ROUTINES 651
Once procedures 
The function close should only be called once . We recommend using a global  
variable in your appl ication to check that close is not called more than once .
(From the manual for a  commercial C library.)
The “once” mechanism is interes ting not just for functions but for procedures as well. 
A once procedure is appropriate when some facility used on a sy stem-wide basis  
must be initialized, but it is not known in advance which syste m component will be the  
first to use the facility. It is like having a rule that whoeve r comes in first in the morning  
should turn on  the heating. 
A simple example is a graphics l ibrary providing a number of di splay routines,  
where the first display routine called in any system execution must set up the terminal. The  
library author could of course r equire every client to perform a setup call before the first  
display call. This is a nuisance  for clients and does not reall y solve the problem anyway:  
to deal properly with errors, any  routine should be able to det ect that it has been called  
without proper setup; but if it is smart enough to detect this case, the routine might just as  
well do the setup and avoi d bothering the client!
Once procedure s provide a better solution:
check_setup
-- Perform terminal se tup if not done yet.
once
terminal_setup  -- Actual setup action
end
Then every display routine in the library should begin with a c all to check_setup . The 
first call will do the setup; s ubsequent ones will do nothing. Note that check_setup does 
not have to be exporte d; client authors do not need to know abo ut it. 
T h i s  i s  a n  i m p o r t a n t  t echnique to improve th e usability of any library or other  
software package. Any time you can remove a usage rule — such a s “Always call  
procedure xyz before the first operation” — an d instead take care of the need ed operations  
automatically and silently, you h ave made the software better.
Arguments 
Like other routines, once routines — procedures and functions —  can have arguments. But  
because of the definition of the  mechanism, these arguments are  only useful in the call that  
gets executed first.
I n  t h e  e a r l i e r  a n a l o g y ,  i m a g i n e  a thermostat dial which anyone coming into the  
building may turn to any marking , but such that only the first person to do s o will set the  
temperature: subsequent attempts have no effect. 
GLOBAL OBJECTS AND CONSTANTS  §18.4 652
Once functions, anchoring and genericity
(This section addresse s a specific technical  point and may be s kipped on first reading.)
Once functions of class types carry a potential incompatibility  with anchored types  
and genericity. 
Let us start with genericity. In a generic class EXAMPLE [G] assume a once function  
returning a value whos e type is the formal generic parameter:
f: G once … end
and consider a possible use:
character_example : EXAMPLE [CHARACTER ]
… 
print (character_example   f )
So far so good. But you also try  to do something with another g eneric derivation:
integer_example : EXAMPLE [INTEGER ]
… 
print (integer_example   f + 1 )
The last instruction adds two int eger values. Unfortunately, th e first of them, the  
result of calling f, has already been computed since f is a once function; and it is a  
character, not an integer. T he addition is not valid.
The problem is that we are sharing a value between different ge neric derivations  
which expect the type of that va lue to depend on the actual gen eric parameter.
A similar issue arises with an chored types. Assume a class B which adds an attribute  
to the features of its parent A: 
class  B inherit  A feature
attribute_of_B : INTEGER
end
Assume that A had a once function f, returning a result of anchored type: 
f: like Current once  create  Result    make end
and that the first evaluation of f  is in
a2 := a1   f
with a1 and a2 of type A. The evaluation of f creates a direct instance of A, and attaches it  
to entity a2, also of type A. Fine. But assume now th at a subsequent use of f is 
b2 := b1   f
where b1 and b2 are of type B. If f were a non-once function,  this would not cause any  
problem, since the call would now  produce and return a direct i nstance of B. Since here  
we have a once function, the resu lt has already been computed t hrough the first call; and  
that result is a direct instance of A, not B. So an instruction such as
print (b2   attribute_of_B )Warning : not valid . 
See below .
Warning : not valid . 
See below .
§18.5   CONSTANTS OF STRING TYPE 653
will try to access a non-existe nt field in an object of type A.
The problem is th at anchoring cau ses an implicit redefinition. Had f  been explicitly  
redefined, through a dec laration appearing in B under the form
f: B once  create  Result    make end
assuming that the original in class A similarly returned a result of type A (rather than  
like Current ), then we would not have any trouble: direct instances of A use the A version,  
direct instances of B use the B version. Anchoring, of course , was introduced  precisely to  
rid us of such explici t redefinitions serv ing type needs only.
These two cases are evidence of i ncompatibilities between the s emantics of once  
functions (proce dures are fine) and the results of either ancho red or formal generic types.
One way out, suggested by the last observation on implicit vs. explicit redefinition,  
would be to treat such cases as we would explicit redefinitions : to specify that the result  
of a once function will be shared only within each generic deri vation of a generic class,  
and, if the result is anchored, only within the direct instance s of the class. The  
disadvantage of this s olution, however, is that it goes against  the expected semantics of  
once functions, which from a cli ent’s viewpoint should be the c onceptual equivalent of a  
shared attribute. To avoid confus ion and possible errors it see ms preferable to take a more  
draconian attitude by bann ing such cases altogether:
18.5  CONSTANTS OF STRING TYPE 
The beginning of this chapter introduced character constants, w hose value is a single  
character. The example was
Backslash : CHARACTER is ' \ '
Often, classes will al so need symbolic constants representing m ulti-character  
strings.The notation for manifes t string constants will use dou ble quotes: 
[S1]
Message : STRING = "Syntax error "
Recall that STRING  is a class of the library, not a simple type. So the value ass ociated  
at run time with an entity such as Message  is an object (an instance of STRING ). As you  
may have guessed, the above declaration is a shorthand for the declaration of a once  
function, here of the form: Once Function rule
The result type of a once function  may not be anchored, and may  not involve  
any formal generic parameter.
GLOBAL OBJECTS AND CONSTANTS  §18.6 654
Message : STRING
-- String of length 12, wit h successive characters
-- S, y, n, t, a, x,  , e, r, r, o, r
once
create  Result    make (12)
Result    put ('S', 1)
Result    put ('y', 2)
…
Result    put ('r', 12)
end
The creation procedure for strings takes as argument the initia l expected length of the  
string; put (c, i) replaces the i-th character with c. 
Such string values are therefore  not constants but references t o shared objects. Any  
class that has access to Message  may change the value of one  or more of its characters. 
You can also use string constants as expressions, for argument passing or assignment:
Message_window    display ("CLICK LEFT BUTTON TO CONFIRM EXIT ")
greeting  := "Hello !"
18.6  UNIQUE V ALUES
It is sometimes necessary to defi ne an entity that has several possible values denoting  
possible cases. For example a re ad operation may produce a stat us code whose possible  
values are codes meani ng “successful”, “erro r on opening” and “ error on reading”.
A simple solution is to use a variable integer attribute
code : INTEGER
with a set of associated i nteger constants, such as
[U1]
Successful : INTEGER = 1
Open_error : INTEGER = 2
Read_error : INTEGER = 3
so that you can write conditio nal instructions of the form
[U2]
if code = Successful then …
or multi-branch inst ructions of the form
[U3]
inspect
code
when Successful then
…
when …
endSee “Multi-branch”, 
page 449 .
§18.6   UNIQUE V ALUES 655
It is tedious, however, to have to come up with the individual constant values. The  
following notation has the sa me practical effect as [U1]:
[U4]
Successful , Open_error , Read_error : INTEGER unique
A unique  v a l u e  s p e c i f i c a t i o n ,  c o m i n g  i n  l i e u  o f  a  m a n i f e s t  i n t e g e r  v a l u e in the  
declaration of a const ant integer attribute, indicates that the  v a l u e  i s  c h o s e n  b y  t h e  
compiler rather than the developer. So the conditional instruct ion [U2] and the multi-
branch [U3] are still applicable.
All unique  values within a class are guaranteed to be positive and differ ent; if they  
are declared together, as the three in [U4], they are also guar anteed to be c onsecutive. So  
if you want to express that code  will only receive one of their values, you can include the  
invariant clause
code >= Successful ; code <= Read_error
With this invariant, a descendant  — which, as we know, may chan ge the invariant  
only by strengthening it — may constrain the possible values of  code  further, for example  
to just two possibilities; it may not extend the set of possibi lities.
Y ou should only use Unique values to represent a fixed set of p ossible values. As  
soon as this set is open to vari ation, or the in structions in a  structure such as [U3] are non-
trivial, it is preferable to dev ise a set of classes which vari ously redefine some features,  
and then to rely on dynamic bindi ng, satisfying the Open-Closed  principle. More  
generally, do not use unique values for cl assification since th e object-oriented method has  
better techniques. The preceding  example is typical of good use s of the mechanism; others  
would be traffic light states ( green , yellow , red: INTEGER unique ) or, as seen earlier,  
notes on the scale ( do, re, mi, …: INTEGER unique ). But a declaration savings , checking ,
money_market : INTEGER unique  is probably a misuse if the various kinds of account  
have different features or diffe rent implementat ions of a commo n feature; here inheritance  
and redefinition wi ll most likely provid e a better solution.
These observations can be summe d up as a methodological rule:
Although similar in some respect s to the “enumerated types” of Pascal and Ada,  
unique declarations do not intro duce new types, only integer va lues. The discussion  
section will explore the difference further.Discrimination principle
Use unique values to describe a fixed number of possible cases.  F o r 
classification of data abstracti ons with varying  features, use inheritance.
GLOBAL OBJECTS AND CONSTANTS  §18.7 656
18.7  DISCUSSION
In this discussion, the term “gl obal object” refers both to glo bal constants of basic types and  
to shared complex objects; their  “initialization” includes obje ct creation in the latter case. 
Initializing globals and shared objects : language approaches 
The principal problem addressed by this chapter is an instance of a general software issue:  
how to deal with global constant and shared objects, and partic ularly their initialization in  
libraries of software components. 
Since the initialization of a global object should be done just  once, the more general  
issue is how to enable a library  component to determine whether  it is the first to request a  
certain service. 
This boils down to an apparently  simple question: how to share a boolean variable  
and initialize it consistently. We can associate with a global object p, or any group of  
global objects that need to be ini tialized at the same time, a boolean indicator, say ready , 
which has value true if and only if initialization has been per formed. Then we may include  
before any access to p the instruction
if not ready then
“Create or compute p”
ready  := True
end
The initialization prob lem still applies to ready , itself a global object that must  
somehow be initialized to false before the first  attempt to acc ess it. 
This problem has not changed muc h since the dawn  of programming  languages, and  
the early solutions are still wi th us. A common technique in bl ock-structured languages  
such as Algol or Pascal is to use for ready  a global variable, de clared at the highest  
syntactical level. The main progr am will do the initialization.  But this does not work for a  
library of autonomous modules whic h, by definition, is not conn ected to any main program. 
In Fortran, a language designed to allow routines to be compile d separately (and hence  
to enjoy a certain degree of aut onomy), the solution is to incl ude all global objects, and in  
particular ready  indicators, in a shared data area called a common block, ident ified by its  
name; every subroutine accessing a  common block must include a directive of the form 
COMMON /common_block_name / data_item_names
There are two problems with this approach: 
• Two sets of routines may use a common block of the same name, triggering a conflict  
if an application needs them bot h. Changing one of the names to  remove the conflict  
may cause trouble since common blocks, by nature , are shared by  many routines.
• How do we initialize the entitie s of a common block, such as o ur ready  indicators?  
Because there is no default initialization rule, any data in a common block must be  
initialized in a special modul e called a “block data” unit. Fortran 77 allows named  
block data units, so that develo pers can combine global data fr om various contexts  
— provided they do not  forget to include a ll the relevant block  data units. A serious  
risk of accidental in consistency exists. 
§18.7   DISCUSSION 657
The C solution is conceptually the same as in Fortran 77. The ready  indicator should  
be declared in C as an “external” variable, common to more than  o n e  “ f i l e ”  ( t h e  C  
compilation unit). Only one file may contain the declaration of  the variable with its initial  
value (false in our case); others will use an extern  declaration, corresponding to Fortran’s  
COMMON  directive, to state that they need the variable. The usual pra ctice is to group such  
definitions in special “header”  files, with names conventionall y ending with    h; they  
correspond to the block data units  of Fortran. The same problem s arise, partially alleviated  
by “Make” utilities which help pr ogrammers keep track of depend encies. 
A solution would appear to be at hand with modular languages su ch as Ada or  
Modula 2 where routines may be gathered in a higher-level modul e, a “package” in Ada  
terms: if all the routines using a group of related global obje cts are in the same package,  
the associated ready  indicators may be declared as boolean variables in that packag e, 
which will also contain the initialization. But this approach ( also applicable in Fortran 77  
and C using techniques described in chapter 18) does not solve the problem of initialization  
in autonomous library components. The more delicate question di scussed in this chapter is  
what to do for global objects that must be shared between routi nes in different  a n d 
independent modules. Ada and Modu la provide no simple answer in  this case.
In contrast, the “once” mechanism preserves the independence of  classes, but allows  
context-dependent initializations. 
Manifest string constants
The notation allows string consta nts (or more properly, as we h ave seen, shared objects)  
to be declared in manifest f orm, using double quotes: "…". A consequence of this policy  
is that the language definition,  and any compiler, must rely on  the presence of class  
STRING  in the library. This is a compr omise between two extreme solut ions: 
•STRING  could have been a predefined basic type, as is the case in man y languages.  
This, however, would have meant adding all string operations (c oncatenation,  
substring extraction, comparison  etc.) as language constructs, making the language  
considerably more complex, even though only few applications re quire all these  
operations; some do not even nee d strings at all. Among the adv antage of using a  
class is the ability to equip it s operations with precise speci fications through  
assertions, and to allow other classes to inherit from it.
• Treating STRING  as just any other class would preclude manifest constants of t he 
"…" form [S1], requiring developers always to enter the characters  individually as  
in form [S2]. It might also prev ent the compiler from applying optimizations for  
time-sensitive operations such as charac ter access. 
So STRING , like its companion ARRAY , leads a double life: predefined type when  
you need manifest constants and optimization, class when you ne ed flexibility and  
generality. All this, of course, is part of the general effort to have a single, universal,  
consistent type system entirely based on the notion of class.
Unique values and enumerated types 
Pascal and derivatives all ow declaring a variable as
code : ERROROn the ARRAY  case 
see “Efficiency con-siderations”, page 327
GLOBAL OBJECTS AND CONSTANTS  §18.7 658
where ERROR  is declared as an “enumerated type”:
type ERROR = (Normal , Open_error , Read_error )
Being declared of type ERROR , variable code  may only take the v alues of this type:  
the three symbolic codes given. 
We have seen how to obtain the equivalent effect in the O-O not ation: define the  
symbolic codes as unique integer constants, and code  as an integer attribute, possibly with  
an invariant clause stating that its value must lie between Normal  and Read_error . The 
result at execution time is almos t identical, since Pascal comp ilers typically implement  
values of an enumerated type by integers. (A good compiler may take advantage of the  
small number of possib le values to represent entities such as code  by short integers.)
The unique  technique involves no new type.  It seems indeed hard to reconc ile the  
notion of enumerated type with ob ject technology. All our types  are based on classes, that  
is to say abstractly characteriz ed by the applicable operations  and their properties. No such  
characterization exists for enumerated types, which are mere se ts of values. Enumerated  
types actually raise problem s even in non-O-O languages:
• The status of the symbolic names is not clear. Can two enumera ted types share one  
or more symbolic names (as Orange  both in type FRUIT  and in type yy-unknown )? 
Are they exportable and subject to the same visibility rules as  variables?
• It is difficult to pass values of an enumeration type to and f rom routines written in  
other languages,  s u c h  a s  C  o r  F o r t r a n ,  w h i c h  d o  n o t  s u p p o r t  t h i s notion. Since  
unique values are plain i ntegers they cause  no such problem.
• Enumerated values may require s pecial operators. For example y ou will expect a  
next operator yielding the next valu e, but it will not be defined f or the last  
enumeration element. You will als o need an operator to associat e an integer with  
every enumerated value (its inde x in the enumeration). To go th e other way around  
requires more operators since we must know the bounds of the en umeration to  
restrict applicable integer values. The resulting syntactic and  semantic complexity  
seems out of proportion with the  mechanism’s contribution to th e language.
Uses of enumeration types in Pascal and Ada tend to be of the f orm
type FIGURE_SORT = (Circle , Rectangle , Square , …)
to be used in connection with var iant record types of the form 
FIGURE =
record
perimeter : INTEGER ;
… Other attributes common to figures of all types …
case fs: FIGURE_SORT of
Circle : (radius : REAL ; center : POINT );
Rectangle : … Attributes specific to rectangles  …;
…
end
end
themselves used in case discrimination instructions:
§18.8   KEY CONCEPTS INTRODUCED IN THIS CHAPTER 659
procedure  rotate (f: FIGURE )
begin case  f of
Circle : … Appropriate actions  to rotate a circle …;
Rectangle : …;
…
which we have learned to handle in a better way to preserve ext endibility: by defining a  
different version of procedures such as rotate  for each new variant, represented by a class.
When this most important application of enumerated types disapp ears, all that  
remains is the need, in some cases, to select integer codes hav ing a fixed number of  
possible values. Defining them as integers avoids many of the s emantic ambiguities  
associated with enumerated types;  f o r  e x a m p l e  t h e r e  i s  n o t h i n g  mysterious about the  
expression Circle  + 1 if Circle  is officially an integer. The o nly unpleasantne ss of integers  
would be to have to assi gn the values yourself; unique  values solve that problem.
18.8  KEY CONCEPTS INTR ODUCED IN THIS CHAPTER 
• A challenging problem in any a pproach to software construction  is how to allow for  
global data: objects that must b e shared by various modular com ponents, and  
initialized at run time by whate ver component happens to need t hem first. 
• A constant can be manifest  ( e x p r e s s e d  a s  a  s e l f - d e s c r i bing representation of its  
value) or symbolic  (expressed by a name).
• Y ou can declare manifest constants of basic types as constant attributes, occupying  
no space in objects. 
• Except for strings, developer-de fined types have no manifest c onstants, which would  
damage information hid ing and extendibility.
• A once routine, which differs from a normal function by one ke yword, once  instead  
of do, is evaluated only once during a system’s execution: the first  time any  
component of the system calls it.  For a function,  subsequent ca lls return the same  
value as the first; for a proce dure, subsequent c alls have no e ffect. 
• Shared objects may be  implemented as once functions. You can u se the invariant to  
specify that the y are constant.
• Use once procedures for operati ons to be perfor med only once o ver the execution of  
a system, such as initializat ions of global parameters.
• The type of a once function ma y not be anchored or generic.
• Constants of string types are t reated internally as once funct ions, although they look  
like manifest constants written in double quotes.
• Enumerated types à la Pascal do not go well with the object-or iented method, but to  
represent codes with several pos sible values there is a need fo r “unique” attributes:  
symbolic constants of type INTEGER , whose value is chosen by the compiler rather  
than by the software writer.
GLOBAL OBJECTS AND CONSTANTS  §18.9 660
18.9  BIBLIOGRAPHICAL NOTES
[Welsh 1977]  and [Moffat 1981]  study the difficulties raised by enumerated types.
Some of the technique s of this chapter we re introduced in [M 1988b] .
EXERCISES
E18.1  Emulating enumerated types with once functions
Show that in the absence of Uniq ue types a Pascal enumerated ty pe of the form 
type ERROR = (Normal , Open_error , Read_error )
could be represented by a class with a once func tion for each v alue of the type.
E18.2  Emulating unique va lues with once functions
Show that in a language that d oes not support the notion of unique  declaration it is  
possible to obtain the effect of
value : INTEGER unique
by a declaration of the form
value : INTEGER once … end
where you are requested to fill in the body of the once functio n and anything else that may  
be needed.
E18.3  Once functions in generic classes
Give an example of a once function whose result involves a gene ric parameter and, if not  
corrected, would yield  a run-time error. 
E18.4  Once attributes ?
Examine the usefulness of a noti on of “once attribute”, pattern ed after once routines. A  
once attribute would be common to  all instances of the class. I ssues to be considered  
include: how does a once attribu t e  g e t  i n i t i a l i z e d ?  I s  t h e  f a c i lity redundant with once  
functions without argum ents and, if not, can you explain clearl y under what conditions  
each facility is appropriate? Can you think of a good syntax fo r declaring once attributes? See “Once functions, 
anchoring and genericity”, page 652 .
Part D: 
Object-oriented methodology: 
applying the method well
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
Part D will cover the methodology of object or ientation: how to apply, for the benefit  
of our projects and th e success of our organizations, the powerful set of concepts and  
techniques reviewed in the preceding chapters.
19  
On methodology
E ntirely devoted to methodology, the next few chapters — making up part D of this  
book — examine how to address th e issues facing object-oriented  projects: how to find  
the classes; how not to misuse i nheritance; the place of object -oriented analysis;  
fundamental design ideas (“patterns”); how to teach the method;  t h e  n e w  s o f t w a r e  
lifecycle. The result will, I hope, help you understand how bes t to take advantage of the  
techniques that we have now finished exploring.
It is appropriate, befo re going into the study of the rules, to  reflect on the role of  
methodology in software . This will be an opportunity to define meta-rules — rules on how  
to make rules — which will help us devise sound methodological advice and separate the  
best from the rest in the metho dological literature. In passing  we will devise a taxonomy  
of rules, finding out that certain  kinds are more desirable tha n others. Finally we will reflect  
on the attractive and dangerous role of metaphors , and take a short l esson in modesty.
19.1  SOFTWARE METHODOLOGY: WHY AND WHAT
People want guidance. The quest for Princip les of Truth, which one only has to follow to  
succeed, is neither new n or specific to software.
The software literature, includi ng for the past few years its o bject-oriented branch,  
has capitalized on this eagernes s and attempted to offer recipe s. This has resulted in much  
useful advice being made availab le (along with some more questi onable ideas). 
We must remember, however, that there is no easy path to qualit y software. Earlier  
chapters have pointed out several times that software construct ion is a challenging task. In  
the past few years our grasp of the issues has vastly improved,  as illustrated in particular by  
the techniques presented in this  book, but at the same time the  size and ambition of what we  
are trying to do has been growing even faster, so the problem r emains as difficult as it ever was.
It is important, then, to know t he benefits and limitations of software methodology.  
From the following cha pters and from the res t of the object-ori ented literature, you are  
entitled to expect good advice, and the benefit of other people ’s experience. But neither  
here nor there will you  find a sure-fire wa y to produce good so ftware.
A comparison made in an earlier ch apter helps set the limits of  what you can expect.  
In many respect, building a softw are system is similar to devel oping a mathematical theory.  
Mathematics, as software construc tion, can be taught, including  the general principles that  
help talented students produce br illiant results; but no teachi ng can guarantee success.
ON METHODOLOGY  §19.2 664
Not all recipe-style approaches are doomed. If you sufficiently  restrict the  
application domain until you are left with a basic set of probl em patterns, then it may be  
possible to define a teachable step-by-step process; this has o ccurred in some areas of  
business data processing, where methodologists have identified a small number of widely  
applicable solution schemes. The eventual fate of such schemes,  of course, is to be  
subsumed by software packages or reusable libraries. But as soo n as you open up the  
problem domain, no simplistic approach will work; the designer must exert his best powers  
of invention. A method will help through general guidelines, th rough the example of  
previous successful designs — also the example of what does not work — but not much  
more.
Keep these observations in mind both when reading part D and wh en going on to the  
methodology literature, where so me methods make exaggerated cla ims. That is not  
necessarily a reason for rejecting  them wholesale, as they may still include some useful  
advice; but they should be t aken with a grain of salt.
A point of terminology: it has be come customary in some of the literature to talk about  
specific “methodologies”, really m eaning methods (actually even  l e s s :  v a r i a n t s  o f  a  
single general method, the object-oriented method). This practi ce may be viewed as just  
another mildly irritating example of verbal inflation — such as  talking of repairmen as  
maintenance engineers — but is damaging since it leads readers to suspect that if the  label 
is inflated the contents must be oversold. This book only uses the word methodology in 
the singular and sticks to the meanings that common dictionarie s give for it: the study of  
methods; the “application of the principles of reasoning to sci entific and philosophical  
inquiry”; and a system of methods.
19.2  DEVISING GOOD RULES: ADVICE TO THE ADVISORS
Before going into specific rules for using object-oriented tech niques, it is necessary to ask  
ourselves what we should be looking for. The methodologist is e ntrusted with a serious  
responsibility: telling software developers how to write their software, and how not to write  
it. In a field where religious metaphors come up so often, it i s hard to avoid the comparison  
with preachers or directors of conscience. Such a position, as is well known, is subject to  
abuse; it is appropriate, then, to define a few rules on rules:  advice for the advisors.
The need for methodology guidelines
The field of software developmen t methodology is not new. Its o rigins may be traced to  
Dijkstra’s famous Go To Statement Considered Harmful letter and subsequent  
publications by the same author a nd his colleagues on structure d programming. But not  
all subsequent methodological wo rk has upheld their standards.
It is relatively easy indeed to legislate about software constr uction, but the danger is  
great of producing rules that ar e useless, poorly thought out, or even harmful. The  
following guidelines, based on an analysis of the role of metho dology in software, may  
help us avoid such pitfalls.[Dijkstra 1968] .
§19.2   DEVISING GOOD RULES: ADVICE TO THE ADVISORS 665
Theory
The first duty of an advisor is t o base his advice on a consist ent view of th e target area:
Dijkstra’s example is still a good guide here. He did not just attack the Goto  
instruction for reasons of taste  or opinion, but supported his suggested ban by a carefully  
woven chain of reasoni ng. One may disagree with some of that ar gument, but not deny  
that the conclusion is backed by  a well thought-out view of the  software development  
process. To counter Dijkstra’s v iew you must find a flaw in his  theory and provide your  
own replacement for that theory.
Practice
The theory is the deductive part of software methodology. But r ules that would only be  
rooted in theory could  be dangerous. The emp irical component is  just as important:
Perhaps one day someone will disp rove this principle by devisin g a brilliant and  
applicable method of software co nstruction through the sole pow er of abstract reasoning.  
In physics, after all, some of the most directly practical adva nces originated with  
theoreticians who never came close an experiment. But in softwa re engineering the case  
has not occurred — all the great  methodologists have also been programmers and project  
leaders on large developments — and seems unlikely to occur. Ob ject technology in  
particular is among ot her things, an intellectual tool to build  large and complex systems;  
the only approach, in fact, that has attempted consistently and  comprehensively to reach  
this goal. One can master the es sential concepts  through taking  classes, reading the  
literature, performing small-sca le experiments and thinking fur ther, but that is not  
preparation enough to give good m ethodological advice. The expe rience of playing a key  
role in the building of large sy stems — thousands of classes, h undreds of thousands of  
lines — is indispensable.
Such an experience must include all activities of the software lifecycle: analysis,  
design, implementation, and of c ourse maintenance (the final re ckoning, at which one  
recognizes whether the solution adopted at earli er stages stand s the test of time and  
change, or collap ses miserably).
Analysis experience, or even ana lysis and design experience, is  not enough. More  
than once I have seen analysis c onsultants who do their job, ch arge their fees, and leave  
the company with no more than “y y-bubbles and arrows” — an anal ysis document. The  Theoretical Basis  methodology principle
Software methodology rules must be based on a theory of the und erlying  
subject.
Practical Basis methodology principle
Software methodology rules should backed by extensive practical  experience.
ON METHODOLOGY  §19.2 666
company then has to pick up the pieces and do the hard work; so metimes the analyst’s  
work turns out to be totally useless as it has missed some of t he most important practical  
constraints. An “analysis only” approach belies the fundamental  ideas of seamlessness and 
reversibility , the integrated lifecycle that characterizes obj ect technology , where analysis  
and design are interwoven with i mplementation and maintenance. Someone who misses  
part of this picture is not equi pped to give met hodological adv ice.
Reuse
Having played a key part in some large projects is necessary bu t not sufficient. In the  
object-oriented field the Practi cal Basis precept yields a coro llary: the need for practical  
reusability experience. 
Among the distinctive properties of the method is its ability t o yield reusable  
components. No one can claim to be an expert who has not produc ed a reused  O-O library;  
not just components claimed to be reusable, but a library that has actually been reused by  
a substantial number of people ou tside of the ori ginal group. H ence the next precept:
A typology of rules
Next we should turn to the form of methodology rules. What kind  of advice is effective in  
software development methodology?
A rule may be advisory  (inviting you to follow a certain style) or absolute (enjoining  
you to work in a certain way); and it may be phrased in a positive  form (telling you what you  
should do) or in negative  form (telling you what you should not do). This gives four kin ds:
The requirements are sligh tly different in each case.
Absolute positives
Rules of the absolute positive k ind are the most useful for sof tware developers, since they  
provide precise and u nambiguous guidance.Reuse Experience  methodology principle
To claim expert status in the object-oriented field, one must h ave played a  
key role in the development of a  c l a s s  l i b r a r y  t h a t  h a s  s u c c e s s fully been  
reused by widely  different projects in widely different context s.
Classification of methodological rules
• Absolute positive: “Always do a”.
• Absolute negative: “Never use b”.
• Advisory positive: “Use c whenever possible”.
• Advisory negative: “Avoid d whenever possible”.
§19.2   DEVISING GOOD RULES: ADVICE TO THE ADVISORS 667
Unfortunately, they are also the  least common in the methodolog ical literature, partly  
for a good reason (for such preci se advice, it is sometimes pos sible to write tools that carry  
out the desired tasks automatically, removin g the need for meth odological intervention),  
but mostly because advisors are too cautious to commit themselv es, like a lawyer who  
never quite answers “yes” or “no ” to a question for fear of bei ng blamed for the  
consequences if his client does act on the basis of the answer.
Yet such rules are badly needed:
Absolute negatives
A b s o l u t e  n e g a t i v e s  a r e  a  s e n s i t i v e  a r e a .  O n e  w i s h e s  t h a t  e v e r y  methodologist who  
followed in Dijkstra’s footsteps had taken the same care to jus tify his negatives as Dijkstra  
did with the Goto. The following precept applies to such rules:
Advisories
Advisory rules, p ositive or negative, are fraught with the risk  of uselessness.
It is said that to d istinguish between a principle  and a platitude you must consider  
the negation of the property: on ly if it is a principle does th e negation still make sense,  
whether or not you agree with it . For example the often quoted software methodology  
advice “Use variable names that are meaningful” is a platitude,  not a principle, since no  
one in his right mind would sugg est using meanin gless variable names. To turn this rule  
into a principle, you must defin e precise standards for naming variables. Of course in so  
doing you may find that some read ers will disagree with those s tandards, which is why  
platitudes are so much more comfortable; but it is the role of a methodological advisor to  
take such risks.
Advisory rules, by avoiding abso lute injunctions, are particula rly prone to becoming  
platitudes, as especia lly reflected in quali fications of the fo rm “whenever possible ” or, for  
advisory negatives, “ unless you absolutely need to ”, the most dishonest formula in  
software methodology.
The next precept helps avoid t his risk by keeping us honest:Absolute Positives methodology principle
In devising methodolog ical rules, favor absolute positives, and  for each such  
rule examine whether it is possi ble to enforce the rule automat ically through  
tools or language constructs.
Absolute Negatives  methodology principle
Any absolute negative must be b acked by a precise explanation o f why the  
author considers the rejected mechanism bad practice, and accom panied by  
a precise description of how to substitute other mechanisms for  it.
ON METHODOLOGY  §19.2 668
H e r e  i s  a n  e x a m p l e  o f  a d v i s o r y  n e g a t i v e ,  e x t r a c t e d  f r o m  t h e  d i s cussion of type  
conversions ( casts ) in the C++ reference book:
Explicit type conversi on is best avoided . Using a cast suppresses the type checking  
provided by the compiler and will therefor e lead to surprises unless the programmer  
really was right .
This is accompanied by no explanation of how the programmer can  find out whether  
he “really was right  ”. So the reader is introduced to a certain language mechanism (type 
casts); warned, rightly, that it is dangerous and will “ lead to surprises ”; advised implicitly  
that the mechanism may sometimes be needed; but given no clue a s to how to spot the  
legitimate uses.
Such advice is essentially usel ess; more precisely, it has a negative  e f f e c t  —  
impressing on the reader that the tool being described, in this  case a programming  
language, is marred by areas of insecurity and uncertainty, and  should not be trusted at all.
Exceptions
Many rules have exceptions. But if you present a software metho dology rule and wish to  
i n d i c a t e  t h a t  i t  m a y  n o t  a l w a y s  a p p l y ,  y o u  s h o u l d  s a y  p r e c i s e l y  what cases justify  
exceptions. Otherwise the rule will be ineffective: each time a  developer runs into a  
delicate case (that is to say, each time he truly needs your ad vice), he will be entitled to  
think that the rule does not apply.
C o n s i d e r  t h e  f o l l o w i n g  p a r a g r a p h  f r o m  a n  a r t i c l e  a b o u t  s o f t w a r e  methodology,  
coming after the presentation of  a rather strict  set of rules:
The strict version of the class form of the Law of Deme ter is intended to be a  
guideline , not an absolute restriction . The minimization ve rsion of the law’s  
class form gives you a choi ce of how strongly you wa nt to follow the strict  
version of the law : the more nonpreferred ac quaintance classes you use , the 
less strongly you adhere  to the stri ct version . In some situations , the cost of  
obeying the strict version may be greater than the benefits .
It is difficult, after reading this extract, to decide how seri ous the authors are about  
their own rule; when should you apply it, and when is it OK to violate it?
What is wrong in not the presence  of exceptions in a general gu ideline. Because  
s o f t w a r e  d e s i g n  i s  a  c o m p l e x  t a s k ,  i t  i s  s o m e t i m e s  i n e v i t a b l e  ( although always  
undesirable) to add to an absolute positive “ Always do X in situation A ” or an absolute  
negative “ Never do Y in situation A ” the qualification “ except in cases B , C and D ”. Such  
a qualified rule remains an absolute positive or negative: simp ly, its domain of application  Advisory Rules methodology principle
I n  d e v i s i n g  a d v i s o r y  r u l e s  ( p o s i t i v e  o r  n e g a t i v e ) ,  u s e  p r i n c i p l es, not  
platitudes.
To help make the distinction, e xamine the rules’ negation.
From [Ellis 1990].
From 
[Lieberherr 1989] .
§19.2   DEVISING GOOD RULES: ADVICE TO THE ADVISORS 669
is not the whole of A, but A deprived of B, C and D. What is unacceptabl e, however, is the  
contrast between a precise, prescriptive rule, and a vague prov ision for exceptions (“ in 
some situations , the cost may be greater than the benefits ” — what situations?). Later in  
the cited article, an example is shown that violates the rule, but the exception is justified  
in terms of ad hoc arguments. It should have been part of the r ule:
If exceptions to a rule are included in the rule, they cease to  be exceptions to the rule! This  
is why the principle talks about the “guideline” associated wit h a rule. There may be  
exceptions to the guideline, but they are not exceptions to the  rule if the rule observes the  
above principle. In “ Cross the street only when the traffic lights are red , except if the  
lights are out of order ”, the guideline “cross only on red” has an exception, but the rule 
as a whole does not.
This principle turns e very rule of the form “Do this...” into a n absolute positive, and  
every rule of the form “Do not do that...” into an absolute neg ative.
Self-doubt is an admirable quali ty in many circumstances of lif e, but not one that we  
expect to find in software metho dology rules. One could almost argue that a wishy-washy  
methodologist is worse than a brilliant one who is occasionally  wrong. The wishy-washy  
advice is largely useless, as it  comes with so many blanket qua lifications that you are  
never sure if it applies to your case of the moment; whereas if  you study a methodological  
precept and decide that you disa gree with it, yo u must try to r efute the author’s arguments  
with your own, and regardless of  the outcome you will have lear ned something: either you  
fail, and gain a deeper, more personal appreciation of the rule  and its relevance to your  
problem; or you succeed, and discover th e rule’s limitations, g aining some insights that  
the rule’s author may have missed.
Abstraction and precision
A common theme of the last few pr inciples is that  methodologica l advice should be  
precise and directive.
T h i s  i s  o f  c o u r s e  m o r e  f u l l y  a p p l i c a b l e  f o r  p r e c i s e  r u l e s  t h a n  for general design  
guidelines. When lookin g for advice on how to discover the righ t classes or how to devise  
the best inheritance hierarchy, you cannot expect step-1-step-2 -step-3 recipes. 
But even then generality and abs traction do not necessarily mea n vagueness. Many  
of the principles of object-oriented design cover high-level is sues; they will not do your  
work for you. Yet they are precise enough to be directly applic able, and to allow deciding  
without ambiguity whether they  apply in any particular case.Exceptions Included methodology principle
If a methodological rule present s a generally ap plicable guidel ine which may  
suffer exceptions, the exception s must be stated as part of the  rule.
ON METHODOLOGY  §19.2 670
If it is baroque, fix it
The advice on C++ type casts quo ted earlier illu strates a gener al problem of advisory  
negatives: recommendations of this kind owe their existence to limitations of the  
underlying tool or language. For  a perfect tool we would never have to give advisory  
n e g a t i v e s ;  e v e r y  f a c i l i t y  w o u l d  b e  a c c o m p a n i e d  b y  a  c l e a r  d e f i n ition of when it is  
appropriate and when it is not — a criterion of t he absolute ki nd, not advisory. No tool is  
perfect, but for a decent one the number of advisory negatives should remain very small.  
If in teaching the proper use of  the tool you find yourself fre quently resorting to comments  
of the form “Try to stay away fr om this mechanis m unless you ab solutely need it”, then  
most likely the problem is what you are teaching about, not you r teaching of it.
In such a case one should abandon trying to give advice, and im prove the tool  
instead, or buil d a better one.
Typical phrases that sign al this situation are
... unless you know what you are doing .
... unless you absolutely have to .
Avoid ... if you can .
Try not to ...
It is generally preferable not to ...
Better stay away from ...
The C/C++/Java literature has a particular fondness for such fo rmulae. Typical is this  
advice: “ Don’t write to your data st ructure unless you have to ”, from the same C++ expert  
who in an earlier chapter was wa rning us against too much use o f O-O mechanisms.
This advice is puzzling. Why woul d developers write to a data s tructure for no reason?
Rampant Problem of Programmers Writing to Data Structures When They Don’t Have  
To Worries US Software Industry . Why do they do it ? Says Jill Kindsoul (not her real  
name ), a Senior Software Engineer in Santa Barbara , California : “My heart goes out to  
the poor things . It can feel so lonely out there in swap space ! I consider it my duty to write  
to each one of my objects’ fields at least once a day , even if it’s just with its own previous  
value . Sometimes I come back during the week-end just for it .” The actions of  
programmers like Jill are a growing concern for the principal software vendors , all 
rumored to have set up special task forces to deal with the issue .
Another case of trying to address  language flaws through method ological advice —  
making language users responsible for someone else’s errors — w as cited in an earlier  
chapter: the Java designers’ recommendation (“ a programmer could still mess up the  
object …”) against using direct field assignments a  x := y, in violation of basic information  
hiding principles. It is a surprising approach, if you think a construct is bad, and just  
happen to be designing a progra mming language, to  include the c onstruct any way and then  
write a book enjoining t he language’s future  users to avoid it.
The “Law of Demeter” cited earlier also provides an example. It  restricts the type of x, 
in a call x    f (...) appearing in a routine r of a class C, to: types of arguments of r; types of  
attributes of  C; creation types (types of u in create  u …) for creation instructions appearing  Advice from [Bright 
1995].  See page 515 .
(Imaginary media 
report .)
“A simple notion of 
book”, page 221 .
“Exceptions”, page 
668.
§19.3   ON USING METAPHORS 671
in r. Such a rule, if justified, should be made part of the languag e. But as the authors  
themselves imply in the quoted e xcerpt this would be too harsh.  The rule would make it  
impossible, for example, to write a call my_stack   item  some_routine applying some_routine  
to the topmost element of my_stack ; yet any alternative phrasing  is heavier an d less clear.
For the first few weeks after the initial design of the notatio n of this book, years ago,  
multi-dot calls of the form a  b  c were not supported. This limitation proved insufferable  
and we did not rest until it was removed.
Examination of the rationale for the Law , and for its exception s, suggests that the  
authors may not have considered the notion of selective export , through which one can  
export a feature of a class C to specific clients hav ing a close relation to C, while keeping  
it away from all other clients. With this mechanism, there may be no need for a Demeter-
like law.
These observations yield our last precept:
19.3  ON USING METAPHORS
ANDROMAQUE : 
I do not understa nd abstractions .
CASSANDRA : 
As you like . Let us resort to metaphors .
Jean Giraudoux, The Trojan  
War Will Not Happen , Act I.
In this meta-methodological discu ssion it is useful to reflect briefly on the scope and limits  
of a powerful exposito ry tool: metaphors.
Everyone uses metaphors — analog ies — to discuss and teach tech nical topics. This  
book is no exception, with such central metaphors as inheritanc e and Design by Contract.  
The name of our entire subject, indeed, is a metaphor: when we use the word “object” to  
talk about some computing concep t, we rely on a term loaded wit h everyday c onnections,  
which we hijack for a very specific purpose.
In scientific discourse metaphors are powerful, but they are da ngerous. This is  
particularly applicable  to software, and ev en more to software methodology.Fixing What Is Broken methodology principle
If you encounter the need for  many advisory negatives:
• Examine the supporting tool or la nguage to determine if this re flects 
deficiencies in  the underlying design.
• If so, consider the possibility of shifting over some of the ef fort from  
documenting that desig n to correcting it.
• Also consider the possibility of eliminating the problem altoge ther by  
switching to a better tool.“SELECTIVE EX-
PORTS AND INFOR-MATION HIDING”, 7.8, page 191
.
ON METHODOLOGY  §19.3 672
A colleague with whom I used to attend software engineering con ferences once swore  
that he would walk out the next time he heard an automotive com parison (“ if programs  
were like cars …”). Had he kept the pledge, he  would not have attended many tal ks.
Are metaphors good or bad? They can be very good, or very bad, depending on the  
purposes for which they are used.
Scientists use metaphors to guide  their research; many have rep orted how they rely  
on concrete, visual images to e xplore the most abstract concept s. The great mathematician  
Hadamard, for example, describes  the vivid images — clouds, red  balls colliding, “ a kind  
of ribbon, which is thicker or darker at the place corresponding to the possibly important  
terms ” of a mathematical series — to w hich he and his peers have res orted to solve  
difficult problems in the most a bstract realms of analysis and algebra.
Metaphors can be excellent teaching tools. The great scientist- expositors — the  
Einsteins, Feynmans, Sagans — ar e peerless in conveying difficu lt ideas by appealing to  
analogies with concept s from everyday’s expe rience. This is the  best.
B u t  t h e  w o r s t  a l s o  e x i s t s .  I f  w e  s t a r t  t a k i n g  m e t a p h o r s  a t  t h e i r face value, and  
deducing properties of the domai n under study from properties o f the metaphor, we are in  
serious trouble. A p seudo-syllogism (“ Proof by analogy ”) of the form
A resembles B
B has property p
Ergo : A has property p
is usually fallacious be cause the conclusion ( A has property p) is precise whereas the first  
premise ( A resembles B) is not. What matters is how exactly A is like B, and, even more,  
how A i s  unlike B; clearly some properties of B must be different from those of A, 
otherwise A and B would be the same thing (as in those stories by Borges or Pérec  in which  
a novel or painting is about its elf, or in the language that th e academicians of Laputa in  
Gulliver’s Travels devised from the observation that “ since words are only names for  
things , it would be more convenie nt for all men to carry abou t them such things as were  
necessary to express the particular  business they are to discourse on ”). A metaphor is  
defined by what differs as much a s by what is common. But then to justify the conclusion  
we have to check that p only involves the common part. O nce Hadamard had intuited his  
result, he knew he had to prove it step by s tep using the auste re rites of mathematics; and  
m an y  a s tu d e n t  o f  a  F e y n m a n  o r L a u r e n t  S ch w a rt z h as  re al i ze d ,  w hen faced with the  
week’s homework, that brilliant images are only the beginning o f the process.
The more alluring the metaphor, the greater the danger of falli ng into twisted  
reasoning of the above form. Thi nk for example of the analogy s o commonly used in the  
reusability literature, this boo k included, between software co mponents and the “chips” of  
our hardware colleagues, through such terms as “software IC” (c oined and trademarked  
by Brad Cox). Up to where do we use the metaphor to help us gai n insights, and where do  
we start con fusing the real thing A with the metaphor B?
Bachelard’s fascinating book on the Formation of the Scientific Mind , which shows  
some of the best minds of the eighteenth century struggling wit h the transition from  
magical modes of reasoning to th e scientific method, tells a st ory that anyone who is ever  
t e m p t e d  t o  u s e  a  m e t a p h o r  i n  s c i e n t i f i c  d i s c o u r s e  s h o u l d  k e e p  i n mind. In trying to  [Hadamard 1945] .
Swift , Gulliver’s 
Travels,  Part 3 , “A 
Voyage to Laputa , 
etc.”, chapter 5 .
[Bachelard 1960].
§19.4   THE IMPORTANCE OF BEING HUMBLE 673
understand the nature of air, the great physicist-philosopher R éaumur used the then  
common metaphor of a sp onge — which, as Bachelard shows, goes b ack at least to  
Descartes. Why not? Many good physics teachers occasionally res ort to such gimmicks to  
capture students’ attention and convey a point, supported or no t by a bit of clowning in the  
classroom or the TV studio. But then things start to go wrong: the sponge becomes  the air!
A very common idea is to consider air as being like cotton , like wool , like a  
sponge , and much more spongiou s even than any other b odies or collections of  
bodies to which th ey may be compared . This idea is particularly adequate to  
explain why air can also become extremely rarefied , and occupy a volume  
considerably bigger than  what we had seen it occupy a moment before .
Air is like a sponge, so air exp ands like a sponge! And now com es none other than  
Benjamin Franklin, who finds spon ges so convincing as to use th em to explain …
electricity. If matter is like a sponge, electric current must of course be like a liquid that  
flows through a sponge:
Common matter is a kind of sponge for the electric fluid . A sponge could not  
receive water if the parts which make up  the water were bi gger than the pores  
of the sponge ; it would only receive it very  slowly if there was no mutual  
attraction between its part s and the sponge’s parts ; the sponge would fill up  
faster if the mutual at traction between the water’ s parts did not create an  
obstacle , requiring that some force be applied to separate them ; finally , the 
filling up would be very fast if , instead of attraction , there was mutu al repulsion  
between the water’s parts , concurring with the sponge’s attraction . This is the  
precise situation with electric al matter and common matter .
Comments Bachelard: “ Franklin only thinks  in sponge terms . The sponge , for him ,
[has become ] an empirical category.” He adds, with a touch of mockery: “ Perhaps , in his  
youth , [Franklin]  had marveled at su ch a simple object [the sponge].  I have often surprised  
children being fascinated by the sight of a blotte r «drinking» ink” .
The Réaumur and Franklin quotations were not culled from a Usen et posting by an  
undergraduate who has yet to be taught to pour a few drops of i ntellectual rigor into his  
enthusiasm. They emanate from in tellectual giants  of their time , each of them responsible  
for decisive scientific advances. They should serve as a soberi ng influence when we  
discuss software concepts, and h elp us keep things in perspecti ve the next time we see an  
author getting a bit carried  away by his own analogies.
19.4  THE IMPORTANCE OF BEING HUMBLE
One final word of general advice  as we prepare to study specifi c rules of design. To produce  
great products, designers, even the best ones, should never ove restimate the value of their  
experience. Every ambitious soft ware project is a new challenge : there are no sure recipes.
The design of a large software pr oduct is an intellectual adven ture. Too much self-
confidence can hurt. The more bo oks you have read (or written),  the more classes you have  
taken (or taught), the more programming languages you know (or designed), the more O-O  
software you have examined (or p roduced), the mo re requirements  documents you have  Réaumur , in 
Memoirs of the [French ] Royal 
Academy of Sciences , 1731 . 
Quoted by Bachelard , p. 74.
B. Franklin , in 
“Experiences and observations on electricity , expressed 
in several letters to P .
Collinson of London’s Royal Society” . Translated 
back from the 1752 French text quoted in Bachelard , p. 77.
ON METHODOLOGY  §19.5 674
tried to decipher (or make deciph erable), the more design patte rns you have learned (or  
devised), the more design meeti ngs you have attended (or led), the more talented co-
workers you have met (or hired), the more projects you have hel ped (or managed), the  
better you will be equipped to deal with a new development. But  do not thi nk that your  
experience makes you infallible.  In advanced software design th ere is no substitute for  
fresh thinking and creative insigh ts. Every new problem calls f or new ideas; everyone, from  
the seasoned project leader to the latest recruit, can have the  right insight on any particular  
issue; and everyone can go wrong.  What distinguishes the great designer is not necessarily  
that he has fewer bad ideas, but that he knows how to discard t hem, swallow his pride, and  
retain the good ideas whether or not he originated them. Incomp etence and inexperience  
are obvious obstacles in the que st for the right solution; conc eit can be just as bad.
No one will be surprised by thes e comments who has heard (altho ugh not necessarily  
believed) Luciano Pavarotti stating that he faces stage fright every night. One of the reasons  
the best people are best is that  they are toughest with themsel ves. This rule is particularly  
r e l e v a n t  i n  s o f t w a r e  d e s i g n ,  w h e r e  t h e r e  i s  a l w a y s  t h e  r i s k  o f  lapsing into intellectual  
laziness and making easy but wro ng decisions, whi ch may later b e sorely regretted.
19.5  BIBLIOGRAPHICAL NOTES
The “advice to the advisors” pa rt of this chapter is based on [M 1995b] .
I first heard the definition of the difference between principl es and platit udes from a  
talk by Joseph Gurvets at TOOLS EUROPE 1992. I owe to Éric Beza ult the comment on  
the relevance of sel ective exports to th e Law of Demeter.
EXERCISES
E19.1  Self-applying the rules
Perform a critique of the methodo logical rules of this book in the light of the precepts of  
this chapter. The list of al l rules appears in Appendix C.
E19.2  Library rules
[M 1994a]  contains an extensive set of ru les, both design principles and  style standards,  
for building library c lasses. Perform a critique of these rules  in the light of the precepts of  
this chapter.
E19.3  Application of the rules
Examine the software methodology  book of your choice, and the r ules it gives, in the light  
of this chapter’s precepts.
E19.4  Metaphors on the Net
Follow for a week or two the disc ussions of objec t technology i n the Usenet newsgroup  
devoted to it, comp .object . Track the use of metaphors to talk about software concepts.  
Examine whether these metaphors are valuable, and whether any o f them leads its author  
to make improper “proof by analogy” inferences.
20  
Design pattern: multi-panel 
interactive systems
In our first example we will devi se a design pattern which, in a ddition to illustrating some  
typical properties of the object- oriented method, provides an e xcellent opportunity to  
contrast it with other  approaches, in partic ular top-down funct ional decomposition.
B e c a u s e  t h i s  e x a m p l e  n i c e l y  c a p t u r e s  o n  a  s m a l l  s c a l e  s o m e  o f  t he principal  
properties of object-oriented sof tware construction, I have oft en used it whe n requested to  
introduce an audience to the met hod in a few hou rs. By showing concretely (even to  
people who have had very little theoretical preparation) how on e can proceed from a  
c l a s s i c a l  d e c o m p o s i t i o n  t o  a n  O - O  v i e w  o f  t h i n g s ,  a n d  t h e  b e n e f its gained in this  
transformation, it serves as a remarkable pedagogical device. T his chapter has been  
written so that it could play th e same role for readers who hav e been directed to it by the  
reference they found in the “spoi ler” chapter at the beginning of this book.
To facilitate their task, it has been made as self-contained as  possible; this is why you  
will find a few repetitions with  previous chapte rs, in particul ar a few short definitions of  
concepts which you already know inside out if you have been rea ding this book  
sequentially and carefully from the start.
20.1  MULTI-PANEL SYSTEMS
The problem is to write a system covering a general type of int eractive system, common  
in business data processing, in which users are guided at each step of a session by a full-
screen panel, with pre defined transitions between the available  panels.
The general pattern is simple an d well defined. Each session go es through a certain  
number of states . In each state, a certain panel is displayed, showing question s to the user.  
The user will fill in the requir ed answer; this answer will be checked for consistency (and  
questions asked again until an a cceptable answer is found); the n the answer will be  
processed in some fashion; for e xample the system will update a  database. A part of the  
user’s answer will be a choice for the next step to perform, wh ich the system will interpret  
as a transition to ano ther state, whe re the same process will b e applied again. 
A typical example would be an ai rline reservation system, where  the states might  
represent such steps of the proc essing as User Identification, Enquiry on Flights (for a  
certain itinerary on a certain date), Enquiry on Seats (for a c ertain flight) and Reservation.
DESIGN CASE STUDY:  MULTI-PANEL INTERACTIVE SYSTEMS  §20.1 676
A typical panel, for the Enquiry on Flights state, might look l ike the following (only  
intended, however, to illustrate  the ideas, and making no claim  of realism or good  
ergonomic design). The screen is shown towards the end of a ste p; items in color italics
are the user’s answers, and items in bold color  show an answer displayed by the system. 
The session begins in an initial state, and ends whenever it re aches a final state. We  
can represent the overall structure by a transition graph showi ng the possible states and  
the transitions between them. Th e edges of the graph are labele d by integers  
corresponding to the p ossible user choices for the next step at  the end of a state. At the top  
of the facing page is a graph fo r a simple airline reservation system. 
The problem is to come up with a  design and implementation for such applications,  
achieving as much generality and flexibility as possible. In pa rticular:
G1  • The graph may be large. It is n ot uncommon to see applications  with several  
hundred states and corres pondingly many transitions.
G2  • The structure is subject to cha nge. The designers are unlikely  to foresee all the  
possible states and transitions.  As users start exercising the system, they will come  
up with requests for c hanges and additions.
G3  • Nothing in the given scheme is s pecific to the choice of appli cation: the airline  
reservation mini -system is just a workin g example. If your comp any needs a  
number of such systems, either for its own purposes or (in a so ftware house) for  
various customers, it will be a big benefit to define a general  design or, better yet,  
a set of modules that you can re use from application to applica tion.A panel– Enquiry on Flights –
Flight sought from: 
Departure on or after:To:
On or before: 
Preferred airline (s):
Special requirements:
A V AILABLE FLIGHTS: 1
Flt# AA 42 Dep 8:25 Arr 7:45 Thru: Chicago
Choose next action:
0 — Exit
1 — Help
2 — Further enquiry
3 — Reserve a seatSanta Barbara
21 NovParis
22 Nov
The figure also 
include state num-bers, for use later in 
the discussion .
§20.2   A SIMPLE-MINDED ATTEMPT 677
20.2  A SIMPLE-MINDED ATTEMPT 
Let us begin with a st raightforward, unsophisticated program sc heme. This version is  
made of a number of blocks, one f or each state of the system: BEnquiry  , BReservation , 
BCancellation  etc. A typical block (expressed  in an ad hoc notation, not the  object-oriented  
notation of this book although it retains s ome of its syntactic  conventions) looks like this: 
BEnquiry :
“Display Enquiry on flights panel”
repeat
“Read user’s answers and choice C for the next step”
if “Error in answer”  then  “Output appropr iate message”  end
until  not error in answer  end
“Process answer”
case C in
C0: goto Exit,
C1: goto BHelp,
C2: goto BReservation ,
…
end
and similarly for each state. Initial
Confirmation
ReservationEnquiry_
on_flights2
2
222
3
3
333
111111 1
1
Enquiry_
on_seatsHelp
Help
11
HelpHelpHelp
Help
111
2
345A transition 
diagram
DESIGN CASE STUDY:  MULTI-PANEL INTERACTIVE SYSTEMS  §20.3 678
This structure has something to speak for it: it is not hard to  devise, and it will do the  
job. But from a software engineer ing viewpoint it leaves much t o be desired.
The most obvious criticism is the presence of goto instructions (implementing  
conditional jumps similar to the switch  of C and the “Computed Go to” of Fortran), giving  
the control structure that unmis takable “spaghetti bowl” look.
But the gotos are the symptom, not the real flaw. We have taken the superfi cial 
structure of the problem — the current form of the transition d iagram — and hardwired it  
into the algorithm; the branchi ng structure of the program is a n exact reflection of the  
structure of the transition grap h. This makes the software’s de sign vulnerable to any of the  
simple and common changes cited above: any time someone asks us  to add a state or  
change a transition, we will have to change the system’s centra l control structure. And we  
can forget, of course, any hope o f reusability across applicati ons (goal G 3 in the above  
list), as the control st ructure would have t o cover all applica tions.
This example is a sobering reminder that we should never get ca rried away when we hear  
about the benefits of “modeling the real world” or “deducing th e system from the analysis  
of the reality”. Depending on how  you describe it, the real wor ld can be simple or messy;  
a bad model will give bad software. What counts is not how clos e the software is to the  
real world, but how good the description is. More on this topic  at the end of this chapter.
To obtain not just a system but a good system we must think a l ittle harder.
20.3  A FUNCTIONAL, T OP-DOWN SOLUTION
Repeating on this particular example the evolution of the progr amming species as a whole,  
we will go from a low-level goto-based structure to a  top-down, hierarchically organized  
solution, analyze its own limitat ions, and only then move on to  an object-oriented version.  
The hierarchical solut ion belongs to a gene ral style also known  as “structured”, although  
this term should b e used with care.
For one thing, an O-O solution is certainly structured too, alt hough more in the sense of  
“structured programming” as originally introduced in the sevent ies by Dijkstra and others  
than relative to the quite distinct notion of “structured desig n”.
The transition function
The first step towards improving the solution is to get rid of the central role of the traversal  
algorithm in the software’s stru cture. The transition diagram i s just one property of the  
system and it has no reason to rule over everything else. Separ ating it from th e rest of the  
algorithm will, if nothi ng else, rid us of the goto instructions. And we should also gain  
generality, since the transition diagram depends on the specifi c application, such as airline  
reservation, whereas i ts traversal may be described generically . 
What is the transition diagram? Abstractly, it is a function transition  t a k i n g  t w o  
arguments, a state and a user choice, such that transition (s, c) is the state obtained when  
the user chooses c when leaving state s. Here the word “function” is used in its  
§20.3   A FUNCTIONAL, TOP-DOWN SOLUTION 679
mathematical sense; at the softw are level we can choose to impl ement transition  either by  
a function in the software sense (a routine returning a value) or by a data structure such as  
an array. For the moment we can afford to postpone the choice b etween these solutions  
and just rely on transition  as an abstract notion. 
In addition to the function transition  we also need to designate one of the states, say  
state initial , as the place where all sessions  start, and to designate one o r more states as  
final through a boole an-valued function is_  final. Again this is a function in the  
mathematical sense, regardless of its eventual implementation.
We can picture the transition  function in tabular form, with rows representing states  
and columns representing choices, as shown below.
Conventions used in this table: there is just one Help  state, 0, with a special transition  
Return  which goes back to the state from which Help  was reached, and just one final state,  
–1. These conventions will not  be necessary for the rest of the discussion but help keep  
the table simple.  
The routine architecture
Following the traditional precepts of top-down decomposition, w e choose a “top” (the  
main program) for our system. Th is should clearly be the routin e execute_session that 
describes how to execute a com plete interactive session. Choice →
↓ State0 1 2 3
1 (Initial ) –1 0 5 2
2 (Flights ) 0 1 3
3 (Seats ) 0 2 4
4 (Reserv .) 0 3 5
5 (Confirm ) 0 4 1
0 (Help ) Return
–1 (Final )A transition 
table
DESIGN CASE STUDY:  MULTI-PANEL INTERACTIVE SYSTEMS  §20.3 680
Immediately below (level 2) we w ill find the operations relativ e to states: definition  
of the initial and final states, transition structure, and execute_state  which prescribes the  
actions to be executed in each st ate. Then at the lowest level (1) we will find the  
constituent operations of execute_state : display a screen and so on. Note how such a  
solution may be described, as we ll as anything ob ject-oriented that we may later see, to  
“reflect the real world”: the str ucture of the software perfect ly mirrors the structure of an  
application, which involves stat es, which involve elementary op erations. Real-
worldliness is not, in this example and many others, a signific ant difference between O-O  
and other approaches; what counts is how we model the world.
In writing execute_session  let us try to make it as application-independent as  
possible. (The routine is again e xpressed in an ad hoc notation  imitated from the O-O  
notation of the rest of this book. The repeat  … until … loop is borrowed from Pascal.) 
execute_session
-- Execute a complet e session of the interactive system
local
state , choice : INTEGER
do
state  := initial
repeat
execute_state (state , →next)
-- Routine execute_state updates the value of next.
state  := transition (state , next )
until  is_ final (state ) end
endexecute_session
initial transitionexecute_
stateis_final
display process message correct readLevel 1Level 3
Level 2Top-down 
functional decomposition
§20.3   A FUNCTIONAL, TOP-DOWN SOLUTION 681
This is a typical transition diagram traversal algorithm. (The reader who has written  
a lexical analyzer will recognize  t h e  p a t t e r n . )  A t  e a c h  s t a g e  w e are in a state  state , 
originally set to initial ; the process terminates when state  satisfies is_ final. For a non-final  
state we execute execute_state , which takes the current state and returns the user’s  
transition choice through  its second argument next, which the function transition uses,  
together with state , to determine the next state.
The technique using a procedure execute_state  that changes the value of one of its  
arguments would never be appropr iate in good O-O design, but he re it is the most  
expedient. To signal it clearly,  the notation flags an “out” ar gument such as next with an  
arrow →. Instead of a procedure which m odifies an argum ent, C develope rs would make  
execute_state a side-effect-producing function called as next := execute_state (state ); we 
will see that this practice is subject to criticism too.
Since execute_state does not show any information ab out any particular interactive  
application, you must fill in the applicatio n-specific properti es appearing on level 2 in the  
figure: transition  function; initial  state; is_ final predicate. 
To complete the design ,  w e  m u s t  r e f i n e  t h e  execute_state routine describing the  
actions to be performed in each state. Its body is essentially an abstracted form of the  
contents of the successiv e blocks in the initial goto-based version: 
execute_state (in s: INTEGER ; out c: INTEGER )
-- Execute the act ions associate d with state s,
-- returning into c the user’s choice f or the next state.
local
a: ANSWER ; ok: BOOLEAN
do
repeat
display (s)
read (s, →a)
ok := correct (s, a)
if not ok then  message (s, a) end
until  ok end
process (s, a)
c := next_choice (a)
end
This assumes level 1 routines with the following roles:
•display (s) outputs the panel as sociated with state s. 
•read (s, →a) reads into a the user’s answer to the display panel of state s. 
•correct (s, a) returns true if and only if a is an acceptable answer to the question  
displayed in state s; if so, process (s, a) processes answer a, for example by updating  
a database or displaying more information; if not, message (s, a) outputs the relevant  
error message. The → notation is a 
temporary conven-tion, used only for this 
particular procedure and for read below .
DESIGN CASE STUDY:  MULTI-PANEL INTERACTIVE SYSTEMS  §20.4 682
The type ANSWER  of the object representing the user’s answer has not been refi ned 
further. A value a of that type globally represents  the input entered by the user in a given  
state; it is assumed to include the user’s choice for the next step, written next_choice (a). 
(ANSWER  is in fact already very much lik e a class, even though the res t of the architecture  
is not object-oriented at all.) 
To obtain a working application , you will need to fill in the v arious level 1 features:  
display , read, correct , message  and process .
20.4  A CRITIQUE OF THE SOLUTION
Have we now a satisfactory solution? Not quite. It is better th an the first ver sion, but still  
falls short of our goals of ex tendibility a nd reusability.
Statism
Although on the surface it seems  we have been able to separate the generic from the  
application-specific, in reality the various modules are still tightly coupled with each other  
and with the choice of application. The main problem is the dat a transmission structure of  
the system. Consider the signature s (argument and result types)  of the routines: 
execute_state ( in s: STATE  ; out c: CHOICE )
display ( in s: STATE  )
read ( in s: STATE  ; out a: ANSWER )
correct ( in s: STATE  ; a: ANSWER ): BOOLEAN
message ( in s: STATE  ; a: ANSWER )
process ( in s: STATE  ; a: ANSWER )
The observation (which sounds lik e an economist’s lament) is th at the role of the  
state is too pervasive. The current state appears under the nam e s as an argument in all the  
routines, coming f rom the top module execute_session , where it is known as state . So the  
hierarchical structure shown in t he last figure, seemingly simp le and manageable, is a lie,  
or more precisely a façade. Behi nd the formal elegance of the f unctional decomposition  
lies a jumble of data transmissio n. The true picture, shown at the top of the facing page,  
must involve the data.
The background for object technol ogy, as presented at the begin ning of this book, is  
the battle between the function  and data (object)  aspects of software systems for control  
of the architecture. In non-O-O approaches, the functions rule unopposed ove r the data;  
but then the data ta ke their revenge.
The revenge comes in the form of sabotage. By attacking the ver y foundations of the  
architecture, the data make the system impervious to change — u ntil, like a government  
unable to handle its perestroika , it will crumble under its own weight.State
intervention
The architectural 
figure is on page 680.
§20.4   A CRITIQUE OF THE SOLUTION 683
In this example the subversion of the structure comes in partic ular from the need to  
discriminate on states. All the level 1 routines must perform d ifferent actions depending  
on s: to display the panel for a certain state; to read and interpr et a user answer (made of  
a number of input fields, differe nt for each state); to determi ne whether the answer is  
correct; to output the proper erro r message; to process a corre ct answer — you must know  
the state. The routines will per form a discrimination of the fo rm
inspect
s
when Initial then
…
when Enquiry_on_  flights then
…
…
end
This means long and complex contro l structures and, worse yet, a fragile system:  
any addition of a state will require changes throughout the str ucture. This is a typical case  
of unbridled knowledge distribution: far too many modules of th e system rely on a piece  
of information — the list of all possible states — which is sub ject to change.
The situation is in fact even worse than it appears if we are h oping for general  
reusable solutions. There is an extra implicit argument in all the routines considered so  
far: the application  — airline reservation or anything else we are building. So to make 
routines such as display truly general we would have to l et them know about all states o f 
all possible applications in a gi ven computing environment! Fun ction transition  would  
similarly contain the transition  graph for all applications. Th is is of course unrealistic. execute_session
initial transitionexecute_
stateis_final
display process message correct readLevel 1Level 3
Level 2
state
state
statestatestateThe flow of 
data
DESIGN CASE STUDY:  MULTI-PANEL INTERACTIVE SYSTEMS  §20.5 684
20.5  AN OBJECT-ORIENTED ARCHITECTURE
The very deficiencies of top-dow n functional decomposition poin t to what we must do to  
obtain a good object-oriented version.
The law of inversion 
What went wrong? Too much data transmission in a software archi tecture usually signals  
a flaw in the design. The remedy , which leads directly to objec t-oriented design, may be  
expressed by the following design rule:
Instead of building modules around operati ons (such as execute_session and 
execute_state ) and distributing the data struc tures between the resulting ro utines, with all  
the unpleasant consequences tha t we have seen, object-oriented design does the reverse: it  
uses the most important data types as the basis for modularizat ion, attaching each routine  
to the data type to which it relates most closely. When objects  take over, their former  
masters, the functions, become their vassals.
The law of inversion is the key to obtaining an object-oriented  design from a  
classical functional (procedural) decomposition, as in this cha pter. Such a need arises in  
cases of reverse-engineering  an existing non-O-O system to make it more maintainable  
and prepare its evolution; it is  also frequent in teams that ar e new to object-oriented design  
and think “func tional” first.
It is of course best to design i n an object-oriented fashion fr om the beginning; then  
no inversion is needed. But the law of inversion is useful beyo nd cases of reverse-
engineering and novice  developers. Even someone who has been ex posed to the  
principles of object-oriented so ftware construction may come up  with an initial design  
that has pockets of functional d ecomposition in an object lands cape. Analyzing data  
transmission is a good way to detect and correct such design fl aws. If you see — even in a  
structure intended as O-O — a da ta transmission pattern similar  to what happens with  
states in the example of this chapter, it should catch your att ention. Probing further will in  
most cases lead you to the discovery of a data abstraction that  has not received its proper  
due in the software’s architecture.
State as a class
The “state” example is typical. Such a data type, appearing so pervasively in the data  
transmissions between routines, i s a prime candidate for servin g as one of the modular  
components of an object-oriented  architecture, which must be ba sed on classes  (abstractly  
described data types).Law of inversion
If your routines exchange too ma ny data, put you r routines in y our data. 
§20.5   AN OBJECT-ORIENTED ARCHITECTURE 685
The notion of state was important in the original problem state ment, but in the  
functional architecture that imp ortance was lost: the state was  just represented by a  
variable, passed from routine to routine as if it were some kin d of lowlife. We have seen  
how it avenged itself. Now we are ready to give it the status i t deserves. STATE  should be  
a class, one of the principals i n the structure of our new obje ct-oriented system.
In that class we will find all th e operations that characterize  a state: displaying the  
corresponding screen ( display ), analyzing a user’s answer ( read), checking the answer  
(correct ), producing an error message for an incorrect answer ( message ), processing a  
correct answer ( process ). We must also include execute_state , expressing the sequence of  
actions to be performed whenever  the session reaches a given st ate; since the original  
name would be over-qualifying in a class called STATE , we can replace it by just execute .
Starting from the original top-down functional decomposition pi cture, we can  
highlight the set of  routines that should  be handed over to STATE : 
The class will have the following form:
… class STATE  feature
input : ANSWER
choice : INTEGER
execute do … end
display …
read …
correct : BOOLEAN …
message …
process …
endSTATE
featuresexecute_session
initial transitionexecute_
stateis_final
display process message correct readLevel 1Level 3
Level 2
STATE
DESIGN CASE STUDY:  MULTI-PANEL INTERACTIVE SYSTEMS  §20.5 686
Features input and choice  are attributes; the others are routines. Compared to their  
counterparts in the functional de composition, the  routines have  lost their explicit state  
arguments, although the state wil l reappear in calls made by cl ients, such as s  execute .
In the previous approach, execute (formerly execute_state ) returned the user’s  
choice for the next step. But su ch a style violates principles of good design. It is preferable  
to treat execute as a command, whose exe cution determines the result of the quer y “what  
c h o i c e  d i d  t h e  u s e r  m a k e  i n  t h e  last state?”, available through  t h e  a t t r i b u t e  choice . 
Similarly, the ANSWER  argument to the level 1 routines is now replaced by the secret  
attribute input . The reason is information hidin g: client code does not need t o look at  
answers except through the interface provided by the exported f eatures. 
Inheritance and deferred classes
Class STATE  does not describe a particular state, but the general notion o f state. Procedure  
execute  is the same for all states, but the other routin es are state-s pecific. 
Inheritance and deferred classes ideally address such situation s. At the STATE  level,  
we know the procedure execute in full detail and the att ributes. We also know the  
existence of the level 1 routines ( display  e t c . )  a n d  t h e i r  s p e c i f i cations, but not their  
implementations. These routines should be deferred; class STATE , which describes a set  
of variants, rather than a fully spelled out abstraction, is it self a deferred cl ass. This gives: 
note
description : "States for interactive panel-driven applications "
deferred  class
STATE
feature  -- Access
choice : INTEGER
-- User’s choice for next step
input : ANSWER
-- User’s answer to questio ns asked in this state.
feature  -- Status report
correct : BOOLEAN
-- Is input a correct answer?
deferred
end
feature  -- Basic operations
display
-- Display panel a ssociated with c urrent state.
deferred
endSee “SIDE 
EFFECTS IN FUNCTIONS”, 23.1, page 748 .
§20.5   AN OBJECT-ORIENTED ARCHITECTURE 687
execute
-- Execute actions  associated with  current state
-- and set choice to denote use r’s choice for next state.
local
ok: BOOLEAN
do
from ok := False  until ok loop
display ; read ; ok := correct
if not ok then message end
end
process
ensure
ok
end
message
-- Output error messag e corresponding to input .
require
not correct
deferred
end
read
-- Obtain user’s answer into input and choice into next_choice .
deferred
end
process
-- Process  input .
require
correct
deferred
end
end
T o  d e s c r i b e  a  s p e c i f i c  s t a t e  y o u  w i l l  i n t r o d u c e  d e s c e n d a n t s  o f  STATE providing  
effectings (implementations) of the deferred features:It is easy to remove 
the test from within the loop for better efficiency .
State class 
hierarchy STATE
INITIALRESER-
VATIONCONFIR-MATION∗
… 
DESIGN CASE STUDY:  MULTI-PANEL INTERACTIVE SYSTEMS  §20.5 688
An example would look like: 
class ENQUIRY_ON_FLIGHTS  inherit
STATE
feature
display
do
… Specific display procedure …
end
… And similarly for read, correct , message  and process  …
end
This architecture separates, at the exact grain of detail requi red, elements common to  
all states and elements specific to individual states. The comm on elements, such as  
procedure execute , are concentrated in STATE  and do not need to be redeclared in  
descendants such as ENQUIRY_ON_FLIGHTS . The Open-Closed prin ciple is satisfied:  
STATE  is closed in that it is a well-defined, compilable unit; but i t is also open, since you  
can add any number of descendants at any time. 
STATE  is typical of behavior classes  — deferred classes capturing the common  
behavior of a large number of pos sible objects, implementing wh at is fully known at the  
most general level ( execute ) in terms of what depends on each variant. Inheritance and  
the deferred mechanism are essen tial to capture such behavior i n a self-contained  
reusable component.
Describing a complete system
To complete the design we must s till take care of managing a se ssion. In the functional  
decomposition this was the task of procedure execute_session , the main program. But now  
we know better. As discussed in an earlier chapter, the “topmos t function of a system” as  
posited in the top-down method is mythical. A large software sy stem performs many  
equally important functions. Here  again, the abstract data type  approach is more  
appropriate; it consid ers the system, taken  as a whole, as a se t of abstract objects capable  
of rendering a certain  number of services. 
We have captured one key abstraction: STATE  (along with ANSWER ). What  
abstraction is our design still missing? Central in the underst anding of the problem is the  
notion of APPLICATION , describing specific interacti ve systems such as the airline  
reservation system. This  will yield a new class.
It turns out that the remaining components of the functional de composition, shown  
in the figure, are all features of an application and will find  their true calling as features of  
class APPLICATION :
•execute_session , describing how to execute an ap plication. Here the name will be 
simplified to execute  since the enclosing class provi des qualification enough (and  
there is no possible confusion with execute  of STATE ).“Don’t call us, we’ll 
call you”, page 504.
“Finding the top”, 
page 107 .
§20.5   AN OBJECT-ORIENTED ARCHITECTURE 689
•initial  and is_ final, indicating which states have special status in an application . Note  
that it is proper to have these features in APPLICATION  rather than STATE  since  
they describe properties of appl ications rather than states: a state is not initial or final  
per se, but only with respect to an application. (If we reuse s tates between  
applications, a state may well be  final in a certain applicatio n but not in another.)
•transition  to describe the transition between states in the application.
The components of the functional decomposition have all found a  place as features  
of the classes in the O-O decomposition — some in STATE , some in APPLICATION . This 
should not surprise us. Object technology, as has been repeated ly emphasized in this book,  
is before anyt hing else an architectural mechanism, primarily affe cting how we organize  
software elements into coherent structures. The elements themse lves may be, at the lowest  
level, the same ones that you wo uld find in a non-O-O solution,  or at least similar (data  
abstraction, information hiding, assertions, inhe ritance, polym orphism and dynamic  
binding help make th em more simple, general and powerful).
A panel-driven system of the kin d studied in this chapter will always need to have  
operations for traversing the application graph ( execute_session , now execute ), reading  
user input ( read), detecting final states ( is_ final). Deep down in the structure, then, we will  
find some of the same building blocks regardless of the method.  What changes is how you  
group them to produce a modular architecture.
Of course we do not need to limi t ourselves to f eatures that co me from the earlier  
solution. What for the functional  decomposition was the end of the process — building  
execute  f o r  a p p l i c a t i o n s  a n d  a l l  t h e  o t h e r  m e c h a n i s m s  t h a t  i t  n e e d s  —  i s  n o w  j u s t  a  
beginning. There  are many more things we may want to do on an a pplication: execute_session
initial transitionexecute_
stateis_final
display process message correct readLevel 1Level 3
Level 2
STATEAPPLICATIONSTATE  and 
APPLICATION
features
DESIGN CASE STUDY:  MULTI-PANEL INTERACTIVE SYSTEMS  §20.5 690
• Add a new state. 
• Add a new transition. 
• Build an application (by repeat ed application of the preceding  two operations). 
• Remove a state, a transition. 
• Store the complete application,  its states and transitions, in to a database. 
• Simulate the application (for e xample on a line-oriented displ ay, or with stubs  
replacing the routines of class STATE , to check the transitions only). 
• Monitor usage of the application. 
All these operations, and others , will yield features of class APPLICATION . They  
are no less and no more importan t than our former “main program ”, procedure execute , 
now just one of the features of the class, inter pares  but not even primus . By renouncing  
the notion of top, we make r oom for evolution and reuse.
The application class
To finish class APPLICATION here are a few possible im plementation decisions: 
• Number states 1 to n for the application. Note that these numbers are not absolute  
properties of the states, but only relative to a certain applic ation; so there is no “state  
number” attribute in class STATE . Instead, a one-dimensional array associated_state , 
an attribute of APPLICATION , yields the state associat ed with a given number.
•R e p r e s e n t  t h e  transition  function by another attribute, a two-dimensional array of  
size n  × m, where m is the number of poss ible exit choices. 
• The number of the initial sta te is kept in the attribute initial and set by the routine  
choose_initial . For final states we can use th e convention that a transition to pseudo-
state 0 denotes sess ion termination. 
• The creation procedure of APPLICATION  uses the creation procedures of the library  
classes ARRAY  and ARRAY2 . The latter describes two-dimensional classes and is  
patterned after ARRAY ; its creation procedure make  takes four arguments, as in  
create  a  make (1, 25, 1, 10), and its item and put routines use two indices, as in  
a  put (x, 1, 2). The bounds of a tw o-dimensio nal array a are a  lower1  etc. 
Here is the class resulti ng from these decisions: 
note
description : "Interactive panel-dr iven applications "
class  APPLICATION  creation
make
§20.5   AN OBJECT-ORIENTED ARCHITECTURE 691
feature -- Initialization
make (n, m: INTEGER )
-- Allocate application with n states and m possible choices.
do
create  transition   make (1, n, 1, m)
create  associated_state   make (1, n)
end
feature -- Access
initial : INTEGER  
-- Initial state’s number
feature -- Basic operations
execute
-- Perform a user session
local
st: STATE ; st_number : INTEGER
do
from
st_number  := initial
invariant
0 <= st_number ; st_number <= n
until  st_number = 0 loop
st := associated_state   item (st_number )
st  execute
-- This refers to the execute  procedure of STATE
-- (see next page for comment s on this key instruction).
st_number  := transition   item (st_number , st  choice )
end 
end
feature -- Element change
put_state (st: STATE ; sn: INTEGER )
-- Enter state st with index sn.
require
1 <= sn; sn <= associated_state   upper
do
associated_state   put (st, sn)
end
choose_initial (sn: INTEGER )
-- Define state number sn as the initial state.
require
1 <= sn; sn <= associated_state   upper
do
initial  := sn
end
DESIGN CASE STUDY:  MULTI-PANEL INTERACTIVE SYSTEMS  §20.5 692
put_transition (source , target , label : INTEGER )
-- Enter transition labeled label  
-- from state number source  to state number target .
require
1 <= source ; source <= associated_state   upper
0 <= target ; target <= associated_state   upper
1 <= label ; label <= transition   upper2
do
transition   put (source , label , target )
end 
feature {NONE } -- Implementation
transition : ARRAY2 [STATE ]
associated_state : ARRAY [STATE ]
… Other features …
invariant
transition   upper1 = associated_state   upper
end
Note how simply and elegantly th e highlighted call on the prece ding page,  
st  execute , captures some of the problem’s  essential seman tics. The featu re called is  
execute  from STATE ; although effective because it describes a known general behav ior, 
execute  relies on deferred features read, message , correct , display , process , deferred at the  
level of STATE  and effected only in its proper descendants such as RESERVATION . When  
we place the call st  execute  in APPLICATION ’s own execute , we have no idea what kind  
of state st denotes — although we do know that it is a state (this is the benefit of static  
typing). To come to life, the instruction needs the machinery o f dynamic binding: when st
becomes attached at run time to a state object of a particular kind, say RESERVATION , 
calls to read, message  and consorts will automaticall y trigger the right version.
The value of st is obtained from associat ed_state , a polymorphic data structure
which may contain objects  of different types, all conforming to STATE . Whatever we find  
at the current index st_number  will determine the ne xt state operations.
A polymorphic 
array of states
Instance of RESERVATION
Instance of RESERVATIONInstance of CONFIRMATIONInstance of HELP
associated_statest_number
1
§20.6   DISCUSSION 693
Here is how you build an interact ive application. The applicati on will be represented  
by an entity, say air_reservation , declared of type APPLICATION . You must create the  
corresponding object:
create  air_reservation   make (number_of_states , number_of_possible_choices )
You will separately define and cr eate the application’s states as entities of descendant  
types of STATE , either new or reused from a state library. You assign to each  state s a 
number i for the application: 
air_reservation   put_state (s, i).
You choose one of the stat es, say the state numbered i0, as initial: 
air_reservation   choose_initial (i0)
To set up a transition from state number sn to state number tn, with label l, you use
air_reservation   put_transition (sn, tn, l )
This includes exit transitions, for which tn is 0 (the default). You may now execute  
the application:
air_reservation   execute_session . 
During system evolution you may at any time use the same routin es to add a new  
state or a new transition.
It is of course possible to extend class APPLICATION , either by chan ging it or by  
adding descendants, to accommodate  more features such as deleti on, simulation, or any of  
the others mentioned in the c ourse of the presentation. 
20.6  DISCUSSION
This example provides a striking picture of the differences bet ween object-oriented  
software construction and earlie r approaches. It shows in parti cular the benefi ts of getting  
rid of the notion of main program. By focusing on the data abst ractions and forgetting, for  
as long as possible, what is “the” main function of the system,  we obtain a structure that  
is much more likely to lend itse lf gracefully to future changes  and to reuse across many  
different variants.
This equalizing effect is one of  the characteristic properties of the method. It takes  
some discipline to apply it cons istently, since it means resist ing the constant temptation to  
ask: “What does the system do?”.  This is one of the skills that  sets the true object-oriented  
professional from people who (al though they may h ave been using  O-O techniques and an  
O-O language for a while) have n o t  y e t  d i g e s t e d  t h e  m e t h o d ,  a n d  will still produce  
functional architectures b ehind an object façade.
We have also seen a heuristic that is often useful to identify key abstractions in an  
object-oriented ( to “find the objects”, or  rather the classes, the topic of a subsequent  
chapter): analyzing data transmi ssions and being  on the lookout  for notions that show up  
DESIGN CASE STUDY:  MULTI-PANEL INTERACTIVE SYSTEMS  §20.7 694
in communications between numerous  components of a system. Ofte n this is an indication  
that the structure should be turn ed upside down, the routines b ecoming attached to the data  
abstraction rather than the reverse.
A final lesson of this chapter i s that you should be wary of at taching too much  
importance to the notion that ob ject-oriented systems are direc tly deduced from the “real  
world”. The modeling power of th e method is indeed impressive, and it is pleasant to  
produce software architectures whose principal components direc t l y  r e f l e c t  t h e  
abstractions of the external sys tem being modeled. But there ar e many ways to model the  
real world, and not all of them will lead to a good system. Our  first, goto-filled version  
was as close to the re al world as the other two — closer actual ly, since it is directly  
patterned after the structure of  t h e  t r a n s i t i o n  d i a g r a m ,  w h e r e a s the other two require  
introducing intermediate concepts . But it is a so ftware enginee ring disaster.
I n  c o n t r a s t ,  t h e  o b j e c t - o r i e n t e d  decomposition that we finally produced is good  
because the abstractions that it uses — STATE , APPLICATION , ANSWER  — are clear,  
general, manageable, change-ready, and reusable across a broad application area.  
Although once you understand the m they appear as real as anythi ng else, to a newcomer  
they may appear less “natural” (that is to say, less close to a n informal perception of the  
underlying reality) than the concepts used in the inferior solu tions studied first.
To produce good software, what counts is not how close you are to someone’s  
perception of the real world, bu t how good are the abstractions  that you choose both to  
model the external systems and t o structure your own software. This is indeed the very  
definition of object-oriented analysis, design and implementati on, the task that you will  
have to execute well, day in and day out, to make  your project succeed, and the skill that  
distinguishes object experts from object amateurs: finding the right abstractions .
20.7  BIBLIOGRAPHICAL NOTE
Variants of the example discusse d in this chapter were used to illustrate object-oriented  
concepts in [M 1983]  and [M 1987] .
21  
Inheritance case study:   “undo” 
in an interactive system
For our second design example we examine a need that confronts t he designers of almost  
any interactive system: how to p rovide a way to undo commands.
The discussion will show how inheritance and dynamic binding yi eld a simple,  
regular and general solution to an apparently intricate and man y-faceted problem; and it  
will teach us a few general lessons about the issues and princi ples of object-oriented design.
21.1  PERSEVERARE DIABOLICUM
T o err is human, it is said, but to foul things up for good tak es a computer (aided, one  
should add, by humans). The fast er and more powerful our intera ctive systems become,  
the easier it becomes to make them perform actions that we do n ot really want. This is why  
we all wish for a way to erase the recent past; not the “big re d button” of computer jokes,  
but a Big Green Button that we c an push to prete nd that we did not do someth ing that we  
did but wish we did not. 
Undoing for fun and profit
In an interactive system, the eq uivalent of the Big Green Butto n is an Undo operation,  
which the system’s designer has provided for the benefit of any  user who, at some stage  
in a session, wants to cancel the  effect of the l ast executed c ommand.
The primary aim of an undo mechan ism is to allow users to recov er from potentially  
damaging input mistakes. It is al l too easy to type the wrong c haracter or click on “OK”  
instead of “Cancel”. But a good undo facility goes further. It frees users from having to  
concentrate nervously on every ke y they type and button they cl ick. Beyond this, it  
encourages a “ What if … ?” style of interaction in which users try out various sorts of  
input, knowing that th ey can back up easily  if the result is no t what they expect. 
Every good interactive system sho uld provide such a mechanism. When present, it  
tends to be one of the most freq uently used operations. (For th at reason, the makers of the  
computer on my desk have wisely provided an Undo key on the key board, although it is  
neither green nor particularly big. It is only effective, of co urse, for those regrettably few  
software applications whose a uthors took notice of it.)
INHERITANCE CASE STUDY: “UNDO”  IN AN INTERACTIVE SYSTEM  §21.1 696
Multi-level undo and redo
Offering an undo mechanism is better than not offering one, but  it is not enough. Most  
systems that provide Undo limit themselves to one level: you ca n only cancel the effect of  
the last command. If you never make two mistakes in a row, this  is enough. But if you ever  
go off in the wrong direction, an d wish you could go back sever al steps, you are in trouble.  
(Anyone having used Micr osoft Word, the Unix Vi editor or FrameMaker, in the releases  
available at the time this book was published, will know exactl y what I mean.)
There is really no excuse for th e restriction to one level of u ndoing. Once you have  
set up the undoing mach inery, going from one-level to multi-lev el undo is a simple matter,  
as we will see in this chapter. And, please (this is a potentia l customer speaking) do not,  
like so many application authors,  limit the number of commands that can be undone to a  
ridiculously small value; if yo u must limit it at all, let the user choose his own limit  
(through a “preferences ” setting that will a pply to all future sessions) and set default to at  
least 20. The overhead is small if you apply the techniques bel ow, and is well justified.
With multi-level undo, you will a lso need a Redo operation for users who get carried  
away and undo too much. With one -level undo no special Redo is required; the universally  
applied convention is that an Und o immediately following an Und o cancels it, so that  
Redo and Undo are the same opera tion. But this cannot work if y ou can go back more than  
one step. So we will have to treat  Redo as a separate operation .
Practical issues
Although undo-redo can be retro fitted with reasonable effort in to a well-written O-O  
system, it is best, if you plan to support this facility, to ma ke it part of the design from the  
start — if only because the solution encourages a certain form of software architecture (the  
use of command classes ) which, although bene ficial in other respects, does not necess arily 
come to mind if you do not need undoing.
To make the undo-redo mechanism practical you will have to deal  with a few  
practical concerns.
First you must include the facility in the user interface. For a start, we may just  
assume that the set of operation s available to users is enriche d with two new requests:  
U n d o  ( o b t a i n e d  f o r  e x a m p l e  b y  t y ping control-U, although follow ing the Macintosh  
convention control-Z seems to hav e become the standard on PC to o l s )  a n d  R e d o  ( f o r  
example control-R). Undo cancels the effect of the last command  not yet undone; Redo  
r e - e x e c u t e s  t h e  l a s t  u n d o n e  c o m m a n d  n o t  y e t  r e d o n e .  Y o u  w i l l  h a ve to define some  
convention for dealing with attem pts to undo more than what has  been done (or more than  
what is remembered), or to redo more than what has been undone:  ignore the request, or  
bring up a warning message.
This is only a first shot at user interface support for undo-re do. At the end of this  
chapter we will see that a nicer , more visual interface is poss ible.
§21.1   PERSEVERARE DIABOLICUM 697
Second, not all commands are undo able. In some cases this is an  impossibility of  
fact, as in the command “fire the  missiles” (notw ithstanding th e televised comment of a  
then-in-office US president, who thought one coul d command a U- turn) or, less  
ominously, “print the page”. In other cases, a command is theor etically undoable but the  
overhead is not worth the trouble ; text editors typically do no t let you undo the effect of a  
Save command, which writes the current document state into a fi le. The implementation  
of undoing will need to take into account such non-u ndoable com mands, making this  
status clear in the user interface. Be sure to restrict non-und oable commands to cases for  
which this property is easily  justifiable in user terms.
As a counter-example, a document processing tool which I freque ntly use tells its user,  
once in a while, that in the current state of the document the command just requested is  
not undoable, with no other visible justification than the whim  of the program. At least it  
says so in advance — in most cases.
Interestingly, this warning is in a sense a lie: you can undo the effect if you want, although  
not through Undo but through “Revert to last saved version of t he document”. This  
observation yields a user interf ace rule: if there remains any case for which you feel  
justified to make a command non-undoable, do not follow the doc ument processing  
system’s example by just displaying a warning of the form “This  command will not be  
undoable” and giving the choice between Continue anyway  and Cancel . Give users three
possibilities: save document, then execute command; execute wit hout saving; cancel.
Finally, it may be tempting to offer, besides Undo and Redo, th e more general  
“Undo, Skip and Redo” scheme, al lowing users, after one or more  Undo operations, to  
skip some of the commands before  triggering Redo. The user inte rface shown at the end  
of this chapter could support this exten sion, but it raises a c onceptual problem: after you  
skip some commands, the next one may not make sense any more. A s a trivial example  
assume a text editor s ession, with a text containing just one l ine, and a user who executes  
the two commands
(1) Add a line at the end.
(2) Remove the second line.
Our user undoes both,  then wants to skip (1) and redo (2). Unfortunately at this stage  
(2) is meaningless: there is no second line. This is less a proble m in the user interface (you  
could somehow indicate to the use r that the command is impossib le) than in the  
implementation: the command Remove the second line  w a s  a p p l i c a b l e  t o  t h e  o b j e c t  
structure obtained as a result of (1), but applying it to the object structure that exists prior  
to (1) may be impossible (that is to say, cause a crash or other unpl easant results).  
Solutions are certainly possible , but they may not be worth the  trouble.
Requirements on the solution
The undo-redo mechanism that we set out to provide should satis f y  t h e  f o l l o w i n g  
properties. 
U1  • The mechanism should be applicable to a wide class of interact ive applications,  
regardless of the application domain.Exercise E21.4, 
page 716 .
INHERITANCE CASE STUDY: “UNDO”  IN AN INTERACTIVE SYSTEM  §21.1 698
U2  • The mechanism should not requir e redesign for each new command . 
U3  • It should make reasonable use of storage. 
U4  • It should be applicable to both  one-level and a rbitrary-level Undo. 
The first requirement follows from the observation that there i s nothing application-
specific about undoing and redoi ng. To facilitate the discussio n, we will use as example a  
kind of tool familiar  to everyone: a text editor (such as Notep ad or Vi), which enables its  
users to enter texts and to perform such commands as INSERT_LINE , DELETE_LINE , 
GLOBAL_REPLACEMENT  (of a word by another) and so on. But this is only an  
example and none of the concepts discussed below is specific to  text editors.
The second requirement excludes treating Undo and Redo as just any other  
command in the interactive system. Were Undo a command, it woul d need a structure of  
the form 
if “Last command was INSERT_LINE”  then
“Undo the effect of INSERT_LINE”
elseif  “Last command was DELETE_LINE”  then
“Undo the effect of DELETE_LINE”
etc.
We know how bad such structures,  the opposite of what the Singl e Choice principle  
directs us to use, are for exten dibility. They have to be chang ed every time you add a  
command; furthermore, the code i n each branch will mirror the c ode for the corresponding  
command (the first bran ch, for example, has to know a lot about  what INSERT_LINE
does), pointing to a flawed design. 
The third requirement directs us t o be sparing in our use of st orage. Supporting undo-
redo will clearly force us to store some  information for every Undo; for example when we  
execute a DELETE_LINE , we will not be able to undo it later unless we put aside  
somewhere, before executing the command, a copy of the line bei ng deleted and a record  
of its position in the text. But we should store only what is l ogically necessary.
The immediate effect of this third requirement is to exclude an  obvious solution:  
saving the whole system state — t he entire object structure — b efore every command  
execution; then Undo wo uld just restore the saved image. This w ould work but is terribly  
wasteful of space. Too bad, sin ce the solution would be trivial  t o  w r i t e :  j u s t  u s e  t h e  
STORABLE facilities for storing and retri eving an entire object structur e in a single blow.  
But we must look for something  a little more sophisticated.
The final requirement,  supporting an arbitra ry depth of undoing , has already been  
discussed. It will turn out to be  easier to consider a one-leve l mechanism first, and then to  
generalize it to multi-level.
These requirements complete the presentation of the problem. It  may be a good idea,  
as usual, to spend a little ti me looking for a solution on your  own before proceeding with  
the rest of this chapter.See “Single 
Choice”, page 61 .
On STORABLE  see 
“Deep storage: a first view of persistence”, page 250 .
§21.2   FINDING THE ABSTRACTIONS 699
21.2  FINDING THE ABSTRACTIONS
The key step in an object-oriente d solution is the search for t he right abstraction. Here the  
fundamental notion is s taring us in the eyes.
Command as a class 
The problem is characterized by a fundamental data abstraction:  COMMAND , 
representing any editor operatio n other than Undo and Redo. Exe cution is only one of the  
features that may be applied to a command: the command might be  stored, tested — or  
undone. So we need a class of the provi sional form 
deferred class COMMAND  feature
execute deferred  end
undo deferred  end
end
COMMAND  describes the abstract notion of command and so must remain de ferred.  
Actual command t ypes are represented by e ffective descendants o f this class, such as 
class LINE_DELETION  inherit
COMMAND
feature
deleted_line_index : INTEGER
deleted_line : STRING
set_deleted_line_index (n: INTEGER )
-- Set to n the number of next line to be deleted.
do
deleted_line_index  := n
end
execute
-- Delete line.
do
“Delete line number  deleted_line_index ”
“Record text of deleted line in deleted_line ”
end
undo
-- Restore last deleted line.
do
“Put back deleted_line at position deleted_line_index”
end
end
And similarly for each command class.
INHERITANCE CASE STUDY: “UNDO”  IN AN INTERACTIVE SYSTEM  §21.2 700
What do such classes represent? An instance of LINE_DELETION , as illustrated  
below, is a little object that carries with it all the informat ion associated with an execution  
of the command: the line being deleted ( deleted_line , a string) and its index in the text  
(deleted_line_index , an integer). This is the information needed to undo the comma nd 
should this be required later on, or to redo it.
The exact attributes — such as deleted_line  a n d  deleted_line_index h e r e  —  w i l l  
differ for each command class, bu t they should always be suffic ient to support the local  
variants of execute and undo . Such objects, conceptually  describing the difference  
between the states that precede a nd follow the application of a  command, will enable us  
to satisfy requirement U 3 of the earlier list — storing o nly what is strictly necessary.
The inheritance structur e of command classes may look like this:
The graph shown is flat (a ll proper desc endants of COMMAND  at the same level),  
but nothing precludes adding mor e structure by grouping command  t y p e s  i n t o  
intermediate categories; this wi ll be justified if such categor ies make sense as abstract data  
types, that is to say, h ave specific features.
When defining a notion, it is always important to indicate what  it does not cover .  
Here the concept of command does not include Undo and Redo; for  example it would not  
make sense to undo an Undo (excep t in the sense of doing a Redo ). For this reason the  
discussion uses the term operation  for Undo and Redo, reserving command  for operations  
which can be undone and redone, such as line insertion. There i s no need for a class  
covering the notion of operation , since non-command operations such as Undo have only  
one relevant feature, their  ability to be executed.
This is a good example of the limitations of simplistic approac hes to “find the objects”,  
such as the famous “Underline the nouns” idea studied in a late r chapter. In the  
specification of the problem, the nouns command  and operation  are equally important;  
but one gives a fundamental class, the other does not give a cl ass at all. Only the abstract  
data type perspective — studying a bstractions in terms of the a pplicable operations and  
their properties — can help us f ind the classes of our object-o riented systems."Some text "deleted_line_index
deleted_line45 A command 
object
See “Requirements 
on the solution”, page 697 .
Command 
class hierarchy*
LINE_ … execute * 
undo*
INSERTIONLINE_
DELETIONCOMMAND
STRING_
REPLACE
“The nouns and the
verbs”, page 720 .
§21.2   FINDING THE ABSTRACTIONS 701
The basic int eractive step
To get started we will see how to support one-level undo. The g eneralization to multi-level  
undo-redo will come next.
In any interactive system, there  must be somewhere, in a module  in charge of the  
communication with users , a passage of the form
basic_interactive_step
-- Decode and execute  one user request.
do
“Find out what the use r wants us to do next”
“Do it (if possible)”
end
In a traditionally structured system, such as editor, these ope rations will be executed  
as part of a loop, the p rogram’s “basic loop”:
from start until quit_has_been_requested_and_confirmed loop
basic_interactive_step
end
whereas more sophisticated syste ms may use an event-driven sche me, in which the loop  
is external to the system proper  (being managed by the underlyi ng graphical  
environment). But in all cases the re is a need for something li ke basic_interactive_step .
I n  l i g h t  o f  t h e  a b s t r a c t i o n s  j u s t  i d e n t i f i e d ,  w e  c a n  r e f o r m u l a t e the body of the  
procedure as 
“Get latest user request”
“Decode request”
if “Request is a normal command (not Undo)” then
“Determine the correspondi ng command in our system”
“Execute that command”
elseif “Request is Undo” then
if “There is a command to be undone” then
“Undo last command”
elseif “There is a comma nd to be redone” then
“Redo last command”
end
else
“Report erroneous request”
end
INHERITANCE CASE STUDY: “UNDO”  IN AN INTERACTIVE SYSTEM  §21.2 702
This implements the convention s uggested earlier that Undo appl ied just after Undo  
means Redo. A request to Undo or  Redo is ignored if there is no thing to undo or redo. In  
a simple text editor wit h a keyboard interface, “Decode request”  would analyze the user  
input, looking fo r such codes as control-I (for insert line), c ontrol-D (for delete line) and  
so on. With graphical interfaces  you have to determine what inp ut the user has entered,  
such as a choice in a menu, a but ton clicked in a  menu, a key p ressed.
Remembering the last command
W i t h  t h e  n o t i o n  o f  c o m m a n d  o b j e c t  w e  c a n  b e  m o r e  s p e c i f i c  a b o u t  the operations  
performed by basic_interactive_step . We will use an attribute
requested : COMMAND
-- Command requested b y interactive user
representing the latest command t hat we have to execute, undo o r redo. This enables us to  
refine the prece ding scheme of basic_interactive_step  into:
“Get and decode la test user request”
if “Request is normal command (not Undo)”  then
“Create appropriate command object and attach it to requested   ”
-- requested  is created as an instance of some
-- descendant of COMMAND , such as LINE_DELETION
-- (This instruction  is detailed below.)
; undoing_mode  := False
elseif  “request is Undo”  and requested /= Void then
if undoing_mode  then
“This is a Redo; details left to the reader”
else
; undoing_mode  := True
end
else
“Erroneous request: output  warning, or do nothing”
end
The boolean entity undoing_mode  determines whether the la st operation was an Undo. In  
this case an immediately following Undo request would mean a Re do, although the  
straightforward details have been left to the reader; we will s ee the full details of Redo  
implementation in the more interesting case of a multi-level me chanism.
The information stored before e a c h  c o m m a n d  e x e c u t i o n  i s  a n  i n s t ance of some  
descendant of COMMAND  such as LINE_DELETION . This means that, as announced, the  
solution satisfies the property labeled U 3 in the list of requiremen ts: what we store for each  
command is the difference between  the new state and the previou s one, not the full state. requested executeDynamic
Binding
requested undo
Exercise E21.2, 
page 716 .
See “Requirements 
on the solution”, page 697 .
§21.2   FINDING THE ABSTRACTIONS 703
T h e  k e y  t o  t h i s  s o l u t i o n  —  a n d  i t s  r e f i n e m e n t s  i n  t h e  r e s t  o f  t his chapter — is  
polymorphism and dynam ic binding. Attribute requested  is polymorphic: declared of type  
COMMAND , it will become attached to objects of one of its effective de scendant types  
such as LINE_INSERTION . The calls requested   execute  and requested   undo  only make  
sense because of dynamic binding : the feature they trigger must  be the version redefined  
for the corresponding command c lass, executing or undoing a LINE_INSERTION , a 
LINE_DELETION  or a command of any other type a s determined by the object to which  
requested  happens to be attached at the time of the call.
The system’s actions
No part of the structure seen so far is application-specific. T he actual operations of the  
application, based on its specific object structures — for exam ple the structures  
representing the current text in a text editor — are elsewhere;  h o w  d o  w e  m a k e  t h e  
connection?
The answer relies on the execute  a n d  undo  p r o c e d u r e s  o f  t h e  c o m m a n d  c l a s s e s ,  
which must call application-specific features. For example proc edure execute  of class  
LINE_DELETION must have access to the editor-sp ecific classes to call feature s that will  
yield the text of the current line, give its position in the te xt, and remove it.
As a result there is a clear sep aration between the user intera ction parts of a system,  
largely application-independent, and the application-specific p arts, closer to the model of  
each application’s conceptual model — be it text processing, CA D-CAM or anything else.  
The first component, especially when generalized to a history m echanism as explained  
next, will be widely reusable bet ween various application domai ns.
How to create a command object
After decoding a reque st, the system must create the correspond ing command object. The  
instruction appeared abstractly as “Create appropriate command object and attach it to  
requested  ”; we may express it more precise ly, using creation instructions , as
if “Request is LINE INSERTION” then
create  {LINE_INSERTION } requested   make (input_text , cursor_  index )
elseif “Request is LINE DELETION” then
create  {LINE_DELETION } requested  make (current_line , line_  index )
elseif
…
This uses the create  {SOME_TYPE } x … form of the creation  instruction, which  
creates an object of type SOME_TYPE  and attaches it to x; remember that SOME_TYPE
must conform to the type declared for x, as is the case here since requested  is of type  
COMMAND and all the command classe s are descendants of COMMAND .
If each command type uses a unique  integer or character code, a slightly simpler  
form relies on an inspect :“Polymorphic cre-
ation”, page 479 .
INHERITANCE CASE STUDY: “UNDO”  IN AN INTERACTIVE SYSTEM  §21.3 704
inspect
request_code
when Line_insertion then
create  {LINE_INSERTION } requested   make (input_text , cursor_  position )
etc.
Both forms are multipl e-branch choices, but they do not violate  the Single Choice  
principle: as was pointed out in  the discussion of that princip le, if a system provides a  
number of alternatives some part of it must know the complete list of  alternatives. The above  
extract, in either variant, is t hat point of single choice. Wha t the principle precludes is  
spreading out such knowledge ove r many modules. Here, no other part of the system needs  
access to the list of commands; every command class deals with just one kind of command.
It is in fact possible to obtain a more elegant structure and g et rid of the multi-branch  
choice totally; we will see this at the end of presentation.
21.3  MULTI-LEVEL UNDO-REDO
Supporting an arbitrary  depth of undoing, with the attendant re doing, is a straightforward  
extension of the preceding scheme.
The history list
What has constrained us to a single level of undoing was the us e of just one object, the last  
created instance of COMMAND available through requested , as the only record of  
previously exe cuted commands.
In fact we create as many objects as the user executes commands . But because the  
software only has one command object reference, requested , always attached to the last  
command, every command object becomes unreachable as soon as th e user executes a  
new command. It is part of the elegance and simplicity of a goo d O-O environment that  
we do not need to worry about such older command objects: the g arbage collector will  
take care of reclaiming the memory they occupy. It would be a m istake to try to reclaim  
the command objects ourselves, since they may all be of differe nt shapes and sizes.
To provide more depth of undoing we need to replace the single command requested
by a list of recentl y executed commands,  the history list:
history : SOME_LIST [COMMAND ]
SOME_LIST  is not a real class name; in true object-oriented, abstract da ta type style  
we will examine what features and properties we need from SOME_LIST  and draw the  
conclusion as to what list class (from the Base library) we can  use. The principal  
operations we need are straightf orward and well known from prev ious discussions:
•put to insert an element at the end  (the only place where we will need insertions). By  
convention, put will position the list cursor  on the element just inserted.
•empty  to find out whether  the list is empty.“Single Choice”, 
page 61 .
“Precomputing 
command objects”, page 708 .
See chapter 9 on 
garbage collection . 
§21.3   MULTI-LEVEL UNDO-REDO 705
•before , is_ first and is_last  to answer questions abo ut the cursor position.
•back  to move the cursor ba ck one position and forth  to advance it one position.
•item to access the element at cursor position, if any; this feature  has the precondition  
(not empty ) and (not before ), which we can express as a q uery on_item .
In the absence of undoing, the cursor will always be (except fo r an empty list) on  
the last element, making is_last  true. If the user starts undoing, the cursor will move  
backward in the list (all the way to before  if he undoes every remembered command); if  
he starts redoing, the cur sor will move forward.
The figure shows the cursor on a n element other than the last; this means the user has  
just executed one or more Undo, possibly interleaved with some Redo, although the  
number of Undo must always be at least as much as the number of  Redo (it is greater by  
two in the state captured in the figure). If at that stage the user selects a normal command  
— neither Undo nor Redo —, the c orresponding object must be ins erted immediately to  
the right of the cursor element. The remaining elements on the right are lost, since Redo  
would not make sense in that cas e; this is the same situation t hat caused us at the beginning  
of this chapter to relegate the notion of Skip operation to an exercise. As a consequence  
we need one mo re feature in SOME_LIST : procedure remove_all_right , which deletes all  
elements to the ri ght of the cursor.
An Undo is possible if and only i f the cursor is on an element,  as stated by on_item . A 
Redo is possible if and only if t here has been at least one non -overridden Undo, that is to  
say, (not empty ) and (not is_last ), which we may expre ss through a query not_last .
Implementing Undo
With the history l ist, it is easy to implement Undo:
if on_item then
history   item  undo
history   back
else
message ("Nothing to undo ")
endOldest
Most recent
commandremembered
commandEXECUTE, REDO UNDO
back forth
is_first is_last before Cursoritem
1 countA history list
Skip is the subject 
of exercise E21.4, page 716 .
INHERITANCE CASE STUDY: “UNDO”  IN AN INTERACTIVE SYSTEM  §21.3 706
See once again how dynamic binding is essential. The history  list is a polymorphic  
data structure:
As the cursor moves left, each successive value of history  item may be attached to  
an object of any of th e available command ty pes; in each case, dynamic bindi ng ensures  
that history   item  undo  automatically selects the  appropriate version of undo .
Implementing Redo
Redo is similar:
if not_last  then
history   forth
history   item  redo
else
message ("Nothing to redo ")
end
This assumes a new procedure, redo, in class COMMAND . So far we had taken for  
granted that redo is the same thing as execute , and indeed in most cas es it will be; but for  
some commands re-executing after  an undo might be slightly diff erent from executing  
from scratch. The best way to ha ndle such situat ions — providin g enough flexibility,  
without sacrificing co nvenience for the common cases — is to pr ovide the default  
behavior in class COMMAND :
redo
-- Re-execute command t hat has been undone
-- by default, the same thing as executing it.
do
execute
end
This makes COMMAND  a behavior class: along with deferred execute  and undo , it 
has an effective procedure redo which defines a behavior base d, by default, on the other  
two. Most descendants will keep this default, but some of them may redefine redo t o 
account for special cases.Instance of  
LINE_
DELETIONInstance of  
LINE_DELETIONInstance of  
LINE_
INSERTIONInstance of  
LINE_
MOVE
Instance of  
STRING_
REPLACEInstance of  
CHARACTER_CHANGEA history list 
with its various command 
objects
“Don’t call us, 
we’ll call you”, page 504 .
§21.4   IMPLEMENTATION ASPECTS 707
Executing a normal command
If a user operation is neither Undo nor R edo, it is a normal co mmand identified by a  
reference that we may still call requested . In this case we must execute the command, but  
we must also insert it into the history list; we should also, a s noted, forget any item to the  
right of the cursor. So the sequence of instructions is:
if not is_last then remove_all_right  end
history   put (requested )
-- Recall that put inserts at the end of the list and moves
-- the cursor to t he new element.
requested   execute
W ith this we have seen all the essential elements of the soluti on. The rest of this  
chapter discusses a few implementation-related topics and draws  the methodological  
lessons from the example.
21.4  IMPLEMENTATION ASPECTS
Let us examine a few d etails that help obtain the best possible  implementation.
Command arguments
Some commands will need arguments. For example a LINE_INSERTION  needs to know  
the text of the line to be inserted.
A simple solution is to add to COMMAND  an attribute and a procedure:
argument : ANY
set_argument (a: like argument )
do argument  := a end
Then any command cl ass can redefine argument  to the proper type. To handle  
multiple arguments, it suffices to choose an array or list type . This was the technique  
assumed above when we passed various arguments to the creation procedures of  
command classes.
This technique is appropriate fo r all simple applications. Note , however, that the  
COMMAND  class in ISE’s libraries uses a different technique, slightly more complicated  
but more flexible: there is no argument  attribute, but procedure execute takes an argument  
(in the usual sense of argument to a routine), representing the  command argument:
execute (command_argument : ANY ) …
The reason is that it is often convenient, in a graphical syste m, to let different  
instances of the same command typ e share the same argument; by removing the attribute  
we can reuse the same command object in many different contexts , avoiding the creation  
of a new command obj ect each time a user  requests a command.
INHERITANCE CASE STUDY: “UNDO”  IN AN INTERACTIVE SYSTEM  §21.4 708
The small complication is that th e elements of the history list  are no longer instances  
of COMMAND ; they must instead be instances of a class COMMAND_INSTANCE  with 
attributes
command_type : COMMAND
argument : ANY
For a significant system, the gain in space and time is worth t his complica tion, since  
you will create one command object per command type, rather tha n one per command  
execution. This techniq ue is recommended for production applica tions. You will only  
need to change a few details in the preceding class extracts.
Precomputing command objects
Before executing a command we mu st obtain, and in some cases cr eate, the corresponding  
command object. The instructio n was abstractly written as “Create appropriate command  
object and attach it to requested  ” and the first implementation draft was
inspect
request_code
when Line_insertion then
create {LINE_INSERTION } requested   make (…)
etc. (one branc h for each c ommand type)
As pointed out, this instruction does not violate the Single Choice principle: it is in  
fact the point of single choice — the only place in the entire system that knows what set  
of commands is supported. But we have by now developed a health y loathing for if or 
inspect  instructions with many branches , so even if this one appears i nevitable at first let  
us see if perhaps we cou ld get rid of it anyway.
W e  c a n  —  a n d  t h e  d e s i g n  p a t t e r n ,  w h i c h  m a y  b e  c a l l e d  precomputing a  
polymorphic instance set , is of wide applicability.
The idea is simply to create once and for all a polymorphic dat a structure containing  
one instance of each variant; th en when we need a new object we  simply obtain it from the  
corresponding entry in the structure.
Although several data structures would be possible for such as a list, it is most  
convenient to use an ARRAY [COMMAND ], allowing us to identify each command type  
with an integer between 1 and command_count , the number of command types. We declare
commands : ARRAY [COMMAND ]
and initialize its elements in such a way that the i-th element ( 1 <= i <= n) refers to an  
instance of the descendant class of COMMAND  corresponding to code i; for example, we  
create an instance of LINE_DELETION , associate it with the first element of the array  
(assuming line deletion has code 1), and so on. Exercise E21.4, 
page 716 .
Page 704 .
§21.4   IMPLEMENTATION ASPECTS 709
A similar technique can be applied to the polymorphic array associated_state  used in the  
O-O solution to the previous chapt er’s problem (panel-driven ap plications).
The array commands i s  a n o t h e r  e x a m p l e  o f  t h e  p o w e r  o f  p o l y m o r p h i c  d a t a  
structures. Its initialization is trivial:
create  commands   make (1, command_count ) 
create   {LINE_INSERTION } requested   make ; commands   put (requested , 1)
create  {STRING_REPLACE } requested   make ; commands   put (requested , 2)
… And so on for ea ch command type …
Note that with this approach the creation procedures of the var ious command classes  
should not have any arguments; i f a command class has attribute s, they should be set  
separately later on through specific procedures, as in li  make (input_text , cursor_  position )
where li is of type LINE_INSERTION .
Then there is no more need for any if or inspect  multi-branch instruction. The above  
initialization se rves as the point of sin gle choice; you can no w write the operation “Create  
appropriate command obj ect and attach it to requested  ” as 
requested  := clone (commands @ code )
where code  is the code of the last command . (Since each command type now has a code,  
corresponding to its index in th e array, the basic user interfa ce operation written earlier as  
“Decode request” analyzes the user’s re quest and determines  the corresponding co de.)
The assignment to requested  uses a clone  of the command template from the array,  
so that you can have more than o ne instance of the same command  type in the history list  
(as in the earlier example, whe re the history  includes two LINE_DELETION  objects).
If, however, you use the suggeste d technique of completely sepa rating the command  
arguments from the command objects (so that the history list co ntains instances of  
COMMAND_INSTANCE  rather than COMMAND ), then the clone is not necessary any  
more, and you can go on using re ferences to the original object s from the array, with just:
requested  := commands @ code
In very long sessions the savings can be significant.Instance of  
LINE_
DELETION
Instance of  
LINE_
INSERTIONInstance of  
LINE_
MOVE
Instance of  
STRING_REPLACEInstance of  
CHARACTER
_CHANGE
commands1command_
countThe array of 
command 
templates
The figure showing 
a history list exam-ple was on page 706.
INHERITANCE CASE STUDY: “UNDO”  IN AN INTERACTIVE SYSTEM  §21.4 710
A representation for the history list
For the history list a type SOME_LIST  was posited, with features put, empty , before , is_ first, 
is_last , back, forth , item and remove_all_right . (There is also on_item , expressed in terms  
of empty  and before , and not_last , expressed in terms of empty  and is_last .)
Many of the classes in the Base libraries can be used to implem ent SOME_LIST ; for 
example we could rely on TWO_WAY_LIST or one of the descendant s of the deferred class  
CIRCULAR_LIST . To obtain a stand-alone solution let us devise an ad hoc clas s 
BOUNDED_LIST . Unlike a linked implementation such as TWO_WAY_LIST , this one  
will rely on an array, so it keep s only a bounded number of com mands in the history. Let  
remembered be the maximum number of remembe red commands. If you use this f acility  
for a system to build, remember (if only to avoi d receiving an angry letter from me should  
I ever become a user) to make this maximum user-settable, both during the session and in  
a permanent user profile consult ed at the beginning of each ses sion; and choose a default  
that is not too small, for example 20.
BOUNDED_LIST  can use an array, managed circularly to enable reusing earlier  
positions as the number of commands goes beyond remembered . With this technique,  
common for representing bounded q ueues (it will show up again f or bounded buffers in  
the discussion of concurrency), we  can picture the  array twiste d into a kind of doughnut:
The size capacity  of the array is remembered + 1 ; this convention means setting aside  
one of the positions (the last, at index capacity ) and is necessary if we want to be able to  
distinguish between an empty lis t and a full list (see below). The occupied positions are  
marked by two integer attributes: oldest  is the position of the oldest remembered  
command, and next is the first free position (the one at which the next command will be  
inserted). The integer attribute index  indicates the current cursor position.
Here is the implementation o f the various features. For put (c), inserting command c
at the end of the list, we executeSee “A buffer is a 
separate queue”, page 990 .
Bounded 
circular list 
implemented by 
an array1
remembered
nextoldest
capacity
Occupied position
Free position
Reserved positionindex
An alternative to 
reserving a free position is to keep track of count , the 
number of elements , 
in an attribute. See “Unconstrained genericity”, page 1181  for yet another 
variant.
§21.5   A USER INTERFACE F OR UNDOING AND REDOING 711
representation   put (x, next ); -- where representation  is the name of the array
next := (next \\ remembered ) + 1
index  := next
where \\ is the integer remainder operation. The value of empty  i s  t r u e  i f  a n d  o n l y  i f  
next = oldest ; that of is_ first, if and only if index  = oldest ; and that of before  if and only if  
(index  \\ remembered ) + 1 = oldest . The body of forth  is
index  := (index  \\ remembered ) + 1
and the body of back  is
index  := ((index + remembered – 2 ) \\ remembered ) + 1
The +remembered term is mathematically redundant, but is included because of th e 
lack of universal conventions as to the computer meaning of rem ainder operations for  
negative operands.
The query item giving the element at cursor position returns representation @ index , 
the array element at index  index . Finally, the procedure remove_all_right , removing all  
elements to the right of the curs or position, is simply impleme nted as
next := (index  \\ remembered ) + 1
21.5  A USER INTERFACE F OR UNDOING AND REDOING
Here is part of a possible user interface support for the undo- redo mechanism. It is taken  
from ISE’s Case analysis and design workbench, but several of o ur other products use the  
same scheme.
Although keyboard shortcuts are available for Undo and Redo, th e complete  
mechanism involves bringing up a  history window  (by clicking on a button in the interface,  
or selecting an item in the Tools menu). The history window is the exact user-visible  
equivalent of the history  list as it exists inside the so ftware. Once it is up, it will be 
regularly updated as you execute  commands and other operations.  In the absence of any  
undoing, it will look like this:
A history 
window , before 
any undoing

INHERITANCE CASE STUDY: “UNDO”  IN AN INTERACTIVE SYSTEM  §21.6 712
This shows the list of recent co mmands. As you execute new comm ands, they will  
appear at the end of the list. The currently active command (th e one at curso r position) is  
highlighted in inve rse video, like change relation label  on the last figure.
To undo the active command, you can click on the up arrow butto n  or use the  
keyboard shortcut (such as ALT-U). The cursor moves up (back) i n the list; after a few  
such Undo, the window would look like this:
As you know, this internally means that the software has been p erforming a few calls  
to back . At this stage you hav e a choice between s everal possibilities :
• Y ou  ca n p er f or m  m or e U nd o op er a ti on s b y c li c ki ng o n t he  up  ar r ow button; the  
highlighting moves to the previous line.
• You can perform one or more Redo by clicking on the down arrow   or using the  
equivalent keyboard sho rtcut; the highlighting goes to the next  l i n e ,  i n t e r n a l l y  
performing calls to forth .
• Y ou can execute a normal command. As we have seen, this will r emove from the  
history any commands that have be en undone but no t redone, inte rnally performing  
a remove_all_right ; in the interface, all the commands below the currently  
highlighted one  disappear.
21.6  DISCUSSION
The design pattern presented in this chapter has an important p ractical role, as it will  
enable you to write significantl y better interactive systems at  little extra effort. It also  
brings an interesting theoretica l contribution, by illuminating  some aspects of object-
oriented methodology wor th exploring  further.
A history 
window , in the 
middle of an 
undo-redo 
process

§21.6   DISCUSSION 713
The role of implementation
A striking property of the examp le user interface presented in the last section is that it was  
directly deduced  from the implementation: we took  the internal, developer-relev ant notion  
of history list and translated it  into an external, user-releva nt history window, with the  
attendant user int eraction mechanism.
One may always imagine that someone could have devised the exte rnal view first, or at  
any rate independently from the implementation. But this is not  the way it happened,  
either in this presentation or in history of our products’ deve lopment.
Instituting such a relation betw een a system’s functionality an d its implementation  
goes against all that traditiona l software engineering methodol ogy has taught. We have  
been told to deduce the implemen tation from the specification, not the reverse!  
Techniques of “iterative development” and “spiral lifecycle” ch a n g e  l i t t l e  t o  t h i s  
fundamental rule that implementa tion is slave to prior concept,  a n d  t h a t  t h e  s o f t w a r e  
developers must do what the “use rs” (meaning, the customers, us ually non-technical) tell  
them. Here we are violating ever y taboo by asserting that the implementation can tell us  
what the system should be doing  in the first place. I n earlier times questioning such time-
honored definitions of what depe nds on what could have led one to the stake.
The legitimate emphasis on involv ing customers — meant to avoid  t h e  a l l  t o o  
common horror stories of systems that do not do what their user s need — has unfortunately  
led to downplaying the software developers’ contribution, whose  importance extends to  
the most external and application-related aspects. It is naïve to believe, for example, that  
customers will suggest the right  interface facilities. Sometime s they will, but often they  
reason on the basis of the systems they know, and they will not  see all the issues involved.  
That is understandable: they hav e their own jobs to do, and the ir own areas of expertise;  
getting everything right in a software system is not their resp onsibility. Some of the worst  
interactive interfaces in the world were designed with too much  user influence. Where  
users are truly irreplaceable is for negative comments: they wi ll see practical flaws in an  
idea which at first seems attract ive to the developers. Such cr iticism must always be  
heeded. Users can make brilliant positive suggestions too, but do not depend on it. And  
once in a while, a developer’s suggestion will seduce the users  — possibly after a number  
of iterations taking their criticism into account — even though  it draws its origin from a  
seemingly humble implem entation technique, s uch as the history list.
This equalization of traditional relationships is one of the di stinctive contributions of  
object technology. By making the  development process seamless a nd reversible, we allow  
a great implementation idea to influence the specification. Ins tead of a one-way flow from  
analysis to design and “coding”,  we have a continuous process w ith feedback loops  
throughout. This assumes, of cou rse, that implementation is no longer viewed as the  
messy, low-level component of sys tem construction; its results,  developed with the  
techniques described t hroughout this book, can and should be as  clear, elegant and abstract  
as anything one can produce in the  most implementation-abhorren t forms of traditional  
analysis and design.More on seamlessness 
and reversibility in chapter 28 .
INHERITANCE CASE STUDY: “UNDO”  IN AN INTERACTIVE SYSTEM  §21.6 714
Small classes
The design described in this chap ter may, for a typical interac tive system, involve a  
significant number of relatively  small classes: one for each ty pe of command. There is no  
reason, however, to be concerned about the effect on system siz e and complexity since the  
inheritance structure on these classes will remain simple, alth ough it does not have to be as  
flat as the one sketched in this chapter. (You may want to grou p commands into categories.) 
In a systematic O-O approach, si milar questions arise whenever you have to  
introduce classes representing act ions. Although some object-or iented languages make it  
possible to pass routines as arguments to other routines, such a facility contradicts the  
basic idea of the method — that a function (action, routine) ne ver exists by itself but is  
always relative to a certain  data abstraction . So instead of passing an operation we should  
pass an object equipped, through a  routine of its generating cl ass, with that operation, as  
with an instance of COMMAND  equipped with the execute  operation.
Sometimes the need to write a wr apper class seems artificial, e specially to people  
used to passing routin es around as arguments. But every time I have seen such a class  
legitimately being int roduced, originally fo r the sole purpose (it was thought) of  
encapsulating an operation, it tu rned out to reveal a useful da ta abstraction, as evidenced  
by the later addition of other f eatures beyond the one that ser ved as the original incentive.  
Class COMMAND  does not fall into this categor y, since right from the start i t was  
conceived as a data abstract ion, and had two features ( execute  and undo ). But it is typical  
of the process, since if you sta rt using commands seriously you  will soon realize the need  
for even more fe atures such as:
•argument : ANY  to represent the command argument (as in one of the versions t hat 
we have encountered).
•help: STRING , to provide on-line help ass ociated with each command.
• Logging and statistical features , to keep track of how often e ach command type is used.
Another example, drawn from the domain of numerical software, i s more  
representative of situations whe re the introduction of a class may seem artificial at first,  
because the object-oriented desig ner will pass an object where a traditional approach  
would have passed a routine as a rgument. In performing scientif ic computation you will  
often need integration mechanisms, to which you give a mathemat ical function f to 
compute its integral on a certain  interval. The traditional tec hnique is to represent f as a 
routine, but in object-oriented design we recognize that “Integ rable function” is an  
important abstraction, with many  possible features. For someone  coming from the  
functional world of C, Fortran a nd top-down design, the need to  provide a class may at  
first appear to be a kind of pro gramming trick: not finding in the language manual a way  
to pass a routine as argument, he asks his colleagues how to ac hieve this effect, and is told  
that he must write a class with the corresponding feature, then  pass objects (instances of  
that class) rather than the feature itself.
§21.7   BIBLIOGRAPHICAL NOTES 715
He may at first accept this tec hnique — perhaps grudgingly — as  one of those quirks  
that programming languages impose on their users, as when you w ant a boolean variable in  
C and have to declare it of type  integer , with 0 for false and 1 for true. But then as he  
continues his design he will rea lize that the technique was not  a hack, simply the proper  
application of object-o riented principles: INTEGRABLE_FUNCTION is indeed one of the  
major abstractions of his problem  domain, and soon new, relevan t features (beyond the  
original one item (a: REAL ): REAL , giving the value of the function at point a) will start  
piling up.
What was thought to be a trick t urns out to yield a major compo nent of the design.
21.7  BIBLIOGRAPHICAL NOTES
The undo-redo me chanism describe d in this chapter was present i n the structural  
document constructor Cépage  developed by Jean-Marc Ne rson and the author in1982  
[M 1984] , and has been integrated into m any of ISE’s interactive tools (including  
ArchiText [ISE 1996] , the successor to Cépage).
In a position paper fo r a panel at t he first OOPSLA conference in 1986, Larry Tesler  
cites a mechanism based on the same ideas, part of Apple’s MacApp interactive framework.
[Dubois 1997]  explains in detail how to apply object-oriented concepts to th e design  
of numerical software, with abst ractions such as “Integrable fu nction” (as mentioned in  
the last section), and  describes in detail a  complete object-or iented numerical library.
EXERCISES
E21.1  Putting together a small interactive system (programming  project)
This small programming project is an excellent way to test your  understanding of the  
topics of this chapter — and more generally of how to build a s mall system making full  
use of object-orien ted techniques.
Write a line-oriented editor sup porting the foll owing operation s:
•p: Print text e ntered so far.
•↓: move cursor to next line if any. (Use the code l, for low, if that is more convenient.)
•↑: move cursor to previ ous line if any. (Use h, for high, if that i s more convenient.)
•i: insert a new line after cursor position.
•d: delete line at cursor position.
•u: Undo last operation if not Un do; if it was Undo, redo undone command.In [Cox 1986].
INHERITANCE CASE STUDY: “UNDO” I N AN INTERACTIVE SYSTEM  §E21.2  716
You may add more comma nds, or choose a more attractive user int erface, but in all cases  
you should produce a complete, w orkable system. (You may also a pply right from the start  
the improvement described  in the next exercise.)
E21.2  Multi-level Redo
Complete the previous exercise’s  one-level scheme by redefining  the meaning of u as
•u: Undo last operation ot her than Undo and Redo.
and adding
•r: Redo last undone command (when applicable).
E21.3  Undo-redo in Pascal
Explain how to obtain a solution imitating the undo-redo techni que of this chapter in non-
O-O languages such as Pascal, Ad a (using record types with vari ants) or C (us ing structure  
and union types). Compare with the object-oriented solution.
E21.4  Undo, Skip and Redo
Bearing in mind the issues raised early in the discussion, stud y how to extend the  
mechanism developed in this chap ter so that it will support Und o, Skip and Redo, as  
well as making it possible to redo an undone command that has b een followed by a  
normal command.
Discuss the effect on both the user interf ace and the implement ation. 
E21.5  Saving on command objects
Adapt all the class extracts of this chapter to treat command a rguments separately from  
commands (adding a routine argument to execute ) and create only one command object  
per command type.
If you have done the preceding e xercise, apply t his technique t o its solution.
E21.6  Composite commands
For some systems it may be usefu l to introduce a notion of comp osite command,  
describing commands w hose execution involves  executing a number  of other commands.  
Write the corresponding class COMPOSITE_COMMAND , an heir of COMMAND , 
making sure that composite comma nds can be undone, and that a c omponent of a  
composite command may itself be composite.
Hint : use the multiple inh eritance scheme prese nted for composite f igures.See “Practical 
issues”, page 696  
and “The history 
list”, page 704 .
See “Command 
arguments”, page 707.
See“Composite fig-
ures”, page 527 .
§E21.7   EXERCISES 717
E21.7  Non-undoable commands
A  s y s t e m  m a y  i n c l u d e  c o m m a n d s  t h a t  a r e  n o t  u n d o a b l e ,  e i t h e r  b y  nature (“Fire the  
missiles”) or for pragmatic reasons (when there is too much inf ormation to remember).  
Refine the solution of this chapter so that it will account for  non-undoable commands.  
(Hint : introduce heirs UNDOABLE  and NON_UNDOABLE  to class COMMAND .) Study  
carefully the effect on the algor ithms presented, and on the us er interface, in particular for  
an interface using the  history windows as pr esented at the end of the chapter.
E21.8  A command library (design and implementation project)
Write a general-purpose command library, meant to be used by an  arbitrary interactive  
system and supporting an unlimit ed undo-redo mechanism. The lib rary should integrate  
the facilities discussed in the last three exercises: separatin g commands from arguments;  
composite commands; non-undoable commands. (Integrating an “Und o, Skip and Redo”  
facility is optional.) Illustrate the applicability of your lib rary by building three  
demonstration systems of widely different natures, such as a te xt editor, a graphics system  
and a training tool.
E21.9  A history mechanism
A useful feature to include in a  command-oriented interactive t ool is a history mechanism  
which remembers the last command s executed, and allows the user  to re-execute a  
previous command, possibly modifi ed, using simple mnemonics. Un der Unix, for  
example, you may direct the C-sh ell (a command language) to rem ember the last few  
executed commands; t hen you may type !–2 t o  m e a n  “ r e - e x e c u t e  t h e  n e x t - t o - l a s t  
command”, or ^yes^no^  to mean “re-execute the last co mmand, replacing the characters  
yes in the command text by no”. Other environments of fer similar facilities.
History mechanisms, wh e n  t h e y  e x i s t ,  a r e  b u i lt in an ad hoc fas hion. On Unix, many  
interactive tools runn ing under the C-shell, such as the Vi edi tor or various debuggers,  
would greatly benefit from such a  mechanism but do not offer on e. This is all the more  
regrettable that the same concep t of command history and the sa me associated facilities  
are useful for any interactive t ool independentl y of the functi ons it performs — command  
language, edito r, debugger. 
Design a class implementing a general-purpose history mechanism , in such a way that any  
interactive tool needing such a mechanism will o btain it by sim ply inheriting from that  
class. (Note that multiple inh eritance is esse ntial here.) 
Discuss the extension of thi s mechanism to a general USER_INTERF ACE  class. 
INHERITANCE CASE STUDY: “UNDO” IN AN INTERACTIVE SYSTEM  §E21.1 0 718
E21.10  Testing environment
Proper testing of a software component, for example a class, re quires a number of facilities  
t o  p r e p a r e  t h e  t e s t ,  i n p u t  t e s t  data, run the test, record the results, compare them to  
expected results etc. Define a general TEST  class that defines an appropriate testing  
environment and may be inherited  by any class in need of being tested. (Note again the  
importance of multip le inheritance.) 
E21.11  Integrable functions
(For readers familiar with the basics of numerical analysis.) W rite a set of classes for  
integrating real functions of a r eal variable over arbitrary in tervals. They should include a  
class INTEGRABLE_FUNCTION , as well as a deferred class INTEGRATOR  to describe  
integration methods, with p roper descendants such as RATIONAL_FIXED_INTEGRATOR .See “Small 
classes”, page 714 . 
For a full-fledged solution see [Dubois 1997].
22  
How to find the classes 
Foremost among the goals of object-oriented methodology, since t he structure of O-O  
software is based on decomposition into classes, is that it sho uld give us some advice on  
how to find these classes. Such is the purpose of the following  pages. (In some of the  
literature you will see the problem referred to as “ finding the objects ”, but by now we know  
better: what is at stake in our software architectures is not i ndividual objects, but object  
types — classes.) 
At first we should not expect too much. Finding classes is the central decision in  
building an object-oriented software system; as in any creative  discipline, making such  
decisions right takes talent and experience, not to mention luc k. Expecting to obtain  
i n f a l l i b l e  r e c i p e s  f o r  f i n d i n g  t h e  c l a s s e s  i s  a s  u n r e a l i s t i c  a s  w o u l d  b e ,  f o r  a n  a s p i r i n g  
mathematician, expecting to obtain recipes for inventing intere sting theories and proving  
their theorems. Although both ac tivities — software constructio n and theory construction  
— can benefit from general advice and the example of successful  predecessors, both also  
require creativity of the kind that cannot fully be covered by mechanical rules. If (like  
many people in t he industry) you still f ind it hard to compare the software developer to a  
mathematician, just think of oth er forms of engi neering design:  although it is possible to  
provide basic guidelin es, no teachable ste p-by-step rules can g uarantee good design of  
buildings or airplanes. 
In software too, no book advice can replace your know-how and i ngenuity. The  
principal role of a me thodological discussi on is to indicate so me good ideas, draw your  
attention to some illuminating pr ecedents, and ale rt you to som e known pitfalls. 
This would be true with any othe r software design method. In th e case of object  
technology, the observ ation is tempered by s ome good news, comi ng to us in the form of  
reuse. Because much of the necessary inventi on may already have  been done, you can  
build on others’ accomplishments.
There is more good news. By star ting with humble expectations b ut studying  
carefully what works and also what does not, we will be able, l ittle by little and against all  
odds, to devise what in the end deserves to be called a method  for finding the classes. One  
of the key steps will be the realization that, as always in des ign, a selection technique is  
defined by two components: what t o consider, and what to reject .
HOW TO FIND THE CLASSES  §22.1 720
22.1  STUDYING A REQUIREMENTS DOCUMENT 
To understand the problem of finding classes, it may be best to  begin by assessing a widely  
publicized approach. 
The nouns and the verbs 
A number of publications suggest  using a simple rule for obtain ing the classes: start from  
the requirements document (assumi ng there is one, of course, bu t that is another story); in  
function-oriented design you would concentrate on the verbs, wh ich correspond to actions  
(“do this”); in object -oriented design you underline the nouns,  which describe objects. So  
according to this view a sentence of the form
The elevator will close its door be fore it moves to  another floor .
would lead the function-oriented  designer to detect the need fo r a “move” function; but as  
an object-oriented designer you should see in it three object t ypes, ELEVATOR , DOOR
and FLOOR , which will give classes. V oilà! 
Would it that life were that sim ple. You would bring your requi rements documents  
home at night, and play Object Pursuit  around the dinner table. A good way to keep the  
children away from the TV set, and make them revise their gramm ar lessons while they  
help Mom and Dad in their so ftware engineering work. 
But such a simple-minded techniqu e cannot take us very far. Hum an language, used  
to express system requirements, is so open to nuance, personal variation and ambiguity  
that it is dangerous to make any important decision on the basi s of a document which may  
be influenced as much by the author’s individual style as by th e actual properties of the  
projected soft ware system. 
Any useful result that the “unde rline the nouns” method would g ive us is obvious  
anyway. Any decent O-O design fo r an elevator control system wi ll include an  
ELEVATOR  class. Obtaining such classes is not the difficult part. To re peat an expression  
used in an earlier discussion, they are here for the picking. F or the non-obvious classes a  
syntactic criterion — such as no uns versus verbs in a document that is by essence open to  
many possible stylistic vari ants — is clos e to useless.
Although by itself the “underlin e the nouns” idea would not des erve much more  
consideration, we can use it further, not for its own sake but as a foil; by understanding its  
limitations we can gain insights into what it truly takes to fi nd the classes and how the  
requirements document can help us in this endeavor.
Avoiding useless classes 
The nouns of a requirements docum ent will cover some classes of  the final design, but will  
also include many “f alse alarms”: concepts that should not yield classes. 
In the elevator example door  was a noun. Do we need a class DOOR ? Maybe, maybe  
not. It is possible that the onl y relevant prope rty of elevator  doors for this system is that  See the bibli-
ographical notes .
§22.1   STUDYING A REQUIREMENTS DOCUMENT 721
they may be opened and closed. Then to express the useful prope rties of doors it suffices  
to include in class ELEVATOR the query and commands
door_open : BOOLEAN ;
close_door
…
ensure
not door_open
end;
open_door
…
ensure
door_open
end
In another variant of the system , however, the notion of door m ay be important  
enough to justify a separate cla ss. The only resource here is t he theory of abstract data  
types, and the only relevant question is:
Only your intuition and experien ce as a designer will tell you the answer. In looking  
for it, you will be aided by the  requirements document, but do not expect grammatical  
criteria to be of more than supe rficial help. Turn instead to t he ADT theory , which will  
help you ask custome rs or future users t he right questions.
We encountered a similar case in the undo-redo mechanism design . The discussion  
distinguished between commands , such as the line insertion command in a text editor, and  
the more general notion of operation , which includes commands but also spec ial requests  
such as Undo. Both of these words figured prominently in the st atement of the problem;  
yet only COMMAND  yielded a data abstraction (one of the principal classes of th e design),  
whereas no class in the solution  directly reflect s the notion o f operation. No analysis of a  
requirements document can sugges t this striking difference of t reatment.
Is a new class necessary? 
Another example of a noun which may or may not give a class in the elevator example is  
floor . Here (as opposed to the door  and operation cases) the question is not whether the  
concept is a relevant ADT: floor s are definitely an important d ata abstraction for an  
elevator system. But this does n ot necessarily mean we should h ave a FLOOR  class. 
The reason is simply that the pr operties of floors may be entir ely covered, for the  
purposes of the elevator system , by those of integers. Each flo or has a floor number; then  Is “door” a separate data type with its own clearly identified operations, or  
are all the operations on doors already covered by operations o n other data  
types such as ELEVATOR ?
Chapter 21 .
HOW TO FIND THE CLASSES  §22.1 722
if a floor (as seen by the elevator system) has no other featur es than those associated with  
its floor number, you may not need a separate FLOOR  class. A typical floor feature that  
comes from a feature of integers is the distance between two fl oors, which is simply the  
difference of their floor numbers.
If, however, floors have properties other than those of their n umbers — that is to say,  
according to the principles of abstract data types and object-o riented software  
construction, significant operations  not covered by those of integers — then a FLOOR
class will be appropriate. For e xample, some floors may have sp ecial access rights  
defining who can vis it them; then the FLOOR  class could include  a feature such as 
rights : SET [AUTHORIZATION ]
and the associated procedures. But even that is not certain: we  m i g h t  g e t  a w a y  b y  
including in some ot her class an array
floor_rights : ARRAY [SET [AUTHORIZATION ]]
which simply associates a set of AUTHORIZATION  values with each floor, identified by  
its number. 
Another argument for having a specific class FLOOR  would be to limit the available  
o p e r a t i o n s :  i t  m a k e s  s e n s e  t o  s u b t r a c t  t w o  f l o o r s  a n d  t o  c o m p a r e them (through the  
infix  "<" function), but not to add or mu ltiply them. Such a class may b e written as an heir  
to INTEGER . The designer must ask himself,  however, whether this goal rea lly justifies  
adding a new class. 
This discussion brings us once again to the theory of abstract data types. A  class  
does not just cover physical “ob jects” in the naïve sense. It d escribes an abstract data type  
— a set of software objects char acterized by well-defined opera tions and formal  
properties of these operations. A  type of real-world objects ma y or may not have a  
counterpart in the software in the form of a type of software o bjects — a class. When you  
are assessing whether a certain notion should yield a class or not, only the ADT view can  
provide the right crite rion: do the objects  of the system under  discussion exhibit enough  
specific operations and propertie s of their own, relevant to th e system and not covered by  
existing classes? 
The qualification “relevant to t he system” is crucial. The aim of systems analysis is  
not to “model the world”. This may be a task for philosophers, but the builders of software  
systems could not care less, at least for their professional ac tivity. The task of analysis is  
t o  m o d e l  t h a t  p a r t  o f  t h e  w o r l d  w h i c h  i s  m e a n i n g f u l  f o r  t h e  s o f tware under study or  
construction. This principle is reinforced by th e ADT approach (that is to say, the object-
oriented method), which holds that objects are only defined by what we can do with them  
— what the discussion of abstrac t data types called the Princip le of Selfishness. If an  
operation or property of an obje ct is irrelevant to the purpose s of the system, then it should  
not be included in the result of  your analysis — however intere sting it may be for other  
purposes. For a census proce ssing system, the notion of PERSON  may have features  
mother  and father ; but for a payroll processing s ystem which does not require in formation  
about the parents, every PERSON  is an orphan. Many hotels have 
no floor 13 , so the 
arithmetic may be a bit more elaborate .
See exercise E22.1, 
page 745 .
“BEYOND SOFT-
WARE”, 6.6, page 147.
§22.1   STUDYING A REQUIREMENTS DOCUMENT 723
If all of the operations and pro perties that you can identify f or a type of objects are  
i r r e l e v a n t  i n  t h i s  s e n s e ,  o r  a r e  a l r e a d y  c o v e r e d  b y  t h e  o p e r a t i ons and properties of a  
previously identified class, the  conclusion is that the object type itself is irrelevant: it must  
not yield a class. 
This explains why an elevato r system might not include FLOOR  as a class because  
(as noted above) from the point of  view of the elevator system floors have no relevant  
properties other than those of t he associated integer numbers, whereas a Computer Aided  
Design system designed for  architects will have a FLOOR  class — since in that case the  
floor has several specific attributes and routines. 
Missing important classes 
Not only can nouns suggest notions which do not yield classes: t h e y  c a n  a l s o  f a i l  t o  
suggest some notions which should definitely yield classes. The re are at least three sources  
of such accidents. 
Do not forget that, as noted, the aim of this discussion is no longer to convince ourselves  
of the deficiencies of the “und erline the nouns” approach, whos e limitations are by now  
so obvious that the exercise would not be very productive. Inst ead, we are analyzing these  
limitations as a way to gain more insight into the process of d iscovering classes. 
The first cause of missed classe s is simply due to the flexibil ity and ambiguity of  
human language — the very qualiti es that make it suitable for a n amazingly wide range of  
applications, from speeches and novels to love letters, but not  very reliable as a medium  
for accurate technical documents . Assume the req uirements docum ent for our elevator  
example contains the sentence
The presence of the noun “record” suggests a class DATABASE_RECORD ; but we  
may totally miss a more important  data abstraction: the notion of a move  between two  
floors. With the above sentence in the requirements document, y ou will almost certainly  
need a MOVE  class, which could  be of the form 
class MOVE  feature
initial , final : FLOOR ;- -  Or INTEGER  if no  FLOOR class
record (d: DATABASE ) …
… Other features …
end
This will be an important class, which a grammar-based method w ould miss because  
of the phrasing of the above sen tence. Of course if the sentenc e had appeared asA database record must be created ev ery time the elevato r moves from one  
floor to another .
A database record must be created fo r every move of the elevator from one  
floor to another .
HOW TO FIND THE CLASSES  §22.1 724
then “move” would have  been counted as a noun, and so would hav e yielded a class! We  
see once again the dangers of pu tting too much t rust in a natur al-language document, and  
the absurdity of making any seri ous property of a system design , especially its modular  
structure, dependent on such  vagaries of style and mood.
The second reason for overlooki ng classes is that some crucial abstractions may not  
be directly deducible from the r equirements. Cases abound in th e examples of this book.  
It is quite possible that the requirements for a panel-driven s ystem did not explicitly cite  
the notions of state and applica tion; yet these are the key abs tractions, which condition the  
entire design. It was pointed ou t earlier that s ome external-wo rld object types may have  
no counterpart among the classes of the software; here we see t he converse: classes of the  
software that do not correspond t o any external-world objects. Similarly, if the author of  
the requirements for a text editor with undo-redo has written “ the system must support line  
insertion and deletion ”, we are in luck since we can spot the nouns insertion  and deletion ; 
but the need for these facilitie s may just as well follow from a sentence of the form
leading the naïve designer to devote his attention to the trivi al notions of “cursor” and  
“position” while missing the command abstractions (line inserti on and line deletion).
The third major cause of missed c lasses, shared by any method w hich uses the  
requirements document as the bas is for analysis,  is that such a  strategy overlo oks reuse. It  
is surprising to note that much of the object-oriented analysis  literature tak es for granted  
the traditional view of software development: sta rting from a r equirements document and  
devising a solution to the specific problem that it describes. One of the major lessons of  
object technology is the lack of a clear-cut distinction betwee n problem and solution.  
Existing software can  and should influence new developments. 
When faced with a new software pr oject, the object-oriented sof tware developer  
does not accept the requirements  document as the alpha and omeg a of wisdom about the  
problem, but combines it with kno wledge about previous developm ents and available  
software libraries. If necessary , he will criticize the require ments document and propose  
updates and adaptations which wi ll facilitate the construction of the system; sometimes a  
minor change, or the removal of a facility which is of limited interest to the final users,  
will produce a dramatic simplific ation by making it possible to  reuse an entire body of  
existing software and, as a result, to decrease the development  time by months. The  
corresponding abstract ions are most likely to be found in the e xisting software, not in the  
requirements document for the new project. 
Classes COMMAND  and HISTORY_LOG  from the undo-redo example are typical.  
The way to find the right abstrac tions for this problem is not to rack one’s brain over the  
requirements document for a text editor: either you come upon t hem through a process of  
intellectual discovery (a “Eureka”, for which no sure recipe ex ists); or, if someone else has  
already found the solu tion, you reuse his abstractions. You may  of course be able to reuse  
the corresponding implementation too if it is available as part  of a library; this is even  
better, as the whole analysis-design-implementation work has al ready been done for you. The editor must allow its users to inse rt or delete a line at the current  
cursor position . Panel-driven system : 
chapter 20 . Undo-
redo: chapter 21 . 
See “THE CHANG-
ING NATURE OF ANALYSIS”, 27.2, page 906 .
§22.1   STUDYING A REQUIREMENTS DOCUMENT 725
Discovery and rejection
It takes two to invent anything. One ma kes up combinations ; the other chooses,  
recognizes what is import ant to him in the mass of  things which the first has  
imparted to him. What we ca ll genius is much less the work of the fi rst than the  
readiness of the second to choose fr om what has been laid before him.
Paul Valéry (cited in [Hadamard 1945] ).
Along with its straightforward lessons, this discussion has tau ght us a few more  
subtle consequences.
The simple lessons have been enc ountered several times: do not put too much trust  
in a requirements do cument; do not put any trust in gramma tical criteria.
A less obvious lesson has emerged from the review of “false ala rms”: just as we need  
criteria for finding classes , we need criteria for rejecting  candidate classes — concepts  
which initially appear promising  but end up not justifying a cl ass of their own. The design  
discussions of this book il lustrate many such cases.
To quote just one example: a discussion, yet to come, of how be st to provide for pseudo-
random number generation, start s naturally enough by considerin g the notion of random  
number, only to dismiss it as not the appropriate data abstract ion.
The O-O analysis and d esign books that I hav e read include litt le discussion of this  
task. This is surprisi ng because in the prac tice of advising O- O projects, especially with  
relatively novice teams, I have found that eliminating bad idea s is just as important as  
finding good ones.
It may even be more important. Sit down with a group of users, developers and  
managers trying to get started with object technology with a fr esh new project and  
enthusiasm fresher yet. There wi ll be no dearth of ideas for cl asses (usually proposed as  
“objects”). The problem  is to dam the torre nt before it damns t he project. Al though some  
class ideas will probably have been missed, many more will have  to be examined and  
rejected. As in a large-scale po lice investigation, many leads c o m e  i n ,  p r o m p t e d  o r  
spontaneous; you must sort the useful ones from the canards.
So we must adapt and extend the question that serves as the top ic for this chapter.  
“How to find the classes” means two things: not just how to com e up with candidate  
abstractions but also how to unma sk the inadequate among them. These two tasks are not  
executed one after the other; in stead, they are constantly inte rleaved. Like a gardener, the  
object-oriented designer must all the time nurture the good pla nts and weed out the bad:
The rest of this chapt er studies bot h components of the class e licitation process.Class Elicitation principle
Class elicitation is a  dual process:  class suggestion, class re jection.“Pseudo-random 
number generators: a design exercise”, page 754 .
HOW TO FIND THE CLASSES  §22.2 726
22.2  DANGER SIGNALS
To guide our search it is preferable to start with the rejectio n part. It will provide us with  
a checklist of typical pitfalls, a lert us to the most important  criteria, and help us keep our  
search for good classes focused on the most prod uctive efforts.
Let us review a few signs that u sually indicate a bad choice of  class. Because design  
is not a completely formalized d iscipline, you should not treat  these signs as proof of a bad  
design; in each case one can thin k of some circumstances that m ay make the original  
decision legitimate. So what we will see is not, in the terms o f a previous chapter,  
“absolute negatives” (s ure-fire rules for rejecting a design) b ut “advisory negatives”:  
danger signals that alert you to the presence of a suspicious p attern, and should prompt  
you to investigate furth er. Although in most cases they should lead you to revise the  
design, you may occasionally deci de in the end th at it is right  as it stands.
The grand mistake
M a n y  o f  t h e  d a n g e r  s i g n a l s  d i s c u s s e d  b e l o w  p o i n t  t o  t h e  m o s t  c o mmon and most  
damaging mistake, which is also t he most obvious:  designing a c lass that isn’t. 
The principle of object-oriente d software construction is to bu ild modules around  
object types, not functions. This  is the key to the reusability  and extendibility benefits of  
the approach. But beginners will  often fall into the most obvio us pitfall: calling “class”  
something which is in fact a routine. Writing a module as class … feature  … end does not  
make it a true class; it may j ust be a routine in disguise.
This Grand Mistake is easy to a void once you are conscious of t he risk. The remedy  
is the usual one: make sure that  each class corresponds to a me aningful data abstraction.
What follows is a set of typical  traits alerting you to the ris k that a module which  
presents itself as a candidate class, and has the syntactical t rappings of a class, may be an  
illegal immigrant not d eserving to be granted citizenship in th e O-O society of modules.
My class performs …
In a design meeting, an architec t u r e  r e v i e w ,  o r  s i m p l y  a n  i n f o r mal discussion with a  
developer , you ask about the role of a certain class. The answe r: “This class prints the  
results ” or “ this class pars es the input ”, or some other  variant of “ This class does …”.
The answer usually points to a d esign flaw. A class is not supp osed to do one thing  
but to offer a number of services (features) on objects of a ce rtain type. If it really does  
just one thing, it is probably a case of the Grand Mistake: dev ising a class for what should  
just be a routine of some other class.
Perhaps the mistake is not in the class itself but in the way i t is being described, using  
phraseology that is too opera tional. But you had better check.
In recent years the “ my class does …” style has become widespread. A NeXT document  
describes classes as follows: “ The NSTextView  class declares the programmatic interface  
to objects that display text laid out …”; “An NSLayoutManager  coordinates the layout  “A typology of 
rules”, page 666 .
NeXT documenta-
tion for OpenStep , 
pre-release 4 .0.
§22.2   DANGER SIGNALS 727
and display of characters …”; “ NSTextStorage  is a semi-concrete subclass of  
NSMutableAttributedString that manages a set of client NSLayoutManagers , notifying  
them of any changes …”. Even if (as is most likely the case here) the classes discus sed 
represent valuable data abstrac tions, it would be preferable to  describe them less  
operationally by emphasizing these abstrac tions.
Imperative names
Assume that in a tentative design you find a class name such as  P ARSE  or PRINT  — a verb  
in the imperative or infinitive. It should catch your attention , as signaling again a probable  
case of a class that “does one  thing”, and shoul d not be a clas s.
Occasionally you may find that the class is right. Then its nam e is wrong. This is an  
“absolute positive” rule:
Although like any other one pert aining to style this rule is pa r t l y  a  m a t t e r  o f  
convention, it helps enforce the principle that every class rep resents a data abstraction
The first form, nouns, covers th e vast majority of cases. A nou n may be used by  
itself, as in TREE , or with some qualifying words, as in LINKED_LIST , qualified by an  
adjective, and LINE_DELETION , qualified by another noun.
The second case, adjec tives, arises only for a specific case: structural  property
classes describing an abstract s tructural property, as with the  Kernel Library class  
COMP ARABLE describing objects on which a certain order relation is availab le. Such  
classes should be defe rred; their names (in  English or French) will often end with ABLE . 
They are meant to be used throug h inheritance to indicate that all instances of a class have  
a certain property; for example in a system for keeping track o f tennis ran kings class  
PLAYER  might inherit from COMP ARABLE . In the taxonomy of i nheritance kinds, this  
scheme will be  classified as structure inheritance .
The only case that may seem to s uggest an exception to the rule  is command classes,  
as introduced in the undo-redo d esign pattern to cover action a bstractions. But even then  
you should stick to the rule: call a text editor’s command clas ses LINE_DELETION  and 
WORD_CHANGE , not DELETE_LINE  and REPLACE_WORD .
English leaves you more flexibil ity in the application of this rule than many other  
languages, since its grammatical categories are more an article  of faith than an observation  
of fact, and almost every verb can be nouned. If you use Englis h as the basis for the names  
in your software it is fair to take advantage of this flexibili ty to devise shorter and simpler  
names: you may call a class IMPORT  where other languages might treat the equivalent as  
a verb only, forcing you to use nouns such as IMPORTATION . But do not cheat: class  Class Name rule
A class name must always be either:
• A noun, possibly qualified.
• (Only for a deferred class desc ribing a structural property) a n adjective.
“Structure inheri-
tance”, page 831 .
See chapter 21 . 
HOW TO FIND THE CLASSES  §22.2 728
IMPORT  should cover the abstraction “objects being imported” (nominal ), not, except for  
a command class, the act  of importing (verbal).
It is interesting to contrast th e Class Name rule with the disc ussion of the “underline the  
nouns” advice at the beginning of this chapter. “Underline the nouns” applied a formal  
grammatical criterion to an informal natural-language text, the  requirements document;  
this is bound to be of dubious value. The Class Name rule, on t he other hand, applies the  
same criterion to a formal  text — th e software.
Single-routine classes
A typical symptom of the Grand M istake is an effective class th at contains only one  
exported routine, possibly callin g a few non-exported ones. The  class is probably just a  
glorified subroutine — a unit of  functional rath er than object- oriented decomposition.
A possible exception arises for objects that legi timately repre sent abstracted actions,  
for example a command in an interactive system, or what in a no n-O-O approach would  
have been represented by a routine passed as argument to anothe r routine. But the examples  
given in an earlier discussion show clearly enough that even in  such cases there will usually  
be several applicable features. We noted that a mathematical so ftware object representing  
a function to be integrated w ill not just have the feature item (a: REAL ): REAL , giving the  
value of the function at point a: others may include domain of definition, minimum and  
maximum over a certain interval, derivative. Even if a class do es not yet have all these  
features, checking that it would make sense to add them later w ill reinforce your conviction  
that you are dealing with a  genuine object abstraction.
In applying the single-routine ru le, you should consider all th e features of a class:  
those introduced in the class it self, and those which it inheri ts from its parents. It is not  
necessarily wrong for a class text to declare only one exported  routine, if this is simply an  
addition to a meaningful abstrac tion defined by its ancestors. It may, however, point to a  
case of taxomania , an inheritance-related disease  w h i c h  w i l l  b e  s t u d i e d  a s  p a r t  of the  
methodology of inheritance.
Premature classification
The mention of taxomania suggest s a warning about another commo n mistake of novices:  
starting to worry about the inhe ritance hierarchy too early in the process.
A s  i n h e r i t a n c e  i s  c e n t r a l  i n  t h e  o b j e c t - o r i e n t e d  m e t h o d ,  s o  i s  a good inheritance  
structure — more accurately, a g ood modular structure, includin g both inheritance and  
client relations — essential to the quality of a design. But in heritance is only relevant as a  
relation among well-understood a bstractions. When you are still  looking for the  
abstractions, it is too early to  devise the inheritance hierarc hy.
The only clear exception arises when you are dealing with an ap plication domain for  
which a pre-existing taxonomy is w idely accepted, as in some br anches of science. Then  
the corresponding abstractions w ill emerge together with their inheritance structure.  
(Before accepting the taxonomy as  the basis for your software’s  structure, do check that it  
is indeed well recognized and st able, not just so meone’s view o f things.)See “Small classes”, 
page 714 . 
See “TAXOMANIA”, 
24.4, page 820 . 
§22.2   DANGER SIGNALS 729
In other cases, you should only design the inheritance hierarch y once you have at  
least a first grasp of the abstr actions. (The classification ef fort may of course lead you to  
revise your choice of abstractions, prompting an iterative proc ess in which the tasks of  
class elicitation and inheritance structure design feed each ot her.) If, early in a design  
process, you find the participan ts focusing on c lassification i ssues even thou gh the classes  
are not yet well unde rstood, they are proba bly putting the cart  before the horse.
With novices, this may be a variant of the object-class confusi on. I have seen people  
start off with inheritan ce hierarchies of the “ SAN_FRANCISCO  and HOUSTON  inherit  
from CITY   ” kind — simply to model a sit uation where a single class, CITY , will have  
several instances at run time.
No-command classes
Sometimes you will find a class that has no routine at all, or only provides queries (ways  
to access objects) but no command s (procedures to  modify object s). Such a class is the  
equivalent of a record in Pascal  or a structure in Cobol or C. It may indicate a design  
mistake, but the mistake may be of two kinds and you will need to probe further.
First, let us examine three ca ses in which the class does not indicate improper design:
• It may represent objects obtained from the outside world, whic h the object-oriented  
software cannot change. They could be data coming from a sensor  in a process-
control system, packets from a packet-switching network, or C s tructures that the O-
O system is not supposed to touch.
•Some classes are meant not for direct instantiation, but for en capsulating facilities  
such as constants, used by other  classes through  inheritance. S uch facility  
inheritance  will be studied in the discus sion of inheritance methodology.
•Finally , a class may be applicative , that is to say describ e non-modifiable objects;  
instead of commands to modify an o bject it will provide functio ns that produce new  
objects, usually of the same typ e. For example the addition ope ration in classes  
INTEGER , REAL and DOUBLE  follows the lead of mathematics: it does not modify  
any value but, given two values x and y, produces a third one x + y . In the abstract  
data type specification such fun ctions will, like others that y i e l d  c o m m a n d s ,  b e  
characterized as command functions.
I n  a l l  t h e s e  c a s e s  t h e  a b s t r a c t i o n s  a r e  e a s y  t o  r e c o g n i z e ,  s o  y ou should have no  
difficulty identifying the two ca ses that may indeed point to a  design deficiency.
Now for these suspicious cases. In the first one, the class is justified and would need  
commands; the designer has simply  forgotten to provide mechanis ms to modify the  
corresponding objects. A simple checklist technique presented i n the discussion of class  
design will help avoid such mistakes.
In the second case, most directl y relevant to this discussion, the class was not  
justified. It is not a real data  abstraction, simply some piece  of passive info rmation which  
might have been repres ented by a structure such as a list or ar ray, or just by adding more  
attributes to another class. This case somet imes happens when d evelopers write a class for  “F ACILITY INHERI-
TANCE”, 24.9, page 847. 
Command functions 
were defined in “Func-tion categories”, page 134. 
See “A checklist”, 
page 770 .
HOW TO FIND THE CLASSES  §22.2 730
what would have been a simple re cord (structure) type in Pascal , Ada or C. Not all record  
types cover separate  data abstractions.
You should investigate such a ca se carefully to try to understa nd whether there is  
room for a legitimate class, now  or in the future. If the answe r is unclear, you may be better  
off keeping the class anyway even if it risks being overkill. H aving a class may imply  
some performance overhead if it means dealing with many small o bjects, dynamically  
created one by one and occupying more space  than simple array e lements; but if you do  
need a class and have not introdu ced it early enough, the adapt ation may take some effort.
We had such a false start in the history of ISE’s compiler. A c ompiler for an O-O language  
needs some internal way to iden tify each class of a system it p rocesses; the identification  
used to be an integer. This work ed fine for several years, but at some point we needed a  
more elaborate class identification scheme, allowing us in part icular to renumber  classes  
when merging several systems. The solution was to introduce a c lass CLASS_
IDENTIFIER , and to replace the earlier integers by instances of that clas s. The conversion  
effort was more than we would have liked, as usually happens wh en you have missed an  
important abstraction. Initially INTEGER  was a sufficient abstraction because no  
commands were applicable to clas s identifiers; the need for mor e advanced features, in  
particular renumbering commands , led to the recognition of a se parate ab straction.
Mixed abstractions
Another sign of an imperfect design is a class whose features r elate to more than  
one abstraction.
In an early release of the NeXT library, the text class also pr ovided full visual text editing  
capabilities. Users complained that the class, although useful,  was too big. Large class size  
was the symptom; the true problem was the merging of two abstra ctions (character string,  
and interactively editable text); the solution was to separate the two abstractions, with a  
class NSAttributedString  defining the basic string handling mechanism and various other s,  
such as NSTextView , taking care of the user interface aspects.
Meilir Page-Jones uses the term connascence  (defined in dictionaries as the property  
of being born and having grown t ogether) to describe the relati on that exists between two  
features when they are closely connected, based on a criterion of simultaneous change: a  
change to one will imply a chang e to the other. As he points ou t, you should minimize  
connascence across class librarie s; but features that appear wi thin a given class should all  
be related to the same clearly identified abstraction.
This universal guideline deserve s to be expressed as a methodol ogical rule  
(presented in “positive” form a lthough it follows a discussion of possible mistakes):
The ideal class
This review of possible mistakes  highlights, by contrast, what the ideal class will look like.  
Here are some of the typical properties:Class Consistency principle
All the features of a class must  pertain to a single, well-iden tified abstraction.[Page-Jones 1995] .
§22.3   GENERAL HEURISTICS FOR FINDING CLASSES 731
• There is a clearly associated a bstraction, which can be descri bed as a data abstraction  
(or as an abstract machine).
• The class name is a n oun or adjective, ade quately characterizi ng the abstraction.
• The class represents a set of p ossible run-time  objects, its i nstances. (Some classes  
are meant to have only one insta nce during an exe cution; that i s acceptable too.)
• Several queries are a vailable to find out properties of an ins tance.
• Several commands are available to change the state of an insta nce. (In some cases,  
there are no commands but instea d functions produ cing other obj ects of the same  
type, as with the operations on integers; that is acceptable to o.)
• Abstract properties can be stat ed, informally or (preferably) formally, describing:  
how the results of the various q ueries relate to each other (th is will yield the  
invariant); under what conditions  features are applicable (prec onditions); how  
command execution aff ects query results (postconditions).
This list describes a set of inf ormal goals, not a strict rule.  A legitimate class may  
have only some o f the properties listed. Most of the examples t hat play an important role  
in this book — from LIST  and QUEUE  to BUFFER , ACCOUNT , COMMAND , STATE , 
INTEGER , FIGURE , POLYGON  and many others — have them all.
22.3  GENERAL HEURISTICS FOR FINDING CLASSES
Let us now turn to the positive part of our discussion: practic al heuristics for finding classes.
Class categories
We may first note that there are three broad categories of clas ses: analysis classes, design  
classes and implementation class es. The division is neither abs olute nor rigorous (for  
example one could find arguments  to support attaching a deferre d class LIST  to any one  
of the three categories), but it is convenient as a general gui deline.
An analysis class describes a data abstraction directly drawn f rom the model of the  
external system. PLANE  in a traffic control system, P ARAGRAPH  in a document  
processing system, P ART  in an inventory control sy stem are typical examples.
An implementation class describe s a data abstraction introduced  f o r  t h e  i n t e r n a l  
needs of the algorithms in  the software, such as LINKED_LIST  or ARRAY .
In-between, a design class descri bes an architectural choice. E xamples included  
COMMAND  in the solution to the undo-redo problem, and STATE  in the solution to the  
problem of panel-driven systems.  Like implementation classes, d esign classes belong to  
the solution  space, whereas analysis classes belong to the problem space. B ut like analysis  
classes and unlike implementatio n classes they d escribe high-le vel concepts.
As we study how to obtain classes in these three categories, we  will find that design  
classes are the most difficult t o identify, because they requir e the kind of architectural  
HOW TO FIND THE CLASSES  §22.3 732
insight that sets the gifted designer apart. (That they are the  most difficult to find does not  
mean they are the most difficult to build , a distinction that u sually belongs to the  
i m p l e m e n t a t i o n  c l a s s e s ,  u n l e s s  o f  c o u r s e  y o u  c o m e  a c r o s s  a  r e a d y-to-be-reused  
implementation library.)
External objects: finding the analysis classes
Let us start with the analysis classes, modeled after external objects.
We use software to obtain answer s to certain questions about th e world (as in a  
program that computes the solution to a specific problem), to i nteract with the world (as  
in a process control system), or to add things to the world (as  in a text proce ssing system).  
In every case, the software must  be based on some model of the aspects of the world that  
are relevant to the application,  such as laws of physics or bio logy in a scient ific program,  
the syntax and semantic s of a computer lang uage in a compiler, salary scales in a payroll  
system, and income tax regulati ons in tax processing software.
To talk about the world being modeled we should avoid the term “real world”, which is  
misleading, both because software is no less “real” than anythi ng else and because many  
of the non-software “worlds” of interest are artificial, as in the case of a mathematical  
program dealing with equations and graphs. (An earlier chapter discussed this question  
in detail.) We should talk about the external world , as distinct from the internal world of  
the software that deals with it.
Any software system is based on an operational model  o f  s o m e  a s p e c t  o f  t h e  
external world. Operational beca use it is used to generate prac tical results and sometimes  
to feed these results back into the world; model because any us eful system must follow  
from a certain interpretatio n of some world phenomena.
Nowhere perhaps is this view of software as inescapable as in t he area of simulation . 
It is no accident that the first object-oriented language, Simu la 67, evolved from Simula 1,  
a language for writing discrete-event simulations. Although Sim ula 67 itself is a general-
purpose programming language, it retained the name of its prede cessor and includes a set  
of powerful simulation primitives. Well into the nineteen-seven ties, simulation remained  
the principal application area of object technology (as a look into the proceedings of the  
annual Association of Simula Users conferences suffices to show ). This attraction of O-O  
ideas for simulation is easy to understand: to devise the struc ture of a software system  
simulating the behavior of a set of external objects, what coul d be better than using  
software components which directly represent those objects?
In a broad sense, of course, all software is simulation. Capita lizing on this view of  
software as operational modeling,  object-oriented software cons truction uses as its first  
abstractions some types deduced from analyzing the principal ty pes of objects, in the non-
software sense of the term, in the external world: sensors, dev ices, airplanes, employees,  
paychecks, tax returns, paragraphs, integrable functions.
These examples, by the way, suggest only part of the picture. A s Waldén and Nerson note  
in their presentation of the B.O.N. method:See “Reality: a 
cousin twice removed”, page 230 .
 See “SIMULA”, 
35.1, page 1113 .
§22.3   GENERAL HEURISTICS FOR FINDING CLASSES 733
A class representing a car is no more tangible than one that models the job  
satisfaction of employees . What counts is how important the concepts are to  
the enterprise , and what you can do with them .
Keep this comment in mind when looking for external classes: th ey can be quite abstract.  
SENIORITY_RULE  for a parliament voting system and MARKET_TENDENCY  f o r  a  
trading system may be just as real as SENATOR and STOCK_EXCHANGE . The smile of  
the Cheshire Cat has as much c laim to objectness as the Cheshir e Cat.
Whether material or abstract, ex t e r n a l  c l a s s e s  r e p r e s e n t  t h e  a b stractions that  
specialists of the external world , be they aerosp ace engineers,  accountants or  
mathematicians, constantly use t o think and talk about their do main. There is always a  
good chance — although not a certainty — that such an object ty pe will yield a useful  
class, because typically the doma in experts will have associate d significant operations and  
properties with it.
The key word, as usual, is abstraction . Although it is desirabl e that analysis classes  
closely match concepts  from the problem domain, this is not wha t makes a candidate class  
good. The first version of our p anel-driven syst em dramatically  showed why: there we had  
a model directly patterned after  some properties of the externa l system, but terrible from  
a software engineering viewpoint because the selected propertie s were low-level and  
subject to change. A good extern al class will be based on abstr act concepts of the problem  
domain, characterized (in the AD T way) through external feature s chosen because of their  
lasting value.
For the object-oriented develope r such pre-existing abstraction s are precious: they  
provide some of the system’s fundamental classes; and, as we ma y note once more, the  
objects are here f or the picking.
Finding the implementation classes
Implementation classes describe the structures t hat software de velopers use to make their  
systems run on a computer. Althou gh the fashion in the software  engineering literature has  
been, for the past fifteen years , to downplay the role of imple mentation, developers know  
the obvious — that implementati on consumes a large part of the effort in building a  
system, and much of the intel ligence that goes into it.
The bad news is that implementation is difficult. The good news  i s  t h a t  
implementation classes, although often hard to build  in the absence of good reusable  
libraries, are not the most difficult to elicit , thanks to the ample body of literature on the  
topic. Since “Data Structures an d Algorithms”, sometimes known as “CS 2”, is a required  
component of computing science e ducation, many te xtbooks survey  the rich catalog of  
useful data structures that have  been identified over the years . Better yet, although most  
existing textbooks do not explic itly use an object-oriented app roach, many naturally  
f o l l o w  a n  a b s t r a c t  d a t a  t y p e  s t y le, even if they do not use the  phrase, to present data  
structures; for example to introduce various forms of table suc h as binary search trees and  
hash tables you have first to sta te the various operations (ins ert an element with its key,  
search for an element through its key and so on) with their pro perties. The transition to  
classes is fairly straightforward.[Waldén 1995],  
pages 182-183 .
HOW TO FIND THE CLASSES  §22.3 734
Recently, some textbooks have star ted to go further by applying  a thoroughly object-
oriented approach to the traditional CS 2 topics.
Whether or not he has gone throu gh a Data Structures and Algori thms Course at  
school, every software engineer s hould keep a good textbook on the topic within reach of  
hand, and go back to i t often. It is all too easy to waste time  reinventing con cepts that are  
well known, implement a less-tha n-optimal algorithm, or choose a representation that is  
not appropriate for the software ’s use of a data structure — fo r example a one-way linked  
list for a sequential structure t hat the algorithms must regula rly traverse back and forth, or  
an array for a structure that constantly grows and shrinks in u npredictable ways. Note that  
here too the ADT approach reigns: the data structure and its re presentation follow from  
the services offered to clients.
B e y o n d  t e x t b o o k s  a n d  e x p e r i e n c e ,  t h e  b e s t  h o p e  f o r  i m p l e m e n t a t i o n  c l a s s e s  i s  
reusable libraries, as we will see at the end of this chapter.
Deferred implementation classes
Traditional data structures text books naturally emphasize effec tive (fully implemented)  
classes. In practice, much of th e value of a set of implementat ion classes, especially if they  
are meant to be reusable, lies i n the underlying taxonomy, as d efined by an inheritance  
structure that will include deferred classes. For example, vari ous queue implementations  
will be descendants o f a deferred class QUEUE describing the abstract concept of  
sequential list.
“Deferred implementation class”,  then, is not an oxymoron. Clas ses such as  
QUEUE , although quite abstract, help build the taxonomies thanks to which we can keep  
the many varieties of implemen tation structures coherent and or ganized, assigning to  
every class a precise place  in the overall scheme.
In another book [M 1994a]  I have described a “Linnaean” taxonomy of the  
fundamental structures of computi ng science, which relies on de ferred classes to classify  
the principal kinds of data structure used in software developm ent.
Finding the design classes
Design classes represent archite ctural abstractions that help p roduce elegant, extendible  
software structures. STATE , APPLICATION , COMMAND , HISTORY_LIST , iterator  
classes, “controller” classes as  in the Smalltalk MVC model are  good examples of design  
classes. We will see other semin al ideas in subsequent chapters , such as active data  
structures and “handles” for plat form-adaptable portable librar ies.
Although, as noted, the re is no sure way to  find design classes , a few guidelines are  
worth noting:
•Many design classes have been de vised by others before. By read ing books and  
articles that describe precise s olutions to design problems, yo u will gain many  
fruitful ideas. For example the book Object-Oriented Applications contains chapters  
written by the lead designers o f various industrial projects wh o describe their   About iterators and 
MVC see the bibli-ographical notes .
[M 1993].
§22.4   OTHER SOURCES OF CLASSES 735
architectural solutions in detail , providing precious guidance to others faced with  
similar problems in telecommunica tions, Computer-Aided Design, artificial  
intelligence and oth er application areas.
•The book on “design patterns” by Gamma et al. has started an effort of capturing  
proven design solutions and is n ow being followed by several ot hers.
• Many useful design classes desc ribe abstractions that are bett er understood as  
machines than as “objects” in th e common (non-software) sense.
• As with implementation classes,  reuse is preferable to inventi on. One can hope that  
many of the “patterns”  currently being stud ied will soon cease to be mere ideas,  
yielding instead directly  usable library classes.
22.4  OTHER SOURCES OF CLASSES
A number of heuristics have prove d useful in the quest for the right abstractions.
Previous developments 
The advice of looking first at w hat is available does not just apply to library classes. As  
you write applications, you will accumulate classes which, if p roperly designed, should  
facilitate later developments. 
Not all reusable software was bo rn reusable. Often, the first v ersion of a class is  
produced to meet some immediate requirement rather than for pos terity. If reusability is a  
concern, however, it pays to devo te some time, after the develo pment, to making the class  
more general and robust, improvi ng its documentation, adding as sertions. This is different  
from the construction of software meant from the start to be re usable, but no less fruitful.  
Having evolved from components o f actual systems, the resulting  classes have passed the  
first test of reusability, namely usability : they serve a t least one useful purpose. 
Adaptation through inheritance 
When you discover the existence of a potentially useful class, you will sometimes find that  
it does not exactly sui t your present need: some adaptation may  be necessary. 
Unless the adaptation addresses a deficiency which should be co rrected in the  
original as well, it i s generally preferabl e to leave the class  undisturbed, preserving its  
clients according to the Open-Cl osed principle. Instead, you ma y use inheritance and  
redefinition to tune the  class to your new need. 
This technique, which our later taxonomy of uses of inheritance  will study in detail  
under the name variation inheritance , assumes that the new class  describes a variant of the  
same abstraction as the original. If used properly (according t o the guidelines of the later  
discussion) it is one of the most remarkable  contributions of t he method, enabling you to  
resolve the reuse-redo  dilemma: combining reusab ility with extendibility.[Gamma 1995].
See “GENERAL-
IZATION”, 28.5, page 928 .
See “Variation 
inheritance”, page 828.
HOW TO FIND THE CLASSES  §22.4 736
Evaluating candidate decompositions
Criticism is said to be easier than art; a good way to learn de sign is to learn to analyze  
existing designs. In particular, when a certain set of classes has been proposed to solve a  
certain problem, you should study them from the criteria and pr inciples of modularity  
given in chapter 3: do they constitute autonomous,  coherent module s, with strictl y 
controlled communication channels ? Often, the discovery that tw o modules are too tightly  
coupled, that a module communicat es with too many others, that an argument list is too  
long, will pinpoint des ign errors and lead to a better solution .
An important criterion was explored in the panel-driven system example: data flow.  
We saw then how important it is to study, in a candidate class structure, the flow of objects  
passed as arguments in successive calls. If, as with the notion  of State in that example, you  
detect that a certain item of information is transmitted over m any modules, it is almost  
certainly a sign that you have missed an important data abstrac tion. Such an analysis,  
which we applied to obtain the class STATE , is an important sou rce of abstractions. 
It is of course preferable to find the classes right from the s tart; but better late than  
never. After such an a posteriori class discovery, you should t ake the time t o analyze why  
the abstraction was initially mi ssed, and to reflect on how to do better next time.
Hints from other approaches
The example of analyzing data flow in a top-down structure illu strates the general idea of  
deriving class insights from con cepts of non-O-O decompositions . This will be useful in  
two non-disjoint cases:
• There may already exist a non-O-O software system which does p art of the job; it  
may be interesting to examine it  for class ideas. The same woul d apply if, instead of  
a working system, you can use the result of an analysis or desi gn produced with  
another, older method.
• Some of the people doing the de velopment may ha ve had extensiv e experience with  
other methods, and as a conseque nce may initially think in term s of different  
concepts, some of which may be turned into class ideas.
Here are examples of this process, starting with programming la nguages and  
continuing with analysis and design techniques.
Fortran programs usually  include one or more common blocks  — data areas that can  
be shared by several routines. A common block often hides one o r more valuable data  
abstractions. More precisely, go o d  F o r t r a n  p r o g r a m m e r s  k n o w  t h a t a common block  
should only include a few variab les or arrays, covering closely  related concepts; there is a  
good chance that such a block wi ll correspond to one class. Unf ortunately, this is not  
universal practice, and even prog rammers who know better than t o use the “garbage  
common block” mentioned at the be ginning of this book tend to p ut too many things in  
one common block. In this case yo u will have to examine pattern s of use of each block to  
discover the abstraction or a bstractions tha t it covers.Chapter 20 .
On garbage common 
blocks see “Small Interfaces”, page 48 .
§22.4   OTHER SOURCES OF CLASSES 737
Pascal and C programs use records, known in C as structures. (P ascal only has record  
types ; in C you can have structure typ es as well as individual struc tures.) A record type  
often corresponds to a class, but  only if you can find operatio ns acting specifically on  
instances of the type, usually ( as we saw) including commands a s well as queries. If not,  
the type may just represent some  attributes of a nother class.
Cobol also has structures, and it s Data Division helps identify  important data types.
In entity-relationship (ER) model ing, analysts isolate “entitie s ”  w h i c h  c a n  o f t e n  
serve as seeds for classes. 
People with a long practice of ER modeling are among those who sometimes find it  
initially hard to apply object-oriented ideas effecively, becau se they are used to treating  
the entities and relationships as being different in nature, an d the “dynamic” behavior of  
the system as completely separate from them. With O-O modeling both the relationships  
and the behavior yield features attached to the types of object s (entities); thinking of  
relations and operations as variants of the same notion, and at taching them to entities,  
sometimes proves to be a little hard to swallow at first.
In dataflow design (“structured analysis and desi gn”) there is little that can be  
directly used for an object-orie nted decomposition, but sometim es the “stores” (database  
or file abstractions) ca n suggest an abstraction.
Files
The comment about stores suggests a more general idea, useful a gain if you are coming from  
a non-O-O background. Sometimes m uch of the intelligence of a t raditional system is to be  
found outside of the software’s text, in the structure of the f iles that it manipulates.
T o anyone with Unix experience, this idea will be clear: for so me of the essential  
information that you need to lea rn, the essential documentation  is the description not of  
s p e c i f i c  c o m m a n d s  b u t  o f  c e r t a i n  k e y  f i l e s  a n d  t h e i r  f o r m a t s :  passwd  for passwords,  
printcap for printer properties, termcap  or terminfo  for terminal properties. One could  
characterize these files as data  abstractions without the abstr action: although documented  
at a very concrete level (“ Each entry in the printcap  file describes a printer , and is a line  
consisting of a number of fields separated by  : characters . The first entry for each printer  
gives the names which ar e known for the printer , separated by | characters ”, etc.), they  
describe important data types accessible through well-defined p rimitives,  w i t h  s o m e  
associated properties and usage conditions. In the transition t o an object-oriented view,  
such files would pl ay a central role.
A similar observation applies to many programs, whose principal  files embody some  
of the principal  abstractions.
I once participated in a consulting session with the manager of  a software system  
who was convinced that the system  — a collection of Fortran pro grams — could not lend  
itself to object-oriented decomp osition. As he was describing w hat the programs did, he  
c a s u a l l y  m e n t i o n e d  a  f e w  f i l e s  t hrough which the programs commu n i c a t e d .  I  s t a r t e d  
asking questions about these fil es, but initially he kept dismi ssing these questions as  
unimportant, immediately coming  back to the programs. I insiste d, and from his  
HOW TO FIND THE CLASSES  §22.4 738
explanations realized that the fi les described complex data str uctures embodying the  
programs’ essential information. The lesson was c lear: as soon as the relevance of these  
files was recognized, they conquer ed the central place in the o bject-oriented architecture;  
in an upheaval typical of object-o riented rearchitecturing, the  programs, formerly the key  
elements of the architecture, bec ame mere feature s of the resul ting classes.
Use cases
Ivar Jacobson has advocated relying on use cases as a way to el icit classes. A use case,  
called a scenario  by some other analysis an d design authors (and a trace in theoretical  
computing science, especially the  study of concur rency), is a d escription of 
a complete course of events initiated by a [user of the future system] and [of] 
the interaction between [the user] and the system .
In a telephone switching system, for example, the use case “cus tomer-initiated call”  
has the sequence of events: customer picks handset, identificat ion gets sent to the system,  
system sends dial tone, and so on. Other use cases for the syst em might include “caller-id  
service installati on” and “customer disconnection”. 
Use cases are a not a good tool f or finding classes. Relying on  them in any significant  
way raises sev eral risks:
•Use cases emphasize ordering (“ When a customer places an order over the phone , his 
credit card number is validated . Then the database is updated and a confirmation  
number is issued  ”, etc.). This is incompatible  with object technology: the meth od 
shuns early reliance on sequentia lity properties, because they are so fragile and  
subject to change. The competent O-O analyst and designer refus es to focus on  
properties of the form “The system does a, then b”; instead, he asks the question  
“What are the operations available on instances of abstraction A, and the constraints  
on these operations?”. The truly fundamental  sequentiality prop erties will emerge in  
the form of high-level constraints on the operations; for examp le, instead of saying  
that a stack supports alternating sequences of push and pop operations with never  
more pop than push , we define the preconditions attached with each of these  
operations, which imply the orde ring property but are more abst ract. Less  
fundamental ordering requirement s simply have no place in the a nalysis model as  
they destroy the system’s adaptability and hence its future sur vival. Early emphasis  
on ordering is among the worst mi stakes an O-O project can make . If you rely on use  
cases for analysis, this mi stake is hard to avoid.
• Relying on a scenario means tha t you focus on how users see th e system’s operation.  
But the system does not exist ye t. (A previous system might exi st, but if it were fully  
satisfactory you would not be as ked to change or rewrite it.) S o the system picture  
that use cases will give you is based on existing processes, co mputerized or not. Your  
task as a system builder is to come up with new, better scenarios, not to perpetuate  
antiquated modes of operation. T here are enough examples around  o f  c o m p u t e r  
systems that slavishly mim ic obsolete procedures.[Jacobson 1992],  
page 154 . Jacobson 
uses the term “actor” for users of the future system .
See “Ordering and 
O-O development”, page 111 and 
“Structure and 
order: the software developer as arson-ist”, page 201 .
§22.4   OTHER SOURCES OF CLASSES 739
• Use cases favor a functional approach, based on processes (act ions). This approach  
is the reverse of O-O decomposit ion, which focuses on data abst ractions; it carries a  
serious risk of reverting, under the heading of object-oriented  development, to the  
most traditional forms of functional design. True, you may rely  on several scenarios  
rather than just one main program . But this is still an approac h that considers what 
the system does  as the starting point, wherea s object technology considers what it  
does it to . The clash is irreconcilable.
The practical consequences are o bvious. A number of teams that have embraced use  
cases find themselves, without r ealizing it, practicing top-dow n functional design (“ the 
system must do a, then b, …”) and building systems that are obsolete on the day they are  
released, yet hard to change be cause they are ti ed to a specifi c view of what the system  
does. I have sat, as an outside c onsultant, in design reviews f or such projects, trying to  
push for more abstraction. But it is difficult to help, because  the designers are convinced  
that they are doing object-orien ted design; they expect the con s u l t a n t  t o  m a k e  a  f e w  
suggestions, criticize a few deta ils and give his  blessing to t he overall resul t. The designs  
that I saw were not object-orien ted at all, and were bound to y ield flawed systems; but  
trying to convey this observation politely was about as effecti ve as telling the group that  
the sun was not shinin g outside — we work from use cases, and d oesn’t everyone know  
that use cases are O-O?
The risks are perhaps less sever e with a very experienced objec t-oriented design  
team — experience being evidenced  by the team’s previous produc tion of large and  
successful O-O systems, in the t housands of classes and hundred s of thousands of lines.  
Such a group might find use case s useful as a complement to oth er analysis techniques.  
But for a novice team, or one with moderate experience only, th e benefits of use cases as  
an analysis tool are so uncertain, and the risk of destroying t he quality of the future system  
so great, as to recomme nd staying away alto gether from this tec hnique:
This principle does not mean tha t use cases are a worthless con cept. They remain a  
potentially valuable tool but th eir role in object-oriented sof tware construction has been  
misunderstood. Rather than an  analysis tool they are a validation tool. If (as you should)  
you have a separate quality assu rance team, it may find use cas es useful as a way to inspect  
a proposed analysis model or ten tative design for possibly miss ing features. The QA team  
can check that the sys tem will be able to run the typical scena rios identified by the users.  
(In some cases of negative answer you may find that the model w ill support a different  
scenario that ac hieves the same or bette r results. This is of c ourse satisfactory.)Use Case principle
Except with a very experienced d esign team (having built severa l successful  
systems of several thousand clas ses each in a pure O-O language ), do not rely  
on use cases as a tool for object-oriented analysis and design.
HOW TO FIND THE CLASSES  §22.5 740
Another possible application of use cases is to the final aspec ts of implementation,  
to make sure that the system includes routines for typical usag e scenarios. Such routines  
will often be of the abstract behavior kind, describing a gener al effective scheme relying  
on deferred routines which vario us components of the system, an d future additions to it,  
may redefine in different ways. ( [Jacobson 1992]  indeed mentions a notion of abstract use  
case that mirrors the object-orient ed concept of be havior class.
In these two roles as a validati on mechanism and an implementat ion guide, use cases  
can be beneficial. But in object t e c h n o l o g y  t h e y  a r e  n o t  a  u s e f ul analysis or design  
mechanism. The system analysts a nd builders shou ld concentrate on the abstractions, not  
on particular ways of scheduling  operations on these abstractio ns.
CRC cards
For completeness it is necessary  to mention an idea that is som etimes quoted as a  
technique to find classes. CRC cards ( Class , Responsibility , Collaboration ) are paper  
cards, 4 inches by 6 inches (10. 16 centimeters by 15.24 centime ters), on which designers  
discuss potential classes in ter ms of their responsibilities an d how they communicate. The  
idea has the advantage of being easy on the equipment budget (a  box of cards is typically  
cheaper than a workstation with CASE tools) and of fostering te am interaction. Its  
technical contribution to the de s i g n  p r o c e s s  —  t o  h e l p i n g  s o r t  out and characterize  
valuable abstractions — is, however, unclear.
22.5  REUSE
T he  ea s ie st  a nd m o st  p ro duc t iv e w ay  of  fi n di ng cl as se s is  no t t o have to invent them  
yourself, but to get them from a  library, pre-written by other designers and pre-validated  
by the experience of earlier reusers.
The bottom-up component
The bottom-up nature of object-o riented development should appl y throughout the  
software development p rocess, starting with  analysis. An approa ch that solely focuses on  
the requirements docum ent and user requests (as reflected for e xample by use cases) is  
bound to lead to a one-of-a-kind  system that will be expensive to build and may miss  
important insights obtained by previous projects. It is part of  the task of a development  
team, beginning at the requireme nts capture phase, to look at w hat is already available and  
see how existing classes may help  with the new development — ev en if, in some cases,  
this means adapting the original requirements.
Too often, when we talk about finding classes, we mean devising  t he m .  W i t h th e  
development of object technology, the grow th of quality librari es and the penetration of  
reusability ideas,  finding will more and more retain the dictionary’s sense of coming across .K. Beck and W . Cun-
ningham : “A Labora-
tory for Teaching O-O Thinking” , OOPSLA 
‘89 Proceedings , 
pages 1-6 .
§22.6   THE METHOD FOR OBTAINING CLASSES 741
Class wisdom
There used to live in the province of Ood a young m an who longed to know the  
secret of finding classes. He had approa ched all the local masters, but none of  
them knew. 
Having attended th e public penance of Yu-Ton, a former abbot of the Sacred  
Order of Arrows and Bubbles, he thought that perhaps this could mean the end  
of his search. Upon entering Yu’s cell , however, he found him still trying to  
understand the difference between Cl asses and Objects. Realizing that no  
enlightenment would come from there, he left without as king any questions. 
On his way home he overheard two donk ey-cart pushers wh ispering about a  
famous elder who was said to  know the secret of clas ses. The next day he set  
out to find that great Master. Many a ro ad he walked, many a hill he climbed,  
many a stream he crossed, until at last he reached the Master ’s hideout. By then  
he had searched for so long that he was no longer a young man; but like all  
other pilgrims he had to un dergo the thirty-three-month  purification rite before  
being permitted to meet the object of his quest. 
Finally, one black winter day as the snow was savagely hitting all the  
surrounding mountain peaks, he was admit ted into the Master’s audience room.  
With his heart beating at the pace of a boulder rolling down the bed of a dried-
up torrent, he faintly uttered his que stion: “Master, how can I find the  
classes?”.
The old sage lowered her head and answ ered in a slow, qu iet tone. “Go back  
to where you came from. The classes were already there.” 
So stunned was the questioner that it took him a few mo ments to noti ce that the  
Master’s attendants were already whiski ng her away. He barely  had time to run  
after the frail figure now disappeari ng forever. “Master” , he asked again  
(almost shouting this  time), “Just one more questi on! Please! Tell me how this  
story is called!” 
The old Teacher tiredly turned back he r head. “Should you not already know?  
It is the story of reuse.” 
22.6  THE METHOD FOR OBTAINING CLASSES
Touch by touch, the ideas discus sed in this chapter amount to w h a t  w e  m a y  n o t  t o o  
pretentiously call (provided we r emember that a method is a way  to incubate, nurture,  
channel and develop invention, n ot a substitute for invention) the method for obtaining the  
classes in object-orient ed software construction.
The method recognizes that class  identification requires two in extricably related  
activities: coming up with class suggestions; and weeding out t he less promising among  
them. The two tables which follo w summarize what we have learne d about these two  
activities. Only a few of the entries cover specific kinds of c lass, such as analysis classes;  
the rest of the advice is applicable to all cases.
HOW TO FIND THE CLASSES  §22.6 742
First, sources of class ideas:
Source of ideas What to look for
 
Existing libraries• Classes that address ne eds of the application.
• Classes that describe c oncepts relevant to the  
application.
 
 
Requirements 
document• Terms that occur frequently.
• Terms to which the text devotes explicit  
definitions.
• Terms that are not defined precisely but taken  
for granted througho ut the presentation.
• (Disregard grammatical categories.)
 
 
Discussions with 
customers and future users• Important abstractions of the application  
domain. 
• Specific jargon of the application domain.
• Remember that classes coming from the  
“external world” can describe conceptual
objects as well as material objects.
Documentation (such 
as user manuals ) for 
other systems (e.g. 
from competitors ) in 
the same domain• Important abstractions of the application  
domain. 
• Specific jargon of the application domain.
• Useful design  abstractions
 
 
 
 
 
 
Non-O-O systems or 
system descriptions• Data elements that are passed as arguments  
between various components of the software,  especially if th ey travel far.
• Shared memory areas ( COMMON  b l o c k s  i n  
Fortran).
• Important files.
•DATA DIVISION units (Cobol).
• Record types (Pascal), structures and structure  
types (C, C++), playing an important role in  
the software, in particu lar if they are used by  
various routines or mo dules (files in C).
• Entities in ER modeling.
Discussions with 
experienced designers• Design classes having been successfully used  
in previous developments  of a similar nature.
Algorithms and data 
structure literature• Known data structures  supporting efficient  
algorithms.
O-O design literature • Applicable design patterns.Sources of 
possible classes
§22.7   KEY CONCEPTS INTRODUCED IN THIS CHAPTER 743
Then, criteria for investigating potential classes more careful ly, and possibly  
rejecting them:
22.7  KEY  CONCEPTS INTRODUCED IN THIS CHAPTER
• Identifying the classes is one of the principal tasks of objec t-oriented software  
construction.
• To identify the cla sses is a dual process: class suggestion and class rejection. Just  
as important as identifying poten tial class candidates is the n eed to eliminate  
unsuitable ideas.Danger signal Why suspicious
Class with verbal 
name (infinitive or 
imperative )• May be a simple subro utine, not a class.
Fully effective class 
with only one exported routine • May be a simple subro utine, not a class.
Class described as 
“performing” something • May not be a proper data abstraction.
 
Class with no routine• May be an opaque piece of information, not an  
ADT. Or may be an ADT, the routines having  
just been missed.
Class introducing no or very few features (but inherits features 
from parents )• May be a case of “taxomania”.
Class covering several 
abstractions• Should be split into several classes, one per  
abstractionReasons for 
rejecting a 
candidate class
HOW TO FIND THE CLASSES  §22.8 744
• To identify the classes is to identify the relevant abstractio ns in the modeled domain  
and the solution space.
• “Underlining the nouns in the re quirements document” is not a sufficient technique  
for finding the classes, since its  results are too dependent on  stylistic issues. It may  
cause designers both to miss useful class es and to include unne cessary ones.
• A broad characterization of cla sses distinguishes analysis cla sses, tied to concepts of  
the external world being modeled, design classes, describing ar chitectural decisions,  
and implementation classes, desc ribing data stru ctures and algo rithms.
• Design classes tend to be the most difficult to invent.
• In designing external classes, remember that external objects include concepts as  
well as material things.
• To decide whether a certain no tion justifies defining an assoc iated class, apply the  
criteria of data abstraction.
• Implementation classe s  i n c l u d e  b o t h  e f f e c t i v e  c l a s s e s  a n d  t h e i r deferred  
counterparts, describi ng abstract categorie s of implementation techniques.
• Inheritance provides a  way to reuse previous designs while ada pting them.
• A way to obtain classes is to evaluate candidate designs and l ook for any unrecognized  
abstraction, in particular by an alyzing inter-module data trans mission.
• Use cases, or scenarios, may be useful as a validation tool an d as a guide to finalize  
an implementation, but should no t be used as an analysis and de sign mechanism.
• The best source of classe s is reusable libraries.
22.8  BIBLIOGRAPHICAL NOTES 
The advice to use nouns from the requirements as a starting poi nt for finding object types  
was made popular by [Booch 1986] , which credits the idea to an earlier article by Abbott.  
Further advice appears in [Wirfs-Brock 1990] .Russell J . Abbott in 
Comm . ACM , 26, 
11, Nov. 1983 , pp. 
882-894 .
§E22.1   EXERCISES 745
An article on formal specification [M 1985a]  analyzes the problems raised by  
natural-language requi rements documents. Working from a short n atural-language  
problem description which has be en used extensively in the prog ram verification  
literature, it identifies a larg e number of deficiencies and of f e r s  a  t a x o n o m y  o f  s u c h  
deficiencies (noise, ambiguity, contradiction, remorse, overspe cification, forward  
reference); it discusses how for mal specifications can remedy s ome of the problems.
[Waldén 1995]  presents useful advice for identifying classes. 
Appendix B of [Page-Jones 1995]  lists numerous “problem symptoms” in candidate  
object-oriented designs (for example “ class interface supports  illegal or dangerous  
behaviors ”), alerting designers to danger  signals such as have been poin ted out in the  
present chapter. The table, as w ell as the rest of Page-Jones’s  book, offers suggestions for  
correcting design deficiencies.
[Ong 1993]  describes a tool for converting non-O-O programs (essentially Fortran)  
to an object-oriented form. The conversion is semi-automatic, t hat is to say relies on some  
manual effort. Relevant to the pr esent chapter is the authors’ description of some of the  
heuristics they use for  identifying potential classes through a nalysis of the original code,  
in particular by looking at COMMON blocks.
Simula 1 (the simulation language that led to modern versions o f Simula) is  
described in [Dahl 1966] . See chapter 35 for more Simula references.
Typical data structures books, p roviding a precious source of i mplementation  
classes, include Knuth ’s famous treatise [Knuth 1968]  [Knuth 1981]  [Knuth 1973]  and 
numerous college textbooks such as [Aho 1974]  [Aho 1983] .
A recent text, [Gore 1996] , presents fundamental data st ructures and algorithms in a  
thoroughly objec t-oriented way.
Sources of design classes include [Gamma 1995] , presenting a number of “design  
patterns” for C++, and [M 1994a] , a compendium of library design techniques and  
reusable classes, discussing in detail the notions of “handle c lass” and “iterator class”.  
[Krief 1996]  presents the Smalltalk MVC model.
EXERCISES
E22.1  Floors as integers
Show how to define a class FLOOR  a s  h e i r  t o  INTEGER , restricting the applicable  
operations.See “Is a new class 
necessary?”, page 721 .
HOW TO FIND THE CLASSES  §E22.2 746
E22.2  Inspecting objects
Daniel Halbert and Patrick O’Brien discuss the following proble m, arising in the design  
of software development environments:
Consider the design of an inspector  facility , used to display information about  
an object in a debugger window : the contents of its fields , and perhaps some  
computed values . Different kinds of inspector are needed for different object  
types . For instance , all the relevant information about a point can be displayed  
at once in a simple format , while a large two-dimens ional array might best be  
displayed as a matrix scrollab le horizontally  and vertically .
You should first decide  where to put the beha vior of the inspector : in the  
[generating class ] of the object to be inspected or in a new , separate class ?
Answer this question by consider ing the pros and cons of variou s alternatives. ( Note : the 
inheritance-related di scussions of the follo wing chapters may b e useful.)From [Halbert 1987],  
slightly abridged .
23  
Principles of class design
Experienced software developers kno w that few issues are more cr itical than the proper  
design of module interfaces. In a multi-person, or just multi-w eek software p roject, many  
of the decisions, discussions, d isputes and conf usions tend to revolve around  matters of  
module interface speci fication: “Who takes care of making sure that…?”, “But I thought  
you only passed me  normalized input …”, “Why are you processing this since I already  
took care of it?”. 
If there were just one advantage  to expect from object technolo gy, this would have  
to be it. From the outset of thi s presentation, object-oriented  development has been  
described as an architectural technique for producing systems m ade of coherent, properly  
interfaced modules. We have now a ccumulated enough technical ba ckground to review  
the design principles through whi ch you can take advantage of t he best O-O mechanisms  
to develop modul es with attractive interfaces.
I n  t h e  f o l l o w i n g  p a g e s  w e  w i l l  e x p l o r e  a  s e t  o f  c l a s s  d e s i g n  p r inciples which  
extensive practice has shown to yield quality and durability. B ecause what determines the  
success of a class is how it will look to its clients, the emph asis here is not on the internal  
implementation of a class but on  how to make its interface simp le, easy to learn, easy to  
remember, and able to withstand the test of time and change.
We will successively examine: wh ether functions should be permi tted to have side  
effects; how many arguments a f eature should reasonably have, a nd the associated notions  
of operand and option; whether yo u should be conc erned about th e size of your classes;  
making abstract structures active ; the role of selective export s; how to document a class;  
how to deal with abnormal cases.
From this discussion will emerge  a n  i m a g e  o f  t h e  c l a s s  d e s i g n e r  as a patient  
craftsman who chisels out and po lishes each class to make it as  attractive as possible to  
clients. This spirit of treating classes as carefully engineere d products, aiming at  
perfection from the start and yet always perfectible, is a perv asive quality of well-applied  
object technology. For obvious r easons it is particularly visib le in the construction of  
library classes, and indeed many of the design principles revie wed in this chapter  
originated in library design; in the same way that successful i deas first tried in Formula 1  
racing eventually trickle down to the engineering of cars for t he rest of us, a technique that  
has shown its value by surviving  the toughest possible test — b eing applied to the  
development of a successful libra ry of reusable components — wi ll eventually benefit all  
object-oriented softwar e, whether or not in itially intended for  reuse.
DESIGNING CLASS INTERFACES  §23.1 748
23.1  SIDE EFFECTS IN FUNCTIONS
The first question that we must address will have a deep effect  on the style of our designs.  
Is it legitimate for functions —  routines that return a result — also to produc e a side effect,  
that is to say, to change som ething in their environment?
The gist of the answer is no, bu t we must first understand the role of side effects, and  
distinguish between good and pot entially bad side effects. We m ust also discuss the  
question in light of all we now k now about classes: their filia tion from abstract data types,  
the notion of abstraction functi on, and the role  of class invar iants.
Commands and queries
A few reminders on ter minology will be usef ul. The features tha t characterize a class are  
divided into commands  and queries . A  co mman d serves to mo dify  ob jects,  a qu ery  to  
return information about objects. A command is implemented as a  procedure. A  query  
may be implemented either as an attribute, that is to say by re serving a field in each run-
time instance of the class to hold the corresponding value, or as a function, that is to say  
through an algorithm that compute s the value when needed. Proce dures (which also have  
an associated algorithm) and func tions are together called rout ines.
The definition of queries does no t specify whether in the cours e of producing its  
result a query may change objects. For commands, the answer is obviously yes, since it is  
the role of commands (procedures ) to change things. Among queri es, the question only  
makes sense for functions, since accessing an attribute cannot change anything. A change  
performed by a function is known as a side effect  to indicate that it  is ancillary to the  
function’s official purpose of answering a query. Should we per mit side effects?
Forms of side effect
Let us define precisely what con structs may cause side effects.  The basic operation that  
changes an object is an assignment a := b (or an assignment attempt a ?= b, or a creation  
instruction  create  a) where the target a is an attribute; execution of this operation will assign  
a new value to the fie ld of the correspondin g object (the targe t of the current routine call).
We only care about s uch assignments when a is an attribute: if a is a local entity, its  
value is only used during an execution of the routine and assig nments to it have no  
permanent effect; if a is the entity Result  denoting the result of th e routine, assignments to  
it help compute that result but have no effect on objects.
Also note that as a result of in formation hiding principles we have been careful, in  
the design of the object-oriente d notation, to avoid any indire c t  f o r m  o f  o b j e c t  
modification. In particular, the  syntax excludes assignments of  t h e  f o r m  obj  attr := b, 
whose aim has to be achieved through a call obj  set_attr (b), where the procedure
set_attr  (x:…) performs the attr ibute assignment attr := x.
The attribute assignment that ca uses a function to produce a si de effect may be in the  
function itself, or in another r outine that the function calls.  Hence the full definition:“Attributes and rou-
tines”, page 173 .
“The client’s privi-
leges on an attri-bute”, page 206 .
§23.1   SIDE EFFECTS IN FUNCTIONS 749
(The term “concrete” will be expl ained below.) In a more fine-t uned definition we  
would replace the second clause by “A call to a routine that (r ecursively) produces a  
concrete side effect”, the defin ition of side effects being ext ended to arbitrary routines  
rather than just functions. But the above form is preferable in  practice even though it may  
be considered both too strong and too weak:
• The definition seems too strong because any procedure call is considered to produce  
a side effect whereas it is possible to write a procedure that changes nothing. Such  
procedures, however, are rarely useful — except if their role i s to change something  
in the software’s environment, for example printing a page, sen ding a message to the  
network or moving a robot arm; but then we do want to consider this a side effect  
even if it does not directly affe ct an object of the software i tself.
• The definition seems too weak because it ignores the case of a  function f  that calls a  
side-effect-producing function g. The convention will simply be that f can still be  
considered side-effect-free. Thi s  i s  a c c e p t a b l e  b e c a u s e  t h e  r u l e at which we will  
arrive in this discussion will prohibit all side effects of a certain kind, so we will need  
to certify each fun ction separately.
The advantage of these conventions is that to determine the sid e-effect status of a  
function you only need to look at the body of the function itse lf. It is in fact trivial, if you  
have a parser for the language, to write a simple tool that wil l analyze a function and tell  
you whether it produces a concr ete side effect according to the  definition.
Referential transparency
Why should we be concerned about  side effects in functions? Aft er all it is in the nature  
of software executi on to change things.
The problem is that if  we allow functions to  change things as w ell as commands, we  
l o s e  m a n y  o f  t h e  s i m p l e  m a t h e m a t ical properties that enable us to reason about our  
software. As noted in the discus sion of abstract data types, wh en we first en countered the  
distinction between the applicativ e and the imperative, mathema tics is change-free: it talks  
about abstract objects and defines operations on these objects,  but the operations do not  
change the objec ts. (Computing  does not change the number two.) This immutability  
is the principal  difference between the worlds of mathematics a nd computer software.Definition: concrete side effect
A function produces a concrete si de effect if its body contains  any of the  
following:
• An assignment, assignment attemp t or creation instruction whos e 
target is an attribute.
• A procedure call.
“Introducing a more 
imperative view”, page 145 .
2
DESIGNING CLASS INTERFACES  §23.1 750
Some approaches to programming seek to retain the immutability of mathematics: Lisp  
in its so-called “pure” form, “Functional Programming” language s such as Backus’s FP,  
and other applicative languages shun change. But they have not caught on for practica l 
software development, suggesting that change is a fundamental p roperty of software.
The object immutability of mathem atics has an important practic al consequence  
known as referential transparency , a property defined as follows:
If x has value three, we can use x i n s t e a d  o f  3, or conversely, in any part of a  
referentially transparent expres sion. (Only Swift’s Laputa acad emicians were willing to  
pay the true price of renouncing referential transparency: alwa ys carrying around all the  
things you will ever want to tal k about.) As a consequence of t he definition, if we know  
that x and y have the same value, we can use one interchangeably with the o ther. For that  
reason referential tra nsparency is also call ed “substitutivity of equals for equals”.
With side-effect-producing funct ions, referential transparency disappears. Assume a  
class contains the attri bute and the function
attr: INTEGER
sneaky : INTEGER do attr := attr + 1 end
Then the value of sneaky (meaning: of a call to that function) is always 0; but you  
cannot use 0 and sneaky  interchangeably, since  an extract of the form
attr := 0; if attr /= 0 then print ("Something bizarre !") end
will print nothing, but would print Something bizarre ! if you replaced 0 by sneaky .
Maintaining referential transparency in expressions is importan t to enable us to  
reason about our software. One o f the central issues of softwar e construction, analyzed  
clearly by Dijkstra many years a go, is the difficulty of gettin g a clear picture of the  
dynamic behavior (the myriad possible executions of even a simp le software element)  
from its static description (the  text of the element). In this effort it is essential to be able  
to rely on the proven form of r easoning, provided by mathematic s. With the demise of  
referential transparency, however, we lose basic properties of mathematics, so deeply  
rooted in our practice that we ma y not even be aware of them. F or example, it is no longer  
true that n + n  is the same thing as 2 ∗ n if n is the sneaky -like function
n: INTEGER do attr := attr + 1 ; Result  := attr end
since, with attr initially zero, 2 ∗ n will return 2 whereas n + n  will return 3.
By limiting ourselves to functio ns that do not produce side eff ects, we will ensure  
that talking about “functions” in software ceases to betray the  meaning of this term in  
ordinary mathematics. We will ma intain a clear distinction betw een commands, which  Definition: referential transparency
An expression e is referentially transparent if  it is possible to exchange any  
subexpression with it s value without cha nging the value of e.Definition from 
“The Free On-Line Dictionary of Com-puting” , http://wom-
bat. 
The Swift quotation 
was on page 672 .
Remember that 
Result  in an integer 
function is initial-ized to zero .
See [Dijkstra 1968] .
§23.1   SIDE EFFECTS IN FUNCTIONS 751
change objects but do not direct ly return results, and queries,  which provide information  
about objects but d o not change them.
Another way to express this rul e informally is to state that asking a question should  
not change the answer .
Objects as machines
The following principle expresse s the prohibitio n in more preci se terms:
Note that we have only defined concrete  side effects so far; for the moment you can  
ignore the difference.
As a result of the principle, only commands (procedures) will b e permitted to produce  
side effects. (In fact, as noted, we not only permit but expect  them to change objects —  
unlike in applicative, completel y side-effect-free approaches.)
The view of objects that emerges from this discussion (a metaphor , to be treated with  
care as usual) is that of a machine, with an internal state tha t is not directly observable, and  
two kinds of button: command buttons, rectangular on the pictur e, and query buttons, round.
Pressing a command button is a way to make the machine change s tate: it starts moving  
and clicking, then comes back to a new stable state (one of the  states shown in the earlier  
picture of object lifecycle). You cannot directly see the state  — open the machine — but  
you can press a query button. Thi s does not change the state (r emember: asking a question  
does not change the answer) but yields a response in the form o f a message appearing in the  
display panel at the top; for boolean queries one of the two in dicators in the display panel,  Command-Query Separation principle
Functions should not produ ce abstract side effects.
The definition of 
abstract side effects appears on page 757.
A list object as 
list machine
start forth go put search
item before after index count
Object lifecycle pic-
ture: page 365 .
DESIGNING CLASS INTERFACES  §23.1 752
representing true and false, will light up. If you press the bu tton several times in a row,  
without touching the command bu ttons, you will get the same res ult each time. If, on the  
other hand, you push a command bu tton and then a query button, the answer that you get  
will usually be different from wh at you would have obtained bef ore the command.
Commands as well as queries may t ake arguments; these are figur atively entered in  
the slot at the top left.
The figure is based on the example of a list object with the ki nd of interface hinted  
at in earlier chapters and studie d in more detail later in the present one. Commands include  
start (move the cursor to the first element), forth  (advance the curs or one position), search  
(move the cursor to the next occurrence of the element entered into the top-left slot);  
queries include item (show in the display panel the value of the element at cursor position)  
and index  (show the current cursor positi on). Note the difference betwee n a notion such as  
“cursor”, relative to the interna l state and hence not directly  visible, and item or index
which provide more abs tract, officially expo rted information ab out the state.
Functions that create objects
A technical point needs to be clarified before we examine furth er consequences of the  
Command-Query Separation princi ple: should we tr eat object crea tion as a side effect?
The answer is yes, as we have s een, if the target of the creati on is an attribute a: in 
this case, the instruction  create  a changes the value of an object’s field. The answer is no  
if the target is a local entity o f the routine. But what if the  target is the result of the function  
itself, as in  create  Result  or the more general form  create  Result   make (…)?
Such a creation instruction need not be considered a side effec t. It does not change  
any existing object and so does not endanger referential transp arency (at least if we  
assume that there is enough memo ry to allocate a l l  t h e  o b j e c t s  w e  n e e d ) .  F r o m  a  
mathematical perspective we may pretend that all of the objects  of interest, for all times  
past, present and future, are al ready inscribed in the Great Bo ok of Objects; a creation  
instruction is j ust a way to obtain one o f them, but it does no t by itself change anything in  
the environment. It is common, a nd legitimate, for a function t o create, initialize and return  
such an object.
These observations assume that in the second form the creation procedure make  does not  
produce side effects on any object other than the one being cre ated.
A clean style for class interfaces
From the Command-Query Separation principle follows a style of design that yields simple  
and readable software, and trem endously helps reliability, reus ability and extendibility.
As you may have realized, this style is very different from the  dominant practices of  
today, as fostered in particular by the C programming language.  The predilection of C for  
side effects — for ign oring the difference between an action an d a value — is not just a  
feature of the common C style (i t sometimes seems just psycholo gically impossible for a  
C programmer to resist the tempta tion, when accessing a value, also to modify  it a little in  
§23.1   SIDE EFFECTS IN FUNCTIONS 753
passing); it is embedded deeply i nto the language, with such co nstructs as x++, meaning:  
return the value of x,  t h e n  i n c r e a s e  i t  b y  o n e  —  s a v i n g  a  f e w  k e y s t r o k e s  i n  y = x++
compared to y = x; x := x+1 , and not to be confused with ++x which increments before
computing the value. A whole ci vilization, in fa ct, is built on  side effects.
It would be foolish to dismiss this side-effect-full style as t houghtless; its widespread  
use shows that many people have found it convenient, and it may  even be part of the  
reason for the amazing success of C and its derivatives. But wh at was attractive in the  
nineteen-seventies and eighties — when the software development  population was  
growing by an order of magnitude  every few years, and the empha sis was on getting some  
kind of job done rather than on l o n g - t e r m  q u a l i t y  —  m a y  n o t  b e  appropriate for the  
software technology of the twenty -first century. There we want software that will grow  
with us, software that we can und erstand, explain, maintain, re use and trust. The  
Command-Query Separati on principle is one o f the required condi tions for these goals.
Applying a strict sepa ration between command s and queries by pr ohibiting abstract  
side effects in functions is par ticularly appropriate for the d evelopment of large systems,  
where the key to success is to exert full control on every inte r-module interaction. 
If you have been used to the conv erse style, you may at first, like many people, find  
the new one too extreme. But after starting to practice it I th ink you will quickly realize its  
benefits.
Quietly, the preceding chapters  have already ap plied Command-Qu ery Separation to  
its full extent. You may remember  for example that the interfac e for all our stack classes  
included a procedure remove  describing the operation of popping a stack (removing the  
top element), and a function or attribute item which yields the top element. The first is a  
command, the second a query. In ot her approaches you might have  seen a routine pop
which both removes the element and returns it — a side-effect-p roducing function. This  
example has, I hope, been studied  in enough depth to show the g ains of clarity and  
simplicity that we achieve by ke eping the two aspects cleanly s eparated.
Other consequences of the princi ples may seem more alarming at first. For reading  
input, many people are used to t he style of using functions suc h as getint  — the C name,  
but its equivale nt exists in many other languages — whose effec t is to read a new input  
element and return its value. Th is is a side-effect-producing f unction in all i ts splendor: a  
call to the function, written getint () — with the empty parentheses so unmistakably  
characteristic of the C look-and -feel — does not just return a value but affects the context  
(“asking a question ch anges the answer”); as  typical consequenc es, excluding the chance  
case in which the input has two identical consec utive values:
• If you call getint () twice you will get d ifferent answers.
•getint () + getint () and 2 ∗ getint () will not yield the same value. (If an overzealous  
“optimizing” compiler treats the first expression like the seco nd, you will report a  
bug to the compile r vendor, and you  will be right.)
In other words, we lose the benefits of referential transparenc y — of reasoning about  
software functions as if they were mathematical functions, with  a crystal-clear view of  
how we can build expre ssions from them and w hat values these ex pressions will denote.
DESIGNING CLASS INTERFACES  §23.1 754
The Command-Query Separation principle brings referential trans parency back. Here  
this means that we will distingu ish between the procedure that advances the input cursor to  
the next item and the function or  attribute that yields the ite m last read. Assume input  is of 
type FILE ; the instructions to read t he next integer from file input  will be something like 
input   advance
n := input   last_integer
If you call last_integer  ten times in a row y ou will, unlike with getint , get ten times  
the same result. If you are new to this style, it may take some  getting used to; but the  
resulting simplicity and clarity will soon remove any temptatio n to go back to side effects.
In this example as in the x++ case seen earlier, the traditional form beats the object-
oriented one if the goal of the game is to minimize keystrokes.  This illustrates a general  
observation: the productivity gains of object technology will n ot derive from trying to be  
as terse as possible on a microscopic scale (a game at which AP L or modern “scripting  
languages” such as Perl will always win against a good O-O lang uage). The achievements  
are on the global structure of a system: through reuse, through  such mechanisms as  
genericity and garbage collection, through the use of assertion s, you can decrease the size  
of your software by amounts far higher than anything you can ac hieve by skimping by a  
character here or a line ther e. Keystroke-wise is ofte n system-foolish.
Pseudo-random number generators: a design exercise
An example sometimes quoted in f avor of functions with side eff ects is that of pseudo-
random number generators, which return successive values from a  sequence enjoying  
adequate statistical p roperties. The sequence is initialized by  a call of the form 
random_seed (seed )
where seed is a seed value provided by the  client. A common way to get th e successive  
pseudo-random values is  by calling a function: 
xx := next_random ( )
But here too there is no reason t o make an exception to the com mand/query  
dichotomy. Before looking at the  solution let us just forget th at we have seen the above  
and restart from scratch by asking the question: how should we handle random generation  
in an object-oriented context? This will provide the opportunit y of a little design exercise,  
and will enable us, if the need arises, to explain the results to someone whose view has not  
been unduly influenced b y pre-O-O approaches.
As always in object technology, the relevant question — often t he only one — is:
What are the data abstractions ?
The relevant abstraction here is not “random number generation”  or “random  
number generator”, both of them quite functional in nature, foc using on what the system  
does rather than what it does it to . 
Probing further, we might think “ random number”, but that is no t the right answer  
yet. Remember, a data abstraction is characterized by features — commands and queries;  
it is hard to think of  features applicable to “random number”.
§23.1   SIDE EFFECTS IN FUNCTIONS 755
That “random number” leads to a dead end illustrates the Class Elicitation principle  
encountered when we studied the general rules for finding the c lasses: a key step may be  
to reject  inappropriate candidates. And once again we see that not all p romising nouns  
yield classes: were a “requirements document” written for this problem, the noun random  
number would certainly figure prominently in it.
A random number does not mean mu ch by itself; it must be unders tood in relation to  
its predecessors and succe ssors in the sequence. 
Wait a minute — here we have it: sequence , more precisely pseudo-random number  
sequence. This is the abstraction we have been looking for; a p erfectly legitimate data  
abstraction, similar to the curs or lists we have seen on a numb er of occasions, only infinite  
(do not look for an after  boolean query!). Fe atures will include:
• Commands: make  — initialize with a certain seed; forth  — advance to next element.
• Queries: item — return the element at cursor  position.
To get a new random number sequence rand, clients will use  create  rand  make (seed); 
to advance to the next value, they will call rand  forth ; and they will obta in the current value  
by xx := rand   item.
There is really no thing specific to random number  sequences in the interface, except  
for the seed argument to the creation procedure. Adding a start procedure which brings  
the cursor to the first item (and which make  may call for random number sequences), what  
w e  h a v e  i s  t h e  f r a m e w o r k  f o r  a  d e f e r r e d  c l a s s  COUNTABLE_SEQUENCE  describing  
arbitrary infinite sequences. Th ink for example of how to model  prime numbers in an  
object-oriented way; the answer  is the same: define a class PRIMES , an heir to  
COUNTABLE_SEQUENCE , whose successive elements are the prime numbers. Other  
sequences — Fibo nacci numbers and the lik e — will be modeled in  the same way.
These examples illustrate in passing that contrary to popular b elief it is quite possible, and  
even trivial, to represent infinite structures on a computer. A bstract data types provide the  
key: a structure is entirely defined by the applicable operatio ns, of which there is of  
course a finite number, three in this case — start, forth , item — plus any auxiliary features  
we may want to add. The trick, of course, is that any execution  will only try to evaluate  
a finite number of elements of an infinite structure.
COUNTABLE_SEQUENCE  and its heirs such as PRIMES  are part of the universal  
computing science hierarchy desc ribed in the companion guide to  reusable components.“Discovery and 
rejection”, page 725 .
An infinite list 
as a machine
forthitem
start
[M 1994a].
DESIGNING CLASS INTERFACES  §23.1 756
Abstract state, concrete state 
From the discussion of referentia l transparency it would seem d esirable to bar all concrete  
side effects from functions. Such  a rule would have the advanta ge that — in line with one  
of our methodology precepts — we  could build it into the langua ge, since a compiler can  
easily detect concrete side effects (as we saw just after the d efinition of this notion).
Unfortunately, this would be una cceptably restrictive, explaini n g  w h y  t h e  
Command-Query Separation principle only prohibits abstract  side effects, a notion that  
will now be defined. The problem is that some concrete side eff ects are not only harmless  
but necessary. They are of two kinds.
The first category includes funct ions which, in the course of t heir execution, modify  
the state, sometimes drastically, and affecting very visible fe atures; but then they restore  
the original state. Consider for  example a class describing int eger lists with cursor, and the  
following function for comput ing the maximum of a list:
max
-- The highest  value of items in the list
require
not empty
local
original_index : INTEGER
do
original_index  := index
from
start; Result  := item
until  is_last loop
forth ; Result  := Result   max (item)
end
go (original_index )
end
To traverse the list, the algorit hm needs to move the cursor ov er all elements. The  
function, calling such procedures as start, forth  a n d  go, is indeed full of concrete side  
effects on the cursor position; but it begins by noting the cur sor position into original_index  
and ends by returning the curs or to that position through a cal l to go. All is well that ends  
well: the function leaves the li st in exactly the state in whic h it found it. But no compiler in  
the world is going to detect tha t the side effect is only appar ent.
Side effects of the second acceptable category may change the s tate of the object, but  
only affecting properties that ar e not visible to clients. To u nderstand the concepts in  
d e p t h ,  i t  w i l l  b e  u s e f u l  t o  m a k e  s u r e  t h a t  y o u  a r e  f a m i l i a r  w i t h the discussion of  
“abstraction function” and “imple mentation invariants” in the p resentation of Design by  
Contract. (In particular, take a  look at the accompanying figur es to refresh your memory.)“If it is baroque, fix 
it”, page 670 .
Pages 375 to 377 .
§23.1   SIDE EFFECTS IN FUNCTIONS 757
We saw then that an object of our software (a concrete  object) is the representation  
of an abstract object, and that two concrete objects may repres ent the same abstract object.  
For example two different stack representations, each made of a n array and a top marker  
count , represent the same stack if they have the same value for count and the same array  
elements up to index count . They may differ in other prope rties, such as the array sizes and 
the values stored at indices above count . In mathematical terms,  every concrete object  
belongs to the domain of t he abstraction function a, and we can have c1 ≠ c2 even with  
a (c1) = a (c2).
What this means for us  is that a function th at modifies a concr ete object is harmless  
if the result of this modificatio n still represents the same ab stract object — yields the same  
a value. Assume for example that a function on stacks contains t he operation
representation   put (some_value , count + 1 )
(with the guarantee that the a rray’s capacity is at least count + 1 ). This side effect changes  
a value above the stack -significant section of the array; it ca n do no ill.
More generally, a concrete side e ffect which changes the concre te state of an object  
c is an abstract side effect  if it also changes its abstract state , that is to say the value of  
a (c) (a more directly usable definit ion of abstract side effects wi ll appear shortly). If a side  
effect is only concrete — does no t affect the abstract state — it is harmless.
In the object-as-machine metaphor, functions producing concrete -only side effects  
correspond to query buttons that may produce an internal state change having  
absolutely no effect on the answers given by any query button. For example the  
machine might save energy by automatically switching off some i nternal circuits if  
nobody presses a button for some time, and turning them on agai n whenever someone  
presses any button, queries included. Such an internal state ch ange is unnoticeable from  
the outside and hence legitimate. 
The object-oriented approach is particularly favorable to cleve r implementations  
which, when computing a function,  may change the concrete state  behind the scenes  
without producing any visible si de effect. The example of a sta ck function that changes  
array elements above the top is somewhat academic, but we will see below a practical and  
useful design that rel ies on this technique.
Since not every class definition is accomp anied by a full-fledg ed specification of the  
underlying abstract da ta type, we need a more directly usable d efinition of “abstract side  
effect”. This is not difficult. In practice, the abstract data type is defined by the interface  
offered by a class to its client s (expressed for example as the  short form of the class). A  
side effect will affect the abst ract object if it changes the r esult of any query accessible to  
these clients. Hence the definition: 
Definition: abstract side effect
An abstract side effect is a concrete side effect that can chan ge the value of  
a non-secret query.Figure page 751 .
DESIGNING CLASS INTERFACES  §23.1 758
This is the notion used by the Co mmand-Query Separation princip le — the principle  
that prohibits abstract si de effects i n functions.
The definition refers to “non-s ecret” rather than exported quer ies. The reason is that  
in-between generally exported and fully secret status, we must permit a query to be  
selectively exported to a set of  clients. As soon as a query is  non-secret — exported to any  
client other than NONE — we consider that changing its result is an abstract side effe ct, 
since the change will be visib le to at least some clients.
The policy 
As announced at the beg inning of this discu ssion, abstract side  effects are (unlike concrete  
side effects) not easily detecta ble by a compiler. In particula r it does not suffice to check  
that a function preserves the values of all non-secret attribut es: the effect on other queries  
might be indirect, or (as in the max example) several concrete side effects might in the end  
cancel out. The most a compiler c an do would be to issue a warn ing if a function modifies  
an exported attribute.
So the Command-Query Separation principle is a methodological p recept, not a  
language constraint. This does not, however, diminish its impor tance.
Past what for some people will be an initial shock, every objec t-oriented developer  
should apply the principle with out exception. I have followed i t for years, and would never  
write a side-effect-producing fun ction. ISE applies it in all i ts O-O software (for the C part  
we have of course to adapt to the  dominant style, although even  here we try to apply the  
principle whenever we can). It has helped us produce much bette r results — tools and  
libraries that we can reuse, exp lain to others, extend and scal e up.
Objections
It is important here two deal wit h two common obje ctions to the  side-effect-free style.
The first has to do with error handling. Sometimes a function w ith side effects is  
really a procedure, which in add ition to doing its job returns a status code indicating how  
t h i n g s  w e n t .  B u t  t h e r e  a r e  b e t t e r ways to do this; roughly spea king, the proper O-O  
technique is to enable the clien t, after an operation on an obj ect, to perform a query on the  
status, represented for  example by an attri bute of the object, as in
target   some_operation (…)
how_did_it_go  := target   status
Note that the technique of retur ning a status as function resul t is lame anyway. It  
transforms a procedure into a fun ction by adding the status as a result; but it does not work  
if the routine was already a func tion, which already has a resu lt of its own. It is also  
problematic if you need more than one status indicator. In such  cases the C approach is  
either to return a “structure” (the equivalent of an object) wi th several components, which  
is getting close to the above scheme, or to use global variable s — which raises a whole set  
of new problems, especially in a  large system where many module s can trigger errors.The principle 
appears on page 751 .
§23.1   SIDE EFFECTS IN FUNCTIONS 759
The second objection is a common misconception: the impression that Command-
Query Separation, for example the  list-with-cursor type of inte rface, is incompatible with  
concurrent access to objects. Th at belief is remarkably widespr ead (this is one of the  
places where I know that, if I am lecturing on these topics, so meone in the audience will  
raise his hand, and the question will be the same whether we ar e in Santa Barbara, Seattle,  
Singapore, Sydney, Sto ckholm or Saint-Petersburg); but it is in correct nonetheless.
The misconception is that in a concurrent context it is essenti al to have atomic  
access-cum-modification operations, for example get o n  a  b u f f e r  —  t h e  c o n c u r r e n t  
equivalent of a first-in, first out queue. Such a get function non-interruptibly performs, in  
our terminology, both a call to item (obtain the oldest element) and remove  (remove that  
element), returning the result of item as the result of get. But using such an example as an  
argument for get-style functions with side effects is confusing two notions. Wh at we need  
in a concurrent context is a way  to offer a client exclusive ac cess to a supplier object for  
certain operations. With such a mechanism, we can protect a cli ent extract of the form
x := buffer   item; buffer   remove
thereby guaranteeing that the buffer element returned by the ca ll to item is indeed the same  
one removed by the following call to remove . Whether or not we permit functions to have  
side effects, we will have to pr ovide a mechanism to ensure suc h exclusive access; for  
example a client may need to dequeue two elements
buffer   remove ; buffer   remove
with the guarantee tha t the removed elements  will be consecutiv e; this require s exclusive  
access, and is unrelat ed to the question of side effects in fun ctions.
Later in this book we will have an extensive discussion of conc urrency, where we  
will study a simple and elegant approach to concurrent and dist ributed computation, fully  
compatible with the Command-Query  Separation principle — which in fact will help us
arrive at it.
Legitimate side effects: an example
To conclude this discussion of sid e effects let us examine a ty pical case of legitimate side  
effects — functions that do not  change the abstract state, but can change the concrete state,  
and for good reason. The example i s representative of a useful design pattern.
Consider the implementation of complex numbers. As with points,  discussed in an  
earlier chapter, two representations are possible: cartesian (b y axis coordinates x and y) and 
polar (by distance to the origin ρ and angle θ). Which one do we choose? There is no easy  
answer. If we take, as usual, the abstract data type approach, we will note that what counts  
is the applicable operations — addition, subtraction, multiplic ation and division among  
others, as well as queries to access x, y, ρ and θ — and that for each of them one of the  
representations is definitely better: cartesian for addition, s ubtraction and such, polar for  
multiplication and division. (Try expressing division in cartes ian coordinates!)Chapter 30 .
Chapter 30. See in par-
ticular “Support for command-query sepa-ration”, page 1029 .
DESIGNING CLASS INTERFACES  §23.1 760
We could let the client decide what representation to use. But this would make our  
classes difficult to use, and vi olate information hiding: for t h e  c l i e n t  a u t h o r ,  t h e  
representation should not matter.
Alternatively, we could keep both representations up to date at all times. But this may  
cause unnecessary  performance penalties. A ssume for example tha t a client only performs  
multiplications and divisions. T he operations use polar represe ntations, but after each one  
of them we must recompute x and y, a useless but expensiv e computation involving  
trigonometric  functions. 
A  better solution is to refuse to choose between the representa tions a priori , but 
update each of them only when we  need it. As compared to the pr eceding approach, we  
do not gain anything in space (since we will still need attribu tes for each of x, y, ρ and θ, 
plus two boolean attributes to t ell us which of the representat ions are up to date); but we  
avoid wasting computation time.
We may assume the following publ ic operations, among others: 
class COMPLEX  feature
… Feature declarations for:
infix "+", infix "–", infix "∗", infix "/",
add, subtract , multiply , divide ,
x, y, rho, theta , …
end
The queries x, y, rho and theta  are exported functions re turning real values. They  
are always defined (except theta  for the complex number 0) since a client may request  
the x and y of a complex number even if the number is internally represente d in polar,  
and its ρ and θ even if it is in cartesian. In addition to the functions "+" etc., we assume  
procedures add etc. which modi fy an object: z1 + z2 is a new complex number equal to  
the sum of z1 and z2, whereas the procedure call z1  add (z2) changes z1 to represent that  
sum. In practice, we might need only the functions or only the procedures.
Internally, the class includes t he following secr et attributes for the representation: 
cartesian_ready : BOOLEAN
polar_ready : BOOLEAN
private_  x, private_  y, private_rho , private_theta : REAL
Not all of the four real attributes are necessarily up to date at all times; in fact only two  
need be up to date. More precise ly, the following implementatio n invariant should be  
included in the class: 
invariant
cartesian_ready or polar_ready
 polar_ready implies (0 <= private_theta and private_theta <= Two_  pi)
-- cartesian_ready implies (private_  x and private_  y are up to date)
-- polar_ready  implies (private_rho and private_theta are up to date)
§23.1   SIDE EFFECTS IN FUNCTIONS 761
The value of Two_  pi is assumed to be 2 π. The last two clauses may only be expressed  
informally, in the form of comments.
At any time at least one of the representations is up to date, although both may be. Any  
operation requested by a client w ill be carried out in the most  appropriate representation; this  
may require computing that representation if it was not up to d ate. If the operation produces  
a (concrete) side effect, the oth er representation will cease t o be up to date. 
Two secret procedures are availa ble for carrying out representa tion changes: 
prepare_cartesian
-- Make cartesian representation available
do
if not cartesian_ready then
check polar_ready  end
-- (Because the invariant re quires at least one of the
-- two representatio ns to be up to date)
private_  x := private_rho ∗ cos (private_theta )
private_  y := private_rho ∗ sin (private_theta )
cartesian_ready  := True
-- Here both cartesian_ready  and polar_ready  are true:
-- Both representations are available
end
ensure
cartesian_ready
end
prepare_  polar
-- Make polar representation available
do
if not polar_ready then
check cartesian_ready  end
private_rho  := sqrt (private_  x ^ 2 + private_  y ^ 2)
private_theta  := atan2 (private_  y, private_  x)
polar_ready  := True
-- Here both cartesian_ready  and polar_ready  are true:
-- Both representations are available
end
ensure
polar_ready
end
Functions cos, sin, sqrt and atan2  are assumed to be taken from a standard mathematical  
library; atan2 (y, x) should compute th e arc tangent of y / x. 
We will also need cr eation procedures make_cartesian  and make_  polar :
DESIGNING CLASS INTERFACES  §23.1 762
make_cartesian (a, b: REAL )
-- Initialize with abscissa a, ordinate b.
do
private_  x := a; private_  y := b
cartesian_ready  := True ; polar_ready  := False
ensure
cartesian_ready ; not polar_ready
end
and symmetrically for make_  polar .
The exported operations are easy  to write; we can start for exa mple with the  
procedure variants (we will see the function variants such as infix "+" next):
add (other : COMPLEX )
-- Add the value of other .
do
prepare_cartesian ; polar_ready  := False
private_  x := x + other   x; private_  y = y + other   y
ensure
 x = old x + other   x; y = old y + other   y
cartesian_ready ; not polar_ready
end
(Note the importance in th e postcondition of using x and y, not private_  x and private_  y 
which might not have been up to date before  the call.)
divide (z: COMPLEX )
-- Divide by z.
require
z  rho /= 0
-- (To be replaced by a numerical ly more realistic precondition )
do
prepare_  polar ; cartesian_ready  := False
private_rho  := rho / other   rho
private_  theta = (theta – other   theta ) \\ Two_  pi
-- Using \\ as remainder operation
ensure
 rho = old rho / other   rho
 theta = (old theta — other   theta ) \\ Two_  pi
 polar_ready ; not cartesian_ready
end
and similarly for  subtract  and multiply . (The precondit ion and postcond ition may need  
some adaptation to reflect the r ealities of floating-point comp utations on computers.) The  
function varia nts follow the same pattern:
§23.1   SIDE EFFECTS IN FUNCTIONS 763
infix "+" ( other : COMPLEX ): COMPLEX
-- Sum of current complex and other
do
create  Result   make_cartesian (x + other   x, y + other   y)
ensure
Result   x = x + other   x; Result   y = y + other   y
Result   cartesian_ready
end
infix "/" (z: COMPLEX ): COMPLEX
-- Quotient of current complex by z.
require
z  rho /= 0
-- (To be replaced by a numeric ally more realistic condition)
do
create  Result   make_  polar (rho / other   rho, (theta – other   theta ) \\ Two_  pi)
ensure
Result   rho = rho / other   rho
Result   theta = (old theta — other   theta ) \\ Two_  pi
Result   polar_ready
end
and similarly for infix "–" and infix "∗". 
Note that for the last postcondition clauses of these functions  to be valid, cartesian_ready
and polar_ready  must be exported to the class itself, by appearing in a clause  of the form  
feature {COMPLEX }; they are not exported to any other class.
But where are the side effects? In the last two functions, they  a r e  n o t  d i r e c t l y  
visible; this is because x, y, rho and theta , behind their innocent looks, are sneaky little  
side-effectors! Computing x or y will cause a secret change of representation (a call to  
prepare_cartesian ) if the cartesian representation was not ready, and symmetrica lly for  
rho and theta . Here for example are x and theta :
x: REAL
-- Abscissa
do
prepare_cartesian ; Result  := private_  x
end
theta : REAL
-- Angle
do
prepare_  polar ; Result  := private_theta
end
DESIGNING CLASS INTERFACES  §23.2 764
Functions y and rho are similar. All these functions call a procedure which may  
trigger a change of state. Unlike add and consorts, however, th ey do not invalidate the  
previous representation when a new one is computed. For example , if x is called in a state  
where cartesian_ready  is false, both representations (all four real attributes) will  be up to  
date afterwards. This is because the functions may produce side  effects on the concrete  
objects only, not on the associa ted abstract objects. To expres s this property more  
formally: computing z  x or one of the other functions m ay change the concrete object  
associated with z, say from c1 to c2, but always with t he guarantee that 
a (c1) = a (c2)
where a is the abstraction function. The computer objects c1 and c2 may be different, but  
they represent the same mathemat ical object, a complex number. 
Such side effects are harmless, as they only affect secret attr ibutes and hence cannot  
be detected by clients. 
The object-oriented approach enc ourages such flexible, self-ada pting schemes,  
which internally choose the best  implementation according to th e needs of the moment.  
As long as the resulting implemen tation changes affect the conc r e t e  s t a t e  b u t  n o t  t h e  
a b s t r a c t  s t a t e ,  t h e y  c a n  a p p e a r  i n functions without violating the Command-Query  
Separation principle or endanger ing referential transparency fo r clients.
23.2  HOW MANY ARGUMENTS FOR A FEATURE?
In trying to make classes — espe cially reusable classes — easy to use, you sh ould devote  
special attention to the number of arguments of features. As we  will see, well-understood  
object technology yiel ds a style of feature interface radically  different from what you  
typically get with traditional ap proaches; there will, in parti cular, be far fewer arguments.
The importance of argument counts
When your development relies on a supplier class, features are your day-to-day channel  
to it. The simplicity of the feature interfaces fundamentally d etermines the class’s ease of  
use. Various factors influence this, in particular the consiste ncy of the conventions; but in  
the end a simple numerical crite rion dominates e verything else:  how many arguments do  
features have? The more arguments, the more you have to remembe r.
This is particularly true of lib rary classes. The criterion for  success there is simple:  
after a potential library user has taken the (preferably short)  time to understand what a  
class is about and, if he decides to use it, selected the set o f features that he needs for the  
moment, he should be able to lea rn these features quickly and, after as few uses as  
possible, remember them  without having to g o back to the docume ntation. This will only  
work if features — aside from all other qualities of consistenc y, proper naming  
conventions and general quality o f the design — have very short  argument lists.
I f  y o u  e x a m i n e  a  t y p i c a l  s u b r o u t ine library you will commonly e ncounter  
subroutines with many arguments. H ere for example is an integra tion routine from a  
mathematical library justly reno wned for the excellence of its algorithms, but constrained  
in its interface by the use of t raditional subro utine technique s:
§23.2   HOW MANY ARGUMENTS FOR A FEATURE? 765
nonlinear_ode
(equation_count : in INTEGER ;
 epsilon : in out DOUBLE ;
func: procedure (eq_count : INTEGER ; a: DOUBLE ; eps: DOUBLE ;
 b: ARRAY [DOUBLE ]; cm: pointer Libtype )
left_count , coupled_count : in INTEGER ;
…)
[And so on. Altogether 19 arguments, including:
- 4 in out  values;
- 3 arrays, used both a s input and output;
- 6 functions, each with 6 or 7 arguments of which 2 or 3 are a rrays!]
Since the purpose of this example is not to criticize one parti cular numerical library but  
to emphasize the difference between O-O and traditional interfa ces, the routine and  
arguments names have been changed and the syntax (in C in the o riginal) has been  
adapted. The resulting notation resembles the notation of this book, which, however,  
would of course exclude such non-O-O mechanisms as in out arguments, explicit pointer
manipulation, and arguments (such as func and 5 others) that are themselves routines.
Several properties make this sch eme particularly complex to use :
• Many arguments are in out , that is to say must be initialized by the caller to pass a  
certain value and are updated by the routine to return some inf ormation. For example  
epsilon specifies on input whether contin uation is required (yes if les s than 0; if  
between 0 and 1, continua tion is required unless epsilon < , etc.). On  
output, it provides an est imate of the increment.
• Many arguments, both to the rou tine itself and to its own rout ine arguments, are  
arrays, which again se rve to pass certain values on input and r eturn others on output.
• Some arguments serve to specify  the many possibilities for err or processing (stop  
processing, write message t o a file, continue anyway …).
Even though high-quality numeric al libraries have been in exist ence for many years  
and, as mentioned in a n earlier chapter, pr ovide some of the mo st concrete evidence of real  
reuse, they are still not as wid ely used in scientific computat ion as they should be. The  
complexity of their in terfaces, and in part icular the large num ber of arguments illustrated  
by nonlinear_ode , are clearly a big part of the reason.
Part of the complexity comes from  the problems handled by these  routines. But one  
can do better. An object-oriented numerical library, Math , offers a completely different  
approach, consistent with obje ct technology conc epts and with t he principles of this book.  
An earlier discussion cited the Math library as an example of u sing object technology to re-
architecture older software, and the library indeed uses an exi sting non-O-O library as its  
core engine, since it would have been absurd to duplicate the b asic algorithmic work; but  
it provides a modern, O-O client  interface. The basic non-linea r ODE routine has the form
solve
-- Solve the problem, rec ording the answer in x and y.Warning : this is not 
an object-oriented interface !
precision
On the Math library 
and techniques of scientific object-ori-ented computing , 
see [Dubois 1997].  
The earlier mention was in “Object-ori-ented re-architec-turing”, page 441 .
DESIGNING CLASS INTERFACES  §23.2 766
In other words it takes no argum ent at all! You simply create a n instance of the class  
GENERAL_BOUNDARY_VALUE_PROBLEM to represent the mathematical problem to  
be solved, set its non-default properties through calls to the appropriate proc edures, attach  
it to a “problem solver” object (an instance of the class in wh ich the above routine appears:  
GENERAL_BOUNDARY_VALUE_PROBLEM_SOLVER ), and call solve  on that object.  
Attributes of the class, x and y, will provide the handle to the computed answer.
More generally, the thorough app lication of O-O techniques has a dramatic effect on  
argument counts. Measures on the ISE libraries, published in mo re detailed elsewhere,  
show an average number of argume nts ranging from 0.4 for the Ba se libraries to 0.7 for  
the Vision  graphical library. For the purp oses of comparison with non-O-O  libraries we  
should add 1 to all these figure s, since we count two arguments  for x  f (a, b) versus three  
for its non-O-O counterpart f (x, a, b); but even so these averages are strikingly low when  
compared with the counts for non -O-O routines wh ich, even when not reaching 19 as in  
the above numerical e xample, often have 5 , 10 or 15 arguments.
These numbers are not a goal by themselves — and of course not by themselves an  
indicator of quality. Instead, t hey are largely the result of a  deeper design principle that we  
will now examine.
Operands and options
An argument to a routine may be of two different kinds: operands  and options .
To understand the difference, consider the example of a class DOCUMENT  and a  
procedure print . Assume — just to make the exam ple more concrete — that printi ng will  
rely on Postscript. A typical cal l illustrating a possible inte rface ( not compatible with the  
principle stated  below) would be
my_document   print  ( printer_name , paper_size , color_or_not , 
 postscript_level , print_resolution )
Of the five arguments, which ones  are truly indispensable? If y ou do not provide a  
Postscript level, the routine ca n use as a default the most com monly available option. The  
same applies to paper size: you can use LTR (8.5 by 11 inches) in the US, A4 (21 by 29.7  
centimeters) elsewhere. 600 dots per square inch may be a reaso nable default for the print  
resolution, and most printers ar e non-color. In all these cases , you might have a  
mechanism supporting installation-level or user-level defaults to override the universal  
ones (for example if your site h as standardized on 1200 dpi res olution). The only argument  
that remains is the printer name ; but here too yo u might have d efined a default printer.
This example illustrates the dif ference between operands and op tions:
Definition: operand and option arguments
An operand argument to a routine represents an object on which the routine  
will operate.
An option argument represen ts a mode of operation.See [M 1994a]  for 
detailed library measurements .
Warning : this is not 
the recommended style!
§23.2   HOW MANY ARGUMENTS FOR A FEATURE? 767
This definition is too general to tell us unambiguously whether  a proposed argument  
is an operand or an option, but h ere are two dir ectly applicabl e criteria:
A c c o r d i n g  t o  t h e  f i r s t  c r i t e r i o n ,  a l l  t h e  a r g u m e n t s  t o  print  a r e  o p t i o n s  ( w i t h  t h e  
possible exception of printer_name  if you have not defined a default printer). Note,  
however, that the target of th e call, an implicit argument ( my_document in the example)  
is, as all targets should be, an  operand: if you do not say wha t document you want to print,  
no one is going to choose a default for you.
The second criterion is less obvious since it requires some for esight, but it reflects  
the software engineering concern s that underlie a ll our discuss ions since the first chapters  
of this book. We know that a class is not an immutable product;  like all software, it may  
change over its lifetime. Some p roperties of a class, however, change more often than  
others. Operands are there for t he long term: adding or removin g a operand is a major,  
incompatible change. Options, on  the other hand, may come and g o. For example one may  
imagine that support for colors was not part of the first versi on of the print  procedure, a  
few years back, and was only added  later. This is typical of an  option.
The principle
The definition of operands and o ptions yields the rule on argum ents:
Two cases for loosening the rule, not quite qualifying as excep tions, are mentioned below.
In the style that this principle promotes, options to an operat ion are set not in calls to  
the operation but in calls to sp ecific option-setting procedure s:
my_document   set_ printing_size ("A4")
my_document   set_color
my_document   print -- No argument at all.
Once set, each option remains in force for the target object un til reset by a new call.  
In the absence of any call to th e corresponding procedures, and  of any explicit setting at the  
time of object creation, options  will have the de fault values.
For any type other than boolean, the option-setting procedure w ill take one argument  
of the appropriate type, as illustrated by set_ printing_size ; the standard name is of the  How to distinguish options from operands
• An argument is an option if, ass uming the client had not suppl ied its value,  
it would have been possible to  find a reason able default.
• In the evolution of a class, arguments tend to remain the same , but options  
may be added and removed.
Operand principle
The arguments of a rou tine should only incl ude operands (no opt ions).
DESIGNING CLASS INTERFACES  §23.2 768
form set_property_name . Note that the argument to a procedure such as set_ printing_size
itself satisfies the Operand prin ciple: the page size, which wa s an option for the original  
print , is an operand for set_ printing_size  which by definition op erates on page sizes.
For a boolean procedure, the sam e technique would yield a proce dure taking either  
True or False  as argument; since this is confusing (as users of the procedur e may forget  
which ones of the two possibilities True represents), it is better t o use a pair of procedures,  
with conventional names of the form set_property_name  and set_no _property_name , for 
example set_color  and set_no_color , although in this case it is probably just as well to call  
the second variant set_black_ and_white .
Application of the Operand princ iple yields several benefits:
• You only specify what differs from the defaults. Any property for which you do not  
need any special setting will be handled with the settings that  have proved to be most  
commonly appropriate.
• Novices need only learn the ess entials and can ignore any adva nced properties.
• As you get to know the class be tter and move on to sophisticat ed uses, you learn  
more properties; but you only have to remember what you use.
• Perhaps most importantly, the t echnique preserves extendibilit y and the Open-
Closed principle: as you add mor e options to a certain facility , you do not need to  
change the interface of a routin e and hence invalidate all exis ting callers. If the  
default value corresponds to the  previous implicit setting, exi sting clients will not  
need to be changed.
Against the Operand principle, a  possible objection comes to mi nd: does it not just  
trade argument complexity for call complexity (calls will be mu ch simpler, but we will  
have more of them since we must include calls to option-setting  procedures)? This is,  
however, not accurate. The only new calls will be for options t hat you want to set to values  
other than the default. Here the complexity is the same as with  option arguments. (You  
may have a few more keystrokes to  type, but what counts is the number of pieces of  
information you have to  provide, and it is the same with both a pproaches.) The big  
difference is that you need only pay attention to the options t hat are relevant for your own  
use, whereas option argume nts force you to specify all options explicitly.
Also note that frequently a cert ain option will apply to many s uccessive calls. In that  
case, using option arguments forc es you to specify it each time .  W i t h  t h e  s t y l e  
recommended here, you gain even i f the value is not the default : you set it the first time  
around, and it stays in place unt il explicitly changed. The gai n is particularly significant  
in cases such as the numerical l ibrary mentioned  above where every  call must include  
arguments indicating the desired  error processing mode, the nam e of the file for error  
output and other general propert ies, which tend to remain appli cable through many calls.
Some languages support the notion of optional argument , achieving some of the benefits of the  
Operand principle but not all. The comparison has been left as an exercise, but you may already note  
that the last point mentioned would not apply: any non-default argument must be specified each time.See exercise E23.3, 
page 807 .
§23.2   HOW MANY ARGUMENTS FOR A FEATURE? 769
Benefiting from the Operand principle
Comments made about th e Command-Query Separ ation principle appl y to the Operand  
principle too: it goes against t oday’s dominant practices, and some readers will  
undoubtedly balk at it initially; but I can recommend it withou t any reservation, having  
applied it for many years and gr eatly benefited from it. It yie lds a simple, cl ear and elegant  
style, fostering clari ty and extendibility. 
That style soon becomes a natura l one for developers who try it . (Predictably, we have  
made it part of our standard at IS E.) You create t he required o bjects; set up any of their  
properties that differ from the d efaults; then apply the operat ions that you ne ed. This is the  
scheme sketched above for solve  in the Math library. It certainly beats passing 19 arguments.
Exceptions to the Operand principle?
The Operand principle is of universal applicability. Rather tha n true exceptions, it requires  
adaptation in tw o specific cases.
First, we can take advantage of t he flexibility of multiple cre ation procedures. Since  
a class can provide more than one  way to initialize an object, through creation  calls of the  
form  create  x  make_ specific  (argument , …) where make_ specific  is any of the creation  
procedures, we can relax the Ope rand principle for such creatio n procedures, facilitating  
the client’s task by offering va rious ways to set up objects wi th values other than the  
default. Two constr aints, however:
• Remember that, as always, every  creation procedure must ensure  the class invariant.
• The set of creation procedures must include a minimal procedur e (called make  in the  
recommended style) which include s no option arguments and sets all option values  
to their defaults.
The other case for loos ening the Operand pr inciple follows from  the last observation.  
If you have applied the principl e, you may find t hat some opera tions (other than creation  
procedures) are often used with option-setting procedures accor ding to a standard pattern;  
for example
my_document   set_ printing_size ("…")
my_document   set_ printer_name ("…")
my_document   print
In such a case, it may be conven ient, in the name of encapsulat ion and reusability,  
and in conformity to the Shoppin g List principle  studied next, to provide an extra routine  
as a convenience for clients:
print_with_size_and_  printer (printer_name : STRING ; size: SIZE_SPECIFICATION )
This assumes, of course, that the basic minimal routine (  print  in the example)  
remains available, and that the new routine is just a supplemen tary facility meant to  
simplify client text in cases th at have been rec ognized as trul y frequent.
This is not really a violation of the principle, since the very  nature of the new routine requires  
the arguments (printer and size in the example) to be present, making them operands.
DESIGNING CLASS INTERFACES  §23.3 770
A checklist
The Operand principle and its re cognition of the need to pay at tention to opt ions suggest  
a technique that helps get a cla ss right. For each class, list the supported options and  
produce a table with one row for each option, illustrated here by one of the rows for the  
DOCUMENT  class:
The successive columns list: the role of the option; how it is initialized by the various  
creation procedures; how it can b e accessed by clients; how it can be set to various values.  
This provides a useful checkli st for frequent deficiencies:
•Initialized entries help spot a wrong initi alization, especially when you r ely on the  
defaults. (A boolean option, for  example, is initialized to fal se; you should choose  
the corresponding attribute accordingly, so that the option for  c o l o r  s u p p o r t  i s  
Black_and_white_only  if you wish the default, false,  to represent full color suppor t.)
•T h e  Queried entries help spot the mistake of providing clients ways to set an option  
but not to access it. Note in par ticular that a routine that ta kes an object in a certain  
state may need to change some options for its own purposes, but  then restore the  
initial state; this is only possible if the routine can query t he initial value.
•T h e  Set entries help spot missing option - s e t t i n g  p r o c e d u r e s .  F o r  e x a m p l e if the  
default value for a boolean opti on is the usual false, and you provide a procedure to  
change it to true, you should no t forget to provide another to reset it to false.
None of the rules suggested here is absolute; for example some options may never  
need to be returned to false. Bu t they do apply in most cases, so it is important to check  
that the table’s entries indicate the behavior that you expect from the class. The table, or  
extracts from it, can also help document the class.
23.3  CLASS SIZE: THE SHOPPING LIST APPROACH
We have learned to be paranoid a bout limiting the external size  of features, as measured  
by the number of arguments, beca use it fundamentally affects th e features’ ease of use and  
hence the quality of a class interface. (We care less about the  internal  size of a feature,  
measured for example by the numb er of its instructions, since i t simply reflects the  
complexity of the algorithm. But  as you will certainly have not ed most routine bodies in  
good O-O design will remain small anyway.)
Should we be similarly concerned  about the size of each class a s a whole? Here the  
answer will be much less drastic.Option Initialized Queried Set
Paper size default:A4 (international)
make_LTR : LTR (US)size set_size  
set_A4  
set_LTR
§23.3   CLASS SIZE: THE SHOPPING LIST APPROACH 771
Class size definition
We must define how to measure th e size of a class. It is possib le to count the number of  
lines (or, preferably, the numbe r of declarations and instructi ons, which is less subject to  
individual variations of textual  l a y o u t ,  a n d  j u s t  r e q u i r e s  a  s i mple parser). Although  
interesting for some application s, this is a supplier-side meas ure. If we are more interested  
in how much functionality a clas s provides to its clients, the appropriate criterion is the  
number of features.
This still leaves two questions:
• Information hiding: do we count all features ( internal  size) or only exported ones  
(external ) size?
• Inheritance: do we count only the immediate features, that is to say those introduced  
i n  t h e  c l a s s  i t s e l f  ( immediate  size), all the features of the class including those  
inherited from any proper ancestor (  flat size, so called in reference to the notion of  
flat form of a class), or the i mmediate features plus those whi ch the class inherits but  
somehow modifies thro ugh redefinition or effecting, although re naming does not  
count ( incremental  size)?
Various combinations may be inte resting. For the present discus sion the most  
interesting measure will be external  and incremental : external size means that we take the  
client’s view of the class, rega rdless of anything that is usef ul for internal purposes only;  
and incremental size means that we focus on the class’s added v alue. With immediate size  
we would ignore the often import ant part of the functionality t hat is inherited; but with flat  
size we would be counti ng the same features  again in every clas s and its descendants.
Maintaining consistency
Some authors, such as Paul Johnso n, have argued for strong rest raints on class size:
Class designers are often tempted to include lots of features (in both the  
language sense and system design sense of the word ). The result is an interface  
where the few commonly used features are lost in a long list of strange routines .
Worse yet , the list of possible features is infinite .
ISE’s experience suggests a diffe rent view. We have found that class size is not by  
itself a problem. Although most c lasses remain relatively small  (a few features to a couple  
dozen), there is occasionally a need for bigger classes (up to 60 or even 80 features), and  
they do not raise any particular problem if they are otherwise well designed.
This experience leads to the shopping list approach: the realization that it does not  
hurt to add features t o a class if they are conceptually releva nt to it. If you hesitate to  
include an exported feature beca use you are not sure it is abso lutely necessary, you should  
not worry about its effect on class size. The only criteria tha t matter involve whether the  
class fits in with the rest. The se criteria can be expressed as  a general guideline:[Johnson 1995].
DESIGNING CLASS INTERFACES  §23.3 772
The first two requirements are related to the Class Consistency  principle, which  
stated that all the features of a class must pertain to a singl e, well-identified abstraction  
The counter-example given there was that of a string class (fro m the original NEXTSTEP  
library) which actually covered se veral abstractions and, as a result, was eventually split  
into several classes. What is at  issue here, however, is not si ze per se but d esign quality.
It is interesting to note that the same example, string, is als o one of the l arger classes  
in ISE’s libraries and has been criticized by Paul Johnson. But  in fact the reaction from  
library users over the years has been the reverse: asking for m ore features. The class,  
although rich, is not p articularly difficult to use because all  the features clearly apply to  
the same abstraction, character string, and it is in the nature  of that abstrac tion that many  
operations are applicable, from substring extraction and replac ement to concatenation and  
global character substitution.
Class STRING  shows that big does not mean complex. Some abstractions are ju st 
naturally endowed with many feat ures. Quoting Waldén and Nerson :
A document handling class th at contains 100 se parate operations to set various  
font operations … may in fact only be dealing with one or a few underlying  
concepts which are quite familiar and easy to grasp . Ease of sele cting the right  
operation is then reduced to having nicely organized manual pages .
In such a case splitting the cla ss would probably decrease rath er than improve its  
ease of use.
An extreme “minimalist” view hol ds that a class should only inc lude atomic features  
— those which cannot be expressed in terms of others. This woul d preclude some of the  
fundamental schemes of successful  object-oriented software cons truction, in particular  
behavior  classes  i n  w h i c h  a n  e f f e c t i v e  f e a t u r e ,  for example a routine describin g an 
iteration on a data structure, re lies on other lower-level feat ures of the class, often  
including some d eferred ones.
Minimalism would also prohibit in cluding two theoretically redu ndant but  
practically complementary features. Consider a class COMPLEX  to describe complex  
numbers, as developed earlier in t his chapter. For arithmetic o perations, some clients may  
need the function versions:
infix "+", infix "–", infix "∗", infix "/"Shopping List advice
When considering the addition of a new exported feature to a cl ass, observe  
the following rules:
S1 • The feature must be r elevant to the data abstraction represent ed by 
the class.
S2 • It must be compatible with th e other features  of the class.
S3 • It must not address exactly the same goal as another feature o f the class.
S4 • It must maintain the invariant of the class.
Page 730 .
[Waldén 1995],  
page 187 .
“Don’t call us, we’ll 
call you”, page 504 .
§23.3   CLASS SIZE: THE SHOPPING LIST APPROACH 773
so that evaluating  the expression z1 + z2  will create a new object  representing the sum of  
z1 and z2, and similarly for th e other functions. Ot her clients, or the same client in other  
contexts, may prefer the proce dure versions, w here the call z1   add (z2) will update the z1
object to represent the result of the addition, and similarly f or subtract , multiply and 
divide . In theory, it is redundant to include both the functions and the procedures, and  
either set can in fact be expressed in terms of the other. In p ractice, it is convenient to have  
both, for at least three reasons:  client convenie nce; efficienc y; and reusability.
Laxity and restrictiveness
In the last example the two sets of features, although theoreti cally redundant, are  
practically different. You should  not, of course, introduce a f eature if another already fills  
exactly the same need; this is covered by clause S 3 of the Shopping List advice. That  
clause is more restrictive than it may seem at first. In partic ular:
•Assume that you want to change t he order of arguments of a rout ine, for  
compatibility with others in the  same class or different ones. But you are concerned  
about compatibility with existi ng software. The solution in thi s case is not to keep  
both features with the same status; this would violate the advi ce. Instead, use the  
obsolete  library evolution mec hanism described lat er in this chapter.
• The same applies if you want to provide a default for an argum ent that used to be  
required for a certain routine. Do not  p r o v i d e  t w o  v e r s i o n s ,  o n e  w i t h  t h e  e x t r a  
argument for compatibility, the other relying on a default alon g the lines discussed  
earlier in this chapter. Make one  interface the official one; t he other will be covered  
by the obsolete  mechanism.
• If you hesitate between two po ssible names for a feature, you should almost always  
resist the temptation to provide  both as synonyms. The only exc eptions in ISE’s  
libraries concern a handful of fundamental features for which i t is convenient to have  
both an infix name and an identifi er, for example array access which can be used as  
my_array   item (some_index ) as well as my_array @ some_index , each form being  
preferable in some contexts. But  this is a rare situation. As a  general rule the class  
designer should choose a name, rather than passing the buck to client authors —  
penalizing them with the cons equences of his indecision.
As you will have noted, the policy resulting from this discussi on is a mix of laxity  
and restrictiveness. The policy seems lax because it explicitly  encourages you to include  
acceptable features ev en if they have not yet proved to be esse n t i a l .  B u t  i t  i s  i n  f a c t  
systematic and restrictive becau se it defines strong conditions  for a feature to be considered  
acceptable. The features of a class should cover as many needs as possible; but they should  
only cover relevant needs and, for  each distinct need, there sh ould be just one feature.
The Shopping List policy is only possible because we follow a s ystematic policy of  
keeping the language  small. A minimalist attitude to language design — ensuring tha t we 
stick to a small number of extreme ly powerful constructs, and a void redundancies —  
enables us to let class designers be non-minimalists. Every dev eloper needs to learn the  
language and, if the language is minimalist enough, will know all of it. Classes, however,  
are only used by client authors , and they can skip what they do  not use.“CLASS EVOLU-
TION: THE OBSO-LETE CLAUSE”, 23.7, page 802 .
DESIGNING CLASS INTERFACES  §23.4 774
You should also relate the S hopping List advice to the precedin g discussion of feature  
size. What might make a class difficult to use is not the numbe r of its features but their  
individual complexity of use. M ore precisely, class size can on ly be a significant problem  
initially, by facilitating or ham pering quick comprehension of the purpose and scope of a  
potentially reusable class which an application developer appro aches for the first time.  
Even there, we have seen that size per se is less relevant than  coherence (the Class  
Consistency principle). Past that stage, the reuser will, day i n and day out, deal with the  
features of the class, or more commonly with a subset of these features. Feature size issues  
take precedence: a feature with many arguments to remember will  make the task difficult.  
But class size has by then ceased to be relevant. Were you to r ely on some arbitrary  
numerical criterion (“no clas s shall have more than m lines or n features”), the result could  
have been to split the class into several, in some cases making  it more  difficult to use.
The lesson for class developers,  embodied in the Shopping List advice, is to worry  
about the quality of a class, in  particular its conceptual inte grity and the size of its features,  
but not about its size.
23.4  ACTIVE DATA STRUCTURES
Examples of this chapter and pre ceding ones have frequently rel ied on a notion of list or  
sequence characterized at any tim e  b y  a  “ c u r s o r  p o s i t i o n ”  i n d i c ating where accesses,  
insertions and deletions take pl ace. This view of data structur es, although different from  
most presentation in “algorithms  and data structures” textbooks , is of broad applicability  
and deserves a more detailed explanation.
To understand the merits of this  approach it will  be useful to start with the more  
common one and asses s its limitations.
Linked list representation
The discussion will be based on the example of lists. Although its results are independent  
of the choice of implementation, we need a specific representat ion to express the  
algorithms and illustrate the is sues. Let us use a popular choi ce: linked lists . Our general-
purpose library must have list c lasses and, among  them, a class  LINKED_LIST .
H e r e  a r e  a  f e w  b a s i c s  a b o u t  l i n k e d  l i s t s ,  a p p l i c a b l e  t o  a l l  t h e  interface styles  
discussed next — with and without cursors.
Linked lists are a useful represe ntation of sequential structur es because they  
facilitate operations of insertion  and deletion . The successive elements will be housed in  
individual cells, or linkables , each containing a value and a reference to another linkable:
A linkable
item right
§23.4   ACTIVE DATA STRUCTURES 775
The corresponding class, LINKABLE , should be generic, since we want the structure  
to be applicable to linked lists of any type. The cell value wi ll be given by feature item, of 
type G, the generic parameter; this wi ll be an in-place value if the actual generic parameter  
is expanded, for example for lists of integers or reals, and a reference otherw ise. The other  
attribute, right , of type LINKABLE [G], always represents a reference.
The list itself is represented by a separate cell, the header, containing a reference  
first_element to the first linkable,  and possibly some b ookkeeping informatio n such as the  
number of items, count . The figure shows  the representation of a list of characters.
This representation makes insert ion or deletion fast if you hav e a reference to the  
linkable immediately to the left of the operation’s target: a f ew reference manipulations  
will do, as shown here for t he deletion of the third element.
On the other hand, linked repres entation is not very good for f inding an element  
known by its value or its position: these operations require se quential list traversal. Array  
representations, in contrast, ar e good for accessing by positio n, but poor for insertions and  
deletions. Many other representations exist, some of which mana ge to combine some of  
the best of both worlds. The basic linked list remains one of t he most commonly used  
implementations, and is indeed a n effective tech nique for appli cations that require many  
local insertio ns and deletions but few random accesses.
A technical point: the figure do es not detail attributes of LINKED_LIST other than  
first_element , showing simply a shaded area. Although we could do with just first_element , 
the classes below will include an attribute count  to record the number of elements of the  
list. This query  could also be a function, but it would then be  inefficient, requ iring a traversal  
of the list to count its items each time a client asks us how m any we have. Of course if you  
use an attribute you must make sur e that every insertion or del etion updates it. The Uniform  
Access principle applies here: y ou can change the implementatio n without disturbing  
clients, which will in all c ases use the s ame notation, l  count , to obtain the item count.A linked list
first_elementInstance of
LINKED_LIST [G]
Instances of LINKABLE [G]
B C D E A
Deletion in a 
linked list
B C D E Afirst_element
See “Uniform 
Access”, page 55 .
DESIGNING CLASS INTERFACES  §23.4 776
Passive classes 
We clearly need two classes: LINKED_LIST for lists (more preci sely, list headers),  
LINKABLE for list element s (linkables). Both are generic. 
The notion of LINKABLE  is essential for the implemen tation, but not relevant to  
most clients. We should strive f or an interface that provides c lient modules with list  
primitives but does not bother them with such implementation de tails as the presence of  
linkable elements. The attributes , corresponding to the earlier  figure, will appear as:
note
description : "Linkable cells , for use in connection with linked lists "
note: "Partial version , attributes only "
class
LINKABLE1 [G]
feature  {LINKED_LIST }
item: G-- The cell value
right : LINKABLE [G]
-- The right neighbor
end
For the type of right  we might consider like Current , but it is preferable at this stage  
to keep more redefinition freedom as we do not know yet what ma y need to be changed  
by the possible descendants of LINKABLE .
To have a true class we need to ad d routines. What  should clien ts be allowed to do  
on a linkable? They will need  the ability to change the item and right  fields. Also, we may  
expect that most clients creating a linkable will specify its i nitial value, requiring a  
creation procedure. Th is yields a proper v ersion of the class: 
note
description : "Linkable cells , for use in connection with linked lists”
class  LINKABLE [G] creation
make
feature  {LINKED_LIST }
item: G
-- The cell value
right : LINKABLE [G]
-- The right neighbor
make (initial : G)
-- Initialize with item value initial .
do put (initial ) end
put (new: G)
-- Replace value with new.
do item  := new end
put_right (other : LINKABLE [G])
-- Put other  to the right of  current cell.
do right  := other end
end
§23.4   ACTIVE DATA STRUCTURES 777
For brevity the class omits the obvious procedure postcondition s (such as ensure  
item = initial  for make ). There are no preconditions.
So much for LINKABLE . Now consider the linked lists themselves, to be accessed  
internally through their headers . Among others we need exported  features to: obtain the  
number of elements ( count ); find out whether the list is empty ( empty ); obtain the value  
of the i-th element, for any legal index i (item); insert a new element at a certain position  
(put); change the value of the i-th element ( replace ); search for an element having a certain  
value ( occurrence ). W e will also need a query returning a reference to the first  element  
(void if the list is empty); i t does not need to be exported.
Here is a sketch of a first vers ion. Some of the  routine bodies  have been omitted.
note
description : "One-way linked lists "
note: "First version , passive "
class
LINKED_LIST1 [G]
feature -- Access
count : INTEGER
empty : BOOLEAN
-- Is list empty?
do
Result  := (count = 0)
ensure
empty_if_no_element : Result = (count = 0)
end
item (i: INTEGER ): G
-- Value of i-th list element
require
1 <= i; i <= count
local
elem : LINKABLE [G]; j: INTEGER
do
from
j := 1; elem  := first_element
invariant  j <= i; elem /= Void variant  i — j until
j = i
loop
j := j + 1 ; elem  := elem   right
end
Result  := elem   item
end
occurrence (v: G): INTEGER
-- Position of first  element of value v in list (0 if none)
do … end
DESIGNING CLASS INTERFACES  §23.4 778
feature -- Element change
put (v: G; i: INTEGER )
-- Insert a new element of value v
-- so that it becomes the  i-th element
require
1 <= i; i <= count + 1
local
previous , new: LINKABLE [G]; j: INTEGER
do
-- Create new cell
create  new  make (v)
if i = 1 then
-- Insert at head of list
new  put (first_element ); first_element  := new
else
from
j := 1; previous  := first_element
invariant
j >= 1; j <= i — 1 ; previous /= Void
-- previous is the j-th list element
variant
i — j — 1
until  j = i — 1 loop
j := j + 1 ; previous  := previous   right
end
-- Insert after  previous
previous   put_right (new)
new  put_right (previous   right )
end
count  := count + 1
ensure
one_more : count = old count + 1
not_empty : not empty
inserted : item (i) = v
-- For 1 <=  j < i, the element of index j has not chang ed its value
-- For i < j <= count ,
-- the element of index j has the value
-- that the element of index j — 1  had before the call
endprevious
new
§23.4   ACTIVE DATA STRUCTURES 779
replace (i: INTEGER ; v: G)
-- Replace by v the value of  i-th list element.
require
1 <= i; i <= count
do
…
ensure
replaced : item (i) = v
end
feature -- Removal
prune (i: INTEGER )
-- Remove  i-th list element
require
1 <= i; i <= count
do
…
ensure
one_less : count = old count — 1
end
… Other features …
feature {LINKED_LIST } -- Implementation
first_element : LINKABLE [G]
invariant
empty_definition : empty = (count = 0)
empty_iff_no_  first_element : empty = ( first_element = Void )
end
It is a good idea to try to complete occurrence , replace  and prune for yourself in this  
first version. (Make  sure to maintain the class invariant.) 
Encapsulation and assertions 
Before we consider better versio ns, a few comments are in order  on this first attempt. 
Class LINKED_LIST1  s h o w s  t h a t  e v e n  o n  f a i r l y  s imple structures reference  
manipulations are tricky, especia lly when combined with loops. The use of assertions  
helps get them right (see procedure put and the invariant); but th e sheer difficulty of this  
type of operations is a strong ar gument for encapsulating them once and for all in reusable  
modules, as promoted by the object-oriented approach. 
Also note the application of the  Uniform Access principle: alth ough count  i s  a n  
attribute and empty  a  f u n c t i o n ,  c l i e n t s  d o  n o t  n e e d  t o  k n o w  t h e s e  d e t a i l s .  T h e y  a r e 
protected against any later reversal of thes e implementation de cisions. 
DESIGNING CLASS INTERFACES  §23.4 780
The assertions for put are complete, but, because of the limitations of the assertion  
language, not completely formal.  Similarly extensive preconditi ons should be added to the  
other routines.
A critique of the class interface 
How usable is LINKED_LIST1 ? Let us evaluat e its design. 
A worrying aspect is the presenc e of significant redundancies: item and put contain  
almost identical loops, and simi lar ones will need to be includ ed in the routines whose  
code has been left to the reader ( occurrence , replace , remove ) .  Y e t  i t  d o e s  n o t  s e e m  
possible to factor out the comm on part. Not a pro mising start. 
This is an implementation problem, internal to the class: lack of reusability of the  
internal code. But it points to a more serious flaw — a poorly designed class interface. 
Consider routine occurrence . It returns the index at whi ch a given element has been  
found in the list, or zero if the  element is not present. One d rawback is that this only gives  
the first occurrence; what if th e client wants to obtain the su ccessive occurrences of a  
v al u e?  B u t  th er e i s  a  m o r e s er i ous difficulty. A client that ha s performed a successful  
search may, among other typical needs, want to change the value  of the element found, to  
delete that element, or to inser t a new one next to it. But any  one of these operations  
requires traversing the li st again! For example, put (v, i) goes through the first i elements,  
even if i is the result of occurrence  — obtained by a similar traversal.
In the design of a general-purpo se library component that will get used over and over,  
one cannot treat such inefficiencies lightly. Any performance o verhead due to the  
increased generality of a reusable solution must remain negligi ble; otherwise developers  
will not accept paying the price, dooming any reuse policy. Her e the price is not  
acceptable. 
Simple-minded solutions 
How can we remove the i nefficiency? Two pos sible solutions come  to mind: 
• We could make occurrence return, instead of an integer, the LINKABLE  reference to  
the cell where the requested value appears, or void for an unsu ccessful search. Then  
the client has a direct handle on  the actual linkable cell and may perform the needed  
operations without retravers al; it can for example use LINKABLE ’s put procedure to  
change the value, and its put_right  procedure to insert a new element. (Deletion is  
more delicate since the client w ould need the previous element too.)
• We could try to provi de enough primitives t o deal with various  combinations of  
operations: search and replace, s earch and insert, search and d elete and so on. 
The first solution, however, defe ats the whole idea of encapsul ating data structures  
in classes: clients would direct ly manipulate the representatio n s ,  w i t h  a l l  t h e  d a n g e r s  
involved. The notion of  linkable is internal; we want client pr ogrammers to think in terms  
of lists and list value s, not of list cells  and pointers. Other wise we lose data abstraction.
§23.4   ACTIVE DATA STRUCTURES 781
The second solution was attempte d in an early version of ISE’s libraries, which made  
an effort to provide routines co vering common combinations of o perations. To insert an  
element just before the occurren ce of a known value, a client w ould use, rather than a call  
to search  followed by a call to put, a single call to 
insert_before_by_value (v: G; v1: G)
-- Insert a new element of value v in front of fir st occurrence
-- of v1 in list, or at end of list if no such occurrence
do
…
end
This solution keeps the internal  representation hidden from cli ents, while avoiding  
the inefficiencies of the initial version. 
But we soon realized we were in for a long journe y. Consider al l the potentially  
useful variants: search_and_replace , insert_before_by_value , insert_after_by_value , 
insert_after_by_  position , insert_after_by_  position , delete_before_by_value , insert_at_
end_if_absent , and more.
This raises troubling questions about the viability of the appr oach, forcing a  
reflection on library d esign. Writing general-purpose reusable software is a difficult task,  
and there is no guarantee that y ou will get everything right th e first time — with a design  
that would follow the horizontal line in the figure below. You should be prepared to extend  
classes with new features as the library’s usage reaches new us ers and new application  
domains. As represented by the co lored line of the picture, how ever, the process must  
converge: after an ini tial tune-up period, t he design should re ach a stable state.
If not — that is to say, if almost every new use brings in the need for extension or  
modification, as represented by the dotted line in the figure —  the approach to reusability  
is obviously flawed. This appeared to be the case with the list  class we had at that point:  
it looked as if every time we pu t the list class to a new use t he need would arise for yet  
another routine, repre senting a new combinat ion of the basic op erations.
To make matters worse, all such routines are rather complex, wi th loops similar to  
the one for put; they have much in common but all differ from each other by sm all details.  
The prospect of a robust, reusab le linked list class seems to b e receding. Evolution of a 
library class
Number of (re)usesNumber
DesirablePerfectof featuresFailure
DESIGNING CLASS INTERFACES  §23.4 782
Introducing a state 
Fortunately, there is a way out. To find it requires taking a d ifferent view of the underlying  
abstract data type. 
So far a list has been treated as a passive repository of infor mation. To provide its  
clients with a better service, the list should become more acti ve by “remembering” where  
the last operation  was performed. 
As noted earlier in this chapter, we should not hesitate to loo k at objects as machines  
with an internal state, and intr oduce both commands that change  the state and queries on  
the state. In the first solution  a list object already had a st ate, defined by its contents and  
modifiable by commands such as put and remove ; but by adding more components to the  
state we will obtain a better in terface, making the class both simpler and more efficient.
Besides the list contents, the state will include the notion of  currently active position,  
or cursor; the interface will allow clients to move the cursor explicitly.
We permit the cursor to be on a list element (if any), or one p osition to the left of the  
first, in which case the boolean query before  will return true, or one position to the right  
of the last, making after  true.
A n  e x a m p l e  o f  a  c o m m a n d  t h a t  m a y  m o v e  t h e  c u r s o r  i s  t h e  p r o c e d u re search , 
replacing the function occurrence . A call to l  search (v) will move the cursor to the first  
element of value v to the right of the current cursor position, or move it after  if there is  
none. Note that in passing this solves the problem of finding m ultiple occurrences of v: 
just call search  as many times as needed. (For  symmetry we could also have search_back .)
The basic commands to man ipulate the cursor are:
•start and finish to move the cursor to the firs t and last position if any.
•forth and back to move the cursor  to the next and previous position. 
•go (i) to move it to a s tated position i.
Besides before  and after , queries on the cursor position include index , its integer  
index (starting at 1 for the fir st element) as well as the bool eans is_  first and is_last .List with 
cursor
first_elementInstance of
LINKED_LIST [G]
Instances of LINKABLE [G]
B C D E A
Cursor
before after
forth back
§23.4   ACTIVE DATA STRUCTURES 783
The procedures to buil d an d m od if y  a l i st  —  in se rt i on ,  de le t io n , replacement —  
become simpler because they do n ot have to worry about position s: they will simply act  
on elements at the current cursor position. All the loops disap pear! For example, remove  
will not be called as l  remove (i) any more, but simply as l  remove , to delete the element  
at the current cursor position. W e need to establish precise an d consistent conventions  
about what happens to the cu rsor after each operation: 
•remove , with no argument, deletes the e lement at cursor position and puts the cursor  
under its right neighbor  (so that the value of index does not change in the end). 
•put_right (v: G) inserts an element of value v to the right of the cursor and does not  
move the cursor ( index  is unchanged). 
•put_left (v: G) inserts an element of value v to the left of the cursor and does not move  
the cursor (increas ing the value of index by 1). 
•replace (v: G) changes the value of the elemen t at cursor pos ition. The value  of this  
element is given by the query function item, which now has no argument (and so  
could be implemented  as an attribute). 
Maintaining consistency: the implementation invariant 
In building the class for such a  fundamental data structure we must be careful to get  
everything right. Here assertion s are indispensa ble. Without th em we would be almost  
sure to miss some de tails. For example:
•I s  a  c a l l  t o  start permitted if the list  is empty and, if so , what is its effect?
• What happens to the cursor after a remove  if the cursor was on the last element? In  
other cases the cursor should go to the element immediately to the right of the  
deleted one, but here there is none. This is one of the reasons  for the convention that  
was stated informally — allowing the cursor to move one positio n off to the right or  
to the left — but we need a more precise statement of this prop erty, addressing all  
cases unambiguously.
A n s w e r s  t o  q u e s t i o n s  o f  t h e  f i r s t  k i n d  w i l l  b e  d e s c r i b e d  b y  p r e conditions and  
postconditions.
For such properties as the permitted cursor positions, we shoul d use the invariant,  
more precisely the clauses const ituting the implementation inva riant. Remember that an  
implementation invariant express es the consistency of a represe ntation, given by a class,  
vis-à-vis the underlying abstrac t data type. Here it will inclu de the property 
0 <= index ; index <= count + 1
What about an empty list? We need to respect the symmetry betwe en left and right.  
One solution, adopted in an earli er version of the library, is to consider that an empty list  
is both before  and after , and constitutes the only case i n which both of these properti es may  
be true together. This works but  leads, in the routines’ algori thms, to frequent tests of the  
form if after  and not empty … to distinguish between true cases of after  and accidental  See “Implementation 
invariants”, page 376 .
DESIGNING CLASS INTERFACES  §23.4 784
ones resulting from empty . It turns out to be preferable to take the view that, conceptu ally, 
a list always has two extra sentinel  elements, shown as  and  in the figure:
The sentinel elements help us reason about the structure, but w e will not necessarily  
store them in the representation . The implementation discussed next stores the left sentinel  
but not the right one; it is als o possible to use an implementa tion that stores neither but  
still conforms to the conceptual  model represented by the above  figure.
Since we often want to state, fo r example as the  precondition f or an operation on an  
element given by its index, that the index indeed marks a posit ion where the list has an  
element, we need a query t o express this condition:
on_item (i: INTEGER ): BOOLEAN
-- Is there an element at position i?
do
Result  := ((index >= 1) and (index <= count ))
ensure
within_bounds : Result = ((index >= 1) and (index <= count ))
no_elements_if_empty : Result implies (not empty )
end
T o  s t a t e  t h a t  t h e r e  i s  a n  e l e m e n t  a t  t h e  c u r s o r  p o s i t i o n ,  w e  m a y define query  
readable , whose value is that of on_item (index ). This is a good example of the  
Shopping List principle: because readable  is conceptually redundant, a minimalist  
policy would get rid of it; by in cluding it we provide our clie nts with a better abstraction,  
freeing them from having to reme mber what exactly constitutes a  valid item index at the  
implementation level.
The invariant will state that not (after and before ). In the boundary case of an empty  
list, the picture becomes:
List with 
sentinels
B C D E Aafter beforenot after ; not before
1 <= index ; index <= count0 1 count count+1
Valid cursor positions

§23.4   ACTIVE DATA STRUCTURES 785
So an empty list will have two possible states: empty and before  and empty  and after, 
corresponding to the two cursor positions in the figure. This s eems strange at first but has  
no unpleasant consequence, and is  i n  p r a c t i c e  p r e f e r a b l e  t o  t h e  earlier convention that  
empty  = (before and after ), now replaced by empty implies (before or after).
Note two general lessons here: the usefulness, as in many mathe matics or physics  
problems, of che cking boundary cases to verify that a general s olution is sound; and the  
importance of relying on asserti ons to express the precise prop erties of a design. Here are  
some of the principal cl auses of the invariant:
0 <= index ; index <= count
before = (index = 0); after = (index = count + 1 )
is_ first = ((not empty ) and (index = 1)); is_last = ((not empty ) and (index = count+1 ))
empty = (count = 0)
-- The next three clauses are theo rems (deducible from the previo us ones):
empty implies  (before or after )
not (before and after )
empty implies ((not is_ first) and (not is_last ))
This example illustrates the gen eral observation that writing t he invariant is the best  
way to get a real understanding of what a class is about. The c lauses seen so far apply  
equally to all impleme ntations of sequentia l lists; they will s hortly be complemented by a  
few others which are specific to the choice of a linked represe ntation.
The last three clauses, as noted, are deducible from the others  (prove them!).  
Invariants are not required to be minimal; it is often useful t o list additional clauses such  
as these if they state important, non-trivial properties of the  class. As we saw in the study  
of abstract data types, an ADT, and hence its implementation as  a class, is a theory — here  
the theory of linked lists. The b asic invariant clauses express  the axioms of the theory; but  
any useful theory has in teresting theorems too.
Of course if you intend to monitor invariants at run time — mea ning that you are not quite  
sure yet that the theory is  sound! — you should also consider t he effect of added clauses  
on execution time. But this only matters for development and de bugging. In a usual  
production context there is no reason for monitoring the invari ants.
The client’s view 
This design provides a simple and  elegant interfa ce to the impl ementation of linked lists.  
Operations such as “se arch and then insert” use two successive calls, although with no  
significant loss  of efficiency: after before
0 count+1 = 1
Valid cursor positions
Empty list with 
sentinels
For more clauses 
see page 791 .
Exercise E23.6, 
page 807 .
DESIGNING CLASS INTERFACES  §23.4 786
l: LINKED_LIST [INTEGER ]; m, n: INTEGER
…
l  search (m)
if not after then  l  put_right (n) end
The call search (m) moves the cursor to the next occurrence of m after the current  
cursor position, or after  if there is none. (The extract a ssumes that the cursor is init ially 
known to be on the fir st element; if not, t he client should exe cute l  start first.)
To delete the third o ccurrence of a certain  value, a client wil l execute: 
l  start; l  search (m); l  search (m); l  search (m)
if not after then  l  remove end
To insert a value at position i: 
l  go (i); l  put_left (i)
and so on. We have obtained a cl ear and easy to use interface b y making the internal state  
explicit, and providing  clients with the appropriate commands a nd queries on this state. 
The internal view
The new solution simplifies the implementation just as it impro ves the interface. Most  
importantly, by giving each routi ne a simpler specification, co ncentrated on just one task,  
it removes unjustified redundanci es, in particular all the unne eded loops. Insertion and  
deletion procedures no longer ha v e  t o  t r a v e r s e  t h e  l i s t ;  t h e y  j ust carry out a local  
modification. The responsibility  of positioning the cursor now lies with other routines  
(back , forth , go, search ), only some of which ( go and search ) need loops.
Along with first_element  it will be useful to keep two references in the list header,  
enabling us to perform insertions and deletions efficiently: active , attached to the cursor  
item at cursor position, and previous attached to the previous one.Cursor list 
representation (first variant )
first_elementInstance of LINKED_LIST [G]
Instances of LINKABLE [G]
B C D E A
Cursorbefore afterpreviousindex
active3
itemcount 5
§23.4   ACTIVE DATA STRUCTURES 787
Clients may know the state of the list by accessing public inte ger attributes count  and 
index  a n d  b o o l e a n  q u e r i e s  before , after, is_  first, is_last , item. Here are two typical  
functions:
after : BOOLEAN
-- Is there no valid posit ion to right of cursor?
do Result  := (index = count + 1 ) end
is_ first: BOOLEAN
-- Is cursor on first item?
do Result  := (index = 1) end
Note the phrasing of the header comments. For after , “Is cursor to the right of last  
element? ” would not be quite correct, since after  may be true even if there is no element  
at all. Writing header  comments so that they are clear, terse a nd accurate is an art form.
The query item returns the element at cursor position, if any:
item: G
-- Element at cursor position
require
readable : readable
do
Result  := active   item
end
Remember that readable  i n d i c a t e s  w h e t h e r  t h e  c u r s o r  i s  o n  a n  e l e m e n t  ( index
between 1 and count ). Also note that item i n  active   item r e f e r s  t o  t h e  a t t r i b u t e  i n  
LINKABLE , not to the function of LINKED_LIST  itself.
Here now are the basic cursor manipulation commands; they are f airly delicate to get  
right but, as a consolation, you may note that only a handful o f routines, such as start, forth , 
put_right , put_left and remove , must perform non-trivial operations on references. Let us  
try start and forth . Procedure start must work for an empty list as well as a non-empty one;  
for an empty list the convention is that start brings the cur sor to the second sentinel. 
start1
-- Move cursor to first position.
-- (Provisional ve rsion; see next.)
do
index  := 1
previous  := Void
active  := first_element
ensure
moved_to_  first: index = 1
empty_convention : empty implies after
endYou should complete 
before  and is_last  
based on this model .
See “Routine header 
comments: an exercise in corporate downsiz-ing”, page 886 .
previous activefirst_element

DESIGNING CLASS INTERFACES  §23.4 788
forth1
-- Move cursor to  next position.
-- (Provisional ver sion; see next.)
require
not_after : not after
do
index  := index + 1
if before then
active  := first_element ; previous  := Void
else
check  active /= Void end
previous  := active ; active  := active   right
end
ensure
moved_by_one : index = old index + 1
end
H e r e  w e  s t o p !  T h i s  i s  b e c o m i n g  t o o  c o m p l i c a t e d  a n d  t o o  i n e f f i c i ent. The  
performance of procedure forth i s  c r u c i a l ,  s i n c e  a  t y p i c a l  u s e  o f  a  l i s t  b y  a  c l i e n t  i s  
from  start until after loop …; forth end. Can we get rid of the test?
We can, by taking the left sentinel seriousl y and always creati ng it when we create  
a list; the creation procedure make  of LINKED_LIST  is left as an exercise. We replace  
first_element  by a reference zeroth_element  to the sentinel:
The properties zeroth_element /= Void and previous /= Void  will be part of the  
invariant (you must of course make sure that the creation proce dure ensures them). They  
are precious since they will  save many repeated tests.
Procedure forth , given here after the new start, is simpler and f aster (no test!):previous active
right
Cursor list 
representation 
(revised variant )
zeroth_element
B C D E A
before afterpreviousindex
active3
itemcount 5

§23.4   ACTIVE DATA STRUCTURES 789
start
-- Move cursor to first position.
do
index  := 1
previous  := zeroth_element
active  := previous   right
ensure
moved_to_  first: index = 1
empty_convention : empty implies after
previous_is_zeroth : previous = zeroth_element
end
forth
-- Move cursor to next position.
-- (Version revi sed for efficiency; no test!)
require
not_after : not after
do
index  := index + 1
previous  := active
active  := active   right
ensure
moved_by_one : index = old index + 1
end
It is convenient to define go_before which positions the curso r on the left sentinel:
go_before
-- Move cursor before .
do
index  := 0
previous  := zeroth_element
active  := zeroth_element
ensure
before : before
previous_is_zeroth : previous = zeroth_element
previous_is_active : active = previous
end
Procedure go is entirely defin ed in terms of go_before and forth :previous activezeroth_element
right
previous active
right
previous
activezeroth_element ,
right

DESIGNING CLASS INTERFACES  §23.4 790
go (i: INTEGER )
-- Move cursor to i-th position.
require
not_offleft : i >= 0
not_offright : i <= count + 1
do
from
if i < index then go_before end
invariant index <= i variant i – index until index = i loop
forth
end
ensure
moved_there : index = i
end
Note the care exercised in avoid ing useless traversal steps in go, the only one of  
procedures seen so far that need s a loop. For symmetry we shoul d add finish , which brings  
the cursor to the last position and can be implemented as just go (count + 1 ).
Although not really indispensable , it is convenie nt (Shopping L ist principle!) to  
export go_before . Then for symmetry we should  also include and export go_after , which  
does go (count + 1 ), and export it.
Also for symmetry is back , using go’s loop:
back
-- Move cursor to previous position.
require
not_before : not before
do
check index – 1 >= 0 end
go (index – 1 )
ensure
index = old index – 1
end
However pleasing, the symmetry between back and forth is not without danger, since  
it may lead client authors to use  both procedures freely even t hough back , which has to  
restart from the beginning of the list and perform index – 1  iterations of forth , is much  
more expensive. If you perform a nything more than a few occasio nal back , the one-way  
linked list is inappropriate; you can for example use two-way l inked lists. The  
corresponding class may be built as an heir to LINKED_LIST  (a valid use of inheritance,  
since a list lin ked both ways is also li nked one way ) and is le ft as an exercise. Make sure  
to do this exercise at some stag e if you want to reach a full m astery of the concepts.
The earlier invariant clauses, as noted, were implementation-in dependent. Here are  
a few more clauses capturing som e of what we have learned about  our implementation:Exercise E23.7, 
page 807 .
§23.4   ACTIVE DATA STRUCTURES 791
empty  = (zeroth_element   right = Void )
zeroth_element /= Void ; previous /= Void
(active = Void ) = after ; (active = previous ) = before
(not before ) implies (previous   right = active )
(previous = zeroth_element ) = (before or is_ first)
is_last = ((active /= Void ) and then  (active   right = Void ))
Most of the queries are straightforward. before should return the boolean value of  
(index = 0) and after that of (index = count + 1 ). The element at cursor position is given by
item: G
-- Value of element at cursor position
require
readable : readable
do
Result  := active   item
end
Procedure search  is similar to go and left to the reader . Y ou should also write the  
procedure i_th (i: INTEGER ) which returns the value o f the element at position i; although  
concrete side effects are acceptable, be sure not to introduce any abstract side effect.
The last category of features in cludes procedures for insertion  a n d  d e l e t i o n .  T h e  
basic deletion operation is: 
remove
-- Delete element at cursor positio n and move cursor to its right  neighbor.
-- (If no right neig hbor, list becomes after ).
require
readable : readable
do
active  := active   right
previous   put_right (active )
count  := count — 1
ensure
same_index : index = old index
one_less_element : count = old count – 1
empty_implies_after : empty implies  after
end
The routine looks trivial; but this is only thanks to the techn ique of keeping the left  
sentinel around as a physical object, avoiding constant tests o f the form previous /= Void 
and first_element /= Void . It is worth considering the more complicated and less efficie nt 
routine body that we would have obtained without this simplific ation:The first set of clauses 
was on page 785 .
previous active
DESIGNING CLASS INTERFACES  §23.4 792
active := active  right
if previous /= Void then previous  put_right (active ) end
count := count — 1
if count = 0 then
first_element := Void 
elseif  index = 1 then
first_element := active
-- else first_element  does not change
end
In either case, the more you can express in assertions, the bet ter you will understand  
what is going on a nd avoid mistakes.
You should exercise your underst anding of these techniques by w riting the insertion  
procedures put_left  and put_right .
Abstract data types and abstract machines
The notion of ac tive data structure is w idely applicable and in  line with earlier principles  
of this chapter, Comma nd-Query Separation in particular. Giving  data structures an  
explicit state often yields simp le, easy to document interfaces . 
One might fear that the resulting structures would become less abstract, but this is  
not the case. Abstract does not mean passive. What the theory o f abstract data types tells  
us is that our objects should be  known through abstract descrip tions of the applicable  
operations and their properties; but this does not imply treati ng them as mere repositories  
of data. By introducing  a state and operati ons on that state, w e actually make the abstract  
data type specification richer as it has more functions and mor e properties. The state itself  
is a pure abstraction, always ac cessed indirectly through comma nds and queries.
The view of objects as state mac hines reflects abstract data ty pes which are more  
imperative , not less abstract.
Separating the state
It is possible to take the preceding techniques further. So far  the cursor was just a concept,  
implemented indirectly  through attributes previous , active  and index  rather than directly  
through one of the classes of the  software. We can define a cla ss CURSOR  w i t h 
descendants for various kinds of  cursor structure. Then we can separate, for a structure  
such as a list, the attributes t hat describe the list contents (zeroth_element , count ) from the  
traversal-related attributes, whi ch will be stored in cursor ob jects.
Although we do not need to pursue  this idea here, it is useful to note its possible  
application to a concurrent cont ext. If a number of clients nee d to access a shared structure,  
they can each have t heir own cursors.
Merging the list and the sentinels
(This section describes an advan ced optimization  and may be ski pped on first reading.)Warning: rejected 
version!
Exercise E23.9, 
page 808 .
Skip to “SELEC-
TIVE EXPORTS”, 23.5, page 796 .
§23.4   ACTIVE DATA STRUCTURES 793
The example of linked lists with  t h e  s e n t i n e l s  c a n  b e n e f i t  f r o m  o n e  m o r e  
optimization, which has indeed b een applied to the latest versi ons of the ISE libraries. We  
will only take a peek at it beca use it is of a specialized natu re and not relevant to normal  
application development. Such de licate optimizations should onl y be considered for  
widely used reusable components.  (In other words: do not try th is at home.)
Can we get the benefit of sentin els without wasting the corresp onding space? As  
noted upon the introduction of t he sentinel concept, we could t reat the sentinels as  
fictitious; but then we would lo se the crucial optimization whi ch has enabled us to write  
the body of forth  as just
index  := index + 1
previous  := active
active  := active   right
without the expensive tests of t he earlier versions. We avoid t hese tests by making sure  
that, for a list in non- after  state, active  is never void (the correspo nding invariant clause is  
(active = Void ) = after ); this is because we always hav e a real cell, the sentinel, av ailable  
to serve as initialization for active , even for an empty list.
For a routine other than forth , the optimization would no t be such a big deal. But  
forth , as noted, is the bread and but ter of list processing by clien ts, resulting from the  
sequential nature of the lists ; typical usage is of the form
from  your_list   start until  your_list   after loop …; your_list   forth end
and it is not uncommon, if you us e a profiler tool to measure w hat happens during  
execution, to discover that the computation spends a good part of its time in forth . So it  
pays to optimize it, and the test -free form above indeed provid es a dramatic improvement  
over the test-full one.
To get this time improvement, ho wever, we pay a space penalty: each list now has  
an extra element, with no actual information. This would seem t o cause a problem only if  
we have many short lis ts. But the problem c an become more serio us:
• In many cases, as hinted earlier , you will need two-way linked  lists, fully symmetric,  
with BI_LINKABLE  elements chained both ways. Class TWO_WAY_LIST  (which, by  
the way, may be written as inheriting twice from LINKED_LIST , relying on repeated  
inheritance techn iques) will need both a left and a right senti nel elements.
•Linked trees present an even mor e serious problem. An important  p r a c t i c a l  c l a s s  i s  
TWO_WAY_TREE , providing a convenient doubly-l inked representation of trees.  
Building on ideas developed in the  presentation of multiple inh eritance, this class  
merges the notion of node and tree; it inherits from both TWO_WAY_LIST and BI_
LINKABLE . But then every node is a list, a two-way one at that, and may  have to  
carry both sentinels.
Although there are other ways to solve the second case — such a s renouncing the  
inheritance structure — let us s ee if we can get the best of al l worlds.“Trees are lists and list 
elements”, page 525 .
DESIGNING CLASS INTERFACES  §23.4 794
To find a solution let us ask an  impertinent question. In the s tructure
do we really need two bookkeeping-onl y objects? The truly use ful information is in t he 
part not shown on the figure, the actual list elements; to mana ge them we have added both  
a list header and a sentinel — two sentinels in the case of a t wo-way list. For long lists we  
are able to ignore this bloated b ookkeeping structure, like a l arge company that has  
accumulated many layers of middle management in times of econom ic prosperity; but  
when the going gets tough it is time to take a closer look and see if we cannot merge a few  
of these management functions.
Can we indeed make the list header itself  play the role of sent inel? It turns out we  
can. All that a LINKABLE needs is an item field and a right  field. For a sentinel, in fact,  
only the right  field. That field denotes the first of the list elements; so i f we put it in the  
list header it will play the same role as what used to be calle d first_element  in the first  
variant of the sentinel implementation. The problem, of course,  was that first_element
could be void, for an empty list , polluting all our algorithms with tests of the form if before  
then … We certainly do not want to go b ack to that situation. But we c an keep the  
representation of the figure at the top of this page as the con ceptual model, while getting  
rid of the sentinel object in the im plementation. The concrete pict ure becomes
The key to understanding this sol ution and getting things right  is to remember that  
this solution is exact ly the same conceptual ly as the last one,  but replaces zeroth_element  
by a reference to the list header itself ( Current  in class LINKED_LIST ), using first_element
to represent what used to be zeroth_element   right  (possibly void, but always defined since  
zeroth_element  was never void). W e still need a convention for  the empty list , with no  
“Useful list eleme nts”; in that case  the last figure becomeszeroth_element
(Instance of LINKED_LIST )
… Useful list elements …List header
(Instance of
LINKABLE )Sentinelright
first_element 
appeared among others in the figures of page 786 .
Header as 
sentinel (non-empty list)(Instance of LINKED_LIST  and LINKABLE )
… Useful list elements …List header and sentinel
first_element
(also plays the role of right )
Header as 
sentinel (empty 
list)
(No useful list elements)first_element
§23.4   ACTIVE DATA STRUCTURES 795
w i t h  a  s i m p l e  c o n v ention: attaching first_element back to the list header itself. This  
way first_element  will never be void — our crucial goal for keeping everything s imple;  
we must just remember to rep lace, everywhere in class LINKED_LIST , any test of the  
form zeroth_element   right by first_element  = Current .
We keep all the desira ble invariant clauses of the previous sen tinel versions:
previous /= Void
(active = Void ) = after ; (active = previous ) = before
(not before ) implies (previous   right = active )
is_last = ((active /= Void ) and then  (active   right = Void ))
The clauses involving zeroth_element , which used to be
zeroth_element /= Void
empty = (zeroth_element   right = Void )
(previous = zeroth_element ) = (before or is_ first)
now yield:
first_element /= Void
empty = ( first_element = Current )
(previous = Current ) = (before or is_ first)
All this is obtained simply (fasten your seat belts) by making LINKED_LIST  inherit  
from LINKABLE :
class LINKED_LIST [G] inherit
LINKABLE [G]
rename  right  as first_element , put_right as set_first_element end
… Rest of class as before, with the removal of zeroth_element  as shown above … 
Is it a kludge to let LINKED_LIST  inherit from LINKABLE ? Not at all! The whole  
idea was to merge the notions of  list header and  sentinel, that  is to say, to consider a list  
header (an instance of LINKED_LIST ) as a linkable too; so we have a perfect example of  
the “is-a” relation of inheritan ce. We have decided to treat ev ery LINKED_LIST  a s  a 
LINKABLE , so inheritance is the proper way to go. Here the client relat ion is not even in  
the race: not only would it not y ield what we want, the removal  of extra fat from our  
structures; it would add even more fields to our objects!
Make sure your seat belts are st ill securely fastened as we sta rt considering what  
happens lower in the i nheritance structure. BI_LINKABLE  inherits twice from  
LINKABLE . Class TWO_WAY_LIST  inherits from LINKED_LIST  (once, or possibly twice  
depending on the implementation technique that we choose) and, in line with the  
technique just seen, from BI_LINKABLE . With all the repeated inheritance involved one  
might think that things would ge t out of hand and that our stru ctures would start getting  
all kinds of unnecessary fields;  but no, the rules on sharing a nd replication in repeated  
inheritance enable us to g et exactly what we want.
DESIGNING CLASS INTERFACES  §23.5 796
The last step is TWO_WAY_TREE  which, for good measure, inherits from both  
TWO_WAY_LIST  and BI_LINKABLE . Enough, one might think, for a few heart attacks,  
but no; everything falls nicely into place. We get all the feat ures we want, none of the  
features we do not want; all the sentinels are in place — conce ptually — so that forth , back
and all the consequent loops can  be as fast as they need to be;  and the sentinels do not take  
up any space at all.
This is indeed the scheme now ap plied to the affected classes i n the Base libraries.  
Before we recover from  the flight, a few observations are in or der:
• Under no circumstance should thi s kind of work, involving tric ky data structure  
manipulation, be undertaken witho ut the full bene fit of asserti o n s .  I t  i s  s i m p l y  
impossible to get them right wit hout stating the invariant prec isely, and checking that  
everything remains c ompatible with it.
• The machinery of repeated inheritance is essential. Without th e techniques  
introduced by th e notation of this book to enable a repeated de scendant to obtain  
sharing or replication on a feature-by-feat ure basis, based on the simple criterion of  
feature names, it is impossible to handle effectively any situa tion involving serious  
use of repeated inheritance.
• To repeat the most important co mment: such delicate optimizati ons are only worth  
considering in heavily used libraries of general-purpose reusab le components. In  
normal application development, they are just too hairy to be w orthwhile. The  
discussion has b een included here to give the reader a glimpse of what it takes to craft  
professional components all the way to the end; but most develo pments will, happily,  
never have to undert ake such efforts.
23.5  SELECTIVE EXPORTS 
The relationship b etween classes LINKABLE  a n d  LINKED_LIST  illustrates the  
importance, for a satisfactory a pplication of the rule of Infor mation Hiding, of supporting  
more than just two export modes , secret and generally available , for a feature.
Class LINKABLE should not make its features — item, right , make , put, put_right  — 
generally available, since most clients have no business peekin g into linkables, and should  
o n l y  u s e  l i n k e d  l i s t s .  B u t  i t  c a nnot make them secret, for that  would hide them from  
LINKED_LIST , their intended beneficiary. Such calls as active   right , essential to the  
operation of forth  and other LINKED_LIST routines, would not be possible.
Selective exports provide the solution by enabling LINKABLE to select a set of  
classes to which, and to which only, it wi ll export its feature s:
class
LINKABLE [G]
feature  {LINKED_LIST }
item: G
right : LINKABLE [G]
etc.
end“SELECTIVE 
EXPORTS AND INFORMATION HID-ING”, 7.8, page 191 .
§23.6   DEALING WITH ABNORMAL CASES 797
Remember that this makes the fea tures available to all descenda nts of LINKED_LIST , 
as is indispensable if they need  to redefine some inherited rou tines or add their own.
Sometimes, as we saw in an earli er chapter, a class must export  a feature selectively  
to itself. For example the heir BI_LINKABLE  of LINKABLE , describing two-way linked  
lists with a field left, includes an invariant  clause of the form
(left /= Void ) implies (left  right = Current )
requiring right  to be declared in a clause feature {… Other classes …, BI_LINKABLE }; 
otherwise the call left  right  would be invalid.
Selective export clauses are essential when a group of related classes, as LINKABLE
and LINKED_LIST  here, need some of each other’s features for their implementat ions, 
although these features remain private to the group and should not be made available to  
other classes. 
A reminder: in a discussion of an earlier chapter we saw that s elective exports are a key  
requirement for the decentralize d architectures of object-orien ted software construction.
23.6  DEALING WITH ABNORMAL CASES
Our next interface design topic i s a problem that affects every  software development: how  
to handle cases that deviate from  the normal, des ired schemes.
Whether due to errors made by the system’s users, to abnormal c onditions in the  
operating environment, to irregu lar input data, to hardware mal function, to operating  
system bugs or to incorrect behav ior of other modules, special cases are the scourge of  
developers. The necessity to acco unt for all possible situation sis a powerful impediment  
in the constant battle agai nst software complexity. 
This problem strongly affects the design of module interfaces W hat software  
developer has not wished that it  would just go away? Then we co uld write clear, elegant  
algorithms for normal cases, and rely on external mechanisms to  take care of all the others.  
Much of the hope placed in except ion mechanisms results from th is dream. In Ada, for  
example, you may deal with an a bnormal case by writing somethin g like 
if some_abnormal_si tuation_detected  then
raise  some_exception ;
end;
“Go on with normal processing”
where execut ion of the raise  instruction stops the execution of the current routine or bloc k 
and transfers control to an “exc eption handler” written in one of the direct or indirect  
callers. But this is a control structure, not a method for deal ing with abnormal cases. In the  
end you still have to decide wha t to do in these cases: is it p ossible to correct the situation?  
If so, how, and what should the system do next? If not, how qui ckly and gracefully can  
you terminate the execution? “Exporting to your-
self”, page 193 .
“The architectural 
role of selective exports”, page 209 .
DESIGNING CLASS INTERFACES  §23.6 798
We saw in an earlier chapter tha t a disciplined exception mecha nism fits well with  
the rest of the object-oriented approach and in particular with  the notion of Design by  
Contract. But not all special ca ses justify resorting to except ions. The design techniques  
that we will now examine are per haps less impre ssive at first —  “low-tech” might be a  
good characterization — but they are remarkably p owerful and ad dress many of the  
possible practical situations. A fter studying them we will revi ew the cases in which  
exceptions remain  indispensable. 
The a priori scheme 
Perhaps the most important crite rion in dealing with abnormal c ases at the module  
interface level is specification.  If you know exactly what inpu ts each software element is  
prepared to accept, and what gua rantees it ensures in return, h alf the battle is won.
This idea was developed in depth as part of the study of Design  by Contract. We saw  
in particular that, contrary to conventional wisdom, one does n ot obtain reliability by  
including many possibl e redundant checks, but by assigning ever y consistency constraint  
to the responsibility of just one  class, either th e client or t he supplier.
Including the constrai nt in a routine prec ondition means assign ing it to the clients.  
The precondition expresses what is required to make the routine ’s operation possible:
operation (x: …)
require
precondition (x)
do
… Code that will only work  if precondition is met …
end
The precondition should, wheneve r possible, be complete, in the  s e n s e  o f  
guaranteeing that any call satis fying will succeed. If so, ther e are two ways to write the  
corresponding client  extracts. One is to  test explicitly: 
if precondition (y) then
operation (y)
else
… Appropriate alternate action …
end
(For brevity this example uses an unqualified call, but of cour se most calls will be of the  
qualified form z  operation (y).) The other possibility avoids the if…then …else b y 
ensuring that the cont ext leading to the call ensures the preco ndition:
… Some instructions tha t, among other possi ble effects, ensure precondition (y) …
check  precondition (y) end
operation (y)
As shown here and in many other examples throughout this book, it is desirable in  
this case to include a check  instruction, with two benefits: making it immediately clear,  Chapter 12 .
“Zen and the art of soft-
ware reliability: guaran-teeing more by checking less”, page 342 .
On check  see “AN 
ASSERTION INSTRUCTION”, 11.11, page 378 .
§23.6   DEALING WITH ABNORMAL CASES 799
for the reader of the software te xt, that you did not forget th e precondition but instead  
checked that it would hold; and,  in case your deduction was wro ng, facilitating debugging  
when the software is executed with assertion mo nitoring on. (If  you do not remember the  
details of the check  instruction, make sure to re-r ead the corresponding section no w.)
Such use of a precondition, whic h the client has to ensure befo rehand — either by  
testing for it as in if precondition ( y) …, or by relying on other instructions —, may be  
called the a priori scheme: the client is asked to take advance  measures to avoid any error.
With the a priori scheme, any remaining run-time failure signal s a design error — a  
client not abiding by the rules. Then the only long-term soluti on is to correct the error,  
although we have seen that for mi ssion-critical systems it is p ossible to devise software-fault-
tolerant solutions which, on asse rtion violation, will attempt partial recovery through retry . 
Obstacles to the a priori scheme 
B e c a u s e  o f  i t s  s i m p l i c i t y  a n d  c l a r i t y ,  t h e  a  p r i o r i  s c h e m e  i s  i deal in principle. Three  
reasons, however, prevent it fro m being universally applicable:  
A1  • Efficiency considerat ions make it impractical in some cases to  test for the  
precondition b efore a call. 
A2  • Limitations of practical asserti on languages imply that some o f the assertions of  
interest cannot be e xpressed formally.
A3  • Finally, some of the conditions  required for the successful ex ecution of a routine  
depend on external events an d are not assertions at all. 
An example of case A 1, from numerical computation, i s a linear equation solver. A  
function for solving an equation of the form a x = b, where a is a matrix, and x (the unknown)  
and b are vectors, might take the following form in an appropriately  designed MATRIX  class:
inverse (b: VECTOR ): VECTOR
so that a particular equation will be solved by x := a  inverse (b). A unique solution only  
exists if the matrix is not “sin gular”. (Singularity mans that one of the rows is a linear  
combination of others or, equiva lently, that the determinant is  zero.) We could make non-
singularity the precondition of inverse , requiring client call s to be of the form
if a  singular then
… Appropriate error action …
else
x := a  inverse (b)
end
This technique works but is very inefficient: determining wheth e r  a  m a t r i x  i s  
singular is essentially the same  operation as sol ving the assoc iated linear equation.  
Standard algorithms (Gaussian elimination) will at each step co mpute a divisor, called the  
pivot; if the pi vot found at some  step is zero or below a certa in threshold, th is shows that  
the matrix was singular. This re sult is obtained as a byproduct  of the equation-solving  
DESIGNING CLASS INTERFACES  §23.6 800
algorithm; to obtain it separately would take almost as much co mputation time as to  
execute the entire algorithm. So doing the job in two steps — f irst finding out whether the  
matrix is singular, an d then, if it is not , computing the solut ion — is a waste of effort.
Examples of A 2 include cases in which the prec ondition is a gl obal property o f a data  
structure and would need to be e xpressed with quantifiers, for example the requirement  
that a graph contain no cycles or that a list be sorted. Our no tation does not support this.  
As noted, we can usually rely on such assertions using function s; but then we might be  
back in case A 1, as the precondition can be too costly to check before every c all. 
Finally, limitation A 3 a r i s e s  w h e n  i t  i s  i m p o s s i b l e  t o  t e s t  t h e  a p p l i c a b i l i t y  o f  t h e  
operation without attem pting to execute it,  because interaction  with the outside world —  
a human user, a communication lin e, a file system — is involved . 
The a posteriori scheme 
W h e n  t h e  a  p r i o r i  s c h e m e  does not work, a simple a posteriori  scheme is sometimes  
possible. The idea is to try the  operation first and then find out how it went; this will work  
if a failed attempt has no ir recoverable co nsequences.
The matrix equation problem prov ides a good example. With an a posteriori scheme,  
client code will now be of the form 
a  invert (b)
if a  inverted then
x := a  inverse
else
… Appropriate error action …
end
Function inverse  has been replaced by a procedure invert , for which a more accurate  
name might be attempt_to_invert . A call to this procedure sets the attribute inverted  to true  
or false to indicate whether a solution was found; if it was, t he procedure makes the  
solution itself available through attribute inverse . (An invariant clause  in the matrix class  
may state that inverted = (inverse /= Void ).)
With this method, any function th at may produce an error condit ion is transformed  
into a procedure, the result being accessible, if it exists, th rough an attribu te set by the  
procedure. To save space you may  use a once function rather tha n an attribute if at most  
one answer is needed at any time.
This also works for input operat ions. For example a “read” func tion that may fail is  
b et t er  ex pr es se d as  a  pr oc ed ur e th at  at te m p ts  t o r ea d,  an d tw o attributes, one boolean  
indicating whether the operation succeeded and the other yieldi ng the value read if any. 
T h i s  t e c h n i q u e ,  a s  y o u  w i l l  h a v e  n o t e d ,  i s  i n  l i n e  w i t h  t h e  C o m mand-Query  
Separation principle. A function that may fail to compute its i ntended result is not side-
effect-free, and so is better decomposed into a procedure that attempts to compute the  
value and two queries (functions or attributes), one to ascerta in success and the other to  
§23.6   DEALING WITH ABNORMAL CASES 801
yield the value in case of succe ss. The technique is also consi stent with the idea of objects  
as machines, whose state can be  changed by comma nds and accesse d by queries.
The example of input functions is typical of cases that can ben efit from this scheme.  
Most of the read functions provided by programming languages or  the associated libraries  
are of the form “next integer”, “next string” etc., requiring t he client to state in advance  
the type of the element to be re ad. Inevitably, they will fail when the actual input does not  
match the expectation. A read pr ocedure, on the other hand, can  attempt to read the next  
input item without any preconception of what it will be, and th en return information about  
its type through one  of the queries available to clients. 
This example highlights one of the constant rules for dealing w ith failure: whenever  
available, a method for engineer ing out failures is preferable to methods for recovering  
from failures. 
The role of an exception mechanism 
The preceding discussion has shown  that in most cases methods b ased on standard control  
structures, principally essentia lly conditional instructions, a re adequate for dealing with  
abnormal cases. Although the a priori scheme is not always prac tical, it is often possible  
to check success after at tempting an operation. 
There remain, however, cases in which both a priori and a poste riori techniques are  
inadequate. The above discussion leaves only three categories o f such cases: 
• Some abnormal events such as numerical failure or memory exhau stion can lead to  
preemptive action by the hardware or operating system, such as raising an exception  
and, unless the software catches the exception, terminating exe cution abruptly. This  
is often intolerable, especially  in systems with  continuous ava ilability requirements  
(think of telephone switches and many medical systems).
• Some abnormal situations, althou gh not detectable through a pr econdition, must be  
diagnosed at the earliest possib le time; the operation must not  be allowed to run to  
completion (for a posteriori chec king) because it could lead to  disastrous  
consequences, such as destroying  the integrity of a database or  even endanger human  
lives, as in a robot control system. 
•Finally, the developer may wish to include some form of protect ion against the most  
catastrophic consequences of any remaining errors in the softwa re; this is the use of  
exceptions for software fault tolerance. 
In such cases, exception-based techniques appear necessary. The  orderly exception  
mechanism presented in an earlier chapter provides the appropri ate tools. “Why run-time moni-
toring?”, page 398 .
Chapter 12 .
DESIGNING CLASS INTERFACES  §23.7 802
23.7  CLASS EVOLUTION: THE OBSOLETE CLAUSE
We try to make our classes perfect. All the techniques accumula ted in this discussion tend  
towards that goal — un reachable, of course , but useful as an ev er present ideal.
Unfortunately (with no intention of offending the reader) we ar e not ourselves  
perfect. What happens if, after a few months  or a few years, we  realize that some of the  
interface of a class c ould have been designe d better? The dilem ma is not pleasant:
•Favor the current users: this will mean continuing to live with  an obsolete design  
whose unpleasant effects will be felt more and more sorely as t ime passes. This is  
known in the computer industry as upward compatibility . Compatibility, how many  
crimes have been committed in th y name! (as Victor Hugo almost wrote).
According to Unix folklore, one of the less pleasant convention s of the Make  
tool, which has bothered quite a few novice users, was detected  not too long  
after the first release. Since it implied a language change and  t h e 
inconvenience was not a show-stopper, the decision was made to let things  
stand so as not to disturb the user community. The Make user co mmunity, at  
that time, must have included a dozen or two people at Bell Lab oratories.
• Favor the futur e users: you cau se trouble to the  current ones,  whose only sin was to  
trust you too early.
Sometimes — but sometimes only —  there is a way out. We introdu ce into our  
notation the concept of obsolete features and obsolete classes . Here is an example of  
obsolete routine:
enter (i: INTEGER ; v: G)
obsolete "Use put (value , index ) instead"
require
correct_index (i)
do
put (v, i)
ensure
entry (i) = v
end
This is a real example, although no longer current. Here is the  context. Early in the  
evolution of the Base libraries, we realized that the names and  conventions were not  
systematic enough; this is when the principles of style develop ed in chapter 26 of this book  
were codified. They entailed i n particular using the name put rather than enter  for the  
procedure that replaces an array element (and item rather than entry  for the corresponding  
query) and, to make things worse , reversing the order of argume nts, for compatibility with  
features of other clas ses in the library.
The above declaration smoothes o ut the evolution. Note how the old feature, enter , 
has a new implementation, relying on the new feature, put; you should normally use this  
scheme when making a feature obso lete, to avoid carrying along two competing  
implementations with the resulti ng reliability and extendibilit y risks.
What are the consequences of mak ing a feature obsolete? Not muc h in practice. The  
tools of the environment must recognize this property, and outp ut the corresponding  The real Hugo quote 
is about Liberty .
§23.8   DOCUMENTING A CLASS AND A SYSTEM 803
warnings when a client system us es the class. The compiler, in particular, will output a  
message, which includes the stri ng that has been included after  the keyword obsolete , 
such as Use put (value , index ) instead  in our example. That is all. The feature otherwise  
continues to be normally usable.
Similar syntax e nables you to declare an  entire class as obsole te.
What you are providing your client developers, then, is a migra tion path. By telling  
them that a feature will be remo ved, you encourage them to adap t their software; but you  
are not putting a knife  to their throat. If  the change is justi fied — as it should be — users  
of the class will not resent havi ng to update their part; what is unacceptable is, when they  
receive a new version, to be for ced to do all the changes immed iately. Given a little time,  
they will readily comply.
In practice, the migration period should be bounded. At the nex t major release — a  
few months later, a year at most — you should remove the obsole te features and classes  
for good. Otherwise no one will take obsolescence warnings seri ously. This is why the  
example was mentioned above as “no longer current”: enter  and entry  were removed  
several years ago. But in their short lives they helped keep mo re than one developer happy.
Feature and class obso lescence only solve a  specific problem. T he comment made  
when we discussed the Open-Close d principle and how inheritance  enables you to adapt  
a parent’s design without disturb ing the original is fully appl icable here: when a design is  
flawed , the only reasonable approach is to correct it, while making y our best efforts to help  
current users make the transitio n. Neither inheritance-cum-rede finition nor obsolescence  
s h o u l d  s e r v e  a s  c o v e r - u p s  f o r  b u g s  i n  e x i s t i n g  s o f t w a r e .  B u t  o b solescence is precious  
when the original desi gn, while satisfactory  in other respects,  does not conform to your  
current views; it typically resulted from a narrower and less c lear perspective than what  
you have gained now. Although ther e was nothing fundamentally w rong with the old  
design, you can do bet ter: simpler interfac es, better consisten cy with the rest of the  
software, interoperability with other products, better naming c onventions. In such cases,  
making a few features and classes obsolete is a remarkable way to protect the investment  
of your current users while movin g ahead to an ever brighter fu ture.
23.8  DOCUMENTING A CLASS AND A SYSTEM
Having mastered the most advance d techniques of class interface  design, you build a set  
of great classes. To achieve the success they deserve, they wil l need good interface  
documentation. We have  seen the basic docum entation tool: the s hort form and its variant  
the flat-short form. Let us summarize their use and examine a c omplementary mechanism  
that works on enti re systems rather than just classes.
Mentions of the short form in th is discussion will encompass th e flat-short form as  
well. The difference between the two, as you will remember, is that the flat-short form  
takes inherited features into ac count, whereas the plain short form only relies on the  
immediate features introduced in  the class itself. In most prac tical cases, the flat-short  
form is what client authors will need.See “The module 
view”, page 495 .
See “Using asser-
tions for documenta-tion: the short form of a class”, page 389, and “The flat-
short form”, page 543.
DESIGNING CLASS INTERFACES  §23.8 804
Showing the interface
The short form directly applies the rule of Information Hiding by removing all secret  
information from client view. Secret information includes:
• Any non-exported feature and an ything having to do with it (fo r example, a clause  
of an assertion which re fers to the feature). 
• Any routine implementa tion, as given by the do … clause. 
What remains is abstract informa tion about the class, providing  authors of client  
classes, current or prospective,  with the implementation-indepe ndent description that they  
need to use it effectively.
Remember that the purpose is abstraction, not protection. We do  not necessarily wish to  
prevent client authors from accessing secret class elements; we  wish to relieve them from  
having to do so. By separating function from implementation, in formation hiding  
decreases the amount of information to be mastered; client auth ors should view it as help  
rather than hindrance.
The short form avoids the techni que (supported, without asserti ons, by Ada,  
Modula-2 and Java) of writing se parate and partia lly redundant module interfaces, as this  
can mean trouble for evo lution; as always in  software engineeri ng, repetition breeds  
inconsistency. Instead  it puts everything in to the class and re lies on computer tools to  
extract abstract information.
The underlying principle was intr oduced at the beginning of thi s book: try to make  
the software as self-documenting as possible. In this effort, j udiciously cho sen assertions  
will play a fundamental part. Examining the examples of this ch apter and constructing  
their short forms (at least ment ally) should provide clear enou gh evidence.
To help the short form deliver t he best possible  results, you s hould keep it in mind  
when writing your classes, and apply the following principle:
This simply translates the more general Self-Documentation prin ciple into a  
practical rule to be applied day to day by developers. Particul arly important will be:
• Well-designed preconditions, postconditions an d invariants.
• Careful choice of names for  both classes and features.
• Informative note clauses.
The chapter on style will give p recise guidelines on the last t wo points.Documentation principle
Try to write the software so tha t it includes all the elements needed for its  
documentation, recognizable by t he tools that are available to extract  
documentation elements automatic ally at various levels of abstr action.See the “common 
misunderstanding” cited on page 52 .
“Self-Documenta-
tion”, page 54 .
Chapter 26 .
§23.8   DOCUMENTING A CLASS AND A SYSTEM 805
System-level documentation
The short  and flat-short  tools, when applied to software developed according to the rul es 
developed in this book  (assertions, Design by Contract, informa tion hiding, clear and  
systematic naming conventions, h eader comments etc.) apply the Documentation  
principle at the module level. T here is also a need for higher- level documentation  — 
d o c u m e n t a t i o n  o n  a n  e n t i r e  s y s t e m ,  o r  o n e  o f  i t s  s u b s y s t e m s  —  a pplying the same  
principle. But here textual outp ut, although necessary, is not sufficient. To grasp the  
organization of a possibly compl ex system, you will want graphi cal descriptions.
The Case tool of ISE’s environmen t, based on Business Object No tation concepts,  
provides such sy s t e m  v i e w s ,  a s  i l l u s t r a t e d  b e l o w  f o r  a  s e s s i o n  devoted to reverse-
engineering of the Base libraries. 
Although further  details fall beyond the scope of this discussi on, we may note that  
the tool supports the exploratio n of large systems through zoom ing, unzooming and other  
abstraction mechanisms  such as the ability t o focus on a cluste r (subsystem) or one of its  
subclusters as well as the entir e system; also, it combines gra phical views, essential to  
provide a general glimpse of an architecture, with textual info rmation about the  
components of a system, dictionaries of abstractions etc.
All these tools are applications  of the Documentation principle , tending towards the  
production of software which, thanks to carefully designed nota tions and with the help of  
advanced environments , should get us ever cl oser to the ideal o f self-documentation.A system 
architecture diagram
See [M 1995c].
DESIGNING CLASS INTERFACES  §23.9 806
23.9  KEY CONCEPTS INTRODUCED IN THIS CHAPTER 
• A class should be known by its interface, which specifies the services offered  
independently of the ir implementation. 
• Class designers shoul d strive for simple , coherent interfaces.  
• One of the key issues  in designing modules is which features s hould be exported, and  
which should remain secret. 
• The design of reusable modules i s not necessarily right the fi rst time, but the  
i n t e r f a c e  s h o u l d  s t a b i l i z e  a f t e r  s o m e  u s e .  I f  n o t ,  t h e r e  i s  a  f l a w  i n  t h e  w a y  t h e  
interface was designed. The mechanism of obsolete  features and classes makes it  
possible to smooth over the tr ansition to a better design.
• It is often fruitful t o treat some data structures as active m achines, with an internal  
state remembered from one feature call to the next. 
• Proper use of assertions (preco nditions, postconditions, invar iants) is essential for  
documenting interfaces. 
• Abnormal situations are best de alt with through standard contr ol structures, either  
through the a priori scheme, whi ch checks applicability before calling an operation,  
or through the a poste riori scheme, which attempts the operatio n and then examines  
whether it has succeeded. A disc iplined exception mechanism rem ains necessary in  
cases when execution must immedi ately cancel a p otential danger ous operation.
23.10  BIBLIOGRAPHICAL NOTES 
The work of Parnas [Parnas 1972]  [Parnas 1972a]  introduced many seminal ideas on the  
design of interfaces. 
The operand-option distinction, a nd the resulting principle, co me from [M 1982a] .
The notion of “active data struc ture” is supported in some prog ramming languages  
by control abstractions called i terators. An iterator is a mech anism defined together with  
a data structure, which describe s how to apply an arbitrary ope ration to every element of  
an instance of the data structur e. For example, an iterator ass ociated with a list describes  
a looping mechanism for traversi ng the list, applying a given o peration to every list  
element; a tree iterator specifies a tree traversal strategy. I terators are available in the  
programming language CLU [Liskov 1981] ; [Liskov 1986]  contains a detailed discussion  
of the concept. In object technology, we can implement iterator s through classes rather  
than predefine them as l anguage constructs; see [M 1994a] , which applies to library design  
a number of ideas from the present chapter.
The example of the self-adaptive  complex number implementation comes from  
[M 1979] , where it was expressed in Simula.
§E23.1   EXERCISES 807
Literate programming  [Knuth 1984]  emphasizes, like this c hapter, that programs  
should contain their own documentation. Its concepts, however, are quite different from those  
of object technology; one of the exercises below invites you to  compare the approaches.
Articles by James McKim and Richard Bielak [Bielak 1993] , [McKim 1992a] 
[McKim 1995]  present useful advice on class interface design based on the n otion of  
Design by Contract.
EXERCISES
E23.1  A function with side effects
The example of component-level m emory management for linked lis ts  ha d a  fu nc ti o n  
fresh  that calls a procedure, remove for stacks, and hence produces a side effect on the data  
structure. Discuss wheth er this is acceptable. 
E23.2  Operands and options
Examine a class or routine libra ry to which you have access and  study its routines to  
determine, for each of them, whic h arguments are operands and w hich are options.
E23.3  Optional arguments
S o m e  l a n g u a g e s ,  s u c h  a s  A d a ,  o f f e r  t h e  p o s s i b i l i t y  f o r  a  r o u t i n e of having optional  
arguments, each with an associat ed argument keyword; if the key word is not included, the  
a r g u m e n t  m a y  b e  s e t  t o  a  d e f a u l t .  D i s c u s s  w h i c h  o f  t h e  a d v a n t a g es of the Operand  
principle this techniq ue retains, and which it fails to ensure.
E23.4  Number of elements as function
Adapt the definition of class LINKED_LIST [G] so that count  is a function r ather than an  
attribute, the interface of the class being unchanged. 
E23.5  Searching in a linked list
Write the LINKED_LIST procedure search (x: G), searching for the next occurrence of x.
E23.6  Invariant theorems
Prove the three assertion clauses listed as theorems in the fir st part of the invariant for  
LINKED_LIST .
E23.7  Two-way lists
Write a class describing two-way linked lists, with the same in terface as LINKED_LIST , 
but more efficient implementati ons of some opera tions such as back , go and finish . Function fresh  
appeared on page 299.
Page 785 .
DESIGNING CLASS INTERFACES  §E23.8 808
E23.8  Alternative l inked list class design
Devise a variant of the linked list class design using the conv ention that an empty list is  
considered both after  and before . (This was the technique used  in the first edition of this  
book.) Assess it against the app roach developed in the present chapter.
E23.9  Insertion in a linked list
Drawing inspiration from remove , write the procedures put_left  and put_right  to insert an  
element to the left and ri ght of the cursor position.
E23.10  Circular lists
Explain why the LINKED_LIST  class may not be used for circ ular lists. (Hint: show what  
assertions would be violated.) Write a class CIRCULAR_LINKED  that implements  
circular lists. 
E23.11  Side-effect-free input functions
Design a class describing input files, with input  operations, w ithout any side-effect-
producing functions. Only the c lass interface (without the do clause describing the routine  
implementations, but with the routine headers and any appropria te assertions) is required. 
E23.12  Documentation 
Discuss, expand and re fine the Self-Documentation principle and  its various  
developments in this book, considering various kinds of documen tation in software and  
examining what styles of documentation are appropriate in vario us circumstances and at  
various levels o f abstraction. 
E23.13  Self-documenting software 
The approach to self-d ocumenting software ad vocated in this cha pter emphasizes  
terseness and do es not readily support l ong explanations of des ign decisions. Knuth’s  
“Literate programming” style of de sign combines techniques from  programming, writing  
and text processing to integrate  a program, its complete design  documentation and its  
design history within a single doc ument. The method relies on a  classical paradigm: top-
down development of a single pr ogram. Starting from Knuth’s wor k, discuss how his  
method could be trans posed to the object-o riented development o f reusable components. See [M 1988],  sections 
9.1 and A .5.
remove is on page 791 .
For references on liter-
ate programming see the bibliographic notes to this chapter . 
24  
Using inheritance well
L earning all the technical detail s of inheritance and related me chanisms, as we did in  
part C, does not automatically me an that we have fully grasped the methodological  
consequences. Of all issues in o bject technology, none causes a s much discussion as the  
question of when and how to use inheritance; sweeping opinions abound, for example on  
Internet discussion gro ups, but the literature is relatively po or in precise and useful advice.
In this chapter we will probe fu rther into the meaning of inher itance, not for the sake  
of theory, but to make sure we u se it best to benefit our softw are development projects. We  
will in particular try to unders tand how inheritance differs fr om the other inter-module  
relation in object-oriented system structures, its sister and r ival, the client relation: when  
to use one, when to use the othe r, when both choices are accept able. Once we have set the  
basic criteria for using inheritance — identifying along the wa y the typical cases in which  
it is wrong to use it — we will be able to devise a classificat ion of the various legitimate  
uses, some widely accepted (subtype inheritance), others, such as implementation or  
facility inheritance, more contr oversial. Along the way we will  try to learn a little from the  
experience in taxonomy, or systematics , gained from older scie ntific disciplines.
24.1  HOW NOT TO USE INHERITANCE
To arrive at a methodological principle, it is often useful — a s illustrated by so many other  
discussions in this book  — to study first how not to do things. Understanding a bad idea  
helps find good ones, which we might otherwise miss. In too con stantly warm a climate, a  
pear tree will not flower; it needs the jolt of Winter frost to  attain full bloom in the Spring.
Here the jolt is obligingly prov ided by a widely successful und ergraduate textbook,  
used throughout the world to teac h software engineering to prob ably more computing  
science students than any other. Already in its fourth edition,  it introduced some elements of  
object orientation, inc luding a discussion of multiple inherita nce. Here is the beginning:
Multiple inherita nce allows several objects to act as base objects and is supported  
in object-oriented languages such as [the notation of the present book] [M 1988] .
The bibliographic reference is t o the first edition of the pres ent book. Apart from the  
unfortunate use of “objects” for classes, this is an auspicious  start. The extract continues:
The characteristics of several  different object classes
(classes, good!)Extracts from “Soft-
ware Engineering” by Ian Sommerville , 
Fourth edition , 
Addison-Wesley , 
USING INHERITANCE PROPERLY  §24.1 810
can be combined to make up a new object .
(no luck). Then come s the example of multiple inheritance:
For example , say we have an object class CAR  which encapsulates information  
about cars and an  object class PERSON  which encapsulates  information about  
people . We could use both of these to define
(will our worst fea rs come out true?)
a new object class CAR-OWNER  which combines the attributes of CAR
and PERSON .
(They have.) We are invited to consider that every CAR-OWNER  object may be viewed as  
n o t  o n l y  a  p e r s o n  b u t  a l s o  a  c a r . To anyone who has studied inh eritance even at an  
elementary level, this will be a surprise.
As you will undoubtedly have figur ed out, the relation to use i n the second case was  
client, not inheritance: a car owner is a person, but has a car.  In pictures:
In formal words:
class CAR_OWNER inherit
PERSON
feature
my_car : CAR
… 
end
In the cited text, both links use the inheritance relation. The  most interesting twist  
actually comes a little later in the discussion, when the autho r advises his reader to treat  
inheritance with caution:
Adaptation through inherita nce tends to lead to ex tra functionality being  
inherited , which can make component s inefficient and bulky .
Bulky indeed; think of  the poor car owner, loaded with his roof , engine and  
carburetor, not to mention four wheels plus a spare. This view might have been influenced  
by one of the picturesque phrases of Australian slang, about a car owner who does look as  
if he also is his car:A proper model
PERSON
CAR_
OWNERCARInheritance
Client
§24.1   HOW NOT TO USE INHERITANCE 811
Inheritance is a non-trivial conc ept, so we can forgive the aut hor of this extract on  
the grounds that he was perhaps a  little far from his home turf . But the example has an  
important practical benefit apart  from helping us feel smarter:  it reminds us of the basic  
rule on inheritance.
In other words, we must be able to convince someone — if only o urselves to start  
with — that “every B is an A” (hence the name: “is-a”). 
In spite of what you may think at first, this is a loose rule, not a strict one. Here is why:
• Note the phrase ‘‘can somehow m ake the argument”. This is volu ntarily vague: we  
d o  n o t  r e q u i r e  a  proof  that every B i s  a n  A. Many cases will leave room for  
discussion. Is it true that “Ever y savings account is a checkin g account”? There is no  
absolute answer; depending on th e bank’s policies and your anal ysis of the properties  
of the various kinds o f account, you may decide to make class SAVINGS_ACCOUNT
an heir to BANK_ACCOUNT , or put it elsewhere in the inheritance structure, getting  
some help from the other criteria discussed in this chapter. Re asonable people  
might still disagree on the result. But for this to be the case  the “is-a” argument  
must be sustainable. Once again our counter-example helps: the argument that a
CAR_OWNER  “is-a” CAR is not sustainable.
• Our view of what “is-a” means will be particularly liberal. It  will not, for example,  
disallow implementation inheritance  — a form of inheritan ce that many people view  
with suspicion — as lo ng as the “is-a” argum ent can reasonably be made.“Is-a” rule of inheritance
Do not make a class B inherit from a class A unless you can  somehow make  
the argument that one can view every instance of B also as an instance of A.
“He has a head 
like an Austin 
Mini with the doors open” .
Cartoon by Geoff 
Hocking; from The 
Dictionary of Aussie Slang , The 
Five Mile Press, Melbourne, Australia, reprintedwith permission.
USING INHERITANCE PROPERLY  §24.2 812
These observations define both t he usefulness and the limitatio ns of the Is-a rule. It  
is useful as a negative rule in the Popperian style, enabling you to detect and reject  
inappropriate uses of inheritance.  But as a positive rule it is  not sufficient; not all  
suggested uses that pass the rul e’s test will be appropriate.
Gratifying as the CAR_OWNER counter-example may be , then, any feeling of  
elation that we may have gained from it will be short-lived. It  was both the beginning and  
the end of the unmitig ated good news — the news that some propo sed uses of inheritance  
are obviously wrong and easy to spot. The rest of this chapter has to contend with the bad  
or at least mixed news: that in just about all other cases the decision is a true design issue,  
that is to say hard, although we will fortunately be able to fi nd some genera l guidelines.
24.2  WOULD YOU RATHER BUY OR INHERIT?
To choose between the two possibl e inter-module relations, clie nt and inheritance, the basic  
rule is deceptively simple: client is has, inheritance is  is. Why then is the choice not easy?
To have and to be
The reason is that whereas to ha ve is not always to be, in many  cases to be is also to have .
No, this is neither some cheap attempt at existentialist philos ophy nor a pitch to make  
you buy a house if you are curre ntly renting; rather, simple ob servations on the difficulty  
of system modeling. We have alrea dy encountered an illustration  of the first property —  
to have is not always to be — in the preceding example: a car o wner has a car, but by no  
twist of reasoning or exposition  can we assert that he is a car .
What about the reverse situation? Take a simple statement about  two object types  
from ordinary life, such as
Every software engin eer is an engineer .[ A ]
whose truth we accept for its value as an example of the “is-a”  relation (whatever our  
opinion may be as to the statement’s accuracy). It seems hard i ndeed to think of a case  
which so clearly  expresses “to b e” rather than “ to have”. But n ow consider the following  
rephrasing of the property:
In every software engine er there is an engineer. [B]
which can in turn be restated as 
Every software engineer ha s an “engineer” component .[ C ]
Twisted, yes, and perhaps a trifle bizarre in its expression; b ut not fundamentally  
different from our premise [A]! So here it is: by changing our perspective slightly we can  
rephrase the “is” pr operty as a “has”.
§24.2   WOULD YOU RATHER BUY OR INHERIT? 813
If we look at the picture through  the eyes of a programmer, we may summon an  
object diagram, in the  style of those which served to discuss t he dynamic model in an  
earlier chapter, showing a typic al instance of a class and its  components:
This shows an instance of SOFTWARE_ENGINEER  with various subobjects,  
representing the various posited aspects of a software engineer ’s personality and tasks.  
Rather than subobjects (the expanded view) we might prefer to t hink in terms of r eferences:
Take both of these representati ons as ways to visualize the sit uation as seen from  
an implementation-oriented minds et, nothing more. Both suggest,  however, that a client,  
or “has”, interpretation — every software engineer has an engin eer as one of his parts —  
is faithful to the original statement. The same observation can  be made for any similar  
“is-a” relationship.
So this is why the problem of ch oosing between c lient and inher itance is not trivial:  
when the “is” view is legitimate , one can always take the “has”  view instead.“COMPOSITE 
OBJECTS AND EXP ANDED TYPES”,8.7, page 254 .
A “software 
engineer” 
object as aggregate
(SOFTWARE_ENGINEER )(ENGINEER )
(POET )
(PLUMBER )
Another 
possible view 
(SOFTWARE_ENGINEER )(ENGINEER )(POET )
(PLUMBER )
USING INHERITANCE PROPERLY  §24.2 814
The reverse is not true: when “h as” is legitimate, “is” is not always applicable, as the  
CAR_OWNER example shows so clearly. This observation takes care of the ea sy mistakes,  
obvious to anyone having understo od the basic concepts, and per haps even explainable to  
authors of undergraduate texts. But whenever “is” does apply it  is not the only contender.  
So two reasonabl e and competent people m ay disagree, one wantin g to use inheritance,  
the other preferring client.
Two criteria fortunately exist to help in such discussions. Not  surprisingly (since  
they address a broad design issue) they may sometimes fail to g ive a clear, single solution.  
But in many practical cases the y do tell you, beyond any hesita tion, which of the two  
relations is the right one.
Conveniently, one of these two c riteria favors inheritance, and  the other favors client.
The rule of change
The first observation is that th e client relation usually permi ts change, while the  
inheritance relation does not. H ere we must be careful with our  use of the verbs “to be”  
and “to have” from ordinary language; so far they have helped u s characterize the general  
nature of our two software relat ions, but software rules are, a s always, more precise than  
their general non-software c ounterparts.
One of the defining properties of inheritance is that it is a r elation between classes , 
not objects. We have interpr eted the property “Class B inherits from class A” as meaning  
“every B object is an A object”, but must remember that  it is not in the power of any such 
object to change that property: only a change of the class can achieve such a result. The  
property characterizes the soft ware, not any particular executi on.
With the client relation, the co nstraints are looser. If an obj ect of type B h a s  a  
component of type A (either a subobject or an object reference), it is quite possi ble to change  
that component; the only restri ctions are those of the type sys tem, ensuring pr ovably reliable  
execution (and governed, through an interesting twist, by the i nheritance structure).
So even though a given inter-object relationship can result fro m either inheritance or  
client relationships b etween the correspondi ng classes, the eff ect will be different as to  
what can be chan ged and what cannot. For example our fictitious  object structure
Object and 
subobject
(SOFTWARE_ENGINEER )(ENGINEER )(Other components omitted)
§24.2   WOULD YOU RATHER BUY OR INHERIT? 815
could result from an inheritance  relationship between the corre sponding classes:
class SOFTWARE_ENGINEER_1 inherit
ENGINEER
feature
…
end
but it could just as well have been obtaine d through the client  relation:
class SOFTWARE_ENGINEER_2 feature
the_engineer_in_me : ENGINEER
…
end
which could in fact be
class SOFTWARE_ENGINEER_3 feature
the_truly_import ant_part_of_me : VOCATION
…
end
provided we satisfy the ty pe rules by making class ENGINEER  a descendant of  
class VOCATION .
Strictly speaking the last two variants represent a slightly di fferent situation from the first  
if we assume that none of the given classes is expanded: instea d of subobjects, the  
“software engineer” objects will in the last two cases contain references  to “engineer”  
objects, as in the second figure of page 813. The introduction of references, however,  
does not fundamentally affect this discussion.
With the first class definition, because the inheritance relati onship holds between the  
generating classes, it is not pos sible to modify the object rel ationship dynamically: once  
an engineer, alw ays an engineer.
But with the other two definitions such a modification is possi ble: a procedure of the  
“software engineer” class can as sign a new value to the corresp onding object field (the  
field for the_engineer_in_me  or the_truly_import ant_part_of_me ). In the case of class  
SOFTWARE_ENGINEER_2  the new value must be of type ENGINEER  or compatible; but  
with class SOFTWARE_ENGINEER_3  it may be of any type compatible with  
VOCATION . So our software can model the idea of a software engineer who , after many  
years of pretending to be an eng ineer, finally s heds that part of his personali ty in favor of  
something that he deems more rep resentative of his work, such a s poet or plumber.ENGINEER
SOFTWARE_ENGINEER_1
SOFTWARE_ENGINEER_3
VOCATION
USING INHERITANCE PROPERLY  §24.2 816
This yields our first criterion:
Only use inheritance if the corre sponding inter-object relation  is permanent. In other  
cases, use the client relation.
The really interesting case is the one illustrated by SOFTWARE_ENGINEER_3 . With  
SOFTWARE_ENGINEER_2 you can only replace the engineer component with another  
of exactly same type. But in the SOFTWARE_ENGINEER_3  scheme, VOCATION  should  
be a high-level class, most likely deferred; so the attribute c an (through polymorphism)  
represent objects of many possible types, all conforming to VOCATION .
This also means that even though this solution uses client as t he primary relation, in  
practice its final form will often use inheritance as a complem ent. This will be particularly  
clear when we come to the notion of handle.
The polymorphism rule
Now for a criterion that will re quire inheritance and exclude c lient. That criterion is  
simple: polymorphic uses. In our  study of inheritance we have s een that with a declaration  
of the form
x: C
x denotes at run time (assuming class C is not expanded) a potentially polymorphic  
reference; that is to say, x may become attached to dir ect instances not just of C but of any  
proper descendants of C. This property is of course a k ey contribution to the power an d 
flexibility of the object-oriented  method, especially through i ts corollary, the possibility  
of defining polymorphic data structures, such as a LIST [C] which may contains instances  
of any of C’s descendants.
In our example, this means that with the SOFTWARE_ENGINEER_1  solution — the  
form of the class which inherits from ENGINEER  — a client can d eclare an entity
eng: ENGINEER
which may become attached at r un time to an object of type SOFTWARE_ENGINEER_1 . 
Or we can have a list of engineers, or a database of engineers,  which includes a few  
mechanical engin eers, a few chemical engi neers, and a few softw are engineers as well.
A reminder on methodology: the use of non-software words is a g ood help for  
understanding the concepts, but we should not let ourselves get  carried away by such  
anthropomorphic examples; the objects of interest are software objects. So although we  
may loosely understand the words “a software engineer” for what  they say, they actually  
denote an instance of SOFTWARE_ENGINEER_1 , that is to say, a software object  
somehow modeling a real person.Rule of change
D o  n o t  u s e  i n h e r i t a n c e  t o  d e s c r i b e  a  p e r c e i v e d  “ i s - a ”  r e l a t i o n  if the  
corresponding object components m ay have to be changed at run t ime. 
§24.3   AN APPLICATION: THE HANDLE TECHNIQUE 817
Such polymorphic effects require inheritance: with SOFTWARE_ENGINEER_2  or 
SOFTWARE_ENGINEER_3  there is no way an entity or data structure of type ENGINEER  
can directly denote “so ftware engineer” objects.
Generalizing these observations —  which are not, of course, spe cific to the example  
— yields the complement of the rule of change:
Summary
Although it brings no n ew concept, the following rule will be c onvenient as a summary of  
this discussion of criteria for and against inheritance.
24.3  AN APPLICATION: THE HANDLE TECHNIQUE
H e r e  i s  a n  e x a m p l e  u s i n g  t h e  p r e c e d i n g  r u l e .  I t  y i e l d s  a  d e s i g n  pattern of wide  
applicability: handles .
The first design of the Vision  library for platform-indepe ndent graphics encountered  
a general problem: how to accoun t for platform d ependencies. Th e first solution used  
multiple inheritance in the follo wing way: a typical class, suc h as the one describing  
windows, would have a parent des cribing the plat form-independen t properties of the  
corresponding abstract ion, and another providing the platform-s pecific elements.
class WINDOW inherit
GENERAL_WINDOW
PLATFORM_WINDOW
feature
…
endPolymorphism rule
Inheritance is appropriate to de scribe a perceived “is-a” relat ion if entities or  
data structure components of the  more general type may need to become  
attached to objects of t he more spec ialized type.
Choosing between client and inheritance
In deciding how to express the dependency of a class B on a class A, apply  
the following criteria:
CI1  • If every instance of B initially has a component of type A, but that  
component may need to be replaced at run time by an object of a  
different type, make B a client of A.
CI2  • If there is a need for entities of type A to denote objects of type B, 
or for polymorphic structures containing objects of type A of which  
some may be of type B, make B an heir of A.
USING INHERITANCE PROPERLY  §24.3 818
Class GENERAL_WINDOW  a n d  s i m i l a r  o n e s  s u c h  a s  GENERAL_BUTTON  a r e 
deferred: they express all that can be said about the correspon ding graphical objects and  
the applicable operations withou t reference to a particular gra phical platform. Classes  
such as PLATFORM_WINDOW  provide the link to a graphical platform such as Windows,  
OS/2-Presentation-Manager or Unix-Motif; they give access to th e platform-specific  
mechanisms (encapsulat ed through a library such as WEL or MEL).
A class such as WINDOW  will then combine i ts two parents thro ugh features which  
effect (implement) the deferred features of GENERAL_WINDOW  by using the  
implementation mechan isms provided by PLATFORM_WINDOW .
PLATFORM_WINDOW  (like all other similar class es) needs severa l variants, one  
for each platform. These identically named classes will be stor ed in different directories;  
the Ace for a compilation (the c ontrol file) will select the ap propriate one.
This solution works, but it has the drawback of tying the notio n of WINDOW  closely  
to the chosen platform. To trans pose an earlier comment about i nheritance: once a Motif  
window, always a Motif window. This may not be too bad, as it i s hard to imagine a Unix  
window which, suddenly seized by middle-age anxiety, decides to  become an OS/2  
window. The picture becomes less  absurd if we expand our defini tion of “platform” to  
include formats such as Postscri pt or HTML; then a graphical ob ject could change  
representation for pur poses of printing or inclusion in a Web d ocument.
The observation that we might n eed a looser connection between GUI objects such  
as a window and the un derlying toolkit sug gests tryi ng the clie nt relation. An inheritance  
link will remain, between WINDOW  and GENERAL_WINDOW ; but the platform  
dependency will be represented  b y  a  c l i e n t  l i n k  t o  a  c l a s s  TOOLKIT  representing the  
underlying “toolkit” (graphical platform). The figure at the to p of the facing page  
illustrates the resulting structure, involving both client and inheritance.
An interesting aspect of this solution is that it recognizes th e notion of toolkit as a full-
fledged abstraction, represented by a deferred class TOOLKIT . Each specific toolkit is then  
represented by an eff ective descendant of TOOLKIT  such as MOTIF  or MS_WINDOWS .
Here is how it works. Each class  describing graphical objects, such as WINDOW , has 
an attribute providi ng access to the und erlying platform:
handle : TOOLKITWINDOWGENERAL_
WINDOWPLATFORM_
WINDOW
On the platform-
specific libraries WEL and MEL see “Object-oriented re-architecturing”, page 441Platform 
adaptation 
through inheritance
On the notion of Ace 
see “Assembling a system”, page 198
§24.3   AN APPLICATION: THE HANDLE TECHNIQUE 819
This will yield a field in each instance of the class. It is po ssible to change the handle:
set_handle (new: TOOLKIT )
-- Make new the new handle for this object.
do
handle  := new
end
A typical operation inherited from GENERAL_WINDOW  in deferred form will be  
effected through a call to  the platform’s mechanism:
display
-- Display window on screen.
do
handle   window_display (Current )
end
Through the handle, the graphica l object asks the platform to p erform the required  
operation. A feature such as window_display  is deferred in class TOOLKIT  and effected  
variously for its variou s descendants such as MOTIF .
Note that it would be inappropri ate to draw from this example t he conclusion “Aha!  
Another case in which inheritanc e was overused, and the final v ersion stays away from it.”  
The initial version was not wrong; in fact it works quite well,  but is less fle xible than the  
second one. And that second version fundamentally relies on inh eritance and the  
consequent techniques of polymor phism and dynamic binding, whic h it combines with the  
client relation. Without the TOOLKIT -rooted inheritance hierarch y, the polymorphic entity  WINDOW TOOLKIT
MOTIFMS_
WINDOWS…handle   window_display (Current )window_display *
* handleGENERAL_
WINDOW
window_display+
window_display+Platform 
adaptation 
through a handle
USING INHERITANCE PROPERLY  §24.4 820
handle , and dynamic binding on features such as window_display , it would not work. Far  
from being a rejection of inherit ance, then, this technique ill ustrates a more sophisticated  
form of inheritance.
The handle technique is widely a pplicable to the development of  libraries supporting  
multi-platform compatibility. Besides the Vision  graphical library, we have applied it to  
the Store  database library, whe re the notion of platf orm covers various SQL-based  
relational database interfaces s uch as Oracle, Ingres, Sybase a nd ODBC.
24.4  TAXOMANIA
For every one of the inheritance  categories introduced later in  this chapter, the heir  
redeclares (redefines or effects ) some inherited features, or i ntroduces features of its own,  
or adds to the invariant. (It may  of course do several of these  things.) A consequence  is:
What this rule addresses is a fo ible sometimes found in newcome rs who have been  
won over to the O-O method, and enthusiastically start seeing t axonomical divisions  
everywhere (hence the name of th e rule, a shortcut for “taxonom y mania”). The result is  
over-complicated inheritance hierarchies. Taxonomy and inherita nce are meant to help us 
master complexity, not to introd uce complexity. Adding useless classification levels is  
self-defeating. 
A s  i s  s o  o f t e n  t h e  c a s e ,  y o u  c a n  gain the proper perspective — and bring the  
neophytes back to reason — by ke eping in mind the ADT view at a ll times. A class is the  
implementation, partial  or total, of an abstract data type. Dif ferent classes, in particular a  
parent and an heir, should descr ibe different ADTs. Then, becau se an ADT is entirely  
characterized by the applicable f e a t u r e s  a n d  t h e i r  p r o p e r t i e s  ( captured in the class by  
assertions), a new class should change an inherited feature, in troduce a new feature or  
change some assertion. Since you c an only change a precondition  or postcondition by  
redefining the enclosing feature, the last case means the addit ion of an invariant clause (as  
in restriction inheritance , one of the categorie s in our taxonomy).
You may occasionally justify a case of taxomania — a class that  does not bring  
anything new of its own, apart from its existence — on the grou nds that the heir class  
describes an important variant o f the notion described by the p arent, and that you are  
introducing it now to pave the w ay for future introduction or r edeclaration of features,  
even if none has occu r r e d  s o  f a r .  T h i s  m a y  b e  v a l i d  w h e n  t h e  i n heritance structure  
corresponds to a generally accepted classification in the probl em domain. But you should  
always be wary of such cases, a nd resist the introduction of ne w featureless classes unless  
you can find compelling arguments. Taxomania rule
Every heir must introduce a feat ure, redeclare an inherited fea ture, or add an  
invariant clause.This is actually a 
consequence of the Inheritance rule seen later in this chapter , page 822 .
§24.4   TAXOMANIA 821
Here is an example. Assume a cer tain system or library includes  a class PERSON  and 
that you are considering adding heirs MALE  and FEMALE . Is this justified? You will have  
to take a closer look. A personnel management system that inclu des gender-specific  
features, pertaining for example  to maternity leave, may benefi t from having heir classes  
MALE and FEMALE . But in many other cases the va riants, if present, would have no 
specific features; for example s tatistical software that just r ecords the gender of  
individuals may be better off with a single class PERSON  and a boolean attribute
female : BOOLEAN
or perhaps
Female : INTEGER unique
Male : INTEGER  unique
rather than new heirs. Yet if the re is any chance that specific  features will be added later  
on, the corresponding classifica tion is so clearly known in the  problem domain that you  
may prefer to introduce  these heirs anyway.
One guideline to keep in mind is  the Single Choice principle. W e have learned to  
distrust the use of explicit variant lists, as implemented by unique  constants, for fear of  
finding our software polluted w ith conditional instructions of the form
if female then
…
else
…
or inspect  instructions. This is, however, not too much of a concern here :
• One of the principal criticisms  against this style was that an y addition of a variant  
would cause a chain reaction of c hanges throughout the software , but in certain cases  
— such as the above example — we  can be confident there will be  no new variants.
• Even with a fixed set of variants, the explicit if … style is less effective than relying  
on dynamic binding through calls such as this_   person   some_operation where  
MALE  and FEMALE  have different redeclarations of some_operation . But then if we  
do need to discriminate on a person’s gender we violate the pre mise of this  
discussion — that there are no features specific to the variant s. If such features do  
exist, inheritance is justified.
The last comment alerts us to the real difficulty . Simple cases  of taxomania — in  
which the patient needlessly add s intermediate nodes all over t he inheritance structure —  
are relatively easy to diagnose (by noticing clas ses that have no specific features) and cure.  
But what if the variants do have specific features, although the resulting classification  
conflicts with other criteria? A personnel management system fo r which we can justify a  
class FEMALE_EMPLOYEE  because of a few specific features might have other  
distinctions as well, such as permanent versus temporary employ ees, or supervisory  
versus non-supervisory ones. Then we do not have taxomania any more, but face a general  
and delicate problem, multi-criteria classification , whose possible sol utions are discussed  
later in this chapter.
USING INHERITANCE PROPERLY  §24.5 822
24.5  USING INHERITANCE: A TAXONOMY OF TAXONOMY
The power of inheritance comes from its versatility. True, this  also makes it scary at times,  
causing many authors to impose re strictions on the mechanism. W hile understanding  
these fears and even sometimes s haring them — do  the boldest no t harbor the  occasional  
doubt and anxiety? — we should ov ercome them and learn to enjoy  inheritance under all  
of its legitimate v ariants, which will now be explored.
After recalling some commonly en countered wrong uses of inherit ance we will  
individually review  the valid uses:
• Subtype inheritance.
• View inheritance.
• Restriction inheritance.
• Extension inheritance.
• Functional variat ion inheritance
• Type variation inheritance.
• Reification inheritance.
• Structure inheritance.
• Implementation inheritance.
• Facility inheritance (with two special variants: constant inhe ritance and machine  
inheritance).
Some of these categories (subtype, view, implementation, facili ty) raise specific  
issues and will be discussed in more detail in separate section s.
Scope of the rules
The relatively broad vi ew of inheritance taken in this book in n o  w a y  m e a n s  t h a t  
“anything goes”. We accept and in fact encourage certain forms of inheritance on which  
some authors frown; but of cours e there are many ways to misuse  inheritance, and not  
just CAR_OWNER . So the inevitable complement  of our broad- mindedness is a  
particularly strict constraint:
This rule is stern indeed: it states that the types of use of i nheritance are known and  
that if you encounter a case that is not covered by one of thes e types you should just not
use inheritance.
What are “the accepted  categories”? The implicit meaning is “th e accepted  
categories, as discussed in the r est of this section”. I indeed  hope that all meaningful uses  Inheritance rule
Every use of inheritance should belong to one of the accepted c ategories.
§24.5   USING INHERITANCE:  A TAXONOMY OF TAXONOMY 823
are covered. But the phrasing is  a little more careful because the taxonomy may need  
further thinking. I found precio us little in the literature abo ut this topic; the most useful  
reference is an unpubl ished Ph. D. thesis [Girod 1991] . So it is quite possible that this  
attempt at classification has mi ssed some categories. But the r ule indicates that if you see  
a possible use of inhe ritance that does not fall into one of th e following categories, you  
should give it serious thought. Most likely you should not use inheritance in that case; if  
after further reflection you are still convinced that inheritan ce is appropriate, and you are  
still unable to attach your examp le to one of the categories of  this chapter, then you may  
have a new contributio n to the literature.
We already saw a consequence of t he Inheritance rule: the Taxom ania rule, which states  
that every heir class should redecl are or introduce a feature, or change some assertion. It  
follows directly from the observation that every legitimate for m of inheritance detailed  
below requires the heir to perform  at least one of these operat ions.
The Inheritance rule does not pr ohibit inheritance links that b elong to more than one
of the inheritance categories. S uch practice is, however, not r ecommended:
T h i s  i s  n o t  a n  a b s o l u t e  r u l e  b u t  w h a t  a n  e a r l i e r  d i s c u s s i o n  c a l led an “advisory  
positive”. The rationale for the rule is once again the desire for simplicity a nd clarity: if  
w h e n e v e r  y o u  i n t r o d u c e  a n  i n h e r i t a n c e  l i n k  b e t w e e n  t w o  c l a s s e s  you apply explicit  
methodological principles, and in  particular decide which one o f the approved variants  
you will be using, you are less likely to make a design mistake  or to produce a messy, hard-
to-use and hard-to-maint ain system structure.
A compelling argument does not seem to exist, however, for maki ng the rule  
absolute, and once in a while it may be convenient to use a sin gle inheritance link for two  
of the goals captured by the cla ssification. Suc h cases remain a minority.
Unfortunately I do not know of a simple criterion that would un ambiguously tell us when  
it is all right to collapse several inheritance categories into  one link. Hence the advisory  
nature of the Inheritance Simplicity rule. The reader’s judgmen t, based on a clear  
understanding of the methodology of i nheritance, should decide any questionable case.
Wrong uses
The preceding two rules confirm t he obvious: that it is possibl e to misuse inheritance.  
Here is a list of typical mistakes, most of which have already been mentioned. Human  
ability for mischief being what it is, we can in no way hope fo r completeness , but a few  
common mistakes are  easy to identify.
The first is “has” relation with no “is” relation . CAR_OWNER served as an  
example — extreme but not unique. Over the years I have heard o r seen a few similar ones,  
often as purported examples of multiple inheritance, such as APPLE_PIE  inheriting from  Inheritance Simplicity rule
A use of inheritance should preferably belong to just one of th e accepted  
categories.Page 820 .
See “Advisories”, 
page 667 . 
USING INHERITANCE PROPERLY  §24.5 824
APPLE  and from PIE, or (this one reporte d by Adele Goldberg) ROSE_TREE  inheriting  
from ROSE  and from TREE .
Another is a typical case of taxomania  in which a simple boo lean property, such as  
a person’s gender (or a property  with a few fixe d values, such as the color of a traffic light)  
is used as an inheritance criter ion even though no significant feature variants depend on it.
A third typical mistake is convenience inheritance , in which the developer sees  
some useful features in a class and inherits fro m that class si mply to reuse these features.  
What is wrong here is neither th e act of “using inheritance for  implementation”, nor  
“inheriting a class for its featur es”, both of which are accept able forms of inheritance  
studied later in this chapter, but the use of a class as a pare nt without the proper is-a  
relationship between the co rresponding abstractions — or in some cases  without adequate  
abstractions at all.
General taxonomy
On now to the valid uses of inhe ritance. The list will include twelve different categories,  
conveniently grouped  into three broad families:
Classification 
of the valid 
categories of 
inheritanceValid use of inheritance
Software  
inheritanceModel  
inheritance
Subtype  
inheritance
Restriction  
inheritanceExtension  
inheritanceVariation  
inheritance
Functional  
variation  
inheritanceType  
variation  
inheritanceView  
inheritanceReification  
inheritance
Structure  
inheritance
Implementation  
inheritanceFacility  
inheritance
Constant  
inheritance
Machine  
inheritanceUneffecting  
inheritance
§24.5   USING INHERITANCE:  A TAXONOMY OF TAXONOMY 825
The classification is based on the observation that any softwar e system reflects a  
certain external model, itself c onnected with some outside real ity in the software’s  
application domain. Th en we may distinguish:
• Model inheritance, reflecting “i s-a” relations between abstrac tions in the model.
• Software inheritance, expressi ng relations within the software , with no obvious  
counterpart in the model.
• V ariation inheritance — a special case that may pertain either  to the software or to  
the model — serving to  describe a class through its differences  with another class.
These three general categories f acilitate unders tanding, but th e most important  
properties are captured by the f inal categories (the tree leave s on the preceding figure).
Since the classification is itself a taxonomy, you may want to ask yourself, out of  
curiosity, how the identified categories apply to it. This is t he topic of an exercise.
The definitions which fo llow all use the names A for the parent class and B for the h eir.
Each definition will state which of A and B is permitted to be deferred, and which  
effective. A table at the end of the discussion recalls the app licable categories for each  
deferred-effective combination.
Subtype inheritance
W e  s t a r t  w i t h  t h e  m o s t  o b v i o u s  f o r m  o f  m o d e l  i n h e r i t a n c e .  Y o u  a re modeling some  
external system where a category  of (external) objects can be p artitioned into disjoint  
subcategories — as with closed f igures, partitio ned into polygo ns, ellipses etc. — and you  
use inheritance to organize the corresponding classes in the so ftware. A bit more formally :
A' could be the set of closed figures, B' the set of polygons, A a n d  B t h e 
corresponding classes. In most practical cases the “external sy stem” will be non-software,  
for example some aspect of a com pany’s business (where the exte rnal objects might be  
checking and savings a ccounts) or some part of the physical wor ld (where they might be  
planets and stars).Definition: subtype inheritance
Subtype inheritance applies if A and B represent certain sets A' and B' of 
external objec ts such that B' is a subset of A' and the set modeled by any other  
subtype heir of A is disjoint from B'. A must be deferred.Exercise E24.2, 
page 869 .
Naming 
convention for definitions of 
inheritance 
categories
BA
USING INHERITANCE PROPERLY  §24.5 826
Subtype inheritance is the form of inheritance that is closest t o  t h e  h i e r a r c h i c a l  
taxonomies of botany, zoology and other natural sciences ( VERTEBRATE  MAMMAL
and the like). A typical softwar e example (other than closed fi gures and polygons) is  
DEVICE  FILE . W e insist that the parent, A, be deferred, so that it describes a non-
completely specified  set of objects. B, the heir, may be effective, o r it may still be deferred.  
The next two categories cover the ca se in which A may be effective.
A later section will explore in m ore detail this inheritance ca tegory, not always as  
straightforward as it would seem at first.
Restriction inheritance
Typical examples are RECTANGLE  SQUARE , where the extra constraint is  
side1  = side2  (included in the invariant of SQUARE ), and ELLIPSE  CIRCLE , where  
the extra constraint is th at the two focuses (or foci) of an ellipse  are the same point  
for a circle ; in the general case an ellipse  is the set of p oints such that  the sum of their  
distances to the two focuses  is equal to a certain con stant. Many mathematical  
examples indeed fall into this category.
The last part of the definition is meant to avoid mixing this f orm of inheritance with  
others, such as extension inheritance, which may add completely  new features in the heir.  
H e r e  t o  k e e p  t h i n g s  s i m p l e  i t  i s  p r e f e r a b l e  t o  l i m i t  n e w  f e a t u r es, if any, to those that  
directly follow from the added  constraint. For example class CIRCLE  will have a new  
feature radius  which satisfies this property: in a circle, all points have th e same distance  
from the merged center, and this distance deserves the status o f a feature of the class,  
whereas the correspond ing notion in class ELLIPSE  (the average of the distances to the  
two focuses) was probably not c onsidered significant enough to yield a feature.
Because the only conc eptual change from A to B is to add some constraints, the  
classes should be both defe rred or both effective.
Restriction inheritance is conce ptually close to subtype inheri tance; the later  
discussion of subtypi ng will for the most part apply to both ca tegories.
Extension inheritanceDefinition: restriction inheritance
Restriction inheritance app lies if the instances of B are those instances of A
that satisfy a certain  constraint, express ed if possible as par t of the invariant  
of B and not included in  the invariant of A. Any feature introduced by B
should be a logical consequen ce of the added constraint. A and B should be  
both deferred or both effective.
Definition: extension inheritance
Extension inherita nce applies when B introduces features not present in A
and not applicable to direct ins tances of A. Class A must be effective.“SUBTYPE INHER-
ITANCE AND DESCENDANT HIDING”, 24.7, page 835 .
§24.5   USING INHERITANCE:  A TAXONOMY OF TAXONOMY 827
The presence of both the restric tion and extension variants is one of the paradoxes of  
inheritance. As noted in the dis cussion of inheri tance, extensi on applies to features  
whereas restriction (and more ge nerally specialization) applies  to instances,  but this does  
not completely elimi nate the paradox.
The problem is that the added fe atures will usually include att ributes. So if we take  
the naïve interpretati on of a type (as given  by a class) as the  set of its instances, then it  
seems the subset relat ion is the wrong way a round! Assume for e xample
class  A feature a1: INTEGER end
class B inherit
A
feature
b1: REAL
end
Then if we view each instance of A as representing a singleton, that is to say a set  
containing one integer (which we can write as <n> where n is the chosen integer) and each  
instance of B as a pair containing an integ er and a real (such as the pair <1, –-2.5>), the 
set of pairs MB is not a subset of the set of singletons MA. In fact, if we absolutely want a  
subset relation, it will be in the reverse direction: there is a one-to-one mapping between  
MA and the set of all pairs having a given second element, for ex ample 0.0.
This discovery that th e subset relation seems to be the wrong w ay may make  
extension inheritance look suspic ious. For example an early ver sion of a respected O-O  
library (not from ISE) had RECTANGLE  inheriting from SQUARE , not the other way  
around as we have learned.  The reasoning was simple: SQUARE has a side attribute;  
RECTANGLE  inherits from SQUARE  and adds a new feature, other_side , so here is an  
inheritance link for you ! Several people cri ticized the design and it was soon reversed.
But we cannot dismiss the general category of extension inherit ance. In fact its  
equivalent in mathematics, where  you specialize a certain notio n by adding completely  
new operations, is frequently us ed and considere d quite necessa ry. A typical example is  
the notion of ring, specializing the notion of group . A group has a certain operation, say  
+, with certain properties. A ring is a group, so it also has + with these properties, but it  
adds a new operation, say ∗, with extra properties of its own. This is not fundamentally  
different from introducing a new  attribute in an heir software class.
The corresponding scheme is frequ ent in O-O software too. In mo st applications, of  
course, SQUARE  should inherit from RECTANGLE , not the reverse; but it is not difficult  
to think of legitimate examples. A class MOVING_POINT  (for kinematics applications)  
might inherit from a purely graphical class POINT  and add a feature speed  describing the  
speed’s magnitude and direction; or, in a text processing appli cation, a class CHAPTER
might inherit from DOCUMENT , adding the specific featur es of a document which is a  
chapter in a book, such as its c urrent position in the book and  a  p r o c e d u r e  t h a t  w i l l  
repos ition it.Non-mathematical 
readers may skip this one paragraph .
USING INHERITANCE PROPERLY  §24.5 828
A proper mathematical model
(Non-mathematically-inclined rea ders should skip  this section.)
For peace of mind we must resolv e the apparent paradox noted ea rlier (the discovery  
that MB is not a subset of MA) since we do want some subset relation to hold between  
instances of an heir and instanc es of the parent. That relation  does exist in the case of  
extension inheritance; what the paradox shows is that it is ina ppropriate to use cartesian  
product of the attri bute types to model a  class. Given a class
class C feature
c1: T1
c2: T2
c3: T3
end
we should not take, as a mathematical model C' for the set of instances of C, the cartesian  
product T'1 × T'2 × T'3, where the prime signs ' indicate that we recursively use the model  
sets; this would lead to the paradox (among other disadvantages ).
Instead, we should con sider any instance as being a partial fun ction from the set of  
possible attribute names ATTRIBUTE to the set of all possible values VALUE , with the  
following properties:
A1  • The function is defined for c1, c2 and c3.
A2  •T h e  s e t  VALUE  (the target set of the function) is a superset of T'1 ∪ T'2 ∪ T'3.
A3  • The function’s value for c1 is in T'1, and so on.
Then if we remember that a function is a special case of a rela tion, and that a  
relation is a set of pairs (for example an instance of class A may be modeled by the  
function {<a1, 25>}, and the instance of B cited on the preceding page by {<a1, 1>, <b1,
–2.5>}), then we do have the expected property that B' is a subset of A. 
Note that it is essential to state the property A 1 as “The function is defined for …”, not  
“The function’s domain is …” which would limit the domain to the set {c1, c2 c3 }, 
preventing descendants from adding their own attributes. As a r esult of this approach,  
every software object is modeled by an infinity of (finite) mat hematical objects.
This discussion has only given a  sketch of the mathematical mod el. For more details  
on using partial funct ions to model tuples, and the general mat hematical background, see  
[M 1990] .
Variation inheritance
(Non-mathematical readers, welco me back!) We now move to the se cond of our three  
broad groups of inheritance categories: variation inheritance.The functions of 
interest are not only partial but finite .
§24.5   USING INHERITANCE:  A TAXONOMY OF TAXONOMY 829
Variation inheritance is appli cable when an existing class A, describing a certain  
abstraction, is alrea dy useful by itself, but you discover the need to represent a similar  
although not identical abstractio n ,  w h i c h  e s s e n t i a l l y  h a s  t h e  s ame features with some  
different signatures or implementations.
The definition require s that both classes be effective (the mor e common case) or both  
deferred: variation inh eritance does not co ver the case of an e ffecting, where we transform  
a notion from abstract to concre te. A closely related category is uneffecting, studied next,  
in which some effective fe atures are made deferred.
The definition stipulates that the heir should introduce no new  features, except as  
directly needed by the  redefined features. This clause distingu ishes variation inheritance  
from extension inheritance.
In type variation inheritance you only c hange the signat ures (argument  and result  
types and number) of some featur es. This form of  inheritance is  suspect; it is often a sign  
of taxomania. In legitimate cases, however, it may be a prepara t i o n  f o r  e x t e n s i o n  
inheritance or implementation va riation inheritance. An example  o f  t y p e  v a r i a t i o n  
inheritance might be the heirs MALE_EMPLOYEE and FEMALE_EMPLOYEE .
Type variation inheritance is no t necessary when the original s ignature used  
anchored ( like …) declarations. For example in the SEGMENT class of an interactive  
drawing package you may ha ve introduced a function
perpendicular : SEGMENT
-- Segment of same length and sa me middle point, rotated 90 deg rees
…
and then want to define an heir DOTTED_SEGMENT  to provide a graphical  
representation with a dotted lin e rather than a continuous one.  In that class, perpendicular  
should return a result of type DOTTED_SEGMENT , so you will need to redefine the type.  
None of this would be needed if the original returned a result of type like Current , and if  
you have access to the source of the original and the authority  to modify it you may prefer  
to update that type declaration,  normally without  any adverse e ffect on existing clients.  
But if for some reason you cannot modify the original, or if an  anchored decl aration is not  
appropriate in that original (perhaps because of the needs of o ther descendants), then the  
ability to redefine the type can save the day.
In functional  variation inheritance we change some of the features’ bodies; if, as is  
usually the case, the features were already effective, this mea ns changing their  Definition: functional and type variation inheritance
Variation inheritance applies if B redefines some features of A; A and B are 
either both deferred o r both effective, and B must not introduce any features  
except for the direct needs of t he redefined features. There ar e two cases:
• Functional variation inheritance : some of the redefinitions af fect 
feature bodies, rather than  just their signatures.
• Type variation inheritance: all redefinitions are signature re definitions.
USING INHERITANCE PROPERLY  §24.5 830
implementation. The features’ sp ecification, as given by assert ions, may also change. It is  
also possible, although less common, to have functional variati on inheritance between two  
deferred classes; in that case th e assertions will change. This  may imply changes in some  
functions, deferred or effective, used by the assertions, or ev en the addition o f new features  
as long as this is for the “direct needs of the redefined featu res” as the definition states.
Functional variation inheritance is the direct application of t he Open-Closed  
principle: we want to adapt an existing class without affecting  the original (of which we  
may not even have the source cod e) and its clients. It is subje ct to abuses since it may be  
a form of hacking: twisting an e xisting class so as to fit a sl ightly differe nt purpose. At  
least this will be organized hacking, which avoids the da ngers of directly modifying  
existing software, as analyzed i n the discussion of the Open-Cl osed principle. But if you  
do have access to the source cod e of the original class, you sh ould examine whether it is  
not preferable to reorganize the  inheritance hierarchy by intro ducing a more abstract class  
of which both A (the existing variant) and B (the new one) will both be heirs, or proper  
descendants with peer status.
Uneffecting
Uneffecting is not common, and should not be. Its basic idea go es against the normal  
direction of inheritance, s ince we usually expect B to be more concrete and A m o r e  
abstract (as with the next category, reification, for which A is deferred and B effective or  
at least less deferre d). For that reason beginners should stay away from uneffecting. But it  
may be justified in th e following two cases:
•In multiple inheritance, you may want to merge features inherit ed from two different  
parents. If one is deferred and the other is effective, this wi ll happen automatically:  
as soon as they have the same name (possibly after renaming), t he effective version  
will serve as implementation. Bu t if both are effective, you wi ll need to uneffect one  
of them; the other’s impleme ntation will take precedence.
• You may find a reus able class that is too concrete  for your purposes, although the  
abstraction it describes serves your needs. Uneffecting will re move the unwanted  
implementations. Before using this solution, consider the alter natives: it is preferable  
to reorganize the inheritance hi erarchy to make the more concre te class an heir of the  
n e w  d e f e r r e d  c l a s s ,  r a t h e r  t h a n  t h e  r e v e r s e .  B u t  t h i s  i s  n o t  a l ways possible, for  
example if you do not have the authority to modify A and its inheritance hierarchy.  
Uneffecting may, in such cases, p rovide a useful form of genera lization.
For a link of the uneffecting category, B will be deferred; A will normally be  
effective, but might be partially deferred.Definition: uneffecting inheritance
Uneffecting inheritance applies if B redefines some of th e effective features  
of A into deferred features.See “The Open-
Closed principle”, page 57 .
See “Rules on 
names”, page 562 .
§24.5   USING INHERITANCE:  A TAXONOMY OF TAXONOMY 831
Reification inheritance
We now come to the third and las t general group, software inher itance.
A n  e x a m p l e ,  u s e d  s e v e r a l  t i m e s  i n  e a r l i e r  c h a p t e r s ,  i s  a  d e f e r r ed class TABLE
describing tables of a very general nature. Reification leads t o heirs SEQUENTIAL_
TABLE  and HASH_TABLE , still deferred. Final reification of SEQUENTIAL_TABLE  leads 
to effective classes ARRAYED_TABLE , LINKED_TABLE , FILE_TABLE .
The term “reification”, from Latin words meaning “making into a  thing”, comes from the  
literary criticism of Georg Lukács. In computing science it is used as part of the VDM  
specification and development method.
Structure inheritance
Usually A represents a mathematical prope rty that a certain set of objec ts may possess; for  
example A may be the class COMP ARABLE , equipped with su ch operations as infix "<"
and infix ">=" , representing objects to which a total order relation is appli cable. A class  
that needs an order relation of its own, such as STRING , will inherit from COMP ARABLE .
It is common for a class to inher it from several parents in thi s way. For example class  
INTEGER  in the Kernel Library inherits from COMP ARABLE  as well as from a class  
NUMERIC  (with features such as infix "+" a n d  infix "∗") representing its arithmetic  
properties. (Class NUMERIC more precisely represents the mathematical notion of ring.)
W h a t  i s  t h e  d i f f e r e n c e  b e t w e e n  t h e  s t r u c t u r e  a n d  r e i f i c a t i o n  c a tegories? With  
reification inheritance B represents the same notion as A, with more implementation  
commitment; with structure inheritance B represents an abstractio n of its own, of which A
covers only one aspect, such as the presence of an order relati on or of arithmetic operations.
Waldén and Nerson note that novic es sometimes believe they are using a similar  
form of inheritance when they ar e in fact mistak ing a “contains ” relation for “is” — as  
with AIRPLANE inheriting from VENTILATION_SYSTEM , a variant of the “car-owner”  
scheme, and just as wrong. They point out that it is easy to av oid this mistake through a  
criterion of the “absolute” kind , leaving no room for hesitatio n or ambiguity:Definition: reification inheritance
Reification inheritance applies if A represents a general ki nd of data structure,  
and B represents a partial or complete choice of implementation for d ata 
structures of that kind. A is deferred; B may still be deferred, leaving room for  
further reification through its own heirs, or it may be effecti ve.
Definition: structure inheritance
Structure inheritance applies if A, a deferred class, represents a general  
structural property and B, which may be deferred or effective, represents a  
certain type of objects po ssessing that property.
See “Numeric and 
comparable val-ues”, page 522 .
USING INHERITANCE PROPERLY  §24.5 832
With the inhe ritance scheme , although the inherited properties are  
secondary , they are still properties of the whole objects  described by the  
class . If we make AIRPLANE  inherit COMP ARABLE  to take account of an  
ordering relation on planes , the inherited features apply to each airplane as  
a whole ; but the features of VENTILATION_SYSTEM  do not . Feature stop of 
VENTILATION_SYSTEM  is not supposed to stop the plane .
The conclusion in this example is clear: AIRPLANE must be a client , not an heir, of  
VENTILATION_SYSTEM .
Implementation inheritance
Implementation inheritance is discussed in detail later in this  chapter. A common case is  
the “marriage of convenience”, ba sed on multiple inheritance, w here one parent provides  
the specification (reification i nheritance) and the other provi des the implementation  
(implementation  inheritance).
The case of inheriting constant attributes or once functions is  covered by the next variant.
Facility inheritance
Facility inheritance is the sche me in which the parent is a col lection of useful features  
meant only for use  by descendants:
An example of facility inheritance was provided by class EXCEPTIONS , a utility  
class providing a set of facilities for detailed access to the exception handling mechanism.
Sometimes, as in the examples gi ven later in this chapter, a li nk of the facility kind  
uses only one of the two variants, constant or machine; but in others, such as  
EXCEPTIONS , the parent class provides both constants (such as the excepti on code  Definition: implementation inheritance
Structural inheritance applies if B obtains from A a set of features (other than  
constant attributes and once func tions) necessary to the implem entation of the  
abstraction associated with B. Both A and B must be effective.
Definition: facility inheritance
Facility inherita nce applies if A exists solely for the purpose of providing a  
set of logically related features  f o r  t h e  b e n e f i t  o f  h e i r s  s u c h  a s  B. Two  
common variants are:
•Constant inheritance  in which the features of A are all constants or once  
functions describing shared objects.
•Machine inheritance  in which the features of A are routines, which may  
be viewed as operations on an abstract machine.Cited (with change 
of example) from  
[Waldén 1995] , 
pages 193-194.
“IMPLEMENTA-
TION INHERI-TANCE”, 24.8, page 844.
See “ADVANCED 
EXCEPTION HAN-DLING”, 12.6, page 431.
§24.6   ONE MECHANISM, OR MORE? 833
Incorrect_inspect_value ) and routines (such as trigger to raise a developer exception).  
Since this discussion is meant t o introduce disjoint inheritanc e categories, we should treat  
facility inheritance as a single category — with two (non-disjo int) variants.
With constant inheritance, both A and B are effective. With machine inheritance,  
there is more flexibility, but B should be at least as effective as A.
Facility inheritance is  discussed in detail  later in this chapt er.
Using inheritance with deferr ed and effective classes
Each of the various categories r eviewed places some requirement s on which of the heir  
and the parent may be deferred and which may be effective. The following table  
summarizes the rules. “Variation”  covers type variation and fun ctional variation. Items  
marked appear in mo re than one entry.            
24.6  ONE MECHANISM, OR MORE?
(Note: this discussion assumes a s background the earlier presen tation of “The meaning of  
inheritance”, especially its secti on entitled “The dual perspec tive”, and the presentation of  
descendant hiding, especially it s section entitled “The two sty les” with its summary table.)
The variety of uses of inheritan ce, evidenced by the preceding discussion, may lead  
t o  t h e  i m p r e s s i o n  t h a t  w e  s h o u l d  have several language mechanis ms to cover the  
underlying notions. In  particular, a number of authors have sug gested separating between  
module  inheritance, essentia lly a tool to reuse existing features in a new module, and type
inheritance, essentially a t ype classification mechanism.
Such a division seems to cause m ore harm than go od, for several  reasons.     Parent →
Heir↓ Deferred Effective
 
 
 
DeferredConstant
Restriction
Structure
Subtype
Uneffecting
Variation
ViewExtension
Uneffecting
 
 
EffectiveConstant
Reification
Structure
SubtypeConstant
Extension
Implementation
Restriction
Variation“F ACILITY INHER-
ITANCE”, 24.9, page 847 .
Deferred and 
effective heir 
and parent
“The dual perspec-
tive”, page 494 ; 
“The two styles”, page 608 .
USING INHERITANCE PROPERLY  §24.6 834
First, recognizing onl y two categories is not representative of  the variety of uses of  
inheritance, reflected by the preceding classification. Since n o one will advocate  
introducing ten different langua ge mechanisms, t he result would  be too restrictive.
The practical effect would be to raise useless methodological d iscussions: assume  
you want to inherit from an iterator class such as LINEAR_ITERATOR ; should you use  
module inheritance or type inheri tance? One can find arguments to support either answer.  
You will waste your time trying to decide between two competing  language mechanisms;  
the contribution of such reflect ions to the only goals that cou nt — the quality of your  
software and the speed at which you produce it — is exactly zer o.
An exercise asks you to analyze our categories to try to see fo r each of them whether it  
relates more to the “module” or “type” kind.
It is also interesting to think of the consequences that such a  division will have on  
the complexity of the language. Inheritance comes with a number  of auxiliary  
mechanisms. Most of them will  be needed on both sides:
•Redefinition  is useful both for subtyping (think of RECTANGLE  redefining  
perimeter  from POLYGON ) and for module extension (the Open-Closed principle  
demands that when we inherit a mo dule we keep the flexibility o f changing what is  
not adapted any more to our new context — a flexibility without  which we would  
lose one of the main attractions of the object-oriented method) .
•Renaming  is definitely useful for module  inheritance. To present it as inappropriate  
for type inheritance (see [Breu 1995] ) seems too restrictive. In the modeled external  
system, variants of a certain not ion may introduce specific ter minology, which it is  
often desirable for the so ftware to respect. A class STATE_INSTITUTIONS in a 
geographical or electoral inform ation system might have a desce ndant class  
LOUISIANA_INSTITUTIONS  reflecting the peculiarities of Louisiana’s political  
structures; it is not unreasonabl e to expect that  the feature counties , giving the list of  
counties in a state, would be renamed parishes  in the descendant, since parish is what  
Louisianians call what the res t of the US knows as a county.
•Repeated inheritance  may occur with either form. Si nce we may expect that module-
only inheritance will preclude polymorphic substitution, the pr oblem of  
disambiguating dynamic bindi ng, and hence the need for a select  clause, will only  
arise for type inheritance; but all the other questions, in par ticular when to share  
repeatedly inherited features an d when to replicate them, still  arise.
• As always when we introduce new mechanisms into a language, th ey interact with  
the rest, and with eac h other. Do we prohibit a class from both  module-inheriting and  
type-inheriting the sa me class? If so, we ma y be just vexing de velopers who have a  
good reason to use the same clas s in two different ways; if not , we open up a whole  
Pandora’s box of new la nguage issues — name  conflicts, redefini tion conflicts etc.Exercise E24.8, page 
870.
§24.7   SUBTYPE INHERITANCE AND DESCENDANT HIDING 835
A l l  t h i s  f o r  t h e  b e n e f i t  o f  a  p u r i s t ’ s  v i e w  o f  i n h e r i t a n c e  —  r e strictive and  
controversial. Not that there is  anything wrong with defending controversial views; but  
one should be careful before imp osing their cons equences on lan guage users — that is to  
say, on everyone. When  in doubt, abstain. O nce again, the contr ast with Dijkstra’s original  
goto excommunication is striking: Dij k s t r a  t o o k  g r e a t  c a r e  t o  e x p l a in in detail the  
drawbacks of the goto instruction, based on a theor y of software construction and  
execution, and to explain what r eplacements were available. In the present case, no  
compelling argument — at least none that I have seen — shows wh y it is “bad” to use a  
single mechanism to cover both module and type inheritance. 
Aside from blanket condemnations based on preconceived ideas of  what inheritance  
should be, there is onl y one serious objection to the use of a single mechanism: the extra  
complication that this appro ach imposes on the task of static type checking . This issue  
was discussed at length in chapter 17; it places an extra burden on compilers , which is  
always justifiable (when the bur den is reasonable, as here) if the effect is to facilitate the  
developer ’s task.
In the end what all this discussion shows is that the ability t o use only one inheritance  
mechanism for both module and type inheritance is not — as part isans of separate  
mechanisms implicitly consider — the result of a confusion of g enres. It is the result of  
the very first decision  of object-oriented software construction: the unification of m odule 
and type concepts into a single notion, the class. If we accept  classes as both modules and  
types, then we s hould accept inheritance as both module accumul ation and subtyping.
24.7  SUBTYPE INHERITANCE AND DESCENDANT HIDING
The first category on our list is probably the only form on whi ch everyone agrees, at least  
everyone who accepts inheritance : what we may call pure subtype  inheritance.
Most of the discussion will also  apply to restriction inheritan ce, whose principal  
difference with subtype  inheritance is that it does not require  the parent to be deferred.
Defining a subtype
As was pointed out in the introduction of inheritance, part of the power of the idea comes  
from its fusion of a type mechanism, the definition of a new ty pe as a special case of  
e x i s t i n g  t y p e s ,  w i t h  a  m o d u l e  m e c h a n i s m ,  t h e  d e f i n i t i o n  o f  a  m o dule as extension of  
existing modules. Many of the co ntroversial questions about inh eritance come from  
perceived conflicts between thes e two views. With subtype inher itance there is no such  
question — although, as we shall see, this does not mean that e verything becomes easy.
Subtype inheritance is closely p atterned after the taxonomical principles of natural  
and mathematical sciences. Every vertebrate is an animal; every  mammal is a vertebrate;  
every elephant is a mammal. Every  group (in mathematics) is a m onoid; every ring is a  
group; every field is a ring. Similar examples, of which we saw  many in earlier chapters,  
abound in object-o riented software:On Dijkstra’s advice 
see “The need for methodology guide-lines”, page 664 .
USING INHERITANCE PROPERLY  §24.7 836
• FIGURE  CLOSED_FIGURE  POLYGON  QUADRANGLE  
RECTANGLE  SQUARE
•D E V I C E   FILE  TEXT_FILE
•S H I P   LEISURE_SHIP  SAILBOAT
• ACCOUNT  SAVINGS_ACCOUNT  FIXED_RATE_ACCOUNT
and so on. In any one of these s ubtype links, we  have clearly i dentified the set of objects  
that the parent type describes; and we have spotted a subset of  these objects, characterized  
by some properties which do not necessarily apply to all instan ces of the parent. For  
example a text file is a file, but it has the extra property of  being made of a sequence of  
characters — a property that som e other files, such as executab le binaries, do not possess.
A general rule of subtype inheritance is that the various heirs  of a class represent  
disjoint sets of instances. No c losed figure, for example, is b oth a polygon and an ellipse.
Several of the examples, such as RECTANGLE  SQUARE , will most likely involve  
an effective parent, and so are  cases of restriction inheritanc e.
Multiple views
Subtype inheritance is straightforward when a clear criterion e xists to classify the variants  
of a certain notion. But sometim es several qualities vie for ou r attention. Even in such a  
seemingly easy example as the cla ssification of polygons, doubt  may arise: should we use  
the number of sides, lea ding to heirs such as TRIANGLE , QUADRANGLE  etc., or should  
we divide our objects into regular polygons ( EQUILATERAL_POLYGON , SQUARE  and 
so on) and irr egular ones?
Several strategies are available to address such conflicts. The y will be reviewed as  
part of the study of  view inheritance later in this chapter.
Enforcing the subtype view
A type is not just as a set of objects, of course: it is also c haracterized by the applicable  
operations (the features), and t heir semantic properties (the a ssertions: preconditions,  
postconditions, invariants). We expect the fate of features and  assertions in the heir to be  
compatible with the concept of s ubtype — meaning that it must a llow us to view any  
instance of the heir also as an instance of the parent.
The rules on assertions inde ed support the subtype view:
• The parent’s invariant is autom atically part of the heir’s inv ariant; so all the  
constraints that have been speci fied for instances  of the paren t also apply to instances  
of the heir.
• A routine precondition applies,  possibly weakened, to any rede claration of the  
routine: so any call which satisfies the requirement specified for instances of the  
parent will also satisfy the (eq ual or weaker) requirement spec ified for instances of  
the heir.
§24.7   SUBTYPE INHERITANCE AND DESCENDANT HIDING 837
• A routine postcondition applies,  possibly strengthened, to any  redeclaration of the  
routine: so any property of the routine’s outcome that has been  s p e c i f i e d  f o r  
instances of the parent will be g uaranteed to hold as a result of the (equal or stronger)  
properties specified for instances of the heir.
For features, the situation is a little more subtle. The subtyp e view implies that all  
operations applicable to an instance of the parent should be ap plicable to an instance of  
the heir. Internally, this is always true: even in the inherita nce of ARRAYED_STACK from
ARRAY , which seems far from subtype inheritance, the features of ARRAY  were still  
a v a i l a b l e  t o  t h e  h e i r ,  a n d  i n d e e d  w e r e  e s s e n t i a l  t o  t h e  i m p l e m e ntation of its STACK
features. But in that case  we had hidden all these ARRAY  features from the  heir’s clients,  
a n d  f o r  g o o d  r e a s o n  ( w e  d o  n o t  w a n t  a  c l i e n t  o f  a  s t a c k  c l a s s  t o perform arbitrary  
operations on the representation, such as directly modifying an  array element, since this  
would be a violation of the class interface).
F o r  p u r e  s u b t y p e  i n h e r i t a n c e  w e  m i g h t  e x p e c t  a  m u c h  s t r o n g e r  r u le: that every
feature that a client can apply to instances of the parent clas s also be applicable, by that  
same client, to instances of the heir. In other words, no desce ndant hiding: if B inherits f
from A, then the export status of f in B is at least as generous as in A. (That is to say: if f 
was generally exported, it still is; and if it was selectively exported to some classes, it is  
still exported to th em, although it may be exported to more.)
The need for d escendant hiding
In a perfect world we could inde ed enforce the no-descendant-hi ding rule; but not in the  
real world of software development. Inheritance must be usable even for classes written by  
people who do not have perfect for esight; some of the features they include in a class may  
not make sense in a de scendant written by so meone else, later a nd in a completely different  
context. We may call such cases taxonomy exceptions . (In a different context the word  
“exception” would suffice, but w e do not want any confusion wit h the software notion of  
exception handling as studied in earlier chapters.)
Should we renounce inhe riting from an attractive and useful cla ss simply because of  
a taxonomy exception, that is to say because one or two of its features are inapplicable to  
our own clients? This would be unreasonable. We just hide the f eatures from our clients’  
view, and proceed with our work.
The alternatives have been studied as part of one of the foundi ng principles of object  
technology — Open-Closed principle  — and they are not attractive:
• We might modify the original cl ass. This means we may invalida te myriads of  
existing systems that relied on i t — no, thanks. In most practi cal cases, anyway, the  
class will not be ours to modify ; we may not even have access t o its source form.
• We might write a new version of the class (or, if we are lucky  and do have access to  
its source code, make a copy), a nd modify it. This approach is the reverse of  
everything that object technology promotes; it defeats any atte mpt at reusability and  
at an organized software process.
USING INHERITANCE PROPERLY  §24.7 838
Avoiding descendant hiding
Before probing further why and w hen we may need descendant hidi ng, it is essential to note  
that most of the time we do not. Descendant hidin g should remai n a technique of last resort.  
When you have a full gr asp of the inheritan ce structure suffici ently early in the design  
process, preconditions  are a better te chnique to handle appare nt taxonomy exceptions.
Consider class ELLIPSE . An ellipse has two focus es through which you can  
normally draw a line:
Class ELLIPSE  might correspondingly have a feature focus_line . 
It is quite normal to define class CIRCLE  as an heir to ELLIPSE : every circle is also  
an ellipse. But for a circle the two focuses are the same point  — the circle’s center — so  
there is no focus line. (It is perhaps more accurate to say tha t there is an infinity of focus  
lines, including any line that passes through the center, but i n practice the effect is the sam e.)
Is this a good example of descendant hiding? In other words, sh ould class CIRCLE
make feature focus_line  secret, as in
class CIRCLE  inherit
ELLIPSE
export {NONE } focus_line end
…
Probably not. In this case, the d esigner of the parent class ha s all the information at  
his disposal to determine that focus_line  is not applicable to all ellipses. Assuming the  
feature is a routin e, it should have a precondition:
focus_line
-- The line throug h the two focuses
require
not equal ( focus_1 , focus_2 )
do
…
endAn ellipse and 
its focus line
FocusesFocus line
A circle and its 
center
Center
§24.7   SUBTYPE INHERITANCE AND DESCENDANT HIDING 839
(The precondition could also b e abstract, usi ng a function distinct_   focuses ; this has  
the advantage that CIRCLE  can redefine that function on ce and for all to yield false.)
Here the need to support ellipses  without a focus line follows from a proper analysis  
of the problem. Writing an ellipse class with a function focus_line  that has no precondition  
would be a design erro r; addressing such an error through desce ndant hiding would be  
attempting to cover up for that error. As was pointed out at th e end of the presentation of  
the Open-Closed princi ple, erroneous desi gns must be fixed, not  patched in descendants.
Applications of descendant hiding
The focus_line  example is typical of taxonomy exceptions arising in applicati on domains  
such as mathematics which can boast a solid theory with associa ted classifications,  
patiently refined over a long per iod. In such a context, the pr o p e r  a n s w e r  i s  t o  u s e  a  
precondition, concrete  or abstract, at the  place where the orig inal feature appears.
But that technique is not always applicable, especially in doma ins that are driven by  
human processes, with their atte ndant capriciousness that often  makes it hard to foresee  
all possible exceptions.
Consider as an example a class hierarchy, rooted in a class MORTGAGE , in a  
software system for managing mort gages. The descendants have be en organized according  
to various criteria, su ch as fixed rate ver sus variable rate, b usiness versus personal or any  
other that was found appropriate; we may assume for simplicity that this is a taxonomy of  
the pure subtype kind. Class MORTGAGE  has a procedure redeem , which handles the  
mechanisms for paying off a mortgage at a certain time earlier than maturation.
Now assume that Congress, in a fit of generosity (or under the pressure of  
construction lobbies), introduce s a new form of government-back ed mortgage whose  
otherwise advantageous conditions carry a provision barring any  early redemption. We  
have found a proper place in the hierarchy for the correspondin g class NEW_MORTGAGE ; 
but what about procedure redeem ?
We could use the technique illustrated with focus_line : a precondition. But what if  
there has never before in banker ’s memory existed a mortgage th at could not be  
redeemed? Then procedure redeem  probably does not have a precondition. (The situation  
is the same if the pre condition existed but was concrete, so th at it cannot be redefined.)
So if we decide to use a precondition we must modify class MORTGAGE . As usual,  
this assumes that we have access to its source code and the rig ht to modify it — often not  
true. Suppose, however, that thi s is not a problem. We will add  to MORTGAGE  a boolean-
valued function redeemable and to redeem a clause
require
redeemable
But now we have changed the interface of the class. All the cli ents of the class and  
of its numerous descendants have instantly been made potentiall y incorrect; to observe the  
specification all calls m  redeem (…) should now be rewritten asSee page 61 .
USING INHERITANCE PROPERLY  §24.7 840
if m  redeemable then
m  redeem (…)
else
… (What in the world  do we say here?) …
end
Initially this change is not ur gent, since the incorrectness is  only potential: existing  
software will only use the  existing descendants of MORTGAGE , so no harm can result.  
But not fixing them means leaving a time bomb — unprotected cal ls to a precondition-
equipped routine — tick ing in our software. As soon as a client  developer has the clever  
idea of using a polymorphic atta chment with a source of type NEW_MORTGAGE  but 
forgets the test we have a bug. And the compiler will not produ ce any diagnostic.
The absence of a precondition in the original version of redeem  was not a design  
mistake on the part of the original designers: in their view of  the world, until now correct,  
no precondition was needed. Ever y mortgage was redeemable. We c annot require every  
feature to have a precondition; imagine a world in which for ev ery useful f  there would be  
an accompanying boolean-valued function f_  feasible  serving as its bodyguard; then we  
would never be able to write a simple x  f  for the rest of our lives; each call would be in an  
if … or equivalent as illustrated above for m  redeem . Not fun.
The redeem  example is typical of taxonomy exceptions which, unlike focus_line  and 
other cases of perfect-foresight  classification, cannot be addr essed through careful a priori
precondition design. The observation made earlier fully applies : it would be absurd to  
renounce inheritance — the reuse of a rich class structure, lov ingly developed and  
carefully validated — because a f eature or two, out of dozens o f useful ones, do not apply  
to our goal of the moment. We sh ould just use de scendant hiding :
class NEW_MORTGAGE inherit
MORTGAGE
export {NONE } redeem end
…
No error or anomaly will be intr oduced in existing software — t he existing class  
structure or its clients. If someone modifies a client class to  include a polymorphic  
attachment with source type NEW_MORTGAGE , and the target of that attachment is also  
used with redeem , as in
m: MORTGAGE ; nm: NEW_MORTGAGE 
…
m := nm
…
m  redeem (…)
then the call becomes a catcall, and the potential error will b e caught statically by the  
extended mechanism described  in our discussion of typing.“BEWARE OF 
POLYMORPHIC CATCALLS!”, 17.7, page 636 .
§24.7   SUBTYPE INHERITANCE AND DESCENDANT HIDING 841
Taxonomies and their limitations
Taxonomy exceptions are not speci fic to software examples. Even  —  o r  p e r h a p s  
especially — in the most establis hed areas of natural science, it sometimes seems  
impossible to find a statement of the form “ members of the ABC phylum  [or genus, species  
etc.] a re characterized by property XYZ   ” that is not prefaced by “ most  ”, qualified by  
“usually ” or followed by “ except in a few cases ”.This is true at all levels of the hierarchy,  
even the most fundamental categories, which a layman might naïv ely believe to be  
established on indis putable criteria!
If you think for example that th e distinction between the anima l and plant kingdoms  
is simple, just ponder  its definition in a p opular reference te xt (italics  added):
DISTINGUISHING PLA NTS FROM ANIMALS
There are several general  factors that distinguish plants from animals, though  there are  
numerous exceptions .
Locomotion  Most  animals move about freely, while  it is rare to find plants that can move  
around in their surrounding environments. Most  plants are rooted in the soil, or attached  
to rocks, wood or other materials .
Food  Green plants that contain chlorophyll manufacture food themsel ves, but most
animals obtain nutrients by eating plants or other animals. [ …]
Growth  Plants usually  grow from the tips of their branches and roots, and at the out er 
layer of their stems, for their entire life. Animals usually  grow in all parts of their bodies  
and stop growing after maturity.
Chemical regulation  Though both plants and animals generally  have hormones and  
other chemicals that regulate certain  reactions within the organism, the chemical  
composition of these hormones differ[s] in the two kingdoms.
The same comments appl y to another area of study, cultural rath er than natural,  
which has also contributed to the development of systematic tax onomy: the historical  
classification of human languages.
In zoology a common example, so famous in Artificial Intelligen ce circles as to have  
become a cliché, still provides a good illustration of taxonomy  exceptions. (Remember,  
however, that this is only an analogy , not a software example, and so cannot prove  
anything; it can only help us un derstand ideas wh ose relevance has been demonstrated  
otherwise.) Birds fly; i n software terms class BIRD  would have a procedure fly. Yet if we  
wanted a class OSTRICH  we would have to admit that o striches, although among the  
birdest of birds, do not fly.
We could think of classifying bi rds into flying and non-flying categories. But this  
would conflict with other possibl e criteria including, most imp ortantly, the commonly  
retained one, shown on the next page.From : the New York 
Public Library Sci-ence Desk Refer-ence, ed. Patricia 
Barnes-Svarney , 
1995 .
USING INHERITANCE PROPERLY  §24.7 842
Kingdom: Animalia  — multicellular organisms without chlorophyll General 
classification 
of birds  
(Data from Ed 
Everham, at 
www.runet.edu/
~eeverham.)Reproduced with the author’s 
permission. 
Associated comments are 
reproduced in  
“The arbitrariness of classifications”, 
page 859.Phylum: Chordata  —coelemic cavity, 3 germ layers, a notocord,  
an endoskeleton and a clo sed circulatory system
Class: Aves  birds (there are 30 orders) 
Order: Anseriformes — waterfowl
Order:  Apodiformes  — swifts and hummingbirds
Order:  Casuariiformes  cassowaries and emu
Order:  Chardriiformes  — shorebirds
Order:  Ciconiiformes  — long-legged wading birds 
Order:  Coliiformes  — mousebirds
Order:  Columbiformes  — pigeons and doves 
Order:  Cuciliformes — cuckoos 
Order:  Dinornithiformes  — kiwis and moas 
Order:  Falconiformes  — raptors 
Order:  Galliformes  — gallinaceous birds (chickens, grouse, quail  
                                         and pheasant) 
Order:  Musophagiformes — turacos 
Order:  Passeriformes  — perching birds, songbirds and passerines
Order: Pelecaniformes  — waterbirds with webbed feet
Order:  Phoenicopteriformes  — flamingos 
Order:  Piciformes  — woodpeckers 
Order:  Podicipediformes  — grebes 
Order:  Procellariiformes  — tube-nosed seabirds 
Order:  Psittaciformes  — parrots, macaws 
Order:  Pteroclidiformes — sandgrouse 
Order:  Rheiformes  — rheas, nandus 
Order:  Strigiformes  — owls 
Order:  Struthioniformes  — ostrich 
Order:  Tinamiformes  — tinamous 
Order:  Trogoniformes  — trogons and quetzals Order:  Coraciiformes — kingfishers
Order:  Sphenisciformes  — penguinsOrder:  Gaviiformes  — loons
Order:  Gruiformes — terrestrial and marsh birds Order:  Caprimulgiformes  — nightjars, potoos, frogmouths,  
owlet- frogmouths and oilbirds 
§24.7   SUBTYPE INHERITANCE AND DESCENDANT HIDING 843
The OSTRICH  example has an interesting twis t. Although regre ttably most of  them 
do not seem to be aware of it, ostriches really should fly. You nger generations lost this  
ancestral skill through an accid ent of evolutionary history, bu t anatomically ostriches have  
retained most of the aeronautical machinery of birds. This prop erty, which ma kes the job  
of the professional ta xonomist a little ha rder (although it may  facilitate that of his  
colleague, the professional taxi dermist), will not in the end p revent him from classifying  
ostriches among birds.
In software terms OSTRICH  will simply inherit from BIRD  and hide the inherited  
fly feature.
Using descendant hiding
All our efforts [at classification] are powerless against the multiple relations  
which from everywhe re affect the living beings around us . This is the fight ,
described by the gr eat botanist Goethe , between Man and Nature in her  
infinity . One can be sure that Man will always be defeated .
Henri Baillon, General Study of the Euphorbiaceous  
Family  (1850). Quoted (in French) in Peter F. Stevens,  
The Development of Bi ological Sy stematics : Antoine-
Laurent de Jussieu , Nature , and the Natural System , 
Columbia University P ress, New York, 1994.
The preceding evidence, from bot h software practice and non-sof tware analogies,  
suggests that even with a carefu l design some taxonomy exceptio ns may remain. Hiding  
redeem from NEW_MORTGAGE or fly from OSTRICH  is not necessarily a sign of sloppy  
design or insufficient foresight ; it is the recognition that ot her inheritance hierarchies that  
would not require descendant hid ing could be more complex and l ess useful.
Such taxonomy exceptions have th e precedent of centuries of eff ort by intellectual  
giants (including Aristotle, Linné, Buffon, Jussieu and Darwin). They may even signal  
some intrinsic limitation of the  human ability to comprehend th e world. Could they be  
related to the indeter minacy results that sh ook scientific thou ght in the twent ieth century,  
uncertainty in physics and und ecidability in mathematics?
All this assumes that descendant hiding remains, as already not ed, a rare occurrence.  
If you design a taxonomy with ta xonomy exceptions all over — we l l ,  t h e y  a r e  n o t  
exceptions any more, so you do n ot really have much of a taxono my.
In software, for those few cases in which conflicting classific ation criteria or massive  
previous work preclude s the producti on of a perfect subtype hie rarchy, descendant hiding  
is more than a convenient fac ility: it will sa ve your neck.
USING INHERITANCE PROPERLY  §24.8 844
24.8  IMPLEMENTATION INHERITANCE
A form of inheritance that has often been criticized but is in fact both convenient and  
conceptually valid is the use of  an inheritance link between a class describing a certain  
implementation of an abstract da ta structure and  the class prov iding the implementation.
The marriage of convenience
In the discussion of multiple inheritance we saw an example of the “marriage of  
convenience” kind, whic h combines a deferred class with a mecha nism to implement it.  
The example was ARRAYED_STACK , of the general form
class ARRAYED_STACK [G] inherit
STACK [G]
redefine  change_top end
ARRAY [G]
rename
count as capacity , put as array_put
export
{NONE } all
end
feature
… Implementation of the  deferred routines of STACK , such as put, count , full,
    and redefinition of change_top , in terms of ARRAY  operations …
end
It is interesting to compare ARRAYED_STACK , as sketched here, with the class  
STACK2  of an earlier discussion — an array implementation of stacks d efined without any  
use of inheritance. Not e in particular how avoiding the need fo r the class to be a client of  
ARRAY  simplifies the notation (the previous version had to use implementation   put where  
we can now just write put). 
In the above inheritance part for ARRAY  all features have been made secret. This is  
typical of marriage-of-convenien ce inheritance: all the feature s from the specification-
providing parent, here STACK , are exported; all the featur es from the implementation-
providing parent, here ARRAY , are hidden. This forces clients of class ARRAY_STACK  to 
use the corresponding instances t hrough stack features only; we  do not want to let them  
perform arbitrary array operation s on the representation, such as changing the value of an  
element other th an the top one.
It feels so good, but is it wrong?
Implementation inheritance is not without its critics. That we hide many inherited features  
seems to some people a violation  of the “is-a” principle of inh eritance.
It is not. There are different forms of “is-a”. By its behavior , an arrayed stack is a stack;  
but internally it is an array. In fact the representation of an  instance of ARRAYED_STACK is 
exactly the same as that of an instance of ARRAY , enriched with one attribute ( count ). “The marriage of 
convenience”, page 530.
STACK2  appeared 
on page 349 .
§24.8   IMPLEMENTATION INHERITANCE 845
Being made in the same  way is a rather strong form of “is-a”. A n d  i t  i s  n o t  j u s t  t h e  
representation: all the features of ARRAY , such as put (renamed array_put ), infix "@" and 
count (renamed capacity ) are available to ARRAYED_STACK , although not exported to its  
clients; the class needs them to implement the STACK  features.
So there is nothing conceptually  wrong with such implementation -only inheritance.  
The comparison with the counter-example studied at the beginnin g of this chapter is  
striking: for CAR_OWNER  we had a gross misunderst anding of the concept; with  
ARRAYED_STACK we have a well-identif ied form of the “is-a” relationship.
There is one drawback: permittin g the inheritance mechanism to restrict the export  
availability of an inh erited feature — that is to say, permitti ng the export  clause — makes  
static type checking more difficul t ,  a s  w e  h a v e  s t u d i e d  i n  d e t a il. But this difficulty is  
largely for the compiler writer , not for the sof tware developer .
Doing without inheritance
L e t  u s  p r o b e  f u r t h e r  a n d  s e e  w h a t  i t  w o u l d  t a k e  t o  w o r k  w i t h o u t  implementation  
inheritance in our example case.  This has been seen already: cl ass STACK2  of an earlier  
chapter. It has an attribute representation  o f  t y p e  ARRAY [G] a n d  s t a c k  p r o c e d u r e s  
implemented in the following  style (assertions omitted):
put (x: G)
-- Add x on top.
require
…
do
count  := count + 1
representation   put (count , x)
ensure
…
end
Every manipulation of the repr esentation requires a call to a f eature of ARRAY  with 
representation as the target. There is a perfor mance penalty: minor for space (the 
representation  attribute), more serious f or time (going throupfgh representation , that is to  
say adding an indirectio n, for each operation).
A s s u m e  w e  c a n  i g n o r e  t h e  e f f i c i e ncy issue. Tediousness is anoth er, with all the  
“representation   ” prefixes that you must add befor e every array operation. This w ill be 
true in all the classes that implement various data structures — stacks, but also lists,  
queues and others —  through arrays.
The object-oriented designer hate s tedious, repetitive tasks. “ Encapsulate repetition”  
is our motto. If we see such a pattern occurring repeatedly thr oughout a set of classes, the  
natural and healthy reaction is to try to understand the common  abstraction, and  
encapsulate it in a class. The abstraction here is something li ke “data structure that has  
access to an array and its oper ations”. The class could be:Page 349 .
USING INHERITANCE PROPERLY  §24.8 846
note
description : "Objects that ha ve access to an array and its operations "
class
ARRAYED [G]
feature -- Access
item (i: INTEGER ): G
-- The representation’s element at index i
require
…
do
Result  := representation   item (i)
ensure
…
end
feature  -- Element change
put (x: G; i: INTEGER )
-- Replace by x the representation’ s element at index i.
require
…
do
representation   put (x, i)
ensure
…
end
feature  {NONE } -- Implementation
representation : ARRAY [G]
end
The features item and put have been exported. Since ARRAYED  only describes internal  
properties of a data structur e, it does not really need exporte d features. So someone who  
disagrees with the very idea of letting a descendant hide some of its parents’ exported  
features may prefer to make all the features of ARRAYED  secret. They will then by default  
remain secret in descendants.
With this class definition it becomes quite uncontroversial to make classes such as  
ARRAYED_STACK or ARRAYED_LIST  inherit from ARRAYED : they indeed describe  
“arrayed” structures. These classes can now use item instead of representation   item and 
so on; we have rid ourselv es of the tediousness. 
But wait a minute! If it i s right to inherit from ARRAYED , why can we not inherit  
directly from ARRAY  ? We gain nothing from the further layer or encapsulation that we 
have thrown over ARRAY  —  a  f o r m  o f  e n c a p s u l a t i o n  t h a t  s t a r t s  l o o k i n g  m o r e  l i k e  
obfuscation. By g oing through ARRAYED we are just pretending t o ourselves that we are  
not using implementation inherit ance, but for all practical pur poses we are. We have just  
made the software more com plex and less efficient.
There is indeed no reason in this example for class ARRAYED . Direct implementation  
inheritance from classes such as ARRAY  is simpler and legitimate.
§24.9   FACILITY INHERITANCE 847
24.9  FACILITY INHERITANCE
With facility inheritance we are even less coy than with implem entation inheritance about  
why we want the marriage: pure, greedy self-interest. We see a class with advantageous  
features and we want to use them . But there is no thing to be as hamed of: the class has no  
other raison d’être .
Using character codes
The Base Libraries  include a class ASCII :
note
description :
"The ASCII character set . %
%This class may be used as ancesto r by classes needing its facilities ."
class ASCII  feature -- Access
Character_set_size : INTEGER = 128; Last_ascii : INTEGER = 127
First_printable : INTEGER = 32; Last_printable : INTEGER = 126
Letter_layout : INTEGER = 70
Case_diff : INTEGER = 32
-- Lower_a – Upper_a
…
Ctrl_a : INTEGER = 1; Soh: INTEGER = 1
Ctrl_b : INTEGER = 2; Stx: INTEGER = 2
…
Blank : INTEGER = 32; Sp: INTEGER = 32
Exclamation : INTEGER = 33; Doublequote : INTEGER = 34
…
…
Upper_a : INTEGER = 65; Upper_b : INTEGER = 66
…
Lower_a : INTEGER = 97; Lower_b : INTEGER = 98
… etc. …
end
This class is a repertoire of c onstant attribute s (142 features  in all) describing  
properties of the ASCII character set. As the description  entry states, it is meant to be  
inherited by classes needing  access to such properties.
Consider for example a lexical a nalyzer — the part of a languag e analysis system  
that is responsible for identif ying the basic elements, or tokens , of an input text; these  
tokens may be (assuming the input is a text in some programming  language) integer  
constants, identifiers , symbols and so on. One of the classes o f the system, say  
TOKENIZER , will need access to the charac ter codes, to classify the inpu t characters into  
digits, letters etc. Such a clas s will inherit t hese codes from  ASCII :
USING INHERITANCE PROPERLY  §24.9 848
class TOKENIZER  inherit ASCII feature
… Routines here may us e such features as Blank , Case_diff etc. …
end
Classes such as ASCII  have been known to raise a fe w eyebrows; befo re going into  
the methodological disc ussion of whether th ey are a proper appl ication of inheritance, we  
will look at another exampl e of facility inheritance.
Iterators
The second example will show a case in which the inherited feat ures are not just constant  
attributes (as with ASCII ) but routines of the  most general kind.
Assume that we want to provide a general mechanism to iterate o ver data structures  
of a certain kind, for example linear structures such as lists.  “Iterating” means performing  
a certain procedure, say action , on elements of such a structu re, taken in their sequential  
order. We are asked to provide a number of iteration mechanisms , including: applying  
action to all the elements; applying it to all the elements that satis fy a certain criterion  
given by a boolean-valued function test; applying it to al l the elements up to the first one  
that satisfies test, or the first one that does not satisfy this condition; and so  on. A system  
that uses the mechanism must be able to apply it to any action and test of its choice.
At first it might seem that the iterating features should belon g to the data structure  
classes themselves, such as LIST  o r  SEQUENCE ; but as an exercise invites you to  
determine for yourself this is n ot the right solution. It is pr eferable to introduce a separate  
hierarchy for iterators:
Class LINEAR_ITERATOR , the one of interest for this discussion, looks like this:Exercise E24.7, 
page 870 .
ITERATOR*
LINEAR_
ITERATOR*
BILINEAR_
ITERATOR*TREE_
ITERATOR*
§24.9   FACILITY INHERITANCE 849
note
description :
"Objects that are able to iter ate over linear structures "
names : iterators , iteration , linear_iterators , linear_iteration
deferred class  LINEAR_ITERATOR [G] inherit
ITERATOR [G]
redefine target end
feature  -- Access
invariant_value: BOOLEAN
-- The property to be maintained  by an iteration (default: true ).
do
Result := True
end
target : LINEAR [G]
-- The structure to which it eration features will apply
test: BOOLEAN
-- The boolean condition used to select applic able elements
deferred
end
feature  -- Basic operations
action
-- The action to  be applied to selected elements.
deferred
end
do_if
-- Apply action  in sequence to every item of target that satisfies test.
do
from start invariant invariant_value until exhausted loop
if test then action end
forth
end
ensure then
exhausted
end
… And so on: do_all , do_while , do_until  etc. …
end
Now assume a class that needs to  perform a certain operation on  selected elements  
of a list of some specific type; for example a command class in  a text processing system  
may need to justify all paragraphs in a document, excepted for preformated paragraphs  
(such as program texts and other display paragraphs). Then:
USING INHERITANCE PROPERLY  §24.9 850
class JUSTIFIER inherit
LINEAR_ITERATOR [P ARAGRAPH ]
rename
action as justify , 
test as justifiable ,
do_all as justify_all
end
feature
justify
do … end
justifiable
-- Is paragraph subject to justification?
do
Result  := not preformated
end
…
end
The renaming was not indispensab le but helps for  clarity. Note that there is no need  
to declare or redeclare the procedure justify_all  (the former do_all ): as inherited, it does  
the expected job based on the effected versions of action  and test.
Procedure justify , instead of being described in the class, could be inherited f rom 
another parent. In this case mul tiple inheritance would perform  a “join” operation that  
effects the deferred action , inherited from one parent under the name justify  (here the  
renaming is essential), with the effective justify inherited from the othe r parent. A form of  
marriage of convenience, in fact.
LINEAR_ITERATOR  is a remarkable example of behavior class , capturing common  
behaviors while leaving specific  components open  so that descen dants can plug in their  
specific variants.
Forms of facility inheritance
The two examples, ASCII  and LINEAR_ITERATOR , are typical of the two main variants  
of facility inheritance:
•Constant  inheritance, in which the parent  principally yields constant a ttributes and  
shared objects.
•Operation inheritance, in which it yields routines.
As noted earlier, it is possible to combine both of these varia n t s  i n  a  s i n g l e  
inheritance link. That  is why facility inher itance is one of ou r categories, not two.
Understanding facility inheritance
To some people facility inheritan ce appears to be an abuse of t he mechanism — a form of  
hacking. But that is not  necessarily the case.“Don’t call us, we’ll 
call you”, page 504 .
§24.10   MULTIPLE CRITERIA AND VIEW INHERITANCE 851
The main question to consider in  these examples is not about in heritance but about  
the classes that have been defined, ASCII  a n d  LINEAR_ITERATOR . As always when  
looking at a class design, we must ask ourselves: “Does this in deed describe a meaningful  
data abstraction?” — a set of obj ects characterized by their ab stract properties.
W i t h  t h e  e x a m p l e s  t h e  a n s w e r  i s  less obvious than with a class RECTANGLE , 
BANK_ACCOUNT  or LINKED_LIST , but it exists all the same:
•C l a s s  ASCII  represents the abstraction: “an y object that has access to the  properties  
of the ASCII character set”.
•Class LINEAR_ITERATOR  represents the abstraction: “an y object that has the ability  
to perform sequential iterations  on a linear structure”. Such o bjects tend to be of the  
“machine” kind described i n the preceding chapter.
Once these abstractions have been accepted, the inheritance lin ks do not raise any  
problem: an instance of TOKENIZER  does need “access to the  properties of the ASCII  
character set”, and an instance of JUSTIFIER  does need “the ability to perform sequential  
iterations on a linear structure ”. In fact, we could classify s uch examples of inheritance links  
under the subtype kind.  What distinguishes f acility inheritance  is the nature of the parent.
That the classes themselves are the issue, not the use of inher itance, is reinforced by  
the observation that a n application class could rely on these c lasses as a client rather than  
heir. This would make thin gs heavier, especially for ASCII : with
charset : ASCII
… 
create  charset
every use of a character code would have to be written charset   Lower_a  and the like. The  
object attached with ASCII  does not play any useful role. With LINEAR_ITERATOR  the 
same comments apply as long as a  given class needs only one kin d of iteration. If several  
are required, it becomes interes ting to create iterator objects , each with its own version of  
action  and test; then you can have as many iteration schemes as you need.
If it is appropriate to have iter ator objects, we need iterator  classes, and there is no  
reason to deny such cla sses the right to jo in the inheritance c lub.
24.10  MULTIPLE CRITERIA AND VIEW INHERITANCE
Perhaps the most difficult problem of using inheritance arises when alternative criteria are  
available to classify the abstrac tions of a certain application  area.
Classifying through multiple criteria
The traditional classifications of the natural sciences use a s ingle criterion (possibly  
involving severa l qualities) at each level: vertebrate versus i nvertebrate, leaves renewed  
each year or not, and so on. The result is what we would call s ingle inheritance hierarchies,  
whose main advantage is their great simplicity. But there are p roblems too, since nature is
definitely not single- criterion. This will be obvious to anyone  who has ever tried to take a  “Objects as 
machines”, page 751.
On iterator objects 
see exercise E15.4, page 567 .
USING INHERITANCE PROPERLY  §24.10 852
nature walk armed with a botani cal book meant to enable plant r ecognition through the  
official Linnaean criteria. Species A is deciduous and species B is not, the book says; how  
long can you afford to wait, if this is July, to find out wheth er the leaves remain? You are  
told that June will bring bright  purple flowers, but how can yo u tell in the midst of  
January? The roots of A are at mo st 7 meters deep, versus at le ast 9 for B — must you dig?
In software, when a single criterion seems too restrictive, we can use all the  
techniques of multiple and especi ally repeated inheritance that  we have learned to master  
in earlier chapters. Assume for example a class EMPLOYEE in a personnel management  
system. Assume further that we h ave two separate  criteria for c lassifying employees:
• By contract type, such as permanent vs. temporary.
• By job type, such as engineerin g, administrative, managerial.
and that both of these criteria have been recognized to lead to  valid descendant classes;  
in other words you are not engagi n g  i n  t a x o m a n i a ,  s i n c e  t h e  c l a sses that you have  
identified, such as TEMPORARY_EMPLOYEE  for the first criterion and MANAGER  for 
the second, are truly characteri zed by specific features not ap plicable to the other  
categories. What do you do?
A first attempt might introduce all the variants at the same  level:
To keep this sketched example small and the figure simple, the class names have been  
abbreviated. To go from this example to a real system we would have to apply the usual  
naming guidelines, which suggest longer and more accurate names  such as  
PERMANENT_EMPLOYEE , ENGINEERING_EMPLOYEE  and so on.
This inheritance hierarchy is not  satisfactory since widely dif ferent concepts are  
represented by classes at the same level.A messy 
classification EMPLOYEE
PERMANENT
TEMPORARYSUPERVISORY
ADMINISTRATIVEENGINEER*
§24.10   MULTIPLE CRITERIA AND VIEW INHERITANCE 853
View inheritance
If you retain the idea of using inheritance for the classificat ion used in the example under  
discussion, you should introduce an intermediate level to descr ibe the competing  
classification criteria:
Note that the name CONTRACT_EMPLOYEE does not mean “employee that has a  
contract” (as opposed to employe e s  w h o  m i g h t  n o t  h a v e  o n e ! ) ,  b u t “employee as  
characterized by his contract”. The name of the sibling class s imilarly means “employee  
as characterized by his specialty”.
That these names seem far-fetched  reflects a certain uneasiness , typical of this  
kind of inheritance. In subtype i nheritance we encountered the rule that the sets of  
instances represented by the vario us heirs to a class be disjoi nt. Here the rule does not  
apply: a permanent employee, for  example, may be an engineer to o. This means that  
such a classification is meant for  repeated inheritance: some p roper descendants of the  
classes shown in the figure will have both CONTRACT_EMPLOYEE  a n d 
SPECIALTY_EMPLOYEE  as ancestors — not directly, but for example by inheriting  
from both PERMANENT  and ENGINEER . Such classes will be r epeated descendants  
of EMPLOYEE .SPECIALTY_
EMPLOYEECONTRACT_
EMPLOYEEEMPLOYEE
PERMANENT
TEMPORARYSUPERVISORY
ADMINISTRATIVEENGINEER*
* *Classification 
through views
USING INHERITANCE PROPERLY  §24.10 854
This form of inheritance may be called view inheritance: variou s heirs of a certain  
class represent not disjoint subsets of instances (as in the su btype case) but various ways  
of classifying instances of the parent. Note that this only mak es sense if both the parent  
and the heirs are deferred classe s, that is to say, classes des cribing general categories rather  
than fully specified objects. Our first attempt at EMPLOYEE classification by views (the  
one that had all descendants at the same level) violated that r ule; the second one satisfies it.
Is view inheritance appropriate?
View inheritance is relatively fa r from the more common uses of  inheritance and is subject  
to criticism. The reader will be judge of whether to use it for  his own purposes, but in any  
case we should examin e the pros and cons.
It should be clear that — like re peated inheritance, which it r equires — view  
inheritance is not a beginner’s mechanism . The rule of prudence t hat was introduced for  
repeated inheritance holds here:  if you have less than a few mo nths’ hands-on experience  
with O-O development of signific ant projects, better stay away from view inheritance.
The alternative to view inherita nce is to choose one of the cla ssification criteria as  
primary, and use it as  the sole guide for devising the inherita nce hierarchy; to address the  
other criteria, you will use specific features. It is interesti ng to note that many modern  
zoologists and botanists use this  approach: their basic classif ication criterion is the  
reconstructed evolutionary histo ry of the genera  and species in volved. Would it that we  
always had such a single, indispu table standard t o guide us in devising software  
taxonomies.
To stick to a single primary crit erion in our example we could decide that the job type  
is the factor of principal interest, and represent the employme nt status by a feature. As a  
first attempt, the feature (in class EMPLOYEE ) could be
is_permanent : BOOLEAN
but this is dangerously constrai ning; to extend the possibiliti es, we could have
Permanent : INTEGER unique
Temporary : INTEGER unique
Contractor : INTEGER unique
…
but then we have learned to be w ary, for good reasons, of expli cit enumerations. A better  
approach is to introduce a class WORK_CONTRACT , most likely defe rred, with as many  
descendants as necessary to acco unt for specific kinds of work contract. Then we can stay  
away from loathed explicit d iscriminations of the form
if is_ permanent then  … else … end
or
§24.10   MULTIPLE CRITERIA AND VIEW INHERITANCE 855
inspect
contract_type
when Permanent then
…
when …
…
end
with their contingent of future extendibility troubles (stemmin g from their violation of just  
about every modularity principle : continuity, single choice, op en-closedness); instead, we  
will equip class WORK_CONTRACT with deferred features rep resenting contract-type-
dependent operations, which will then be effected differently i n descendants. Most of  
these features will need an argument of type EMPLOYEE , representing the employee to  
which the operation is being app lied; examples might include hire and terminate .
The resulting structure  will look like this:
This scheme, as you may have noted, is almost identical to the handle -based design  
pattern described earlier in this chapter.
Such a technique may be used in place of view inheritance. It d oes complicate the  
structure by introducing a separate hierarchy, a new attribute (here contract ) and the  
corresponding client relations. It has the advantage that the a bstractions in such a hierarchy  
are beyond question (work contract, permanent work contract); w ith the view inheritance  
solution, the abstractions are clear too but a little trickier to explain (“employee seen from the  
perspective of his work contract”, “employee seen from the pers pective of his specialty”).Multi-criteria 
classification 
through 
separate , 
client-related 
hierarchiesEMPLOYEE
SUPERVISORY
ADMINISTRATIVEENGINEER* WORK_
CONTRACT
PERMANENT_
CONTRACT*contrac
hire* 
terminate *
hire+ hire+ TEMPORARY_
CONTRACT
See “AN APPLICA-
TION: THE HAN-DLE TECHNIQUE”,24.3, page 817 .
USING INHERITANCE PROPERLY  §24.10 856
Criteria for view inheritance
It is not uncommon to think of vi ew inheritance early in the an alysis of a problem domain,  
while you are still struggling w ith the fundamental concepts an d considering several  
possible classification criteria, all of which vie for your att ention. As you improve your  
understanding of the a pplication area, it will often happen tha t one of the criteria starts to  
d o m i n a t e  t h e  o t h e r s ,  i m p o s i n g  i t s e l f  a s  t h e  p r i m a r y  g u i d e  f o r  d evising the inheritance  
structure. In such cases, the pr eceding discussion strongly sug gests that you should  
renounce view inheritan ce in favor of more straightfo rward tech niques.
I still find view inheritance useful when the following three c onditions are met:
• The various classification crit eria are equally important, so any choice of a primary  
one would be arbitrary.
• Many possible combinations (suc h as, in the earlier example, p ermanent supervisor,  
temporary engineer, permanent e ngineer and so o n) are needed.
• The classes under consideration are so important as to justify  spending significant  
time to get the best possible in heritance structure. This appli es in particular when the  
classes are part of a reusable library  with large reuse potential.
An example of application of the se criteria is the uppermost st ructure of the Base  
libraries, in the environment de scribed in the last chapter of this book. The resulting  
classes followed from an effort, described in detail in the boo k [M 1994a] , of applying  
taxonomical principles to the sys tematic classification of comp uting science’s basic  
structures, in the tradition of t he natural scientists. The hig hest part of the “container”  
structure looks like this:
A view-based 
classification of fundamental 
computing 
structuresCONTAINER*
** *
* ** * *BOXCOLLECTION TRAVERSABLE
FINITE INFINITE BAG SET
LINEAR HIERARCHI
CAL*
§24.10   MULTIPLE CRITERIA AND VIEW INHERITANCE 857
The first-level classification ( BOX , COLLECTION , TRAVERSABLE ) is view-based;  
the level below it (and many of those further below, not shown)  is a subtype classification.  
A container structure is charact erized through three criteria:
• How items will be accessed: COLLECTION . A SET makes it possible to find out  
whether an item is present, whereas a BAG  also enables the client to find out the  
number of occurrences of a given  element. Furthe r refinements i nclude such access  
abstractions as SEQUENCE  (items are accessed sequentially), STACK  (items are  
accessed in the reve rse order of their insertion) and so on.
• How items will be represented: BOX . Variants include  finite and infinite structures.  
A finite structure can be bounde d or unbounded; a bounded struc tured can be fixed  
or resizable.
• How the structure can be traversed: TRAVERSABLE .
It is interesting to note that the hierarchy did not start out as view inheritance. The  
initial idea was to define BOX , COLLECTION and TRAVERSABLE as unrelated classes,  
each at the top of a separate hierarchy; then, when describing any particular data structure  
implementation, to use multiple inheritance to pick one parent from each of the three parts.  
For example a linked list is fin ite and unbounded (representati on), sequentially accessed  
(access), and lin early traversable  (traversal):  
But then we realized that it  was inappropriate to keep BOX , COLLECTION and 
TRAVERSABLE  separate: they all needed a few  c o m m o n  f e a t u r e s ,  i n  p a r t i c u l a r  has
(membership test) and empty (test for no elements). This clearly indicated the need for a  
common ancestor — CONTAINER , where these common features now appear. Hence a  
structure that was initially des igned as pure mu ltiple inherita nce, with three disjoint  Building a data 
structure class 
by combination 
of abstractions through 
multiple 
inheritance** * BOX COLLECTION TRAVERSABLE
Representation  
hierarchyAccess  
hierarchyTraversal  
hierarchy
USING INHERITANCE PROPERLY  §24.11 858
hierarchies at the top, turned o ut to be a view inheritance hie rarchy with a considerable  
amount of repeated inheritance.
Although initially difficult to g et right, this structure has t urned out to be useful,  
flexible and stable, confirming b oth of the conclusions of this  discussion: that view  
inheritance is not for the faint  of heart; and that when applic able it can play a key role for  
complex problem domains where ma ny criteria interact — if the e ffort is justified, as in a  
fundamental libra ry of reusable component s, which simply has to  be done right.
24.11  HOW TO DEVELOP INHERITANCE STRUCTURES
When you read a book or  pedagogical article on the object-orien ted method, or when you  
discover a class library, the inh eritance hierarchies that you see have already been  
designed, and the author does not always tell you how they got to be that way. How then  
do you go about designin g your own structures?
Specialization and abstraction
V oluntarily or not, ma ny pedagogical present ations tend to crea te the impression that  
inheritance structures should be designed from the most general  (the upper part) to the  
most specific (the leaves). This  is in part because this is oft en the best way to describe  a 
good structure once it exists: from the general to the particul ar; from the figures to the  
closed figures to the polygons to the rectangles to the squares . But the best way to describe  
a structure is not neces sarily the best way to produce  it.
A similar comment, due to Michael Jackson, was mentioned in the  discussion of top-
down design.
In an ideal world populated with p erfect people, we would alway s recognize the  
proper abstractions right away, a nd then draw the  categories, t heir subcategories and so  
on. In the real world, however, we often see a specific case be fore we discover the general  
abstraction of which it is but a variant.
In many cases the abstraction is not unique; how best to genera lize a certain notion  
depends on what you or your clien ts will most likely want to do  with the notion and its  
variants. Consider for example a  notion that we have often enco untered in earlier  
discussion: points in a two-dime nsional space. At least four ge neralizations are possible:
• Points in arbitrary-dimension s pace — leading to  an inheritanc e structure where the  
sisters of class POINT will be classes POINT_3D  and so on.
• Geometrical figures — the other classes in the structure being  the likes of FIGURE , 
RECTANGLE , CIRCLE and so on.
• Polygons — with oth er classes such as QUADRANGLE (four vertices), TRIANGLE
(three vertices) and SEGMENT  (two vertices), POINT  being the special polygon  
with just one vertex.
• Objects that are entirely deter mined by two coordinates — the other conten ders here  
being COMPLEX and VECTOR_2D .Some of the material 
in this section is from [M 1995].
See “Production 
and description”, page 114 .
§24.11   HOW TO DEVELOP INHERITANCE STRUCTURES 859
Although some of these generaliz ations may intuitively be more appealing than  
others, it is impossib le to say in the absolute which one of th em is the best. The answer  
will depend on how your software base evolves and what it will need. So a prudent process  
in which you sometimes abstract a bit too late, because you wai ted until you were sure that  
you had found the most useful pa th of generalization, may be pr eferable to one in which  
you might get too much untes ted abstraction too soon.
The arbitrariness of classifications
The POINT  example is typical. When presented with two competing classifi cations of a  
certain set of abstractions, you will often be able to determin e, based on rational  
arguments, which one is better ; but seldom is one in a positi on to determine that a certain  
inheritance structure is the best possible one.
T h i s  s i t u a t i o n  i s  n o t  s p e c i f i c  t o  s o f t w a r e .  D o  n o t  b e l i e v e  f o r  example that the  
Linnaean classifications of natu ral science are universally acc epted or eternal. The  
maintainers of the “Tree of Life ” Internet archive mentioned ea rlier (see also the  
bibliographical notes) state at the outset that the project’s c lassification — however  
collaborative and interdisciplin ary — is controversial. And thi s is not just for weird  
smallish creatures too viscous t o be discussed a t lunch; Dr. Everham’s Web classification  
of birds cited earlier c omes with the comment 
There are 174 Families , 2044 Genera and 9021 species of bi rds in the world ! The 
most abundant species are in the order Passeriform es with 5276 species . The least  
number of species in an order is 1 : the Ostrich in Struthioniformes . (I would have  
thought the Ostrich would be in an order with the Emus , Kiwis and Moas , all 
extinct , because they all are flightless with stout legs and longish necks .) The 
Linnaeus system groups organisms based on morpholo gical similarities . Another  
classification of animals is ba sed on DNA-DNA hybridization . This is highly  
complex ; for example an American Cuckoo would be classified as : Kingdom ,
Animalia ; Phylum , Chordata ; Class , Aves ; Subclass , Neornithes ; Infraclass ,
Neoaves ; Parvclass , Passerae ; Superorder , Cuculimorphae ; Order ,
Cuculiformes ; Infraorder , Cuculides ; Parvorder , Coccyzida ; Family , Coccyzidae .
This shows the competition between two systems: the traditional  one, based on  
morphology (and evolution); and a more inductive one based on D NA analysis. They lead  
to radically different results. Also note, as an aside, that he re we see a zoologist who does  
think that flightlessn ess should be a significant taxonomical c riterion — but the official  
classification disagrees.
Induction and deduction
To design software hierarchies, the proper process is a combina tion of the deductive and  
the inductive, of specialization and generalization: sometimes you see the abstraction first  
and then infer the special cases ; sometimes you first build or find a useful class and then  
realize that there is a more a bstract underl ying concept.See page 842 . Bib-
liographic refer-ences removed .
More on competing 
classification meth-ods at the end of this chapter.
USING INHERITANCE PROPERLY  §24.11 860
I f  y o u  f i n d  y o u r s e l f  n o t  a l w a y s  u s i n g  t h e  f i r s t  s c h e m e ,  b u t  o n c e  i n  a  w h i l e  
discovering the abstract only afte r you have seen the concrete,  maybe there is nothing  
wrong with you . You are simply using a normal “yoyo” approach to classificati on.
As you accumulate experience an d insight, you should find that the share of (correct)  
a priori decisions gro ws. But an a posterior i component will al ways remain.
Varieties of class abstraction
This principle of Re version is the most  wonderful of all  
the attributes of inheritance.
Charles Darwin
Two forms of a posteriori parent  construction are common and us eful.
Abstracting  is the late recognition of a higher-level concept. You find a class B which  
covers a useful notion, but whose developer did not recognize t hat it was actually a special  
case of a more general notion A, justifying an inheritance link:
That this insight was initially missed — that is to say, that B was built without A — 
is not a reason to renounce the use of inheritance in this case . Once you recognize the need  
for A, you can, and in most cases sho uld, write this class and adapt  B to become one of its  
heirs. It is not as good as having written A earlier, but better than  not writing it at all.
Factoring  is the case in which you detect that two classes E and F actually represent  
variants of the same general notion:
If you recognize this commonality  belatedly, the generalization  step will enable you  
to add a common parent class D. Here again it would have been preferable to get the  
hierarchy right the fi rst time around, but l ate is better than never.Abstraction
A
B
Factoring D
E F
§24.11   HOW TO DEVELOP INHERITANCE STRUCTURES 861
Client independence
Abstracting and factoring may in  many cases proceed without neg ative effects on the  
existing clients (an application of the Open-Closed principle).
This property results from the me thod’s use of information hidi ng. Consider again  
the preceding schematic cases, but  with a typical client class X added to the picture:
When B gets abstracted into A, or the features of E get factored with those of F into 
D, a class X that is a client of B or E (in the figure it is a client of both) will in many cases  
not feel any effect from the change. The ancestry of a class do es not affect its clients if  
they are simply applying the fea tures of the class on entities of the corresponding type. In  
other words, if X uses B and E as suppliers  under the scheme
b1: B; e1: E
…
b1  some_feature_of_B
…
e1  some_feature_of_E
then X is unaffected by any re-parenting of B or E arising from abstract ing or factoring.
Elevating the level of abstraction
Abstracting and factoring are ty p i c a l  o f  t h e  p r o c e s s  o f  c o n t i n u ous improvement that  
characterizes a successful obj ect-oriented soft ware constructio n process. In my  
experience this is one of the mo st elating aspects of practicin g the method: knowing that  
even though you are not expected to reach perfec tion the first time around, you are given  
the opportunity to improve your d esign continually, until it sa tisfies everyone.
In a development group  that applies the met hod well, this regul ar elevation of the  
level of abstraction  of the software, and as a corol lary of its quali ty, is clearly  perceptible  
to the project members , and serves as consta nt incentive and mo tivation.Abstraction , 
factoring and 
clientsD
E FA
B X
USING INHERITANCE PROPERLY  §24.12 862
24.12  A SUMMARY VIEW: USING INHERITANCE WELL
Inheritance will never cease to surprise us with its power and versatility. In this chapter we  
have tried to get a better handle at what inheritance really me ans and how we can use it to  
our best advantage. A few central conclusions have emerged.
First, we should not be  afraid of the varie ty of ways in which we can use inheritance.  
Prohibiting multiple inheritance or facility inheritance achiev es no other aim than to hurt  
ourselves. The mechanisms are th ere to help you: use them well,  but use them. 
Next, inheritance is for the most part a supplier ’s technique. It is one weapon in our  
arsenal of techn iques for fighting our a dversaries (in particul ar complexity, the software  
developer’s relentless foe). Inheritance may matter to client  software as well, especially in  
the case of libraries,  but its main goal is to help us building  the thing in the first place.
Of course, all software is designed for its clients, and the cl ients’ needs drive the  
p r o c e s s .  A  s e t  o f  c l a s s e s  i s  g o o d  i f  i t  w i l l  o f f e r  e x c e l l e n t  s e rvice to client software:  
interfaces and associated implementations that are complete, fr ee from bad surprises (such  
as unexpected performance penalties), simple to use, easy to le arn, easy to remember,  
extendible. To achieve these goa ls, the designer is free to use  inheritance and other object-
oriented techniques in any way he pleases.The end justifies the  means.
Also remember, when de signing an inheritance  structure, that th e goal is software  
construction, not philosophy. Se ldom is there a single solution , or even a best one in the  
absolute. “Best” means best for the purposes of a certain class  of client applications. This  
is particularly true as we move away from areas such as mathema tics and fundamental  
computing science, where a widel y accepted body of theory exist s, towards business-
driven application domains. To find out what class hierarchy be st addresses the notion of  
company share, you pro bably need to know whether the software c aters to individual  
investors, to a public ly traded company, t o a stock broker, or to the Stock Exchange.
In a way, this is comforting. The naturalist who classifies a c ertain set of plants and  
animals must devise absolute categories. In software the equiva lent only happens if you  
a r e  i n  t h e  b u s i n e s s  o f  p r o d u c i n g  g e n e r a l - p u r p o s e  l i b r a r i e s  ( s u c h as those covering  
fundamental data struct ures, graphics, data bases). Most of the time, your aims will be  
more modest. You wil l need to design a good  hierarchy, one that will  satisfy the needs of  
a certain kind of c lient software.
The final lesson of this chapter  generalizes a comment made in the discussion of  
facility inheritance: the princ ipal difficulty of building clas s structures is not inheritance  
per se; it is the search for abstractions. If you have identifi ed valid abstractions, their  
inheritance structure will follow. To find the abstractions, th e guide you will use is the  
guide that we follow throughout t his book: the theory of abstra ct data types.
§24.13   KEY CONCEPTS INTRODUCED IN THIS CHAPTER 863
24.13  KEY CONCEPTS INTRODUCED IN THIS CHAPTER
• Every use of inheritance should  reflect some form of “is” rela tion between two  
categories of object, e ither in an external  modeled domain or i n the software itself.
• Do not use inheritance to model  a “has this kind of component”  relation; this is the  
province of the client  relation. (Remember CAR_OWNER .)
• When inheritance is applicable,  c l i e n t  i s  o f t e n  p o t e n t i a l l y  a p p l i c a b l e  t o o .  I f  t h e  
corresponding view can change, use the clie nt relation; if you foresee polymorphic  
uses, use inheritance.
• Do not introduce intermediate inheritance nodes unless they de s c r i b e  a  w e l l -
identified abstractio n, characterized by specific features.
• A classification of inheritance was defined, based on twelve k inds divided into three  
general categories: mo del inheritance (descr ibing relations exi sting in the modeled  
domain), software inheritance (d escribing relations in the soft ware itself), and  
variation inheritance (for class  adaptation in either the model  or the software).
• The power of inheritance comes from its combination of a type specialization and a  
module extension mechanism. It se ems neither wise  n o r  u s e f u l  t o  u s e  d i f f e r e n t  
language mechanisms.
• Implementation and facility inhe ritance require some care but can be powerful  
supplier-side techniques.
• View inheritance, a delicate t echnique involving repeated inhe ritance, allows  
classifying object types along several competing criteria. It i s useful for professional  
libraries. In many cas es a simpler handle technique is preferab le.
• Although not theoretically ideal , the actual process of design ing inheritance  
hierarchies is often yoyo-like — from the abstract to the concr ete and back.
• Inheritance is primaril y a supplier technique.
24.14  BIBLIOGRAPHICAL NOTES
The principal reference on th e taxonomy of inheritance is [Girod 1991] . A book on O-O  
methodology [Page-Jones 1995] , one of a very small number that provide useful  
methodological advice on object-o riented design, includes preci ous advice on uses and  
misuses of inheritance. Another useful reference is [McGregor 1992] ; John McGregor has  
particularly explored t he technique called view inheritance in this chapter.
[Breu 1995]  also provides interesting conce pts, based on a view of proper  
inheritance usage more restrictiv e than the one i n this chapter . 
A technique similar to  this chapter’s “handl es” is described in  [Gil 1994] .
The preparation of this chapter benefited from the comments of several biologists  
who maintain Web-accessible reso urces on the taxonomy of living  beings, in particular:  
the “tree of life” at the University of Arizona ( phylogeny .arizona .edu/tree/life.html),  
courtesy of Professors David Ma ddison and, for birds, Michel La urin (the latter from  
Berkeley). Professor Edwin Everham from Radford Univers ity was also very helpful.
General references on the th eory of classification, or systematics , appear at the end  
of the next section.
USING INHERITANCE PROPERLY  §24.15 864
24.15  APPENDIX: A HISTORY OF TAXONOMY
This Appendix is supplementary material, not used in the rest o f this book. The study of  
taxonomic efforts in other disciplines is full of potential les sons for us object-oriented software  
developers. I hope to spur further  interest in this fascinating  area — possibly a topic for an inter-
disciplinary Master’s or Ph. D. thesis.
From Aristotle to Darwin
The classification of species began at least as early as Aristo tle (384-322 B.C.E.), whose  
taxonomy of animals, Historia Animalium , continued for plants under the title Historia  
Plantarum by his student Theophrastus of Eresos (ca. 370-288 B.C.E.), was  accepted as definitive  
for many centuries. Aristotle’s criteria for classifying animal s include both how they reproduce  
and where they live; from a modern viewpoint, only the first wo uld be considered relevant, as we  
have come to accept that regardless of habitat considerations a  dolphin is closer to a llama than to  
a shark. Theophrastus’s classification was more systematically structural. Modern botanical  
terminology comes largely from Aristotle and Theophrastus throu gh the Latin translation of the  
latter’s terms in the Natural History of Pliny the Elder (23-79 C.E.) (Pliny was well aware of the  
need to avoid being misled by appearances: “ It was the plan  [of some Greek naturalists]  to 
delineate the various plants in colors , and then to add in writing a description of the properties  
which they possessed . Pictures , however , are very apt to mislead ; … besides , it is not sufficient to  
delineate a plant as it appears at one period only , as it presents a different appearance at each of  
the four seasons of the year .”) A later important contributor  was Dioscorides of Anazarbus (1st 
century C.E.), Nero’s doctor, who classified plants according t o their medicinal properties.
Several scholars took up the work  at the time of the Renaissanc e, in particular Conrad  
Gessner, who was to influence Linné and Cuvier through his Opera Botanica and Historia  
Plantarum  (1541-1571), distinguishing genus from species and order from class, and Caspar  
Bauhin, who devised a binomial sy stem for the classification of  plants in his Pinax (1596). In the  
next century, John Ray (1628-1705) removed some of the arbitrar iness of prevailing  
classifications by taking into account several properties of pl ants’ morphology, rather than just  
one feature. He established the basic division of flowering pla nts into monocots and dicots  
(foreseen by Theophrastus). That division, still in use today, is another example of the fuzziness  
of even some of the fundamental classification criteria of biol ogy; the UC Berkeley Museum of  
Paleontology (see the bibliographi cal references at the end of this section) gives a list of seven  
factors distinguishing monocots from dicots — one vs. two cotyledons in the embryo, flower parts  
in multiples of three vs. multiples of four or five, etc. — but adds that no single fac tor in that list  
will infallibly identify a given flowering plant as a monocot o r dicot.
Only in the eighteenth century, with the development of biology  as a science and the fast  
growth in known species, did the pr oblem of biological classifi cation start to acquire a character  
of urgency. Whereas Theophrastus had identified five hundred pl ant species, Bauhin knew six  
thousand, and Linnaeus catalogued eighteen thousand; less than a century later Cuvier listed over  
fifty thousand! The philosopher-scientists of the Age of Enligh tenment, aroused by Newton’s  
classification of heavenly bodies in his Principia Mathematica  (1687), were not content any more  
to list the species, but started to look for meaningful princip les of grouping them into categories  
— for the proper abstraction mechanisms, as we software people would say. The roots of modern  
taxonomy can be traced to that collective effort of the early m odern era.
The key contributor was the Swedish botanist Carl Linné (1701-1 778), also known by the  
Latin name Carolus Linnaeus, who in 1737 published his taxonomi c system, still the basis of all  
taxonomic systems used today. One  of his major innovations, was  — using software engineering  
§24.15   APPENDIX: A HISTORY OF TAXONOMY 865
terminology again — to discard the top-down  approach used by previous taxonomists (who  
posited basic abstract categories and successively divided them  into smaller groups) in favor of a  
bottom-up  approach, well in line with the emphasis on pragmatism and exp erimentation that  
marked the beginnings of the scientific method; he started from  the species themselves and  
grouped them into categories. 
Both Ray and Linné were in search of a “natural system”, that i s  t o  s a y  a n  i d e a l  
classification that would reveal divine intentions.
Progress between Linné and Darwin  was largely due to an astonis hing succession of  
naturalists at the Paris Jardin des Plantes :
• Georges-Louis de Buffon (1707-1788) wrote the magnificent 44-v olume Histoire  
Naturelle , bold enough to suggest a common anc estry for humans and apes.
• Antoine-Laurent de Jussieu (1748-1836) looked for a more natur al and comprehensive  
system of plant classification than Linné’s. Modern taxonomies of plants actually follow  
from Jussieu’s work, itself base d on Ray’s. (Although modern cl assification systems are  
based on Linné’s ideas, his act ual taxonomy has largely been di scarded — initially in part  
because of moral reasons, since he  gave such importance to sexu al features.)
• Jean-Baptiste Lamarck (1744-1829), whose theory of evolution a nnounced Darwin’s,  
published his Flore française  in 1778 and almost single-handedly originated the  
classification of “invertebrate s”, a term he coined. In his Histoire naturelle des Animaux  
sans Vertèbres  he was the first to separate th e crustaceans from the insects.
• Georges Cuvier (1769-1832) did for vertebrates what Lamarck di d for invertebrates. He  
was famous for his ability to reconstruct complete organisms fr om fossil fragments. He  
classified animals  into four branches.
• Étienne Geoffroy Saint-Hilaire (1772-1844), another great taxo nomist, was the adversary  
of Cuvier (whom he had brought to Paris) in a famous public deb ate about unity vs. diversity  
of life forms. The dispute reflected deeper questions: evolutio nary vs. fixed views of  
species, and the issue, still open today, of formalism vs. functionalism. When we see Cuvier  
writing “ If there are resemblances between the organs of fishes and those of the other  
vertebrate classes, it is only insofar as there are resemblances between their functions ” in 
1828, and Geoffroy responding “ Animals have no habits but those that result from the  
structure of their organs ” in 1829, it is hard for a software professional to avoid thin king 
“abstract data type” and “implementation”.
The next revolution in taxonomi cal thought came with Charles Da rwin (1809-1882), whose  
Origin of Species (1859) suggested a simple basis for taxonomy: use evolutionary history. The  
classification of organisms acco rding to their origin in evolut ion is known as cladistics . For some  
biologists, this is the only criterion. The Berkeley Mus eum of Paleontology again:
For many years , since even before Darwin , it has been popular to tell “stories” about  
how certain traits of organisms came to be . With cladistics , it is possible to determine  
whether these stories have merit , or whether they should be abandoned in favor of a  
competing hypothesis . For instance , it was long said that the orb-weaving spiders , with 
their intricate and orderly webs , had evolved from spiders with cobweb-like webs . The 
cladistic analysis of these spiders showed that , in fact , orb-weaving was the primitive  
state, and that cobweb-weaving had evolved from spiders with more orderly webs .
Biologists who use to this single, unimpeachable criterion, are  in a way more fortunate than  
us poor software modelers: they c an assume, or pretend, that th ere is a single taxonomical truth,  
and that the only problem is to reconstruct it. (In other words  they have fulfilled Ray’s, Linné’s  
and Jussieu’s quest for a single Natural System.) In software m odeling we cannot postulate, let  
alone discover, such an underlying truth.
USING INHERITANCE PROPERLY  §24.15 866
The modern scene
You would think that biological taxonomy, with its long and pre stigious history, from Aristotle to  
Darwin and Huxley, would by now be a sedate field. Think again.  Since the sixties, controversy  
has been raging. There are three  main schools, the ardor of who se debates will seem thoroughly  
familiar to anyone who has heard software engineers debate thei r favorite programming  
languages. Here is — after the taxonomy of taxonomy which occup ied our efforts at the beginning  
of this chapter — the taxonomy of taxonomists:
• The numerical pheneticists draw their classifications from the study of organisms’  
individual characters, using numer ical measures of distance (an d relying generously on  
computer algorithms) to group organisms that have the most char acters in common. Sokal  
and Sneath are recognized as th e founders of this approach.
• The cladists  use evolutionary history as the sole criterion. The Berkeley e xtract reflected  
this view (more details below). Cladistics draws its inspiratio n from work by the German  
scientist Willi Hennig, fir st published in German in 1950 and i n English in 1965.
• The evolutionary taxonomists , led by G.G. Simpson and Ernst Mayr, who claim Darwin’s  
direct heritage, “ base [their] classifications on observed similarities and differences among  
groups of organisms, evaluated in the light of their inferred evolutionary history ” (as stated  
by Mayr, 1981, reference below).
It is next to impossible to find neutral accounts of the argume nts for each approach in the  
literature. (Perhaps this sounds familiar.) It falls on the out sider to try to develop an impartial  
view. In this brief survey we w ill try to remain as close as po ssible to the software analogies.
Numerical phenetics — what we would call the bottom-up approach  — has the advantage  
of being based on precise, repeat able measures. But the choice of measured characters and their  
weighting is subjective. And a pur ely external measure risks be ing influenced by chance factors;  
it is well known since Darwin tha t evolution involves not only divergence (species evolving from  
a common ancestor by developing different characters) but conve rgence (completely distinct  
species developing similar features to adapt to similar environ ments or by sheer coincidence). So  
there is a great danger of arbitrariness. One can also fear ins tability: the discovery of new species  
— which occurs all the time in biology — could, more than with the other approaches, put into  
question classifications drawn fro m the statistical analysis of  the previously known species.
On the surface the other two schools would seem to be very clos e to each other. Why then  
do they keep arguing with each other from their respective jour nals and conferences? The reason  
is that the cladists are particularly rigorous, as they would s ee it, or dogmatic, as the other two  
schools might put it. They take evolution, and evolution only, as the classification criterion. The  
method is particularly strict: i t examines the evolutionary his tory, as given by the fossil record,  
and decides which characters are synapomorhic and which ones plesiomorphic . A feature is  
plesiomorphic if it was already present in a common ancestor; t hen for the cladist it is not  
interesting at all! The useful features as the synapomorphic on es, which hold for two organisms  
but not their ancestors. Synapomorphies are the primary tool fo r positing new groups ( taxa, the 
plural of taxon ). 
In the following situation, then, t he cladists will see only tw o taxa:
§24.15   APPENDIX: A HISTORY OF TAXONOMY 867
This is a cladogram , or record of the appearance of characters in the evolutionary  history.  
The marks indicate new characters. B and C have a synapomorphy, character b, which was not in  
the ancestor and is not in A; so for a cladist B and C will form a taxon, and A another. For an  
evolutionary taxonomist, there would be three taxa, since C differs from B in many other  
characters ( c to h). In its pure form cladistics is even more restrictive: like R oman Jakobson’s  
phonology, it only considers binary  characters; and it posits that when taxa evolve from a  
common ancestor the ancestor disappears.
Evolutionary taxonomy seems a more moderate approach, trying to  draw from both  
cladistics and phenetics: evoluti on is the classification basis , but complemented by analysis of  
other characters, not necessarily synapomorphic.
Why then the restrictiveness of c ladistics? The principal argum ent is epistemological: an  
attempt to satisfy Karl Popper’s rules of falsifiability. Cladi sts argue that their approach is the  
only non-circular one; whereas the other two more or less assum e (according to this view)  
what they are trying to deduce, a cladistic hypothesis can be r efuted, in the same way that a  
single experiment can disprove a theory of physics, although no  amount of experimentation  
will prove  a theory.
The debate between these approaches is not closed. The progress  of molecular biology will  
certainly affect it; in particular, by providing a link between  observed characters and the  
evolutionary record, it may help achieve some reconciliation be tween phenetics and the other  
two methods.
We will stop here, with regret (more mundane software engineeri ng topics are claiming our  
attention). For an O-O software developer, reading the taxonomy  literature, although requiring a  
fair deal of attention in some cases (“ A phylogenetic definition of homology may be considered  
more falsifiable than a phenetic definition and th erefore preferable if it leads to a hypothesis of  
homology which includes all the potential falsifiers  provided by phenetic comparisons as well as  
the potential falsifiers provided by phylogeny …”) is rich in rewards. O ur own work constantly  
subjects us, like our friends fro m the Biology department or th e Herbarium, to two siren songs  
from opposite sides: the a priori form of classification, top-d own, deductive and based on a  
“natural” order of things, coming to us through the cladists fr om Linné; and the empirical,  
inductive, bottom-up view of the pheneticists, telling us to ob serve and gather. Perhaps, like the  
evolutionary taxonomists, we will want a bit of both.b
c
d
e
f
g
hbaiA
B
CEvolutionary timeA cladogram
After Mayr, 1961.
USING INHERITANCE PROPERLY  §24.15 868
Bibliography on taxonomy
The following references — which have been separated from the m ain bibliography of this book  
to avoid too much mélange des genres — will be useful as a starting point on the subject of  
taxonomy history:
• The on-line material on evolution at the University of Califor nia Museum of Paleontology  
in Berkeley: http://www.ucmp.berkel ey.edu/clad/clad4.html  (authors: Allen G. Collins,  
Robert Guralnick, Brian R. Speer). Resolutely cladist. Some of the above presentation  
draws from the UCMP pages and from suggestions by their authors .
• A biography of Jussieu: Antoine-Laurent de Jussieu , Nature and the Natural System by 
Peter F. Stevens, Columbia University Press, New York, 1994. (I  am grateful to Prof.  
Stevens for several important suggestions.)
• A collection of pape rs on cladistics: Cladistic Theory and Methodology , edited by Thomas  
Duncan and Tod F. Stuessy, Van Nostrand Reinhold, 1985. Quite c ladist, but the end of the  
volume adds some interesting cr itical articles, one in particul ar by Ernst Mayr ( Cladistic  
analysis or cladistic classifications ?, pages 304-308, originally in Zeitung Zool. Syst.  
Evolut.-Forsch. , 19:94-128, 1974).
• Another volume of contributions: Prospects in Systematics , ed. D.L. Hawksworth,  
Systematics Association, Clarendon Press, Oxford, 1988.
• A textbook: Biological Systematics  by Herbert H. Ross, Addison-Wesley, Reading  
(Mass.), 1973.
• The founding book of cladistics: Phylogenetic Systematics  by Willi Hennig, English  
translation, University of Illi nois Press, Urbana (Ill.), 1966.  See also a shorter presentation  
by Hennig (adapted from his original 1950 article) in Duncan an d Stuessy.
• A cladistic treatise, starti ng with the picture of Hennig: Phylogenetics — The Theory  
and Practice of Phylogenetic Systematics  by E.O. Wiley, published by John Wiley and  
Sons, New York, 1981. By the same author, a Popperian argument for cladistics, Karl 
R. Popper, Systematics, and Classifica tion: A Reply to Walter Bock and Other  
Evolutionary Taxonomists , pages 37-47 of Duncan and Stuessy, originally in Syst. Zool  
24:233-243, 1975.
• A clear article by Ernst Mayr, leaning to evolutionary taxonom y but discussing the other  
approaches with some sympathy: Biological Classification:  Towards a Synthesis of  
Opposing Methodologies , in Science , vol. 214, 1961, pages 510-516.
• The foundational text of the pheneticists: Principles of Numerical Taxonomy , by Robert  
P. Sokal and Peter H.A. Sneath, Freeman Publishing, San Francis co, 1963, revised  
edition 1973.
• A short and more recent book advocating Transformed Cladistics  (subtitle: Taxonomy and  
Evolution ) by N.R. Scott-Ram, Cambr idge University Press, 1990.
§E24.1   EXERCISES 869
EXERCISES
E24.1  Arrayed stacks
Write in full the STACK  class and its heir ARRAYED_STACK  sketched in this chapter,  
using the “marriage of c onvenience” technique.
E24.2  Meta-taxonomy
Imagine this chapter’s classific ation of the forms of inheritan ce were an inheritance  
hierarchy. What kind or kinds would it involve?
E24.3  The stacks of Hanoï
(This exercise comes from an exa mple used by Philippe Drix on t he French GUE  
electronic mailing list, lat e 1995 and early 1996.)
Assume a deferred class STACK  with a procedure put to push an element onto the  
top, with a precondition involvi ng the boolean-valued function full (which could also be  
called extendible ; as you study the exercise you will note that the choice of na me may  
affect the appeal of var ious possible solutions).
Now consider the famou s problem of the Tower s of Hanoï, where d isks are stacked  
on piles — the towers — with the rule that a disk may only be p ut on a larger disk.
Is it appropriate to define the class HANOÏ_STACK , representing such piles, as an heir  
to STACK ? If so, how should the class be written? If not, can HANOÏ_STACK still make use  
of STACK ? Write the class in full for th e various possible solutions; d iscuss the pros and  
cons of each, state which one yo u prefer, and explain the ratio nale for your choice.
E24.4  Are polygons lists?
The implementation of our firs t inheritance example, class POLYGON , uses a linked list  
attribute vertices to represent the vertices  of a polygon. Should POLYGON  instead inherit  
from LINKED_LIST [POINT ]?
E24.5  Functional variation inheritance
Provide one or more exa mples of funct ional variation inheritanc e. For each of them,  
discuss whether they are legitim ate applications of the Open-Cl osed principle or examples  
of what the discussion cal led “organized hacking”.
E24.6  Classification examples
For each of the follo wing cases, indicate w hich one of the inhe ritance kinds applies:
•SEGMENT  from OPEN_FIGURE .
•COMP ARABLE  (objects equipped with a total order relation) inheriting from  
PA R T _ CO MPA R A B L E  (objects with a partial order relation).
•Some class from EXCEPTIONS .See “General taxon-
omy”, page 824 .
The Towers of Hanoï 
problem , used in 
many computing sci-ence texts as an exam-ple of recursive procedure , comes 
from Édouard Lucas , 
“Récréations Mathématiques” , 
Paris , 1883 , reprinted 
by Albert Blanchard , 
Paris , 1975 .
“POLYGONS AND 
RECTANGLES”, 14.1, page 460 .
“ADVANCED EXCEP-
TION HANDLING”, 12.6, page 431 .
USING INHERITANCE PROPERLY  §E24.7 870
E24.7  Where do iterators belong?
Would it be a good idea to have iterator features ( while_do  and the like) included in  
classes describing the data structures on which they iterate, s uch as LIST  ? Consider the  
following points:
• The ease of applying it erations to arbitrary action  and test routines, chosen by the  
application.
• Extendibility: the possibility of adding new iteration schemes  to the library.
• More generally, respect of objec t-oriented principles, in part i c u l a r  t h e  i d e a  t h a t  
operations do not exist by thems elves but only in relation to c ertain data ab stractions.
E24.8  Module and type inheritance
A s s u m e  w e  d e v i s e  a  l a n g u a g e  w i t h  t w o  k i n d s  o f  i n h e r i t a n c e :  m o d u le extension and  
subtyping. Where would each of t he inheritance k inds identified  in this chapter fit?
E24.9  Inheritance and polymorphism
Of the kinds of inheritance reviewed in this chapter between a parent A and an heir B, 
which ones do you expec t in practice to be used for polymorphic  attachment, that is to say  
assignments x := y or the corresponding argument passing with x of type A and y of type B?
25  
Useful techniques
E xamples of object-oriented desig n given in prece ding chapters h ave illustrated a  
number of distinctive techniques . Although we are  not done yet w i t h  o u r  r e v i e w  o f  
methodological issues — we must still explore style rules, O-O analysis concepts,  
teaching methods, and the software process — it is time to paus e briefly to recapitulate  
some of the principal O-O tech niques that we have learned.
This will be the tersest chapter of all: it just enumerates fru itful ideas, followed in a  
few cases by keywords meant to r emind you of some of the exampl es in which we first  
encountered the ideas.
25.1  DESIGN PHILOSOPHY 
General development scheme
Bottom-up development:  build a solid basis , then apply it to sp ecific cases.
Seamlessness: apply co nsistent techn iques and tools to analysis , design, implementation,  
maintenance.
Reversibility: let the functiona l specification benefit from th e lessons of implementation.
Generalization: from specialized cla sses, derive reusable ones.  Abstraction, factoring out  
commonalities.
The structure of systems
Systems are made of classes only.
The development style is bottom- up. Whenever possible, start fr om what you have.
Try to make classes as general  as possible from the start.
Try to make classes as autonomous as possible.
Two inter-class relations: client (with “reference client” and “expanded client” variants);  
inheritance. Roughly corres pond to “has” and “is”.
Use multi-layer architectures to  separate abstract interface fr om implementations for  
various platforms: Vision, WEL/PEL/MEL.Chapter 28 discusses 
seamlessness and reversibility.
USEFUL TECHNIQUES  §25.2 872
System evolution
Design for change and reuse.
When improving a desig n, use obsolete featur es and classes to f acilitate the transition.
25.2  CLASSES
Class structure
Every class should correspond to  a well-defined data abstractio n.
Shopping List approach: if a feat ure is potentially useful, and  fits in with the data  
abstraction of the class, put it in.
Facility classes: group related facilities (e.g. a set of const ants).
Active data structures (object as abstract machine).
Key decision is what features to make secret and what to export .
Use selective exports for a grou p of intimately connected class es: LINKED_LIST , 
LINKABLE .
Re-engineer non-O-O software by encapsulating abstractions into  classes (cf. Math  library).
Class documentation
Put as much information as p ossible in the class itself.
Write header comments carefully and consistently; they will be part of the official  
interface.
Note clauses.
Designing feature interfaces
Command-Query Separation principl e: a function should not produ ce any abstract side  
effect (concrete side effects are OK).
Use only operands as arguments.
Set status, then e xecute operation.
For each status-settin g command, provide a s tatus-returning que ry.
For argumentless queries, there should be no externally visible  difference between an  
attribute implementation and a function implementation.
Let an object change r epresentation silently as a result of req uested operations (example  
of complex number class).
Cursor structures ( LIST , LINKED_LIST  and many others).
§25.3   INHERITANCE TECHNIQUES 873
Using assertions
The precondition binds the clien t, the postcondition binds the supplier.
Make precondition strong enough t o enable the routine to do its  job well — but not stronger.
Two kinds of invariant clause: some clauses come from the under lying abstract  data type;  
others ( representation invariant ) describe consistency prope rties of the implementation.  
Use implementation invariant to express and improve your unders tanding of the  
relationship between the differen t constituents of the class, a ttributes in  particular.
For an argumentless query, include abstract properties in the i nvariant (even if, for a  
function, the property also ap pears in the postcondition).
Redeclarations can weaken the pr econdition to make the routine more tolerant.
To achieve the effect of strengt hening the precondition, use an  abstract precondition  
(based on a boolean func tion) in the original.
Even with no strengthe ning need, abstract pr econditions are pre ferable.
Any precondition must be enfor ceable and testable by clients.
Do not overconstrain postconditi on, to enable str engthening in a descendant (for example  
you may want to use one-way implies  rather than equality).
Dealing with special cases
A priori checking: before operat ion, check if you can apply it.
A  p o s t e r i o r i  c h e c k i n g :  t r y  o p e r a t i o n ,  t h e n  q u e r y  a n  a t t r i b u t e  ( or higher-level function  
encapsulation) to find out whether it worked.
When everything el se fails: use exce ption handling.
Organized failure: if a rescue executes to the end, do not fo rget to restore the invariant.  
The caller will get  an exception too.
Retrying: try another algorithm, or (the strategy  of hope) the same one again. Record what  
happened through an at tribute or local entity; local entities a re initialized only when the  
call starts, not after a retry .
25.3  INHERITANCE TECHNIQUES
Redeclaration
Redefining a routine to use a mo re specific algorithm, for more  efficiency: perimeter  in 
POLYGON , RECTANGLE , SQUARE .
Redefining a routine into an attribute: balance  in ACCOUNT .
Effecting a feature that w as deferred in the parent.
USEFUL TECHNIQUES  §25.3 874
Joining two or more features thr ough effecting (all but one inh erited as deferred; the  
effective one takes over). Undefi ne some effectiv e ones if need ed.
Redefining two or more effe ctive features together.
Accessing parent versi on in a redefinition: precursor .
Redeclarations preserve sema ntics (rules on assertions).
Deferred classes
Deferred classes capture high-level categories.
Deferred classes also serve as an analysis and design tool, to describe abstractions without  
commitment to an implementation.
Behavior classes: capture general behavior. Effective routines call deferred ones. Class  
w i l l  b e  p a r t i a l l y  d e f e r r e d ,  p a r t i a l l y  i m p l e m e n t e d  ( c o v e r s  p a r t i al choice of ADT  
implementation).
Polymorphism
Polymorphic data structures: thr ough inheritance and genericity , combine right amount of  
similitude and variation.
Handles: describe a va riable-type component through a polymorph ic attribute.
Dynamic binding: avoid ex plicit discrimination.
Dynamic binding on a polymorphic data structure: apply to each element of a structure an  
operation that the ele ment will apply in i ts own appropriate wa y.
For the point of single choice, pre-compute a data structure wi t h  o n e  o b j e c t  o f  e a c h  
possible type (as in t he undoing pattern).
Forms of inheritance
Make sure all uses of inheritance belong to one of the categori es in the taxonomy.
Inheritance for subtyping.
Inheritance for mo dule extension.
Marriage of convenience: impleme nt abstraction t hrough concrete  structure.
Restriction inherita nce: add constraint.
Inheriting general-purpose mech anisms from facility classes.
Functional Variation inheritance : “organized hacking”, Open-Clo sed principle.
Type Variation inheri tance: covariance.
26  
A sense of style
I mplementing the objec t-oriented method req uires paying attentio n to many details of  
style, which a less ambitious ap proach might con sider trifles.
26.1  COSMETICS MATTERS!
Although the rules appearing hereafter are not as fundamental a s the principles of object-
oriented software construction c overed in earlier chapters, it would be foolish to dismiss  
them as just “cosmetics”. Good software is good in the large and in the small, in its high-
level architecture and in its low -level details. True, quality in the details does not guarantee  
quality of the whole; but sloppiness in the details usually ind icates that something more  
serious is wrong too. (If you can not get the cosmetics right, w hy should your customers  
believe that you can master the truly difficult aspects?) A ser ious engineering process  
requires doing everything  right: the grandiose and the mundane.
So you should not neglect the re levance of such seemingly humbl e details as text  
layout and choice of names. True , it may seem surprising to mov e on, without lowering  
our level of attention, from the mathematical notion of suffici ent completeness in formal  
specifications (in the chapter on abstract data types) to wheth er a semicolon should be  
preceded by a space (in the pres ent chapter). The explanation i s simply that both issues  
deserve our care, in the same way that when you write quality O -O software both the  
design and the realization w ill require yo ur attention.
W e can take a cue from the notio n of style in its literary sens e. Although the first  
determinant of good writing is t he author’s basic ability to te l l  a  s t o r y  a n d  d e v i s e  a  
coherent structure, no text is su ccessful until everything work s: every paragraph, every  
sentence and every word.
Applying the rules in practice
Some of the rules of this chapte r can be checked or, better yet , enforced from the start by  
software tools. Tools will not do everything, however, and ther e is no substitute for care  
in writing every pie ce of the software.
A SENSE OF STYLE  §26.1 876
There is often a temptation to p ostpone the appl ication of the rules, writing things  
casually at first and thinking “I will clean up everything late r on; I do not even know how  
much of this will eventually be discarded”. This is not the rec ommended way. Once you  
get used to the rules, they do not add any significant delay to  the initial writing of the  
software; even without special t ools, it is always more costly to fix the text later than to  
write it properly from the start. And given the pressure on sof tware developers, there is  
ever a risk that you will forget or not find the time to clean things up. Then someone who  
is asked later to take up your work will waste more time than i t would have cost you to  
write the proper header comments,  devise the right feature name s, apply the proper layout.  
That someone may be you.
Terseness and explicitness
Software styles have o scillated between the terse and the verbo se. In programming  
languages, the two extremes are perhaps APL and Cobol. The cont rast between the  
Fortran-C-C++ line and the Algol - P a s c a l - A d a  t r a d i t i o n  —  n o t  j u s t the languages  
themselves, but the st yles they have bred — is almost as stark.
W h a t  m a t t e r s  f o r  u s  i s  c l a r i t y  a n d ,  m o r e  g e n e r a l l y ,  q u a l i t y .  E x treme forms of  
terseness and verbosit y can both work against these goals. Cryp t i c  C  p r o g r a m s  a r e  
unfortunately not limi ted to the famous “obfuscated C” and “Obf uscated C++” contests;  
but the almost equally famous DIVIDE DAYS BY 7 GIVING WEEKS of Cobol is a waste  
of everyone’s attention.
The style that follows from this chapter’s rules is a particula r mix of Algol-like  
explicitness (although not, it is hoped, verbosity) and telegra m-style terseness. It never  
begrudges keystrokes, even lines, when they truly help make the  software readable; for  
example, you will find rules that enjoin using clear identifier s based on full words, not  
abbreviations, as it is foolish to save a few letters by callin g a feature disp (ambiguous)  
rather than display  (clear and precise), or a class ACCNT  (unpronounceable) rather than  
ACCOUNT . There is no tax on keystrokes. But at the same time when it c omes to  
eliminating waste and unneeded redundancies the rules below are  as pitiless as the  
recommendations of a General Accounting Office Special Commissi on on Improving  
Government. They limit header comments to indispensable words, getting rid of all the  
non-essential “the” and other such amenities; they proscribe ov er-qualification of feature  
names (as in account_balance  in a class ACCOUNT , where balance  is perfectly  
sufficient); against dominant mores, they permit the grouping o f related components of a  
complex construct on a single line, as in from i := 1 invariant i <= n until i = n loop; and 
so on.
This combination of terseness an d explicitness is what you shou ld seek in your own  
texts. Do not waste space, as exaggerated size will in the end mean exaggerated  
complexity; but do not hesitate to use s pace when it is necessa ry to enhance clarity.
Also remember, if like many peop le you are concerned about how much smaller the  
text of an object-oriented implementation will be than the text  of a comparable C, Pascal,  
Ada or Fortran program, that the only interesting answer will a ppear at the level of a  
§26.1   COSMETICS MATTERS! 877
significant system or subsystem.  I f  y o u  e x p r e s s  a  b a s i c  a l g o r i t h m  —  a t  t h e  l e v e l  o f  
Quicksort, say, or Euc lid’s algorithm — in C and in the notatio n of this book , expect the  
O-O version to be at least as l arge. In many cases, if you appl y the principl es thoroughly,  
it will be larger, since it will include assertions and more ty pe information. Yet in ISE’s  
experience of looking at medium-scale systems we have sometimes  found (without being  
able to give a general law, as the circumstances vary considera bly) the object-oriented  
solution to be several times smaller. Why? This is not due to t erseness at the “micro” level  
but to systemwide application of  the architectur al techniques o f the O-O method:
• Genericity is one of the key factors. We have found C programs  t h a t  r e p e a t e d  
essentially the same C code many  times to handle different type s. With a generic  
class — or for that matter a gen eric Ada package — you immediat ely get rid of that  
redundancy. It is disturbing in this respect to see that Java, a recent O-O language  
based on C, does not su pport genericity.
• Inheritance is also fundamenta l in gathering commonalities and  removing duplications.
• Dynamic binding repla ces many complex decision structures by m uch shorter calls.
• Assertions and the associated i dea of Design by Contract avoid  redundant error  
checking, a principal source of bloat.
• The exception mech anism gets rid of some error code.
If you are concerned with source size, make sure to concentrate  on these architectural  
aspects. You should also be terse  in expressing algorithms, but  never skimp on keystrokes  
at the expense of clarity.
The role of convention
Most rules define a single permissible form, with no variants. The few exceptions include  
font use, which is governed by e xternal considerations (what lo oks good in a book may  
not be visible on overhead trans parencies), and semicolons, for  w hi ch  th er e e xi st  tw o  
opposite schools  with equally forceful a rguments (although we w ill have a f ew universal  
rules anyway). In all other cases, in line with the introductor y methodology chapter’s  
exhortations against wishy-washi ness, the rules leave about as much room to doubt as a  
past due reminder from the  Internal Revenue Service.
The rules are rooted in a careful analysis of what works and wh at works less well,  
resulting from many years of obs ervation; some of the rationale  will appear in the  
discussion. Even so, some rules may appear arbitrary at first, and indeed in a few cases the  
decision is a matter of taste, s o that reasonable persons worki ng from the same  
assumptions may disagree. If you  object to one of the recommend ed conventions, you  
should define your own, provided  you explain it in detail and d ocument it explicitly; but  
do think carefully before making  such a decision, so obvious ar e the advantages of abiding  
by a universal set of rules that  have been syste matically appli ed to thousand s of classes  
over more than ten years, and tha t many people know and underst and.
A SENSE OF STYLE  §26.1 878
As noted in an earlier chapter (in the more general context of design principles),  
many of the style rules were originally developed for libraries , and then found their way  
into ordinary software  development. In object technology, of co urse, all software is  
developed under the assumption t hat even if it is not reusable yet it might  eventually be  
made reusable, so it is  natural to apply th e same style rules r ight from the start.
Self-practice
Like the design rules of the pre ceding chapters, the style rule s which follow have been  
carefully applied to the many exa mples of this book. The reason s are obvious: one should  
practice what one preaches; and,  more fundamentally, the rules d o  s u p p o r t  c l a r i t y  o f  
thought and expression , which can only be g ood for a detailed p resentation of the object-
oriented method.
The only exceptions are a few oc casional departures from the ru les on software text  
layout. These rules do not hesit ate to spread texts over many l ines, for example by  
requiring that every assertion c lause have its own label. Lines  are not a scarce resource on  
computer screens; it has been ob served that with the computer a ge we are reversing the  
direction of the next-to-last revolution in written communicati on, the switch from papyrus  
rolls to page-structured books. But this text is definitely a b ook, structured into pages, and  
a constant application of the la yout-related rules would have m ade it even bigger than it is. 
The cases of self-dispensation a ffect only two or three layout- related rules, and will  
be noted in their presentation be low. Any exception only occurs  after the first few  
examples of a construct in the b ook have applied the rules scru pulously.
Such exceptions are only justifie d for a paper presentation. Ac tual software texts  
should apply the rules literally.
Discipline and creativity
It would be a mistake to protest against the rules of this chap ter (and others) on the grounds  
that they limit developer creati vity. A consistent style favors  rather than hampers  
creativity by channeling it to w here it matters. A large part o f the effort of producing  
software is spent reading existi ng software and making others r ead what is being written.  
Individual vagaries be nefit no one; common conventions help eve ryone.
Some of the software engineering literature of the nineteen-sev enties propounded  
the idea of “egoless programming ”: developing software so that it does not reflect  
anything of its authors’ personal ity, thereby making developers  interchangeable. Applied  
to system design, this goal is c learly undesirable, even if som e managers may sometimes  
long for it (as in this extract o f a programming management boo k quoted by Barry Boehm:  
“…the programmer [‘s] creative instincts should be totally dulled  to insure uniform and  
understandable programming” , to which Boehm comments: “Given what we know about  
programmers and their growth moti vation, such advice is a clear  recipe for disaster”).
What quality software requires is egoful design with egoless expression .The comment was in 
the introduction to chapter 23.
Sentence in italics from
D.H. Brandon , “Data 
Processing Organiza-tion and Manpower Planning” , Petrocelli , 
1974, emphasis in 
original . Quoted in 
[Boehm 1981],  p. 674.
§26.2   CHOOSING THE RIGHT NAMES 879
More than style standards, what would seem to require justifica tion is the current  
situation of software development, with its almost total lack o f style standards. In no other  
discipline that demands to be ca lled “engineering” is there suc h room for such broad  
personal variations of whim and fancy. To become more professio nal, software  
development needs to  regulate itself.
26.2  CHOOSING THE RIGHT NAMES
The first aspect that we need to  r e g u l a t e  i s  t h e  c h o i c e  o f  n a m e s. Feature names, in  
particular, will be strictly cont rolled for every one’s benefit.
General rules
What matters most is the names of classes  and features  which will be used extensively by  
the authors of classes  that rely on yours.
For feature and class names, use  full words, not abbreviations,  u n l e s s  t h e  
abbreviations are wide ly accepted in the a pplication domain. In  a class PA R T  describing  
parts in an inventory control system, call number , not num, the feature (qu ery) giving the  
part number. Typing is cheap; so ftware maintenance is expensive . An abbreviation such  
as usa in a Geographical Inf ormation System or copter  in a flight control system, having  
gained an independent status as a word of its own, is of course  acceptable. In addition, a  
few standard abbreviations have gained recognition over the yea rs, such as P ART for 
PA R T I A L  in class names such as P ART_COMP ARABLE  describing objects equipped with  
a partial order relation.
In choosing names, aim for clarity. Do not hesitate to use seve ral words connected  
by underscores, as in ANNUAL_RATE , a class name, or yearly_premium , a feature name.
Although modern languages do not place any limit on the length of identifiers, and  
treat all letters as significan t, name length should remain rea sonable. Here the rule is not  
the same for classes and for features. Class names are input on ly occasionally (in class  
headers, type declarations, inheritance clauses and a few other  cases) and should describe  
an abstraction as completely as possible, so PRODUCT_QUANTITY_INDEX_
EVALUATOR m a y  b e  f i n e .  F o r  f e a t u r e s ,  t h e r e  i s  s e l d o m  a  n e e d  f o r  m o r e  t h a n  t w o  o r  
possibly three underscore-connected words. In particular, do not overqualify feature  
names . If a feature name appears too long, it is usually because it is overqualified:
The feature giving the part number in class PA R T should be called just number , not 
part_number . Such over-qualification is a t ypical beginner’s  mistake; the resulting names  Composite Feature Name rule
Do not include in a feature name  the name of the underlying dat a 
abstraction (which should serve as the c lass name).
A SENSE OF STYLE  §26.2 880
obscure rather than illuminate the text. Remember that every us e of the feature will  
unambiguously indicate the class, as in part1   number where part1 must have been  
declared with a certain type, P ART  or a descendant.
For composite names, it is bette r to avoid the style, populariz ed by Smalltalk and also  
used in such libraries as the X W indow System, of joining sever al words together and  
starting the internal ones with  an upper-case letter, as in yearlyPremium . Instead, separate  
components with underscores, as in yearly_  premium . The use of internal upper-case  
letters is ugly; it conflicts with the conventions of ordinary language; and it l eads to cryptic  
names, hence to possible errors (compare aLongAndRatherUnreadableIdentifier with
an_even_longer_but_  perfectly_clear_choice_of_name ).
Sometimes, every instance of a c ertain class contains a field r epresenting an instance  
of another class. This suggests using the class name also as at tribute name. You may for  
example have defined a class RATE and, in class ACCOUNT , need one attribute of type  
RATE , for which it seems natural to use the name rate — in lower case, according to the  
rules on letter case stated bel ow. Although you should try to f ind a more specific name,  
you may, if this fails, just declare the feature as rate: RATE . The rules on identifier choice  
explicitly permit assigning the same name to a feature and a cl ass. Avoid the style of  
prefixing the name with the, as in the_rate , which only adds noise.
Local entities and routine arguments
The emphasis on clear, spelled- out names applies to features an d classes. Local entities  
and arguments of a routine only have a local scope, so they do not need to be as evocative.  
Names that carry too much meanin g might almost decrease the sof tware’s readability by  
giving undue weight to ancillary elements. So it is appropriate  to declare local entities  
(here in routines of TWO_WAY_LIST  in the Base libraries) as
move (i: INTEGER )
-- Move cursor i positions, or after  if i is too large.
local
c: CURSOR ; counter : INTEGER ; p: like FIRST_ELEMENT
…
remove
-- Remove current item; move cursor to righ t neighbor (of after if none).
local
succ, pred , removed : like first_element
…
If succ a n d  pred had been features they w ould have been called successor  a n d 
predecessor . It is also common to use the names new for a local entity representing a new  
object to be created by a routine, and other  for an argument representing an object of the  
same type as the current one , as in the declaration for clone  in GENERAL :
frozen  clone (other : GENERAL ): like other is…
§26.2   CHOOSING THE RIGHT NAMES 881
Letter case
L e t t e r  c a s e  i s  n o t  s i g n i f i c a n t  i n  o u r  n o t a t i o n ,  a s  i t  i s  t o o  d a ngerous to let two almost  
identical identifiers denote different things. But strongly rec ommended guidelines help  
make class texts consi stent and readable:
• Class names appear in all upper case: POINT , LINKED_LIST , PRICING_MODEL . 
Formal generic parameters too, u sually with just one letter: G.
• Names of non-constant attributes , routines other than once fun ctions, local entities  
and routine arguments app ear in all lower case: balance , deposit , succ, i.
• Constant attributes have their first letter in upper case and the rest in lower case:  
Pi: INTEGER = 3.1415926524 ; Welcome_message : STRING = "Welcome !". This  
applies to unique values, whi ch are constant integers.
•The same convention applies to o nce functions, the equivalent o f constants for non-
basic types: Error_window , Io. Our first example, the complex number i, remained  
in lower case for compatibility with mathematical conventions.
This takes care of developer-chosen names. For reserved words, we distinguish two  
categories. Keywords  such as do and class play a strictly syntactic ro le; they are written in  
lower case, and will appear in b oldface (see below) in printed texts. A few reserved words
are not keywords because they carry an associated semantics; wr itten with an initial upper  
case since they are similar to constants, they include Current , Result , Precursor , True and 
False . 
Grammatical categories
Precise rules also govern the g rammatical category of the words  from which identifiers are  
derived. In some languages, thes e rules can be applied without any hesitation; in English,  
as noted in an earlier  chapter, they will l eave more flexibilit y.
The rule for class names has already been given: you should alw ays use a noun, as  
in ACCOUNT , possibly qualified as in LONG_TERM_SAVINGS_ACCOUNT , except for  
the case of deferred c lasses describing a structural property, which may use an adjective  
as in NUMERIC or REDEEMABLE .
Routine names s hould faithfully reflect t he Command-Query separ ation principle:
• Procedures (commands) should be verbs in the infinitive or imp erative, possibly  
with complements: make , move , deposit , set_color .
• Attributes and functions (queries) should never be imperative or infinitive verbs;  
never call a query get_value , but just value . Non-boolean query names should be  
nouns, such as number , possibly qualified as in last_month_balance . Boolean  
queries should use adjectives, as in full. In English, because of possible confusions  
between adjectives and verbs ( empty , for example, could mean “is this empty?” or  The example of i 
was on page 648 .
See the Class Name 
rule on page 727 .
A SENSE OF STYLE  §26.2 882
“empty this!”), a frequent convention for boolean queries is th e is_ form, as in is_
empty .
Standard names
You will have noted, throughout this book, the recurrence of a few basic names, such as  
put and item. They are an importan t part of th e method.
Many classes will need features representing operations of a fe w basic kinds: insert  
an element into a structure, replace the value of an element, a ccess a designated element …
Rather than devising specific na mes for the variants of these o perations in every class, it  
is preferable to apply a sta ndard terminol ogy throughout.
Here are the principal standard names. W e can start with creati on procedures, for  
which the recommended is make  for the most common creation procedure of a class. Non-
vanilla creation procedures may be called make_ some_qualification , for example make_
polar  and make_cartesian  for a POINT  or COMPLEX  class.
For commands the most common names are:
For non-boolean  queries (attributes or functions):extend Add an element.
replace Replace an element.
force Like put but may work in more cases; for example put
for arrays has a preconditi on to require the index to be  
within bounds, but force  has no precondition and will  
resize the array if necessary.
remove Remove an (unspecified) element.
prune Remove a specific element.
wipe_out Remove all elements.
item The basic query for acce ssing an element: in ARRAY , the 
element at a given index; in STACK  classes, the stack  
top; in QUEUE classes, the oldest element; and so on.
infix "@" A synonym for item in a few cases, notably ARRAY .
count Number of usable eleme nts in a structure.
capacity Physical size allocated to a  bounded structure, measured  
in number of potential elements. The invariant should  
include 0 <= count and count <= capacity .Standard 
command 
names
Standard 
names for non-
boolean queries
§26.2   CHOOSING THE RIGHT NAMES 883
For boolean  queries:
A few name choices which may see m strange at fir st are justifie d by considerations  
of clarity and consistency. For example prune goes with prunable  a n d  extend with 
extendible ; delete  and add might seem more natural, but then s  deletable and s  addable  
would carry the wrong connotation, since the  question is not wh ether s can be deleted or  
added but whether we can add ele ments to it or delete elements from it. The verbs prune
and extend , with the associated queries , convey the int ended meaning.
The benefits of consistent naming
The set of names sketched above is one of the elements that mos t visibly contribute to the  
distinctive style of software c onstruction develo ped from the p rinciples of this book.
Is the concern for consistency go ing too far? One could fear th at confusion could  
result from routines that bear t he same name but internally do something different. For  
example item for a stack will return the top element, and for an array will  return an element  
corresponding to the index  specified by the client.
With a systematic appr oach to O-O software construction, using static typing and  
Design by Contract, this fear is not justified. To learn about a feature, a client author can  
rely on four kinds of property, a ll present in the short form o f the enclosing class:
F1  •I t s  n a m e .
F2  • Its signature (number and type o f arguments if a routine, type  of result if a query).
F3  • Its precondition and postcondition if any.
F4  • Its header comment.
A routine also has a body, but that is not part of what client authors are supposed to use.empty Is the structure d evoid of elements?
full I s  t h e r e  n o  m o r e  r o o m  i n  t h e  r e p r e s e n t a t i o n  t o  a d d  
elements? (Normally the same as count = capacity .)
has I s  a  c e r t a i n  e l e m e n t  p r e s e n t ?  ( T h e  b a s i c  m e m b e r s h i p  
test.)
extendible Can an element be added? (May serve as a precondition  
to extend .)
prunable Can an element be removed? (May serve as a  
precondition to remove  and prune .)
readable Is there an accessible element? (May serve as  
precondition to item and remove .)
writable Is it possible to change a n element? (May variously  
serve as precondition to extend , replace , put etc.)Standard 
names for boolean 
queries
A SENSE OF STYLE  §26.3 884
Three of these elements will dif fer for the variants of a basic  operation. For example  
in the short form of class STACK you may find the feature
put (x: G)
-- Push x on top.
require
writable : not full
ensure
not_empty : not empty
pushed : item = x
whereas its namesa ke will appear in ARRAY as
put (x: G; i: INTEGER )
-- Replace by x the entry of index i
require
not_too_small : i >= lower
not_too_large : i <= upper
ensure
replaced : item (i) = x
The signatures are different (on e variant takes an index, the o ther does not); the  
preconditions are diff erent; the postcondit ions are different; and the header comments are  
different. Using the same name put, far from creating confusion,  draws the reader’s attention  
to the common role of these rout ines: both provi de the basic el ement change mechanism.
This consistency has turned out to be one of the most attractiv e aspects of the method  
and in particular of the librari es. New users take to it quickl y; then, when exploring a new  
class which follows th e standard style, they feel immediately a t home and can zero in on  
the features that they need.
26.3  USING CONSTANTS
Many algorithms will rely on cons tants. As was noted in an earl y chapter of this book,  
constants are widely k nown for the detestable practice of chang ing their values; we should  
prepare ourselves against the con sequences of suc h fickleness.
Manifest and symbolic constants
The basic rule is that uses of c onstants should not explicitly rely on the value:
Symbolic Constant principle
D o  n o t  u s e  a  m a n i f e s t  c o n s t a n t ,  o t h e r  t h a n  t h e  z e r o  e l e m e n t s  o f  b a s i c  
operations, in any construct othe r than a symbolic constant dec laration.
§26.3   USING CONSTANTS 885
In this principle, a manifest constant  is a constant given explicitly by its value, as  
in 50 (integer constant) or "Cannot find file " (string constant). The  principle bars using  
instructions  of the form
population_array   make (1, 50)
or
print ("Cannot find file ") -- See mitigating comment below about this case
Instead, you should declare the c orresponding con stant attribut es, and then, in the  
bodies of the routines that need  the values, denote them throug h the attribute names:
US_state_count : INTEGER = 50
File_not_found : STRING = "Cannot find file "
…
population_array   make (1, state_count )
…
print (file_not_found )
The advantage is  obvious: if a new state is added, or the messa ge needs to be  
changed, you have only have to u pdate one easy-t o-locate declar ation.
The use of 1 together with state_count in the first instruction is not a violation of the  
principle, since its prohibition applies to manifest constants “other than zero elements of  
basic operations ”. These zero elements, which yo u may use in manifest form, inc lude the  
integers 0 and 1 (zero elements of addition and multiplication), the real numbe r 0.0, the 
null character written '%0', the empty string " ". Using a symbolic constant One every time  
you need to refer to the lower bound of an array (1 using the d efault convention) would  
lead to an unsustainable style —  pedantic, and in fact less rea dable because of its verbosity.  
Sometimes, Freud is supposed to h ave said, a cigar is just a ci gar; sometimes One is just 1.
Some other times 1 is just a system parameter that happens to have the value one today 
but could become 4,652 later — its role as addition’s zero elem ent being irrelevant. Then  
it should be declared as a symbolic constant, as in Processor_count : INTEGER = 1 in a 
system that supports multiple processors and is initially appli ed to one processor. 
The Symbolic Constant principle may be judged too harsh in the case of simple  
manifest strings used just once, such as "Cannot find file " above. Some readers may want  
to add this case to the exceptio n already stated in the princip le (replacing the qualification  
by “other than manifest stri ng constants used only once in the same class , and zero  
elements of basic operations ”). This book has indeed empl oyed a few mani fest constants  
in simple examples. Such a relaxation of the rule is acceptable , but in the long run it is  
probably preferable to stick to the rule as originally given ev en if the result for string  
constants looks a little pedantic at times. One of the principa l uses of string constants, after  
all, is for messages to be outpu t to users; when a successful s ystem initially written for the  
home market undergoes internatio nalization, it will be that muc h less translation work if  
all the user-visible message str ings (at least any of them that  actually appear in the  
software text) have been put in symbolic constant declarations.
A SENSE OF STYLE  §26.4 886
Where to put constant declarations
If you need more than a handful of local constant attributes in  a class, you have probably  
uncovered a data abstraction — a certain concept c haracterized by a number of numeric  
or character parameters.
It is desirable, then, to group the constant declarations into a class, which can serve  
as ancestor to any class needing the constants (although some O -O designers prefer to use  
the client relation in this case). An example in the Base libra ries is the class ASCII , which  
declares constant attributes for the different characters in th e ASCII character set and  
associated properties.
26.4  HEADER COMMENTS AND NOTE CLAUSES
Although the formal elements of a class text should give as muc h as possible of the  
information about a class, they must be accompanied by informal  explanations. Header  
comments of routines and feature  clause answer t his need togeth er with the note clause of  
each class.
Routine header comments: an exercise in corporate downsizing
Like those New York street signs that read “Don’t even think  of parking here!”, the sign at  
the entrance of your software department should warn “Don’t eve n think of writing a routine  
without a header comment”. The header comment, coming just afte r the signature of the  
routine, expresses its purpose c oncisely; it will be kept by th e short and flat -short forms:
distance_t o_origin : REAL
-- Distance to point (0, 0)
local
origin : POINT
do
create  origin
Result  := distance (origin )
end
Note the indentation: one step f urther than the start of the ro utine body, so that the  
comment stands out.
Header comments should be informative, clear, and terse. They h ave a whole style  
of their own, which we can learn by looking at an initially imp erfect example and improve  
it step by step. In a class CIRCLE  we might start withSee “Facility inher-
itance”, page 832 .
§26.4   HEADER COMMENTS AND NOTE CLAUSES 887
tangent_  from (p: POINT ): LINE
-- Return the tangent l ine to the current circle going through the point p,
-- if the point i s outside of the current circle.
require
outside_circle : not has (p)
…
There are many things wrong here.  First, the comment for a quer y, as here, should  
not start with “Return the …” or “Compute the …”, or in general use a verbal form; this  
would go against the Command-Que ry Separation principle. Simply  name what the query  
returns, typically using a quali fied noun for a non-boolean que ry (we will see below what  
to use for a boolean query a nd a command). Here we get:
-- The tangent line to  the current circle going through the poi nt p,
-- if the point p is outside of the current circle
Since the comment is not a sentence but simply a qualified noun , the final period  
disappears. Next we ca n get rid of the auxil iary words, especia lly the, where they are not  
required for understandability. T elegram-like style is desirabl e for comments. (Remember  
that readers in search  of literary frills ca n always choose Pro ust novels instead.)
--Tangent line to curr ent circle from point p,
-- if point p is outside current circle
The next mistake is to have included, in the second line, the c ondition for the routine’s  
applicability; the precondition, not has (p), which will be retained in the short form where  
it appears just after the header comment, expresses this condit ion clearly and  
unambiguously. There is no need to paraphrase it: this could le ad to confusion, if the  
informal phrasing seems to contradict the formal precondition, or even to errors (a common  
oversight is a precondition of the form x >= 0 with a comment stating “ applicable only to  
positive  x”, rather than “ non-negative ”); and there is always a risk that during the software’s  
evolution the precondition will b e updated but not the comment.  Our example becomes:
-- Tangent line to curre nt circle from point p.
Yet another mistake is to have used the words line to refer to the result and point  to 
refer to the argument: this info rmation is immediately obvious from the declared types,  
LINE  and POINT . With a typed notation we can rely on the formal type declarat ions —  
which again will appear in the s hort form — to express such pro perties; repeating them in  
the informal text brings nothing. So:
-- Tangent to current circle from p.
The mistakes of repeating type information and of duplicating t he precondition’s  
requirements point to the same g eneral rule: in writing header comments, assume the  
reader is competent in the fu ndamentals of the technology ; do not include information that  
is obvious from t he immediately adjacent  short form text. This does not mean, of course,  
that you should never specify a type; the earlier example, -- Distance to point (0,0) , could  
be ambiguous without the word point . Warning : not the 
recommended style for header com-ments !
Not the recom-
mended style .
Not yet …
Still not it …
Almost there , but 
not quite …
A SENSE OF STYLE  §26.4 888
When you need to refer to the cu rrent object represented by a c lass, use phrasing such  
as current circle , current number  and so on as above, rather th an referring explicitly to the  
entity Current . In many cases, howev er, you can avoid mentioning the current object  
altogether, since it is clear to  everyone who can read a class text that features apply to the  
current object. Here, for  example, we just need
-- Tangent from p.
At this stage — three words, sta rting from twenty-two, an 87% r eduction that would  
make the toughest Wall Street ex ponent of corporate downsizing jealous — it seems hard  
to get terser and we can  leave our comment alone. 
A few more general guidelines. We have noted the uselessness of  “Return the …” in 
queries; other noise words and phrases to be avoided in routine s of all kinds include “ This 
routine computes …”, “This routine returns …”; just say what the routine does, not that it  
does it. Instead of
-- This routine records the last outgoing call.
write 
-- Record outgoing call.
As illustrated by this example,  header comments for commands (p rocedures) should  
be in the imperative or infiniti ve (the same in English), in th e style of marching orders.  
They should end with a period. F or boolean-valued queries, the comment should always  
be in the form of a question, t erminated by a question mark:
has (v: G): BOOLEAN
-- Does v appear in list?
…
A  c o n v e n t i o n  g o v e r n s  t h e  u s e  o f  software entities  — attributes,  a r g u m e n t s  —  
appearing in comments. In typese t texts such as the above they will appear in italics (more  
on font conventions be low); in the source text they should alwa ys appear between an  
opening quote (“backquote”) and a closing quote; the original t ext for the example is then:
-- Does ‘v’ appear in list?
Tools such as the short  class abstracter will recognize this convention when  
generating typeset ou tput. Note that the t wo quotes should be d ifferent: ‘v’, not ’v’.
Be consistent. If a function of a class has the comment Length of string , a routine of  
the same class should not say Update width of string if it affects the same property. 
All these guidelines apply to ro utines. Because an exported att ribute should be  
e x t e r n a l l y  i n d i s t i n g u i s h a b l e  f r o m  a r g u m e n t l e s s  f u n c t i o n s  —  r e m e mber the Uniform  
Access principle — it should als o have a comment, which will ap pear on the line  
following the attribut e’s declaration, with the same indentatio n as for functions:
count : INTEGER
-- Number of students in course
For secret attributes a comment is desirable too but the rule i s less strict.This is it .
§26.4   HEADER COMMENTS AND NOTE CLAUSES 889
Feature clause header comments
As you will remember, a class may  have any number of feature cl auses:
note
…
class LINKED_LIST [G] inherit … creation
… 
feature -- Initialization
make …
feature -- Access
item: G …
…
feature -- Status report
before : BOOLEAN …
…
feature -- Status setting
…
feature -- Element change
put_left (v: G) …
…
feature -- Removal
remove …
…
feature {NONE } -- Implementation
first_element : LINKABLE [G].
…
end
One of the purposes of having se veral feature clauses is to all ow different features to  
have different export privileges ; in this example everything is  generally available except  
the secret features in the last clause. But another consequence  of this convention is that  
you could, and should, group feat ures by categories. A comment on the same line as the  
keyword feature should characterize the category. Such comments are, like heade r 
comments of routines, recognized an preserved by documentation tools such as short .
Eighteen categories and the corr esponding comments have been st andardized for the  
Base libraries, so that every f eature (out of about 2000 in all ) belongs to one of them. The  
example above illustrates some of the most important categories . Status report  corresponds  
to options (set by features in the Status setting category, not included in the example).  
Secret and selectively exported features appear in the Implementation category. These  
standard categories always appear in the same order, which the tools know (through a user-
editable list) and will preserve or reinstate in their output. Within each category, the tools  
list the features alphabetically for ease of retrieval.
The categories cover a wide range of application domains, altho ugh for special areas  
you may need to add your own categories.“Operands and 
options”, page 766.
A SENSE OF STYLE  §26.4 890
Note clauses
Similar to header comments but slightly more formal are note cl auses, appearing at the  
beginning of a class:
note
description : "Sequential lists , in chained representation "
names : "Sequence ", "List"
contents : GENERIC
representation : chained
date: "$Date : 96/10/20 12 :21:03 $"
revision : "$Revision : 2.4$"
…
class LINKED_LIST [G] inherit
…
Note clauses proceed from the sa me Self-Document ation principle  (which also leads  
to built-in assertions and heade r comments): include as much as  possible of the  
documentation in the software itself. For properties that do no t directly appear in the  
formal text, you may  include note entries, all of the form
indexing_term : indexing_value , indexing_value , …
where the indexing_term is an identifier and each indexing_value  is some basic element  
such as a string, an integer and so on. Entries can indicate al ternative names under which  
potential client authors might search for the class ( names ), contents type ( contents ),  
implementation choices ( representation ), revision control information, author  
information, and anything else that may facilitate understandin g the class and retrieving it  
through keyword-based search tools — tools that support reuse a nd enable software  
developers to find their way th rough a potentially rich set of reusable components.
B o t h  t h e  i n d e x i n g  t e r m s  a n d  t h e  indexing values are free-form, but the possible  
choices should be standardized fo r each project. A set of stand ard choices has been used  
throughout the Base libraries; the above example illustrates si x of the most common entry  
kinds. Every class must have a description  entry, introducing as index_value a string  
describing the r ole of the class , always express ed in terms of the instances (as Sequential  
lists…, not “this class describes sequ ential lists”, or “sequential l ist”, or “the notion of  
sequential list” etc.). Most sign ificant class texts in this bo ok — but not short examples  
illustrating a specific point — include the description  entry.
Non-header comments
The preceding rules on comments applied to standardized comment s, appearing at  
specific places — feature declarations and beginning of feature  clauses — and playing a  
special role for cl ass documentation.Note clauses were 
previewed in “A note about compo-nent indexing”, page 78 .
“Self-Documenta-
tion”, page 54 .
More details in  
[M 1994a].
§26.5   TEXT LAYOUT AND PRESENTATION 891
As in all forms of software deve lopment, there is also a need f or comments within  
routine bodies, to prov ide further explanations
Another use of comments, although frequent in the practice of s oftware development,  
does not figure much in software engineering and programming me thodology textbooks.  
I am referring here to the technique of transforming some part of the code into comments,  
either because it does not work, or because it is not ready yet . This practice is clearly a  
substitute for better tools and techniques of configuration man agement. It has enriched the  
language with a new verb form, comment out , whose potential, surprisingly enough, has  
not yet been picked up by hip journalists, even though the non- technical applications seem  
attractive and indeed endless: “Th e last elections have enabled  Congress to comment out
the President”, “Letterman was commented out  of the Academy Awards”, and so on.
Every comment should be of a lev el of abstraction higher than t he code it documents.  
A famous count er-example is -- Increase  i by 1  commenting the instruction i := i + 1 . 
Although not always that extreme , the practice of writing comme nts that paraphrase the  
code instead of su mmarizing its effect  is still common.
Low-level languages cr y for ample commenting. It is a good rule  o f  t h u m b ,  f o r  
example, that for each line of C  there should be a comment line ; not a negative reflection  
on C, but a consequence that in modern software development the  r o l e  o f  C  i s  t o  
encapsulate machine-oriented and  operating-syste m-level operati ons, which are tricky by  
nature and require a heavy expla natory apparatus. In the O-O pa rt, non-header comments  
will appear much more sparsely; they remain useful when you nee d  t o  e x p l a i n  s o m e  
delicate operation or foresee pos sible confusion . In its consta nt effort to favor prevention  
over cure, the method decreases t he need for comments through a  modular style that yields  
small, understandable routines, and through its assertion mecha nisms: preconditions and  
postconditions of rout ines, to express their semantics formally ; class invariants; check
instructions to express properti es expected to hold at certain stages; the systematic naming  
conventions introduced earlier in this chapter. More generally,  the secret of clear,  
understandable software is not a dding comments after the fact b ut devising coherent and  
stable system structures  right from the start.
26.5  TEXT LAYOUT AND PRESENTATION
The next set of rules affects how we should physically write ou r software tex ts on paper  
— real, or simulated on a screen. More than any others, they pr ompt cries of “Cosmetics!”;  
but such cosmetics sho uld be as important to  software developer s as Christian Dior’s are  
to his customers. They  play no little role i n determining how q uickly and acc urately your  
software will be  understood by its reader s — maintainers, reuse rs, customers.
Layout 
The recommended layout of texts r esults from the general form o f the syntax of our  
notation, which is rou ghly what is known a s an “operator gramma r”, meaning that a class  
text is a sequence of symbols al ternating between “operators” a nd “operands”. An  
operator is a fixed language  symbol, such as a keyword ( do etc.) or a separator (semicolon,  
comma …); an operand is a programmer-ch osen symbol (iden tifier or cons tant).
A SENSE OF STYLE  §26.5 892
Based on this property, the textu a l  l a y o u t  o f  t h e  n o t a t i o n  f o l l ows the comb-like  
structure  introduced by Ada; the idea is that a syntactically meaningful  part of a class,  
such as an instruction or an  expression, s hould either:
• Fit on a line together with a p receding and succeeding operato rs.
• Be indented just by itself on one or more lines — organized so as to observe the same  
rules recursively.
Each branch of the comb is a seq uence of alternating operators and operands; it  
should normally begin and end wi th an operator. In the space be tween two branches you  
find either a single operand or , recursively, a similar comb-li ke structure.
As an example, depen ding on the size of its constituents a, b and c, you may spread  
out a conditional instruction as 
if c then  a else b end
or 
if
c
then
a
else
b
end
or 
if c then
a
else b endThe comb-like 
structure of 
software texts
Operand
Operator
(keyword,separator etc.)
§26.5   TEXT LAYOUT AND PRESENTATION 893
You would not, however, use a line containing just if c or c end, since they include  
an operand together with something else, and are missing an end ing operator in the first  
case and a starting ope rator in the second.
Similarly, you may sta rt a class, after the note clause, with
class C inherit -- [1]
or
class  C feature -- [2]
or
class -- [3]
C
feature
but not
class C -- [4]
feature
because the first line would violate the rule. Forms [1] and [2] are used in this book for  
small illustrative classes; since  most practical classes have o ne or more labeled feature
clauses, they should in the absence of an inherit  clause use form  [3] (rather than [2]):
class
C
feature  -- Initialization
…
feature  -- Access
etc.
Height and width
Like most modern languages, our notation does not attach any pa rticular significance to  
line separations except to termi n a t e  c o m m e n t s ,  s o  t h a t  y o u  c a n  include two or more  
instructions (or  two or more declaration s) on a single line, se parated by semicolons:
count  := count + 1 ; forth
T h i s  s t y l e  i s  f o r  s o m e  r e a s o n  n o t very popular (and many tools for estimating  
software size still measure lines  rather than syntactical units ); most developers seem to  
prefer having one instruction pe r line. It is indeed not desira ble to pack texts very tightly;  
but in some cases a group of two  or three short, closely relate d instructions can be more  
readable if they all  appear on one line.
In this area it is best to defer  to your judgment and good tast e. If you do apply intra-
line grouping, make sure that it  remains moderate, and consiste nt with the logical relations  
between instructions. The Semico lon Style principle seen later in this chapter requires any  
same-line instructions to be  separated by a semicolon.
A SENSE OF STYLE  §26.5 894
For obvious reasons of space, this book makes a fair use of int ra-line grouping,  
consistent with these guidelines . It also avoids splitting mult i-line instructions into more  
lines than necessary; on this point one can recommend the book’ s style for general use:  
there is really no reason to split from  i:= 1 invariant i <= n until i = n loop or 
if a = b then . Whatever your personal taste, d o observe the Comb structure.
Indenting details
The comb structure uses indentat ion, achieved through tab chara cters ( not spaces, which  
are messy, error-prone, and not reader-parameterizable).
Here are the indentation levels for the basic kinds of construc t, illustrated by the  
example on the facing page:
• Level 0: the keywords introducing the primitive clauses of a c lass. This includes  
note (beginning of a note clause), class  (beginning of the class body), feature
(beginning of a feature clause, except if on the same line as class ), invariant
(beginning of an invariant claus e, not yet seen) and the final end of a class.
• Level 1: beginning of a feature  declaration; note entries; inv ariant clauses.
• Level 2: the keywords starting the successive clauses of a rou tine. This includes  
require , local , do, once , ensure , rescue , end.
• Level 3: the header comment for a routine or (for consistency)  attribute; declarations  
of local entities in a routine; f irst-level instructions of a r outine.
Within a routine body there may be further indent ation due to t he nesting of control  
structures. For example the earlier if a then  … instruction contains two branches, each of  
them indented. These branches co uld themselves contain loops or  conditional instructions,  
leading to further nesting (although the style of object-orient ed software construction  
developed in this book leads to s imple routines, seldom reachin g high levels of nesting).
A check  instruction is indented, together with the justifying comment that normally  
follows it, one level to the right of the instruction that it g uards.
note
description : "Example for formating "
class  EXAMPLE inherit
MY_P ARENT
redefine f1, f2 end
MY_OTHER_P ARENT
rename
g1 as old_g1 , g2 as old_g2
redefine
g1
select
g2
end
creation
makeA layout 
example
Note: this class 
has no useful semantics!
§26.5   TEXT LAYOUT AND PRESENTATION 895
feature -- Initialization
make
-- Do something.
require
some_condition : correct (x)
local
my_entity : MY_TYPE
do
if a then
b; c
else
other_routine
check max2 > max1 + x ^ 2 end
-- Because of the postcondition of other_routine .
new_value  := old_value / (max2 – max1 )
end
end
feature  -- Access
my_attribute : SOME_TYPE
-- Explanation of its role (aligned with comment for make ) 
… Other feature declarati ons and feature clauses …
invariant
upper_bound : x <= y
end
Note the trailer c omment after the end of the class, a sys tematic convention.
Spaces
White space contributes as much to the effect produced by a sof tware text as silence to the  
effect of a musical piece.
The general rule, for simplicity and ease of remembering, is to  follow as closely as  
possible the practice of standard written language. By default w e  w i l l  a s s u m e  t h i s  
language to be English, although  it may be appropriate to adapt  the conventions to the  
slightly different rul es of other languages.
Here are some of the consequ ences. You will use a space:
• Before an opening paren thesis, but not after: f  (x) (not f (x), the C style, or f (  x)).
• After a closing parenthesis unless  the next character is a punctuation sign such as a  
period or semicolon; b ut not before. Hence: proc1 (x); x := f1 (x) + f2 (y)
• After a comma b ut not before: g (x, y, z).
• After the two dash sign s that start a comment: -- A comment .
A SENSE OF STYLE  §26.5 896
Similarly, the default rule for semicolons is to  use a space af ter but not before:
p1; p2 (x); p3 (y, z)
Here, however, some people prefe r, even for English-based softw are texts, the  
French style of including a spa ce both before and after, which makes the semicolon stand  
out and emphasizes the symmetry between the components before a nd after it:
p1 ; p2 (x) ; p3 (y, z)
Choose either style, but then use it consistently. (This book u ses the English style.)  
English and French styles have the same difference for colons a s for semicolons; since,  
however, the software notation only uses colons for declaration s, in which the two parts  
—  t h e  e n t i t y  b e i n g  d e c l a r e d  a n d  i t s  t y p e  —  d o  not p l a y  a  s y m m e t r i c  r o l e ,  i t  s e e m s  
preferable to stick to t he English style, as in your_entity : YOUR_TYPE .
Spaces should appear be fore and after arithm etic operators, as in a + b . (For space  
reasons, this book has omitted t he spaces in a f ew cases, all o f the form n+1.)
For periods the notation departs  from the conventions of ordina ry written language  
since it uses periods for a spec ial construct, as originally in troduced by Simula. As you  
know, a  r means: apply feature r to the object attached to a. In this case there is a space  
neither before nor after the period. To avoid any confusion, th is book makes the period  
bigger, as illustrated:     rather than just .
There is another use of the peri od: as decimal p oint in real nu mbers, such as 3.14. 
Here, to avoid any confusion, the  period is not made any bigger .
S o m e  E u r o p e a n  l a n g u a g e s  u s e  a  c o m m a  r a t h e r  t h a n  a  p e r i o d  a s  t h e  separator between  
integral and fractional parts of numbers. Here the conflict is irreconcilable, as in English the  
comma serves to separate parts of big numbers, as in “300,000 d ollars”, where other  
languages would use a space. The committee discussions for Algo l 60 almost collapsed  
when some continental members refused to bow to the majority’s choice of the period; the  
stalemate was resolved when someone suggested distinguishing be tween a reference  
language, fixed, and representation languages, parameterizable.  (In retrospect, not such a  
great idea, at least not if you ever have to compile the same p rogram in two different  
countries!) Today, few people would make this a point of conten tion, as the spread of digital  
watches and calculators built for world markets have accustomed  almost everyone to  
alternate between competing conve ntions.
Precedence and parentheses
The precedence conventions of the notation conform to tradition  and to the “Principle of  
Least Surprise” to avoid errors and ambiguities.
Do not hesitate, however, to add parentheses for clarity; for e xample you may write  
(a = (b + c )) implies  (u /= v) even though the meaning of that expression would be the same  
if all parentheses were removed. The examples in this book have  systematically over-
parenthesized expressions, in pa rticular assertions, risking he aviness to avert uncertainty.
§26.5   TEXT LAYOUT AND PRESENTATION 897
The War of the Semicolons
Two clans inhabit the computing world, and the hatred between t hem is as ferocious as it  
is ancient. The Separa tists, following Algol  60 and Pascal, fig ht for the recognition of the  
semicolon as a separator between instructions; the Terminatists , rallied behind the  
contrasting flags of PL/I, C and  Ada, want to put a semicolon b ehind every instruction.
Each side’s arguments are endles sly relayed by its propaganda m achine. The  
Terminatists worship uniformity: if every instruction is termin ated by the same marker, no  
one ever has to ask the question  “do I need a semicolon here?” (the answer in Terminatist  
languages is always yes, and anyo ne who forgets a semicolon is immediately beheaded for  
high treason). They do not want t o have to add or remove a semi colon because an  
instruction has been moved from one syntactical location to ano ther, for example if it has  
been brought into  a conditional instructio n or taken out of it.
The Separatists praise the elega nce of their convention and its  compatibility with  
mathematical practices. They see do instruction1 ; instruction2 ; instruction3  end as the  
natural counterpart of f (argument1 , argument2 , argument3 ). Who in his right mind, they  
ask, would prefer f (argument1 , argument2 , argument3 ,) with a superfluous final comma?  
They contend, furtherm ore, that the Terminatists are just a fro nt for the Compilists, a cruel  
people whose only goal i s  t o  m a k e  l i f e  e a s y  for compiler writer s, even if that means  
making it hard for appl ication developers.
The Separatists constantly have to fight against innuendo, for example the  
contention that Separa tist languages will prevent  you from includin g extra semicolons.  
Again and again they must repeat  the truth: that every Separati st language worthy of the  
name, beginning with t he venerated Patriarch of the tribe, Algo l 60, has supported the  
notion of empty instruct ion, permitting all of
a; b; c
a; b; c; 
; a ;; b ;;; c; 
to be equally valid, and to mean  exactly the same thing, as the y only differ by the extra  
e m p t y  i n s t r u c t i o n s  o f  t h e  l a s t  t w o  v a r i a n t s ,  w h i c h  a n y  d e c e n t  c ompiler will discard  
anyway. They like to point out how much more tolerant this conv ention makes them:  
whereas their fanatica l neighbors will use any missing semicolo n as an excuse for renewed  
a t t a c k s ,  t h e  S e p a r a t i s t s  w i l l  g l a d l y  a c c e p t  a s  m a n y  e x t r a  s e m i c olons as a Terminatist  
transfuge may still, out of habi t, drop into an outwardly Separ atist text.
Modern propaganda needs science and statistics, so the Terminat ists have their own  
experimental study, cited everyw here (in particular as the just ification for th e Terminatist  
convention of the Ada language): a 1975 measurement of the erro rs made by two groups  
of 25 programmers each, using languages that, among other disti nguishing traits, treated  
semicolons differently. The resu lts show the Separatist style c ausing almost ten times as  
many errors! Starting to feel the  heat of incessant enemy broad casts, the Separatist  
leadership turned for help to th e author of the present book, w ho remembered a long-
forgotten principle: quoting is good , but reading is better . So he fearlessly went back to  The article is a 
study by Gannon and Horning [Gannon 1975].
A SENSE OF STYLE  §26.5 898
the original article a nd discovered that the  Separatist languag e used in the comparison —  
a mini-language meant only for “ teaching students the concepts of asynchronous  
processes” — treats an extra semicolon after the final instruct ion of a compound, as in  
begin a; b; end, as an error! No real Separatist language, as noted above, has  ever had such  
a rule, which would be absurd in  any circumstance (as an extra semicolon is obviously  
harmless), and is even more so in the context of the article’s experiment since some of the  
subjects apparently had Terminatist experience from PL/I and so  would have been  
naturally prone to add a few sem icolons here and there. It then  seems likely, although the  
article gives no data on this po int, that many of the semicolon  errors were a result of such  
normally harmless additions — en ough to disqualify the experime nt, once and for all, as  
a meaningful bas is for defending  Terminatism over Separatism. 
On some of the other issues it studies, the article is not marr ed by such flaws in its test  
languages, so that it still makes good reading for people inter ested in language design.
All this shows, however, that it  is dangerous to  take sides in such a sensitive debate,  
especially for someone who takes pride in having friends in bot h camps. The solution  
adopted by the notation of this book is radical:
“Almost” because of a few rare cases, not encountered in this b ook, in which omitting the  
semicolon would cause a syntactical ambiguity.
The Semicolon Syntax rule mean s you can choose your style:
• Terminatist: every instruction,  declaration or assertion claus e ends with a semicolon.
• Separatist: semicolons appear b etween successive elements but not, for example,  
after the last declaration of a feature or local clause.
• Moderately Separatist: like the Separatist style, but not worr ying about extra  
semicolons that may appear as a result of habit or of elements being moved from one  
context to another.
• Discardist: no semico lons at all (except as per the Semicolon Style principle below).
This is one of the areas where it is preferable to let each use r of the notation follow  
his own inclination, as the choice cannot cause serious damage.  B u t do  st ic k,  at  le as t  
across a class and preferably across an entire library or appli cation, to the style that you  
have chosen (although this will not mean much for the Moderatel y Separatist style, which  
is by definition lax), and obser ve the following principle:Semicolon Syntax rule
Semicolons, as markers to delimi t instructions, declarations or  assertion  
clauses, are optional in almost all the positions where they ma y appear in the  
notation of this book.
Exercise E26.2, 
page 902 .
§26.5   TEXT LAYOUT AND PRESENTATION 899
The second clause governs elemen ts that appear t wo or more to a  line, as in
found  := found + 1 ; forth
which should always include the semicolon; omitting it would ma ke the line quite confusing.
Just for once, this discussion has no advice  here, letting you decide which of the four  
styles you prefer. Since the earliest version of the notation r equired semicolons — in other  
words, it had not yet been tuned to support the Semicolon Synta x rule — the first edition  
of this book used a Separatist st yle. For the present one I dab bled into a few experiments;  
after polling a sizable group of  co-workers and experienced use rs of the notation, I found  
(apart from a handful of Terminatists) an almost equal number o f Discardists and  
Separatists. Some of the Discard ists were very forceful, in par ticular a university professor  
who said that the main reason hi s students loved the notation i s that they do not need  
semicolons — a comment which any  future language designer, with  or without grandiose  
plans, should find instruc tive or at lea st sobering.
Y o u  s h o u l d  d e f e r  t o  y o u r  o w n  t a s t e  a s  l o n g  a s  i t  i s  c o n s i s t e n t  and respects the  
Semicolon Style principle. (As t o this book: for a while I stuc k to the original Separatist  
style, more out of habit than of  real commitment; then, hearing  the approach of the third  
millenium and its call to start a new life free of antique supe rstitions, I removed all the  
semicolons over a single n ight of utter debauchery.)
Assertions
You should label assertion claus es to make the t ext more readab le:
require
not_too_small : index >= lower
This convention also helps produce useful information during te sting and debugging  
since, as you will remember, the assertion label will be includ ed in the run-time message  
produced if you have enabled monitoring of assertions and one o f them gets violated.
This convention will spread an as sertion across a s many lines a s it has clauses. As a  
consequence, it is one of the rules to which the present book h as made a few exceptions,  
again in the interest of saving space. When collapsing several clauses on one line, you  
should actually remove the  labels for readability:
require
index >= lower ; index <= upper
In normal circumstances, that is  to say for software texts rath er than a printed  
textbook, better stick to the official rule  and have one labele d clause per line.Semicolon Style principle
If you elect to include semicolo ns as terminator s (Terminatist style), do so  
for all applicab le elements. 
If you elect to forego semicolon s, use them only when syntactic ally 
unavoidable, or to separate elem ents that appear  on the same li ne.
See “Monitoring 
assertions at run time”, page 392 .
A SENSE OF STYLE  §26.6 900
26.6  FONTS
In typeset software texts, the following conventions, used thro ughout this book and related  
publications, are recommended.
Basic font rules
Print software element s (class names, feature names, entities …) in italics  to distinguish  
them from non-software text elem ents. This facilitates their in clusion in sentences of the  
non-software text, such as “We can see that the feature number is a query, not an attribute”.  
(The word number  denotes the name of the feature ; you do not want  to mislead yo ur reader  
into believing that you are talk ing about the number of feature s!)
Keywords, such as class , feature , invariant  and the like, appear in boldface .
This was also the convention of the first edition of this book.  At some stage it seemed  
preferable to use boldface italics  which blends more nicely with italics. What was  
esthetically pleasing, however, turned out to hamper quality; s ome readers complained  
that the keywords did not stand out clearly enough, hence the r eturn to the original  
convention. This is a regrettable case of fickleness. [M 1994a]  and a handful of books by  
other authors show the intermediate convention.
Keywords play a purely syntactic role: they have no semantics o f their own but  
delimit those elements, such as feature and class names, that d o carry a semantic value. As  
noted earlier in this chapter, t here are also a few non-keyword  reserved words, such as  
Current  and Result , which have a denotation of the ir own — expressions or entitie s. They  
are written in non-bol d italics, with an i nitial upper-case let ter.
Following the traditio n of mathematics, symbols — colons and se micolons : ;, 
brackets [ ], parentheses ( ), braces { }, question and exclamation marks ? ! and so on —  
should always appear in roman (s traight), even when they separa te text in italics. Like  
keywords, they are purely syntactic elements.
Comments appear in roman. This av oids any ambiguity when a feat ure name —  
which, according to the principle s seen earlier, will normally be a word from ordinary  
language — or an argument name a ppears in a comment; the featur e name will be in italics  
and hence will stand  out. For example:
accelerate (s: SPEED ; t: REAL )
-- Bring speed to s in at most t seconds.
…
set_number (n: INTEGER )
-- Make n the new value of number .
…
§26.7   BIBLIOGRAPHICAL NOTES 901
In the software text itself, where no font variations are possi ble, such occurrences of  
formal elements in comments should follow a specific convention  already mentioned  
earlier: they will appear preceded by a back quote ‘ and followed by a normal quote  ’ , as in
-- Make ‘n’ the new value of ‘number’.
(Remember that you must use two different quote characters for opening and  
closing.) Tools that process class texts and can produce typese t output, such as short and
flat, know this convention and so can make sure the quoted elements  are printed in italics.
Other font conventions
The preceding font co nventions work well for  a book, an article  or a Web page. Some  
contexts, however, may call for different approaches. In partic ular, elements in plain  
italics, and sometimes even bold  italics, are not always readab le when projected on a  
projection screen, especially if  what you are projecting is the  output of a laptop computer  
with a relatively small display.
In such cases I have come to u sing the followi ng conventions:
•Use non-italics boldface for eve rything, as this projects best.
•Choose a wide enough font, such as Bookman  (for which boldface may be called  
“demibold”).
• Instead of italics versus roman  versus bold, use color to dist inguish the various  
elements: keywords in black; co mments in red; th e rest (entitie s, feature names,  
expressions …) in blue. More colors can be us ed to highlight special element s.
These conventions seem to work well, although there is always r oom for  
improvement, and new media will undoubtedly prom pt new conventi ons.
Color
The particularly attentive reader may by now have come to notic e another convention used  
by this book: for added clarity, all formal elements — software  texts or text extracts, but  
also mathematical elements — appear in color . This technique, which of course cannot be  
presented as a general requirement, enhances the effect of the rules seen so far on font usage.
26.7  BIBLIOGRAPHICAL NOTES
[Waldén 1995]  is the source of the idea of showing by example that even a lo nger 
separated_by_underscores  identifier is easier to read than an internalUpperCase  identifier.
[Gannon 1975]  is an experimental study of the effect of variou s language des ign 
choices on error rates.
The rules on standard feature names were first presented in [M 1990b]  a n d  a r e  
developed in detail in [M 1994a] .
I received important comments fr om Richard Wiener on students’ appreciation of  
the optionality of semicolons, and from Kim Waldén on the respe ctive merits of bold  
italics and plain bold.
A SENSE OF STYLE  §E26.1 902
EXERCISES
E26.1  Header comment style
Rewrite the following header c omments in the proper style:
reorder (s: SUPPLIER ; t: TIME )
-- Reorders the curre nt part from supplier s, to be delivered
-- on time t; this routine will o nly work if t is a time in the  future.
require
not_in_past : t >= Now
…
next_reorder_date : TIME
-- Yields the next tim e at which the current part is scheduled
-- to be reordered.
E26.2  Semicolon ambiguity
Can you think of a case in whi ch omitting a semicolon between t wo instructions or assertions  
could cause syntactic ambiguity, or at least confuse a simple-m inded parser? ( Hint : a feature  
call can have as its target a pa renthesized expression, as in (vector1 + vector2 )   count .)
27  
Object-oriented analysis
F ocused initially on the implementation aspects of software cons truction, the object-
oriented method quickl y expanded to cover the totality of the s oftware lifecycle. Of  
p a r t i c u l a r  i n t e r e s t  h a s  b e e n  t h e  a p p l i c a t i o n  o f  O - O  i d e a s  t o  t h e modeling of software  
systems, or even of non-software systems and issues. This use o f object technology to  
present problems  rather than solutions is know n as object-oriented analysis.
In the past few years, many book s have appeared on the topic an d many specific  
methods of object-oriented analy sis have been pr oposed. The bib liography section lists  
some of the best-known  books, and Web addre sses for some of the  best-known methods.
Most of the concepts introduced i n the preceding chapters are d irectly relevant to  
object-oriented analysis. Here we will briefly review what make  object-oriented analysis
special among other object-ori ented topics, and what makes object-oriented analysis  
different from other  analysis methods.
Two points of terminology to avo id imagining differences where none exist. First,  
y o u  w i l l  e n c o u n t e r ,  a s  a  s y n o n y m  f o r  “ a n a l y s i s ” ,  t h e  t e r m  system modeling , or just  
modeling . Second, the computing science community tends t o use the word  specification
where information modeling folks  talk about analy sis; in partic ular, computing scientists  
have devoted considerable efforts to devising methods and langu ages for formal  
specification using mathematical techniques fo r purposes of system modeling. The goals  
are the same, although the techn iques may differ. In the past f e w  y e a r s  t h e  t w o  
communities — informati on modelers and form al specifiers — have  been paying more  
attention to each ot her’s contributions.
27.1  THE GOALS OF ANALYSIS
To understand analysis issues we  must be aware of the roles of analysis in software  
development and define requirem ents on an analysis method.
Tasks
By devoting time  to analysis and produci ng analysis documents w e pursue seven goals:
OBJECT-ORIENTED ANALYSIS  §27.1 904
If analysis is being applied to a non-software system, or indep endently of a decision  
to build a software system, A 1, A2 and A 3 may be the only relevant goals.
For a software system, the list assumes that analysis follows a  stage of feasibility  
study  which has resulted in a decision to build a system. If, as som etimes happens, the two  
stages are merged into one (not an absurd proposition, since yo u may need an in-depth  
analysis to determine whether a satisfactory result is conceiva ble), the list needs another  
item: A0, deciding whethe r to build a system. 
Although related, the goals listed are distinct, prompting us i n the rest of this chapter  
to look for a set of complementary techniques; what is good for  one of the goals may be  
irrelevant to another.
Goals A 2 and A 3 are the least well covered in the analysis literature and dese rve all  
the emphasis they can get. One o f the primary benefits of an an alysis process,  
independently of any document tha t it produces in the end, is t hat it leads you to ask the  
relevant questions (A 2): what is the maximum accepta ble temperature? What are the  
recognized categories of employees? How are bonds handled diffe rently from stocks? By  
providing you with a framework, w hich you will have to fill usi ng input from people  
competent in the application doma in, an analysis method will he l p  s p o t  a n d  r e m o v e  
obscurities and ambiguities which can be fatal to a development . Nothing is worse than  
discovering, at the last stage of  implementation,  t h a t  t h e  m a r k eting and engineering  
departments of the client company have irreconcilable views of what equipment  
maintenance means, that one of these views was taken by default , and that no one cared  
to check what the actual order giver had in mind. As to A 3, a good analysis document will  
be the place to which everyone co nstantly goes back if delicate  questions or conflicting  
interpretations arise durin g the development process.
Requirements
The practical requirements on the  analysis process and supporti ng notations follow from  
the above list of goals:Goals of performing analysis
A1 • To understand the problem or problems that the eventual softwar e 
system, if any, should solve.
A2 • To prompt relevant questions abo ut the problem and the system.
A3 • To provide a basis for  answering que stions about specific prope rties of  
the problem and system.
A4 • To decide what the system should do.
A5 • To decide what the s ystem should not do.
A6 • To ascertain that the system will satisfy the needs of its user s, and define  
acceptance criteria (especially when the system is developed fo r an 
outside customer under a c ontractual relationship).
A7 • To provide a basis for the d evelopment of the system.
§27.1   THE GOALS OF ANALYSIS 905
• There must be a way to let no n-software people contribute inpu t to the analysis,  
examine the results and discuss them (A 1, A2).
• The analysis must also have a f orm that is directly usable by software developers (A 7).
• The approach must scale up  (A1).
• The analysis notation must be able to express precise properti es unambiguously (A 3).
• It must enable readers to get a quick glimpse of the overall o rganization of a system  
or subsystem (A 1, A7)
Scaling up (the third point) mean s catering to sys tems that are  complex, large or both  
— the ones for which you most need analysis. The method should enable you to describe  
the high-level structure of the problem or system, and to organ ize the description over  
several layers of abstraction, s o that you can at any time focu s on as big or as small a part  
of the system as you wish, while  retaining the overall picture.  Here, of course, the  
structuring and abstracting faci lities of object technology wil l be precious.
Scaling up also means that the c riteria of extendibility and re usability, which have  
guided much of our earlier discus sions, are just as applicable to analysis as they are to  
software design and implementati on. Systems change, requiring t heir descriptions to  
follow; and systems are similar to previous systems, prompting us to use libraries  o f 
specification elements to build their specifications, just as w e use libraries of software  
components to build th eir implementations.
The clouds and the precipice
It is not easy to reconcile the last two requirements of the ab ove list. The conflict, already  
discussed in the context of abstr act data types, has plagued an alysis methods and  
specification languages as long as they have existed. How do yo u “express precise  
properties unambiguously” without saying too much? How do you p rovide readable  
broad-brush structural  descriptions withou t risking vagueness?
The analyst walks on a mountain path. On your left is the mount ain top, deep  
ensconced in clouds; this is the realm of the fuzzy. But you mu st also stay away, on your  
right, from the precipice of ove rspecification, to which you mi ght be perilously drawn if  
your attempts to be precise tempt you to say too much, especial ly by giving out  
implementation  details instead of external  properties of the system.
The risk of overspecification is ever present in the minds of p eople interested in  
analysis. (It is said that, to gain the upper hand in a debate in this field, you should try  
“Approach X is nice , but isn’t it a tad implementation-oriented   ?” The poor author of X,  
reputation lost, career shattered, will not dare show up in a s oftware gathering for the  
next twenty years.) To avoid thi s pitfall, analysis methods hav e tended to err on the side  
of the clouds, relying on formal isms that do a good job of capt uring overall structures,  
often through cl oud-like graphical notat ions, but are quite lim ited when it comes to  
expressing the semantic properties of systems as required to address goal A 2 (answering  
precise questions).
OBJECT-ORIENTED ANALYSIS  §27.2 906
Many of the traditional analysis  methods fit this description. Their success comes  
from their ability to list the c omponents of a system and descr ibe their relations  
graphically, making them the  software equivalent of the block diagrams  of other  
engineering disciplines. But the y are not too go od at capturing  the semantics. For software  
projects this carries a risk: believing that  you have completed  a successful analysis when  
all you have really done is to d efine the major components and their relations, leaving out  
many deeper properties  of the specification that may turn out t o be critical.
Later in this chapter we will study ideas for reconciling the g oals of structural  
description and se mantic precision.
27.2  THE CHANGING NATURE OF ANALYSIS
Although the object-oriented analysis literature hardly mention s this point, the most  
significant contribution of object technology to analysis is no t technical but  
organizational. Object technology does not just provide new way s of doing analysis; it  
affects the very nature of the t ask and its role in the softwar e process.
This change follows from the meth od’s emphasis on reusability. I f  i n s t e a d  o f  
assuming that every new project must start from scratch, consid ering the customer’s  
requirements as the Gospel, we b ring into the picture the prese nce of a regularly growing  
repertory of software components , some obtained (or obtainable)  from the outside and  
some developed as a result of in-house projects, the process be comes different: not the  
execution of an order  from above, but a negotiation .
The figure suggests this process: the customer starts with a re quirement at A; you 
counter with a  proposal at B, covering perhaps only part of the requirements, or a slightly  
d i f f e r e n t  f o r m  o f  t h e  r e q u i r e m e n t s ,  b u t  b a s e d  f o r  a  l a r g e  p a r t  on existing reusable  
components and hence achievable at significantly less cost and sooner. The customer may  
initially find the sacrifice of functionality too large; this o pens a haggling phase which  
should eventually lead to an acceptable compromise.
The haggling has always been the re, of course. The customer’s r equirements were  
the Gospel only in some descript ions of the “software process” in the software engineering  
literature, presenting an ideal v iew for pedagogical purposes, and perhaps in some  
government contracts. In most nor mal situations, the developers  had some freedom to  
discuss requirements. But with t he advent of object technology this officious phenomenon  
becomes an official pa rt of the software development process, a nd gains new prominence  
with the development o f reusable libraries.Requirements 
analysis as a 
negotiationCustomer
DeveloperA
B(Compromise)
§27.3   THE CONTRIBUTION OF OBJECT TECHNOLOGY 907
27.3  THE CONTRIBUTION OF OBJECT TECHNOLOGY
Object technology also affects, o f course, the techniques of an alysis.
Here the most important thing to  learn is that we have almost n othing to learn. The  
framework defined in the precedi ng chapters has more than enoug h to get us started with  
modeling. “More than enough” act ually means too much: the notat ion includes an  
operational part, made of two components whic h we do not need for analysis:
• Instructions (assignments , loops, procedure calls, …) and all that goes with them.
• Routine bodies of the do form (but we do need deferred  routines to specify  
operations without giving o ut their implementation).
If we ignore these imperative el ements, we have a powerful syst em modeling  
method and notation. In particular:
•Classes  will enable us to organize our system descriptions around obje ct types, in  
the broad sense of the word “obj ect” defined in preceding chapt ers (covering not just  
physical objects  but also important conc epts of the application  domain).
•T h e  ADT  approach — the idea of characte rizing objects by the applicabl e operations  
and their properties — yields cle ar, abstract, evo lutionary spe cifications.
• To capture inter-component rela t i o n s ,  t h e  t w o  b a s i c  m e c h a n i s m s  o f  “ c l i e n t ”  a n d  
inheritance are appropriate. The client  relation, in particular, covers such  
information modeling c oncepts as “pa rt of”, associa tion and agg regation.
• As we saw in the discussion of objects, the distinction betwee n reference  a n d 
expanded  clients corresponds to the two basic kinds of modeling associa tion.
•Inheritance  — single, multiple and repeated — addresses classification. Ev en such  
seemingly specialized inheritance mechanisms as renaming will b e precious to  
model analysis concepts.
•Assertions  are essential to capture w hat was calle d above the semantics  of systems:  
properties other than structural. Design by Contract is a power ful guide to analysis.
•Libraries  of reusable classes will provide us — especially through their  higher-level  
deferred classes — w ith ready-made specification elements.
This does not necessar ily mean that the approach seen so far co vers all the needs of  
system analysis (a question that  will be discussed further belo w); but it certainly provides  
the right basis. The following e xample will provide some eviden ce.
27.4  PROGRAMMING A TV STATION
Let us see concretely how to appl y the O-O concepts that we kno w to pure modeling.
The example involves organizing the schedule of a television st ation. Because it is  
drawn from a familiar applicati on area, we can start it (althou gh we most likely could not  
complete it) without the benefit  of input from “domain experts” , future users etc.; we can  
just, for the analysis exercise, rely on every layperson’s unde rstanding of TV .
Although the effort may be the prelude to the construction of a  computerized system  
to manage the station’s programmi ng automatically, this possibi lity is neither certain nor  
relevant here; we are just  interested in modeling.
OBJECT-ORIENTED ANALYSIS  §27.4 908
Schedules
W e  c o n c e n t r a t e  o n  t h e  s c h e d u l e  f o r  a  2 4 - h o u r  p e r i o d ;  t h e  c l a s s  (data abstraction)  
SCHEDULE  presents itself. A schedule con tains a sequence of individual program  
segments; let us start with
class SCHEDULE  feature
segments : LIST [SEGMENT ]
end
When doing analysis we must cons tantly watch ourselves for fear  of lapsing into  
overspecification. Is it overspecifying to use a LIST ? No: LIST is a deferred class,  
describing the abstract notion of sequence; and television prog ramming is indeed  
sequential, since one cannot broa dcast two segments on the same  station at the same time.  
By using LIST  we capture a property of th e problem, not the solution.
Note in passing the importance of reusability: by using classes  such as LIST  you 
immediately gain access to a whole set of features describing l ist operations: commands  
such as put for adding elements, queries su ch as the number of elements count . Reusability  
is as central to object-oriented analysis as it is to other O-O  tasks.
What would be overspeci fying here would be to equate  the notion of schedule with  
that of list of segments. Object  technology, as you will rememb er from the discussion of  
abstract data types, is implicit ; it describes abstractions by listing their properties. Here  
there will certainly be more to a schedule than the list of its  s e g m e n t s ,  s o  w e  n e e d  a  
separate class. Some of  the other features of a schedule presen t themselves naturally:
note
description : "Twenty-four hour TV schedules "
deferred class  SCHEDULE feature
segments : LIST [SEGMENT ]
-- The successi ve segments
deferred  
end
air_time : DATE is 
-- Twenty-four hour period for this schedule  
deferred  
end
set_air_time (t: DATE )
-- Assign this schedule to be broadcast at time t.
require
t  in_future
deferred
ensure
air_time = t
end
print
-- Print paper version of schedule.
deferred
end
endSee “More on 
implicitness”, page 149.
§27.4   PROGRAMMING A TV STATION 909
N o t e  t h e  u s e  o f  d e f e r r e d  b o d i e s .  This is appropriate since by n ature an analysis  
document is implementation-indepe ndent and even d esign-independ ent; having no body,  
deferred features are the proper tool. You could, of course, di spense with writing the  
deferred specification and instead use a fo rmalism such as that of short  forms. But two  
important arguments justif y using the full notation:
• By writing texts that conform t o the syntax of the software no tation, you can make  
use of all the tools of the sup porting software development env ironment. In  
particular, the compiling mechanism will double up as a preciou s CASE (computer-
aided software engineering) tool,  applying type rules and other  validity constraints  
to check the consistency of your specifications and detect cont radictions and  
ambiguities; and the browsing and  documentation facilities of a  good O-O  
environment will be as useful fo r analysis as th ey are for desi gn and implementation.
• Using the software notation als o means that, should you decide  to proceed to the  
design and implementation of a software system, you will be abl e to follow a smooth  
transition path; your w o r k  w i l l  b e  t o  a d d  n e w  c l a s s e s ,  e f f e c t i v e versions of the  
deferred features and new fe atures. This supports the seamlessness  of the approach,  
discussed in the next chapter.
The class assumes a boolean query in_ future  on objects of type DATE ; it only allows  
setting air time for future date s. Note our first use of a prec ondition and postcondition to  
express semantic pro perties of a system during analysis.
Segments
Rather than continuing to refine and enhance SCHEDULE , let us at this stage switch to  
the notion of SEGMENT . We can start with th e following features:
note
description : "Individual fragments of  a broadcasting schedule "
deferred class  SEGMENT feature
schedule : SCHEDULE deferred end  
-- Schedule to whi ch segment belongs
index : INTEGER deferred end  
-- Position of segment in its schedule
starting_time , ending_time : INTEGER deferred end  
-- Beginning and end of scheduled air time
next: SEGMENT deferred end  
-- Segment to be played next, if any
sponsor : COMP ANY deferred end  
-- Segment’s principal sponsorSee “Using asser-
tions for documen-tation: the short form of a class”, page 389 .
OBJECT-ORIENTED ANALYSIS  §27.4 910
rating : INTEGER deferred end  
-- Segment’s rating (for c hildren’s viewing etc.)
… Commands such as change_next , set_sponsor , set_rating omitted …
Minimum_duration : INTEGER = 30 
-- Minimum length of s egments, in seconds
Maximum_interval : INTEGER = 2 
-- Maximum time between two s uccessive segments, in seconds
invariant
in_list : (1 <= index ) and (index <= schedule   segments   count )
in_schedule : schedule   segments   item (index ) = Current
next_in_list : (next /= Void ) implies (schedule   segments   item (index + 1 ) = next)
no_next_iff_last : (next = Void ) = (index = schedule   segments   count )
non_negative_rating : rating >= 0
positive times : (starting_time > 0) and (ending_time > 0)
sufficient_duration : ending_time – starting_time >= Minimum_duration
decent_interval : (next  starting_time ) – ending_time <= Maximum_interval
end
Each segment “knows” the schedule of which it is a part, expres sed by the query  
schedule , and its position in that schedule, expressed by index . It has a starting_time  and 
an ending_time ; we could also add a query duration , with an invariant clause expressing  
its relation to the previous two.  Redundancy is acceptable in s ystem analysis provided  
redundant features express concep ts of interest to users or dev elopers, and the relations  
between redundant elements are s tated clearly th rough the invar iant. Here , clauses in_list
and in_schedule  of the invariant express the re lation between a segment’s own index  and 
its position in the sched ule’s list of segments.
A segment also knows about the  segment that will follow , next. Invariant clauses  
again express the consistency requirements: clause next_in_list  i n d i c a t e s  t h a t  i f  t h e  
segment is at position i the next one is at position i +1; clause no_next_iff_last , that there  
is a next if and only if the segment is  not the last in its schedule.
The last two invariant clauses express constraints on durations : sufficient_duration
defines a minimum duration of 30  seconds for a program fragment  to deserve being called  
a segment, and decent_interval  a m ax im u m  of  tw o s ec on ds  fo r t he  t im e  be tw ee n t w o  
successive segments  (when the TV scre en may go blank).
The class specification has taken two shortcuts that would almo st certainly have to  
be removed at the next iteration  of the analysis process. First , times and durations have  
been expressed as integers, measured in seconds; this is not ab stract enough, and we  
should be able to rely on library classes DATE , TIME  and DURATION . Second, the notion  
of SEGMENT  covers two separate notions: a TV program fragment, which can be defined  
independently of its scheduling ti me; and the scheduling of a c ertain program  at a certain  
time slot. To separate these two notions is easy; just add to SEGMENT an attribute
content : PROGRAM_FRAGMENT
§27.4   PROGRAMMING A TV STATION 911
with a new class PROGRAM_FRAGMENT  describing the conten t independently of its  
scheduling. Feature duration  should then  appear in PROGRAM_FRAGMENT , and a new  
invariant clause of SEGMENT  should state
content   duration = ending_time – starting_time
For brevity the rest of this sketch continues to treat the cont ent as part of the segment.  
Such discussions are typical of what goes on during the analysi s process, aided by the  
object-oriented method: we examine various abstractions, discus s whether they justify  
different classes, move features to other classes if we think t hey have been misassigned.
A segment has a primary sponsor, and a rating. Although here to o we might benefit  
from a separate class, rating  has just been specified as an i nteger, with the  convention tha t 
a higher rating implies more res trictions; 0 means a segment ac cessible to al l audiences.
Programs and commercials
Probing the notion of SEGMENT  further, we distinguish two kinds: program segments and  
commercial breaks (advertizing se gments). This immediately sugg ests using inheritance:
T h i s  u r g e  t o  u s e  i n h e r i t a n c e  d u r ing analysis, by the way, is al ways suspect; you  
should be wary of bouts of taxom ania, prompting you to create s purious classes where  
simple distinctive properties wo uld suffice. The guiding criter ion was given in the  
description of inherit ance: does each propos e d  c l a s s  r e a l l y  c o r respond to a separate  
abstraction, characterized by sp ecific features and properties?  Here the answer will be yes;  
it is not difficult to think of features for bot h programs and commercials, as will be listed  
in part below. Using inheritance will also yield the benefit of  openness: we can add a new  
heir such as INFOMERCIAL  later to describe segments of a different kind.
We can start COMMERCIAL  as follows:
note
description : "Advertizing segment "
deferred class  COMMERCIAL inherit
SEGMENT
rename sponsor  as advertizer endPROGRAMSEGMENT
COMMERCIAL
See “TAXOMA-
NIA”, 24.4, page 820.
OBJECT-ORIENTED ANALYSIS  §27.4 912
feature
primary : PROGRAM deferred end  
-- Program to which this commercial is attached
primary_index : INTEGER deferred end  
-- Index of primary
set_primary (p: PROGRAM )
-- Attach commercial to  p.
require
program_exists : p /= Void
same_schedule : p  schedule = schedule
before : p  starting_time <= starting_time
deferred
ensure
index_updated : primary_index = p  index
primary_updated : primary = p
end
invariant
meaningful_primary_index : primary_index = primary   index
primary_before : primary   starting_time <= starting_time
acceptable_sponsor : advertizer   compatible (primary   sponsor )
acceptable_rating : rating <= primary   rating
end
Note the use of renaming, anothe r example of a notational facil ity that at first sight  
might have appeared to be useful  mostly for impl ementation-leve l classes, but turns out to  
be just as necessary f or modeling. When a segment is a commerci al, it is more appropriate  
to refer to its sponsor  as being its advertizer .
Every commercial segment is attached to an earlier program segm ent (not a  
commercial), its primary , whose index in the schedule is primary_index . The first two  
invariant clause s express consistency conditions; the last two express compatibility rules:
• If a show has a sponsor, any ad vertizer during that show must be acceptable to it; you  
do not advertize for Pe psi-Cola during a sh ow sponsored by Coca -Cola. The query  
compatible  of class COMP ANY  might be given thr ough some database.
• The rating of a commercial must be compatible with that of its  primary program: you  
should not advertize for Bulldozer Massacre III on a toddlers’ program.
The notion of primary  needs refinement. It becomes cle ar at this stage  of our analys is 
that we should really add a leve l: instead of a schedule being a succession of program  
segments and commercials, we sh ould view it as a succession of shows, where each show  
(described by a class SHOW ) has its own features, such as the show’s sponsor, and a  
s u c c e s s i o n  o f  s h o w  s e g m e n t s  a n d  c o m m e r c i a l s .  S u c h  i m p r o v e m e n t  a nd refinement,  
developed as we gain more insight into the problem and learn fr om our first attempts, are  
a normal component of the analysis process.
§27.4   PROGRAMMING A TV STATION 913
Business rules
We have seen how invariant clauses and other assertions can cov er semantic constraints  
of  th e a pp li c at io n d om a in ,  a ls o known in analysi s parlance as business rules : in class  
SCHEDULE , that one can schedule a segm ent only in the future; in SEGMENT , that the  
interruption between two segment s may not exceed a preset durat ion; in COMMERCIAL , 
that a commercial’s rating must be compatible with that of the enclosing program.
It is indeed one of the principa l contributions of the method t hat you can use  
assertions and the principles of Design by Contract to express such rules along with the  
structure, avo iding both the cloud s and the precipice.
A practical warning however: eve n without any implementation co mmitment, there  
is a risk of overspecification. In assertions of the analysis t ext, you should only include  
business rules that have a high d egree of certainty and durabil ity. If any rule is subject to  
change, use abstraction to expre ss what you need but leave room  for adaptation. For  
example the rules on sponsor-advertizer compatibility can chang e; so the invariant of  
COMMERCIAL  stays away from overspecification by simply postulating a bool ean-
valued query compatible in class COMP ANY . One of the great advantages of analysis is  
that you choose what you say and  what you say not. State what i s known — if you specify  
nothing, the specification will n ot be of much interest — but n o more. This is the same  
comment that we encountered in the discussion of abstract data types: we want the truth,  
all the relevant t ruth, but nothing more  than the truth.
That ADT comments should be directly applicable here is no surp rise: ADTs are a high-
level specification technique, and in fact the use of deferred classes with their assertions  
as a tool for analysis, illustrated by the TV station example, is conceptually a variant of  
ADT specification using software syntax.
Assessment
Although we have only begun the TV station programming example,  we have gone far  
enough to understand th e general principles  of the approach. Wh at is striking is how  
powerful and intuitive the concep ts and notation are for genera l, software-independent  
system modeling, even though the y were initially developed (in earlier chapters) for  
software purposes and, to the su perficial observer, may even ap pear to address just  
programming  issues. Here they come out in their full scope: as a general-p urpose method  
and notation for describing systems of many kinds, covering the  structure of systems as  
well as fine aspects of their semantics, and able to tackle com plexity as well as evolution.
Nothing in a specification of the  kind illustrated above is imp lementation-related, or  
even software-related, or even computer-related. We are using t he concepts of object  
technology for purely descriptive  purposes; no co mputer need en ter the picture.
Of course if you or your customer do decide to go ahead and bui ld a software system  
for managing TV station programmi ng, you will have the tremendo us advantage of a  
description that is al r e a d y  i n  a  s o f t w a r e - like form, syntactica lly and structurally. The  
transition to a design and implementation will proceed seamless ly in the same framework;  
you may even be able to retain many of the analysis classes as is in the final system, with  
implementations provided  in proper descendants.
OBJECT-ORIENTED ANALYSIS  §27.5 914
27.5  EXPRESSING THE ANALYSIS: MULTIPLE VIEWS
The use of specifications express ed in a software -like language , illustrated by the TV  
station example, raises an obviou s question of practicality in normal industrial  
environments.
What can cause some skepticism is that the people who will have  to review the  
analysis document may not all be comfortable with such notation s; more than any other  
stage, analysis is the time for collaboration with application domain experts, future users,  
managers, contract administrators . Can we expect to them to rea d a specification that at first  
sight looks like a software text (although it is a pure model),  and possibly contribute to it?
Surprisingly often, the answer is  yes. Understanding the part o f the notation that  
serves for analysis, as illustra ted by the preceding example, d oes not require in-depth  
software expertise, simply an un derstanding of e lements of the basic laws of logic and  
organized reasoning in any discip line. I can attest to having u sed such specifications  
successfully with people of widel y different backgrounds and ed ucation.
But this is not the end of the story. A core of formalism-avers e people may remain,  
whose input you will still need. And even those who appreciate the power of t he formalism  
will need other views, in particu lar graphical re presentations.  In fact the recurrent fights  
about graphics versus formalism, formalism versus natural langu age, are pointless. In  
practice the description of a non-trivial system requires several  complementary views,  
such as:
• A formal text, as illustrated  in the preceding example.
• A graphical representation, sho wing system structures in terms  of “yy-bubble and  
arrow” diagrams (also used in one instance for the example). He re the graphs will  
show classes, clusters, objects , and relations such as client a nd inheritance.
• A natural-language re quirements document.
• Perhaps a tabular form, as appe ars in the prese ntation of the BON method below.
Each such view has its unique ad vantages, addressing some of th e multiple goals of  
analysis defined at the beginnin g of this chapter; each has lim itations that may make it  
irrelevant to other g oals. In particular:
•Natural-language documents are irreplaceable for conveying esse ntial ideas and  
explaining fine nuances. But they are notoriously prone to impr ecision and  
ambiguity, as we saw in the crit ique of the “underline the noun s” approach.
• Tabular representations are use ful to collect a set of related  properties, such as the  
principal characteristics of a c lass — parents, features, invar iant.
• Graphical representations a re excellent for describing structural  properties of a  
problem or system by s howing the components and their relations . This explains the  
success of “yy-bubble-and-arrow”  descriptions as promoted by “s tructured  
analysis”. But they are severely  limited when it comes to expre ssing precise  
semantic properties, as required by item A 3 of the list of analysis goals (answering  
specific questions). For example a graphical description is not  the best place to look  “STUDYING A 
REQUIREMENTS DOCUMENT”, 22.1, page 720 .
§27.5   EXPRESSING THE ANAL YSIS: MULTIPLE VIEWS 915
at for an answer to the question “ what is the maximum length of a commercial  
break ?”.
• Formal textual representations,  such as the notation of this b ook, are the best tool for  
answering such precise  questions, although they cannot compete with graphical  
representation when the goal is simply to get a quick understan ding of how a system  
is organized.
The usual argument for graphical representations over textual o nes is the cliché that “a  
picture is worth a thousand words”. It has its share of truth; block diagrams are indeed  
unsurpassed to convey to the reader the overall impression of a  structure. But the proverb  
conveniently ignores the details that the words can carry, the imprecision that can affect  
the picture, and the errors  that it can contain. The next time someone invites you to use a 
diagram as the final specification of some delicate aspect of a  system, look at the comics  
page of the daily paper: the “find the differences between thes e two variants” teasers do  
not ask you to rack your eyes and brain over two sentences or t wo paragraphs, but to find  
the hidden differences between two deceptively similar pictures .
So what we need with a good analysis method is a way to use eac h one of these views  
as the need arises, switching freely from one to the other.
The question then arises of how to maintain cons istency between  the various views.  
The solution is to use one of th e views as the reference, and t o rely on software tools to  
make sure that additions and chan ges get propagated to all view s. The best candidate to  
serve as reference — the only credible one, in fact — is the fo rmal text, precisely because  
it is the only one that is both defined rigorously and able to cover semantic s as well as  
structural properties.
With this approach, the use of f ormal software-like description s is not exclusive of  
other styles, and you can use a variety of tools adapted to the  expertise levels and personal  
tastes of the analysis participa nts (software people, managers,  end users). For the formal  
text, the software development e nvironment may be appropriate: we have seen in  
particular that the compiler can double as an analysis support tool thanks to its facilities  
for checking type rules  and other validity constraints, althoug h its code generation  
mechanism is irrelevant at this stage. For the graphical notati on, you will use a graphical  
CASE tool, apt at producing and manipulating structure charts. For the natural language  
texts, document manipulation and management systems can help. T ables can also have  
specific tool support. The various  tools involved can be either  separate or integrated in an  
analysis or development workbench.
Graphical or tabular input will immediately be reflected in the  formal representation;  
for example if the graphi cal view showed a class C inheriting from a class A
Inheritance 
link
CA B
OBJECT-ORIENTED ANALYSIS  §27.5 916
and you interactively redirect the arrow to point to B, the tools will aut omatically change  
the inherit  clause of the formal text to reflect the change. Conversely, i f you edit the  
formal description, the graphical and tabular representations w ill be updated.
It is more difficult for tools to process changes in natural-la nguage descriptions. But  
if the document manipulation syst em enforces structured system descriptions, with  
chapters, sections and paragraphs, it is pos sible to keep links  between the formal text and  
the natural-language requirements document, for example to indi cate that a certain class  
or feature is connected to a cer tain paragraph of the requireme n t s ;  t h i s  i s  p a r t i c u l a r l y  
useful when the envir onment also provides co nfiguration managem ent tools, so that when  
something changes in the require ments the tools can, if not upd ate the formal description,  
at least alert you to the change and produce a list of all the elements that depended, directly  
or indirectly, on the modified part.
The other direction is interesti ng too: producin g natural-langu age descriptions from  
formal texts. The idea is simply to reconstruct, from a formal system description, a  
natural-language text that would express the same information i n a form that will not scare  
the more formalism-ave rse members of the target readership. It is not hard indeed to think  
of a tool that, starting from ou r analysis sketch, would produc e a fake English form such as
1. System concepts
The concepts of this system are:
SCHEDULE , SEGMENT , COMMERCIAL , PROGRAM …
SCHEDULE  is discussed in section 2; SEGMENT is discussed in section 3; [etc.]
2. The notion of  SCHEDULE
…
3. …
4. The notion of  COMMERCIAL
4.1 General description:
Advertizing segments
4.2 Source notions.
The notion of COMMERCIAL is a specialized c ase of the notion
of SEGMENT and has all its operati ons and properties,
except for redefined o nes as listed below.
4.2 Renamed operations.
What is called sponsor for SEGMENT is called advertizer  for COMMERCIAL .
…
4.3 Redefined operations
…
4.4 New operations
The following operations characterize a COMMERCIAL :
primary , a query returning a PROGRAM
Needs: none [Arguments, if any, wo uld be listed here]
Description:
Program to which commercial is attached
Input conditions:
§27.6   ANALYSIS METHODS 917
…
Result conditions:
…
… Other operations …
4.5 Constraints
… An English-like rendition of the invariant properties …
4. The notion of  PROGRAM
…
etc.
All the English sentences (“ The concepts of this system are ”, “The following  
operations characterize a …” and so on) are drawn from a standard set of predefined  
formulae, so they are not really “natural” language; but the il lusion can be strong enough  
to make the result palatable to non-technical people, with the guarantee that it is consistent  
with the more formal view since it has been mechanically derive d from it.
Although I do not know any tool t hat has explored this idea ver y far, the goal seems  
reachable. A project to build such a tool would be several orde rs of magnitude more  
realistic than long-going efforts  in the reverse direction (att empts at automatic analysis of 
natural-language requirements documents) which have never been able to produce much,  
because of the inherent difficu lty of analyzing natural languag e. Here we are interested in  
natural language generation , an easier task (in the same way that speech synthesis has  
progressed faster than speech recognition).
What makes this possible is the generality of th e formal notati on and, especially, its  
support for assertions, allowing  us to include useful semantic properties in the generated  
natural-language texts. Without assertions we would remain in t he vague — in the clouds.
27.6  ANALYSIS METHODS
Here is a list of some of the best-known methods of O-O analysi s, listed in the approximate  
order of their public appearance. Although the description focu ses on the analysis  
component of the methods, note that most of them also include d esign-related or even  
implementation-related component s. The short summaries cannot d o justice to the methods;  
to learn more, see the books and Web pages listed in the biblio graphic notes to this chapter.
The Coad-Yourdon  method initially resulted fro m an effort to objectify ideas  
c o m i n g  f r o m  s t r u c t u r e d  a n a l y s i s .  I t  i n v o l v e s  f i v e  s t a g e s :  f i n d i ng classes and objects,  
starting from the application do main and analyzing system respo nsibilities; identifying  
structures by looking for genera lization-specialization and who le-part relationships;  
defining “subjec ts” (class-object groups ); defining attributes;  defining services.
The OMT  method (Object Modeling Techniq ue) combines concepts of object  
technology with those of entity-r elation modeling. The method i ncludes a static model,  
based on the concepts of class , attribute, operation, relation and aggregation, and a  
dynamic model based on event-stat e diagrams, describing in an a bstract way the intended  
behavior of the system.
OBJECT-ORIENTED ANALYSIS  §27.6 918
The Shlaer-Mellor  method is original in its emphasis on producing models that le nd 
themselves to simulation and ex ecution, making it possible to v alidate model behavior  
independently of any design or implementation. To separate conc erns, it divides the problem  
into a number of domains: appli cation domain, service domains ( such as the user interface  
domain), software architecture domain, implementation domains ( such as operating system  
or language). Rather than seamless development, its model for t he development process uses  
translation to link the domains t ogether into code for final sy stem construction.
The presence of architecture, des ign and implementation models in Shlaer-Mellor and  
some of the following methods illustrates the comment made abov e that the methods’  
ambition often extends beyond analysis to cover a large part of  the lifecycle, or all of it.
In the Martin-Odell  method, also known as OOIE (Object-Oriente d Information  
Engineering), analysis consists of two parts: object structure analysis, which identifies the  
object types and their compositi on and inheritance relations; a nd object behavior analysis,  
which defines the dynamic model by considering object states an d the events that may  
change these states. The events are considered first, leading t o the identification of classes.
The Booch  method uses a logical model (class and object structure) and a  physical  
model (module and process archit ecture), including both static and dynamic components,  
and relying on numerous graphica l symbols. It is intended to be  subsumed by the “Unified  
Modeling Languag e” (see below).
The OOSE  method (Object-Oriented Softwar e Engineering), also known as  
Jacobson’s method or as Objectory, the name of the original sup porting tool, relies on use  
cases (scenarios) to elicit class es. It distingui shes five use case models: domain object  
model, analysis model (the use c ases structured by the analysis ), design model,  
implementation mod el, testing model.
The OSA  method (for Object-oriented Sys tems Analysis) is meant to prov ide a 
general model of the analysis process rather than a step-by-ste p procedure. It consists of  
three parts: the object-relations hip model, which describes obj ects and classes as well as  
their relations — with each other  and with the “real world”; th e object-behavior model,  
which provides the dynamic view through states, transitions, ev ents, actions and  
exceptions; and the obj ect-interaction mode l, specifying possib le interactions between  
objects. The method also supports a notion of view, as well as generalization and  
specialization, which apply to bo th the interacti on and behavio r models.
The Fusion  method seeks to combine some of the best ideas of earlier meth ods. For  
analysis it includes an object m odel, devoted to the problem do main, and an interface  
model, describing system behavio r. The interface model is itsel f made of an operation  
model, specifying even ts and the resulting operations, and a li fecycle model, describing  
scenarios that guide the evolutio n of the system. Analysts shou ld maintain a data  
dictionary which collects all th e information from the various models.
The Syntropy  method defines three mode ls: the essential model “ is a model of a real  
or imaginary situation , [having nothing ] to do with software : it describes the elements of  
the situation , their structure and behavior ”. The specification model is an abstract model  
that treats the system as a stimulus-response mechanism, assumi ng unlimited hardware  
resources. The implementation m odel takes into account the actu al computing environment.  
Each model may be expressed along several views: a type view de scribing object types and  
their static properties; state v iews, similar to the state tran sition diagrams of OMT, to  See “Use cases”, 
page 738 .
Citation from the 
Syntropy Web page listed in the bibliog-raphy section .
§27.7   THE BUSINESS OBJECT NOTATION 919
describe dynamic behavior; and mechanisms diagrams for implemen tation. The method  
also supports a notion of viewpoint to describe various interfa ces to the same objects, going  
beyond the mere separat ion of interface and implementation prov ided by O-O languages.
The MOSES  method involves five models: obje ct-class; event, showing clas s 
collaboration by describing what  messages are triggered as a re sult of calling a service on  
an object; “objectcharts”, to mo del state-transition dynamics; inheritance; and service  
structure, to show data flow. Lik e the Business Object Notation  r e v i e w e d  i n  t h e  n e x t  
section, MOSES emphasizes the im portance of contracts in specif ying a class, using  
preconditions, p ostconditions and invari ants in the style of th e present book. Its “fountain”  
process model defines a number of  standard documents to be prod uced at each stage.
The SOMA  method (Semantic Object Modeling  Approach) uses a “Task Object  
Model” to capture the requirement s and transforms them into a “ Business Object Model”.  
It is one of the few methods to have benefited from formal appr oaches, using a notion of  
contract to de scribe business rules applying to objects.
At the time of writing, two separate efforts are progressing to  unify existing methods.  
One, led by Brian Henderson-Sellers, Don Firesmith, Ian Graham and Jim Odell, is  
intended to prod uce an OPEN (the retained name) unified method.  The other, by Rational  
Corporation, is starting from th e OMT, Booch and Jacobson metho ds to define a “Unified  
Modeling Language”.
27.7  THE BUSINESS OBJECT NOTATION
Each of the approaches listed in the preceding sections has its  strong points. The method  
that seems to provide the most be nefit for the least complexity  is Nerson’s a nd Waldén’s  
Business Object Notation; let us take a slightly closer look at  it to gain some insight into  
what a comprehensive approach to O-O analysis requires. This br ief presentation will only  
sketch the principal features of the method, limiting itself to  its contributio n to analysis;  
for more details, and to explore design and implementation aspe cts, see the Waldén-
Nerson book cited in the bibliography.
The Business Object Notation started as a graphical formalism f or representing  
system structures. The original name was kept, even though BON has grown from just a  
notation to a complete developmen t method. BON has been used in  many different  
application areas for the analys is and developmen t of systems, some very complex.
BON is based on three principles: seamlessness , reversibility  a n d  contracting . 
Seamlessness is the use of a con tinuous process t hroughout the software lifecycle.  
Reversibility is the support for  both forward and backward engi neering: from analysis to  
design and implementation, and  back. Contracting (remember Design by Contract ) is the  
precise definition, for each so ftware element, of the associate d semantic properties; BON  
is almost the only one among the p opular analysis methods to us e a full-fledged assertion  
mechanism, allowing analysts to specify not only the structure of a system but also its  
semantics (constraints, invariant s, properties of  the expected results).
Several other pr operties make BON stand out among O-O methods:
• It is meant to “scale up”, in th e sense explained at the begin ning of this chapter.  
Various facilities and conventions enable y ou to choose the lev el of abstraction of a  
OBJECT-ORIENTED ANALYSIS  §27.7 920
system or subsystem description, to zoom in on a component, to hide parts of a  
description. This selective hidi ng is preferable, in my opinion , to the use of multiple  
models illustrated by some of th e preceding meth ods: here, for seamlessness and  
reversibility, you keep a single  model; but you can at any time  decide what aspects  
are relevant to your needs of the moment, and hide the rest.
• BON, created in the nineteen-nineties, was designed under the assumption that its  
users would have access to computing resources, not just paper and whiteboards.  
This makes it possible to use po werful tools to display complex  information, free  
from the tyranny of fixed-size areas such as paper pages. Such a tool is sketched in  
the last chapter of th is book. For small exa mples, the method c an of course be used  
with pencil and paper.
• For all its ambition, especially its ability to cover large an d complex systems, the  
method is notable for its simplic ity. It only involves a small number of basic  
concepts. Note in particular that the formalism can be describe d over two pages; the  
most important elements appear  below and on the facing page.
BON’s support for large systems r elies in part on the notion of  cluster , denoting a  
group of logically related class es. Clusters can include subclu sters, so that the result is a  
nested structure allowing analys ts to work on various levels at  different times. Some of the  
clusters may of course  be libraries; the met hod puts a strong e mphasis on reuse.
The static part of the model focuses on classes and clusters; t he dynamic part  
describes objects, object interac tions and possible scenarios f or message sequencing.
BON recognizes the nee d for several complementary formalisms, e xplained earlier  
in this chapter. (The assumed av ailability of software tools is  essential here: with a manual  
process, multiple views would ra ise the issue of how to maintai n the consistency  of the  
model; tools can ensure it auto matically.) The f ormalisms inclu de a textual notation, a  
tabular form and graphical diagrams.
The textual notation  is similar to the notation of t his book; but since it does not  have 
to be directly compilable, it ca n use a few extensions in the a rea of asserti ons, including  
delta  a to specify that a feature can change an attribute a, forall and exists  to express logic  
formulae of first-order predic ate calculus, and set operators s uch as member_of .
The tabular form  is convenient to summarize the properties of a class compactly . 
Here is the general fo rm of a tabular class chart:
CLASS Class_name Part:
Short description Indexing information
Inherits from
Queries
Commands
ConstraintsFor further discus-
sion of clusters see “CLUSTERS”, 28.1, page 923 .
“Constraints” are 
invariants .
§27.7   THE BUSINESS OBJECT NOTATION 921
The graphical notation is extreme ly simple, so as to be easy to  learn and remember.  
The principal conven tions, static as wel l as dynamic, appear below. 
Main diagram 
types of the 
Business Object Notation 
(After  
[Waldén 1995] , 
used with 
permission .)
NAME NAMENAME
[G, H]∗NAME+
NAME
NAME NAMEClass : generic,  effective, deferred, re used, persistent, interfaced, roo t.

NAMESTATIC DIAGRAMS
NameInter-class relations
Inherits from
Client
Expanded client
(aggregation)Cluster (with some classes)
3 23Multiplicity of relations
InvariantInherits:  
   Parent classes
Public features
A, B, 
Features selectively
exported to  A, B
Class invariantNAMEClass : detailed interface
Features
name *, name+, name++deferred, effective, redefined
→name : TYPE input argument
     precondition, postcondition ? !
Assertion operators
Δ name feature may change attribute name  
@, ýýý∅ current object, v oid reference
∃, ∀, |,    symbols for predicat e calculus operations
∈, ∉ membership operators
DYNAMIC DIAGRAMS
NameObject group (wi th some objects) Object 
Objects
(one or more)Name
Name
Inter-object relations
Message passingname
name
7
(with message number from scenario)
OBJECT-ORIENTED ANALYSIS  §27.8 922
The method defines a precise process for analysis and developme nt, consisting of  
seven tasks. The order of tasks corresponds to an ideal process , but the meth od recognizes  
that in practice it is subject to  variation and iteration, as i mplied in fact by the very concept  
of reversibility. The standard tasks are:
B1  •Delineate system borderline : identify what the syst em will include and not  
include; define major subsystems , user metaphors, functionality , reused libraries.
B2  •List candidate classes : produce first list of class es based on problem domain.
B3  •Select classes and group into clusters : organize classes in logical groups, decide  
what classes will be deferred, p ersistent, externally interface d etc.
B4  •Define classes : expand the initial definition of classes to specify each of t hem in  
terms of queries, comma nds and constraints.
B5  •Sketch system behavior : define charts for object creation, events and scenarios.
B6  •Define public features : finalize class interfaces.
B7  •Refine system .
Throughout the proc ess, the method prescribes keeping a glossary of terms of the  
technical domain. Experience show s this to be an essential tool  for any large application  
project, both to give non-expert s a place to go when they do no t understand some of the  
domain experts’ jargon, and to make sure that the experts actua lly agree on the terms (it is  
surprising to see how often the process reveals that they do no t!).
More generally, the method speci fies for each step is a precise  list of its deliverables:  
documents that the manager is en titled to expect as a result of  t h e  s t e p ’ s  w o r k .  T h i s  
precision in defining organizational respons ibilities makes BON  not only an analysis and  
design method but also a strategi c tool for project management.
27.8  BIBLIOGRAPHY
The principal reference on the Business Object Notation is [Waldén 1995] . The basic  
concepts were introduced in [Nerson 1992] . A Web page is available at www .tools .com/
products /bon/.
Here are the principal references  on other methods, with associ ated Web addresses.  
Coad-Yourdon: [Coad 1990] , www .oi.com; OMT:  [Rumbaugh 1991] ; Shlaer-Mellor  
[Shlaer 1992] , www .projtech .com; Martin-Odell, [Martin 1992] ; Booch: [Booch 1994] ; 
OOSE: [Jacobson 1992] ; OSA: [Embley 1992] , osm7 .cs.byu.edu/OSA.html; Syntropy:  
[Cook 1994] , www .objectdesigners .co.uk/syntropy ; Fusion, [Coleman 1994] ; MOSES:  
[Henderson-Sellers 1994] , www.csse.swin.edu.au/cotar/OPEN/OPEN.html ; SOMA,  
[Graham 1995] .
On the OPEN method convergence project see [Henderson-Sellers 1996] ; 
[Computer 1996]  is a discussion of Rational’s U nified Modeling Language effort  (Booch-
OMT-Jacobson).
Katsuya Amako maintains a set of descriptions of O-O methods, a long with other  
useful O-O information, at arkhp1 .kek.jp/~amako /OOInfo .html.Add the ritual http:// 
as a prefix to all Web addresses .
28  
The software construction process
F oremost among the methodological  issues of object technology is  how it affects the  
broader picture of software deve lopment. We will now examine th e consequences of  
object-oriented princi ples on the organization of projects and their division into phases.
Such a presentation is part of a more general topic: the manage ment perspective on  
object technology. Another book, Object Success , explores management issues in detail.  
The discussion which follows, drawing in part from Object Success , presents the essential  
ideas: clusters , the basic organizational unit; principles of concurrent engineering
leading to the cluster model of the software lifecycle; steps a nd tasks of that model; the role  
of generalization  for reusability; and the principles of seamlessness  and reversibility .
28.1  CLUSTERS
The module structure of the obje ct-oriented method is the class . For organizational  
purposes, you will usually need t o group classes into collectio ns, called clusters — a  
notion briefly previewed in the last chapter’s s ketch of the Bu siness Object Notation.
A cluster is a group of related classes or, recursively, of rel ated clusters.
The two cases are exclusive: for simplicity and ease of managem ent, a cluster that  
contains subclusters should not have any classes of its own. So  a cluster will be either a  
basic cluster , made of classes, or a supercluster , made of other clusters.
Typical basic clusters could include a parsing cluster for anal yzing users’ text input,  
a graphic cluster for graphical manipulations, a  communications  cluster. A basic cluster  
will typically have somewhere between five and forty classes; a t around twenty classes,  
you should start thinki ng about splitting it  into subclusters. The cluster is also the natural  
unit for single-developer master y: each cluster should be manag ed by one person, and one  
person should be able to understand all of it — whereas in a large development no one can  
understand all of a system or  even a major subsystem. 
Clusters are not super-modules. In an ea rlier chapter we saw the argumen ts for  
avoiding the introduction of uni ts such as packages, and instea d keeping a single module  
mechanism, the class.[M 1995].
On super-modules see
“The architectural role of selective exports”, page 209 .
THE SOFTWARE CONSTRUCTION PROCESS  §28.2 924
Unlike packages, clusters are no t a language construct, althoug h they will appear in  
the Lace control files used to assemble systems out of componen ts. They are a  
management tool. The responsibili ty for finding c lusters will r est with the project leader;  
less challenging than the task o f finding classes, studied in d etail in a previous chapter,  
clustering classes mos tly relies on common sense and the projec t leader’s experience. This  
point actually deserves  some emphasis, as it is sometimes misun derstood: the truly  
difficult job, which can launch a project on to an auspicious l ife or wreck it, and for which  
o n e  c a n  t a l k  o f  r i g h t  a n d  w r o n g  s olutions, is to identify the c lasses (the proper data  
abstractions); groupin g these classes into clusters is an organ izational matter, for which  
many solutions are possible, dep ending on the resources availab le and on the expertise of  
the various team members. A less-than-optimal clustering decisi on may cause trouble and  
slow the development, but will not by itself  bring the project down.
28.2  CONCURRENT ENGINEERING
One of the consequences of the d ivision into clusters is that w e can avoid the  
disadvantages of the all-or-nothing nature of traditional softw are lifecycle models. The  
well-known “waterfall” approach , introduced in 1970, was a reac tion against the “code it  
now and fix it later” approach o f that bygone era. It had the m erit of separating concerns,  
of defining the princi pal tasks of software engineering, and of  emphasizing the importance  
of up-front specification and design tasks.On Lace see “Assem-
bling a system”, page 198.
The waterfall 
model
(WARNING : this is 
not the recom-
mended process model for O-O de-
velopment !)FEASIBILITY
STUDY
REQUIREMENTS
ANALYSIS
SPECIFICATION
IMPLEMEN-
DISTRIBUTIONGLOBAL
DESIGN
DETAILED
DESIGN
TATION
V ALIDATION &
VERIFICATION
TIME
§28.2   CONCURRENT ENGINEERING 925
But the Waterfall Model also suf fers (among other  deficiencies)  from the rigidity of  
its approach: taken literally, it would mean that no design can  proceed until all the  
specification is complete, no implementation until all design i s complete. This is a certain  
recipe for disaster: one grain o f sand in the machine, and the whole project comes to a halt.
Various proposals such as the Spiral model have attempted to re duce this risk by  
providing a more iterative appro ach, But they retain the one-th r e a d  a p p r o a c h  o f  t h e  
Waterfall, which hardly reflects the nature of today’s software  development, especially for  
large “virtual” teams that may be distributed over many sites, communicating through the  
Internet and other “electron ic collocation” mechanisms.
Successful object-oriented dev elopment needs to support a concurrent engineering
scheme, offering decentralization  and flexibility, without losi ng the benefits of the  
waterfall’s orderliness. We will  in particular have to retain a  sequential component, with  
well-defined activities . Object-oriented de velopment does not m ean that we can or should  
get rid of sound engin eering practices. If a nything, the added power of the method requires  
us to be more organized than before.
With a division into clusters we can achieve the right balance between sequentiality  
and concurrent engineering. We w ill have a sequential process, but subject to backward  
adjustments (this is the concept of reversibility, discussed in  more detail at the end of this  
chapter), and  applied to clusters  rather than to the entire system.
The mini-lifecycle gove rning the developmen t of a cluster may p ictured as this:
The shape of the activity represe ntations suggests the seamless  nature of the  
development. Instead of separate  s t e p s  a s  i n  t h e  w a t e r f a l l  m o d e l, we see an accretion  
process — think of the figure as  depicting a stalactite — in wh ich every step takes over  
from the previous one and adds its own contribution.Individual 
cluster 
lifecycle
Generali-zationImplementationDesignSpecification
V & V
TIME
THE SOFTWARE CONSTRUCTION PROCESS  §28.3 926
28.3  STEPS AND TASKS
The steps listed in the mini-li fecycle of each cluster are:
• Specification: identify the clas ses (data abstractions) of the  cluster and their major  
features and constraints (yielding invariant clauses).
• Design: define the architecture  of the classes and their relat ions.
• Implementation: finalize the cl asses, with all details added.
• Verification & Validation: check  that the cluster’s classes pe rform satisfactorily  
(through static examination, testing and other techniques).
• Generalization: prepare  for reuse (see below).
Given the high-level of abstraction of the method, the distinct ion between design and  
implementation is not always clear-cut. So a variant of the mod el merges these two steps  
into one, “design-implementation”.
The need remains for two system-wide, cluster-independent phase s. First, as with  
any other approach, you should perform a feasibility study , resulting in a go or no-go  
decision. Then, the project needs to be divided into clusters; t h i s  i s ,  a s  n o t e d ,  t h e  
responsibility of the project le ader, who can of course rely on  the help of other experienced  
team members.
28.4  THE CLUSTER MODEL OF THE SOFTWARE LIFECYCLE
The general development scheme, known as the Cluster Model, app ears on the facing  
page. The vertical axis represen ts the sequential component of the process: a step that  
appears lower than another will be executed after it. The horiz ontal direction reflects  
concurrent engineering: tasks at the same level c an proceed in parallel.
Various clusters, and various steps within each cluster, will p roceed at their own pace  
depending on the difficulty of the task. The project leader is in charge of deciding when to  
start a new cluster or a new task.
The result is to give the project leader the right combination of order and flexibility.  
Order because the definition of cluster tasks provides a contro l framework and control  
points against which to assess p rogress and delays (one of the most difficult aspects of  
project management); flexibility  because you can buffer unexpec ted delays, or take  
advantage of unexpectedly fast p rogress, by starting activities  sooner or later. The project  
leader also controls the degree of concurrent engineering: for a small team, or in the early  
stages of a difficult project, t here may be a small number of p arallel clusters, or just one;  
for a larger team, or once the basic existential questions seem s to be under control, you  
can start pursuing seve ral clusters at once.
Better than traditional approach es, the cluster model enables p roject leaders to do  
their job to its full extent, ex erting their decision power to devote resources where they are  
needed the most.
§28.4   THE CLUSTER MODEL OF THE SOFTWARE LIFECYCLE 927
To avoid divergence, the current  states of the various clusters ’ development must be  
regularly reconciled. This is the task of integration , best performed at preset intervals, for  
example once a week. It is the responsibility of the project le ader, and ensures that at every  
stage after start-up  there will be a current demo , not necessarily up to date for all aspects  
of the system, but ready to be s howed to whoever — customers, m anagers... — needs  
reassurance about the project’s progress. This also serves to r emove any inconsistency  
between clusters before it has ha d the opportunit y to cause dam age, reassuring the project  
members themselves that the piec es fit together and that the fu ture system is taking shape.
What makes possible the cluster model’s form of concurrent engi neering is the set of  
information hidi ng properties of the obj ect-oriented method. Cl usters may depend on each  
other; for example a graphical interface cluster may need, for remote display , classes of  
the communication cluster. Thanks  t o  d a t a  a b s t r a c t i o n ,  i t  i s  p o s s i b l e  f o r  a  c l u s t e r  t o  
proceed even if the clusters on which it depends are not yet fi nished; it suffices that the  
specification  phase of the needed classes be complete, so that you can proce ed on the basis  FEASIBILITY STUDY
TIMECluster 2
Cluster nCluster 1
Generali-zationImplementationDesignSpecification
V & VDIVISION INTO CLUSTERS
Generali-zationImplementationDesignSpecification
V & V
Generali-zationImplementationDesignSpecification
V & VThe cluster 
model of the 
software 
lifecycle
THE SOFTWARE CONSTRUCTION PROCESS  §28.5 928
of their official inte rface, given as a short form or deferred version. This aspect of the  
model is perhaps easier to picture if we rotate the preceding f igure, as illustrated below, to  
emphasize the software layers co rresponding to the various clus ters, with the more general  
clusters at the bottom and the mo re application-sp ecific ones a t the top. The design and  
implementation of each cluster d epend only on the specification s of clusters below it, not  
on their own design and implemen tation. The figure only shows d ependencies on the  
cluster immediately below, but a  cluster may rel y on any lower- level cluster. 
28.5  GENERALIZATION
The last task of cluster mini-li fecycles, genera lization (the G  on the above figure) has no  
equivalent in traditional approa ches. Its goal i s to polish the  classes so as to turn them into  
potentially reusable s oftware components.
Including a generalization step immediately suggests a criticis m :  i n s t e a d  o f  a n  a  
posteriori add-on, should reusab ility concerns n ot be part of t he entire software process?  
How can one make software reusable after the fact? But this cri ticism is misplaced. The a  TIMECluster 2Cluster n
Cluster 1 I D S V&V GI D S V&V GI D S V&V G
More
More generalapplication-
specific
Client
dependencyA project’s 
clusters as a set 
of abstraction 
layers
§28.5   GENERALIZATION 929
priori view of software reuse (“ to be reusable, software should  be designed as reusable  
from the start”) and the a posteriori view (“software will not be reusable the first time  
around”) are complementary, not c ontradictory. The success of a  reusability policy  
requires both instilling a reusability culture  in the minds of everyone involved, and  
devoting sufficient res ources to improving t he reusability of c lasses’ initial versions.
In spite of the best of intentions, software elements produced as part of an  
application-oriented project wil l usually not be fully reusable . This is due in part to the  
constraints affecting projects — the pressure of customers want ing the next version ASAP,  
of the competition putting out it s own products, of shareholder s eager to see results. We  
live in a hurried world and an e ven more hurried industry. But there is also an intrinsic  
r e a s o n  f o r  n o t  a l w a y s  t r u s t i n g  r e usability promises: until some one has reused it, you  
cannot be sure that a product has been freed of all its depende ncies, explicit and  
(particularly) implici t, on its original developers’ background , corporate affiliation,  
technical context, working pract ices, hardware resources and so ftware environment.
The presence of a gener alization step is not, then, an excuse f or ignoring reusability  
until the last moment. The arguments of the a priori school are  correct: you cannot add  
reusability as an afterthought. But do not assume that having a  reusability policy is  
sufficient. Even with reusability built into everyone’s mindset , you will need to devote  
some more time to your project’s classes before you can call th em software components.
Including a generalization step in the official process model i s also a matter of policy.  
Very few corporate executives these days will take a public sta nd against  reusability. Of  
course, my friend, we want our s oftware to be reusable! The sof tware people need to find  
out whether this is sincere commitment or lip service. Very eas y. The commitment exists  
if management is ready to reserve some  resources, on top of the money and time allocated  
to each project, for generalization. This is a courageous decis ion, because the benefits may  
not be immediate and other urgent projects may suffer a little.  But it is the only way to  
guarantee that there will, in the end, be reusable components. If, however, the management  
is not ready to pledge such res ources, even modest ones (a few percent above the normal  
project budget can make a world of difference), then you can li sten politely to the grandiose  
speeches about reuse and read sympathetically about the “reuser  of the month” award in  
the company’s newsletter: in truth, the company is not ready fo r reusability and will not  
get reusability.
If, on the other hand, some resources are devoted to generaliza tion, remember that  
this is not sufficient either. Su ccess in reusabi lity comes fro m a combination of a priori and  
a posteriori efforts:
The reusability culture
Develop all software under the a ssumption that it will be reuse d.
Do not trust that any software w ill be reusable until you have seen it reused.
THE SOFTWARE CONSTRUCTION PROCESS  §28.6 930
The first part implies applying reusability concerns throughout  development. The  
second implies not taki ng the result for gr anted, but performin g a generalization step to  
remove any traces of con text-specific elements.
The generalization task may involve the following activities:
•Abstracting : introducing a deferred class to  describe the pure abstraction  behind a  
certain class.
•Factoring : recognizing that two classes, originally unrelated, are in fa ct variants of  
the same general notion, which can then be descr ibed by a commo n ancestor.
• Adding assertions, es pecially postconditions and invariant cla uses which reflect  
increased understanding of the semantics of the class and its f eatures. (You may also  
have to add a precondi tion, but this is more akin to correcting  a bug, since it means  
the routine was not properly protected.)
• Adding rescue clauses to handle exceptions who se possibility may initially ha ve 
been ignored.
• Adding documentation.
The first two of these activitie s, studied in the discussion of  inheritance  
methodology, reflect the non-sta ndard view of inheritance hiera rchy construction that we  
explored then: the rec ognition that, although it would be nice always to go from the  
general to the specific and the abstract to the concrete, the a ctual path to invention is often  
more tortuous, and sometimes just the other  way around.
The role of generalization is to improve classes that may be co nsidered good enough  
for internal purposes — as long, that is, as they are only used  within a particular system —  
but not any more when they become part of a library available t o any client author who  
cares to use them for his own n eeds. Peccadillos that may have been forgivable in the first  
setting, such as insufficient specification or reliance on undo cumented assumptions,  
become show-stoppers. This is wh y developing for reusability is  more difficult than  
ordinary application development: when your software is availab le to anyone, working on  
applications of any kind for any platform anywhere in the world , everything starts to  
matter. Reusability breeds perfe ctionism; you cannot leave good  enough alone.
28.6  SEAMLESSNESS AND REVERSIBILITY
The “stalactite” nature of the cluster lifecycle reflects one o f the most radical differences  
between O-O development and earli er approaches. Instead of erec ting barriers between  
successive lifecycle steps, we ll-understood object technology d efines a single framework for  
analysis, design, implementation and maintenance. This is known  as seamless development ; 
one of its consequences, previewe d in the last chapter’s discus sion of the Business Object  
Notation, is the need for a reversible  software development process.On abstracting and 
factoring see “Variet-ies of class abstrac-tion”, page 860.
§28.6   SEAMLESSNESS AND REVERSIBILITY 931
Seamless development
Different tasks will of course remain. To take extreme examples , you are not doing the  
same thing when defining general properties of a system that ha s yet to be built and  
performing the last rounds of de bugging. But the idea of seamle ssness is to downplay  
differences where the traditional approach exaggerated them; to  recognize, behind the  
technical variations, the fundam ental unity of t he software pro cess. Throughout  
development the same issues arise, the same intellectual challe nges must be addressed, the  
s a m e  s t r u c t u r i n g  m e c h a n i s m s  a r e  n e e d e d ,  t h e  s a m e  f o r m s  o f  r e a s o ning apply and, as  
shown in this book, the same notation can be used.
The benefits of a seamle ss approach are numerous:
• You avoid costly and error-prone  transitions between steps, ma gnified by changes in  
notation, mindset, and personnel (analysts,  designers, implemen ters...). Such gaps  
are often called impedance mismatches  by analogy with a circuit made of  
electrically incompatible elemen ts; the mismatches between anal ysis and design,  
design and implementation, imple mentation and ev olution, are am ong the worst  
causes of trouble in traditio nal software d evelopment.
•By starting from the analysis classes as a basis for the rest o f the development, you  
ensure a close correspondence between the description of the pr oblem and the  
solution. This direct mapping property  helps the dialog with customers and users,  
and facilitates evolution by ensuring that they all think in te rms of the same basic  
concepts. It is part of  the O-O method’s su pport for extendibil ity.
• T h e  u s e  o f  a  s i n g l e  f r a m e w o r k  f a c i l i t a t e s  t h e  b a c k w a r d  a d j u s t m ents that will  
inevitably accompany the normal ly one-directional progress of t he software  
development process.
Reversibility: wisdom sometimes blooms late in the season
The last benefit cited defines one of the principal contributio ns of object technology to the  
software lifecycle — reversibility.
Reversibility is the official ac ceptance of a characteristic of  software development  
which, although inevitable and u niversal, is one of the most cl osely guarded secrets of the  
software literature: the influen ce of later stages of the softw are process on decisions made  
during initial stages.
We all wish, of course, that problems be fully defined before w e get to solve them.  
That is the normal way to go, an d in software it means that we complete the analysis before  
w e  e n g a g e  i n  d e s i g n ,  t h e  d e s i g n  b e f o r e  w e  s t a r t  i m p l e m e n t a t i o n ,  t h e  i m p l e m e n t a t i o n  
before we deliver. But what if, during implementation, a develo per suddenly realizes that  
the system could do something be tter, or should do something di fferent altogether? Do we  
scold him for not minding his own  business? What if his suggest ion is indeed right?“Direct Mapping”, 
page 47.
THE SOFTWARE CONSTRUCTION PROCESS  §28.6 932
The phrase esprit de l’escalier , “wit of the staircase”, captures this phenomenon.  
Picture a pleasant dinner in an apartment on the second or four th floor (the fashionable  
ones) of a Parisian building. Sha rp comments fly back and forth  over the veal Marengo,  
and you feel dumb. The soirée finishes and you take leave of yo ur hosts, start walking  
down the stairs, when … there it is: the smashing repart ee that would ha ve made you the  
hero of the evening! But too late.
Are bouts of esprit de l’escalier  too late in software also? They have existed ever  
since software projects have b een told to freeze the specificat ion before they start on a  
solution. Bad managers suppress them, telling the implementers,  in effect, to code and shut  
up. Good managers try t o see whether they can take advantage of  belated specification  
ideas, without attracting the at tention of whoever is in charge  of enforcing the company’s  
software quality plan and its wate rfall-style ukases against ch anging the specification at  
implementation time.
With O-O development it becomes clear that the esprit de l’escalier phenomenon is  
not just the result of laziness in analysis, but follows from t he intrinsic nat ure of software  
development. Wisdom sometimes bl ooms late in the season. Nowher e more than with  
object technology do we see the intimate connection between pro blem and solution that  
characterizes our field. It is not just that we sometimes under stand aspects of the problem  
only at the time of the solution , but more profoundly that the solution affects the problem  
and suggests better functionalities. 
Remember the example of command undoing and redoing: an impleme ntation  
technique, the “history list” — which someone trained in a more  t ra di t io na l a pp r oa ch  
would dismiss as irrelevant to t he task of defining system func tionality — , actually  
suggested a new way of providing  end-users of our system with a  convenient interface for  
undoing and redoing commands.
The introduction of reversibility  suggests that the general for ward thrust of our  
earlier cluster mini-lifecycle diagrams is actually tempered by  the constant possibility of  
backward revisions and corrections:The bad managers 
may be uncon-sciously applying another escalier  
aphorism , Clem-
enceau’s “in love, 
the best moment is in the stairs”  — 
beforehand , that is.
Chapter 21 .
Individual 
cluster 
lifecycle , 
reversible
Generali-zationImplementationDesignSpecification
V & V
§28.7   WITH US, EVERYTHING IS THE FACE 933
28.7  WITH US, EVERYTHING IS THE FACE
The stress on seamlessness and r eversibility is perhaps the mos t potentially subversive  
component of object technology. It affects project organization , and the very nature of the  
software profession; in line wit h modern trends in other indust ries, it tends to remove  
barriers between narrow specialti e s  —  a n a l y s t s  w h o  o n l y  d e a l  i n  ethereal concepts,  
designers who only worry about s tructure, implementers who only  write code — and to  
favor the emergence of a single category of generalists: developers in a broad sense of the  
term, people who are a ble to accompany part of a project from b eginning to end.
The approach also departs from t he dominant view in the current  s o f t w a r e  
engineering literature, which tr eats analysis and implementatio n (with design somewhere  
in the middle) as fundamentally different activities, susceptib le to different methods, using  
different notations and  pursuing different goals, often with th e connotation that analysis  
and design are all that really mat ters, implementation being an  inevitable chore. This view  
has historical justifications: fr om its infancy in the nineteen -seventies, software  
engineering was an attempt to pu t some order into the haphazard  nature of program  
construction by teaching softwar e people to think before they s hoot. Hence the stress on  
early stages of softwa r e  d e v e l o p m e n t ,  o n  t h e  n e e d  t o  s p e c i f y  w h at you are going to  
implement. This is all justified, now as much as then. But some  of the consequences of  
t h i s  e s s e n t i a l l y  b e n e f i c i a l  e f f o r t  h a v e  g o n e  t o o  f a r ,  c r e a t i n g  impedance mismatches  
between the different activities, and producing a strictly sequ ential model even though  
product and process quality demand s seamlessness and reversibil ity.
With object technology we can rem ove the unnecessary difference s between  
analysis, design and im plementation — the n ecessary ones will m anifest themselves  
clearly enough — and rehabilitate the much maligned task of imp lementation. It was  
natural for the pioneers of software engineering, when programm ing meant trying to solve  
many machine-dependent issues an d explaining the  result to the computer in a language  
that it could understand, usually low-level and sometimes inele gant, to detach themselves  
from these mundane aspects and st r e s s  i n s t e a d  t h e  i m p o r t a n c e  o f  studying abstract  
concepts from the problem domain . But we can retain these abstr action qualities without  
losing the link to the solution.
The secret is to make the concep ts of programming, and the nota tions for  
programming, high-level enough th at they can serve just as well  as tools for modeling . 
This is what object technology achieves.
The following story, stole n from Roman Jakobson’s Essays on General Linguistics , 
will perhaps help ma ke the point clear:
In a far-away country , a missionary was scolding the natives . “You should not  
go around naked , showing your body like this !”. One day a young girl spoke  
back , pointing at him : “But you , Father , you are also showing a part of your  
body !”. “But of course” , the missionary said with a dignified tone ; “That is my  
face” . The girl replied : “So you see , Father , it is really the same thing . Only ,
with us , everything is the face” .
So it is with object technology.  With us, everyth ing is the fac e.
THE SOFTWARE CONSTRUCTION PROCESS  §28.8 934
28.8  KEY CONCEPTS COVERED IN THIS CHAPTER
• Object technology calls for a new process model, supporting se amless, reversible  
development.
• The unit for the sequential com ponent of the lifecycle is the cluster, a set of logically  
related classes. Clusters can be arbitrarily nested.
• T h e  l i f e c y c l e  m o d e l  r e l i e s  o n  c oncurrent engineering: parallel  development of  
several clusters, each permitted  to rely on the specification o f earlier ones.
• Object technology rehab ilitates implementation.
28.9  BIBLIOGRAPHICAL NOTES
[M 1995]  discusses further the topics of  this chapter. I t develops in d etail the cluster  
model, and explores the consequences of the object-oriented sof tware process on team  
organization, on the manager’s ro le, and on the economics of so ftware engineering.
[Baudoin 1996]  is an extensive discussion of the lifecycle issues raised by o bject 
technology, also cover ing many other import ant topics such as p roject organization and  
the role of standards, and inc luding several  case studies. 
The first presentation of the cluster model appeared in [Gindre 1989] . Another O-O  
lifecycle model, the fountain model , originally appeared in [Henderson-Sellers 1990]  and is  
further developed in [Henderson-Sellers 1991] , [Henderson-Sellers 1994] ; it complements  
rather than contradicts the clus ter model, emphasizing the need  to iterate lifecycle activities.
A number of O-O analysis pub lications, in particular [Rumbaugh 1991]  (the original  
text on the OMT method) and [Henderson-Sellers 1991] , stress seamless development.  
For a detailed treatment of reve rsibility as well as seamlessne ss, see [Waldén 1995] .
***
Wisdom sometimes blooms late in the season
Or half-way down the stairs .
Is it, my Lords , a crime of high treason
To trust the implementers ?
29  
Teaching the method
E nding our study of methodological issues, we turn our attention  to one of the principal  
questions facing companies and un iversities that adopt object t echnology: how best to  
educate those who will have to a pply it. This chapter presents teaching principles and  
points to common errors.
The first part of the discussion takes the view of someone who is in charge of  
organizing a training program in  a company; the following parts  take the view of a  
university or high school professor. All emphasize the pedagogi cal issues of O-O training,  
and so they should be relevant to  you even if you are in neithe r of these positions — in  
particular if you a re a trainee rathe r than a trainer.
29.1  INDUSTRIAL TRAINING
Let us start with a few general observations about how to teach  object technology — either  
in public seminars or as part of  an in-company training plan — to software professionals  
previously trained in other approaches.
Paradoxically, the trainer’s task may be harder now than when o bject technology  
started to attract wide interest  in the mid-eighties. It was ne w then to most people, and  
had an aura of heresy which made the audience listen. Today, no  one will call security if  
one of the cocktail guests decla res object-orien ted tastes. Thi s is the buzzword effect,  
which has been dubbed mOOzak : the omnipresence, in the computer press, of O-O this  
and O-O that, causing a general dilution of the concepts. The w ords flow so c ontinuously  
from the loudspeakers — ob ject, class, polymorphism … — as to seem familiar, but are  
the concepts widely un derstood? Often not. This puts a new burd en on the trainer:  
convincing the trainees that the y do not yet know everything, s ince no one can learn a  
subject who thinks h e already knows it.
The only strategy guaranteed to overcome this pro blem applies t he following plan:
Initial training: the “hit them twice” strategy
T1 • Take the initial training courses.
T2 • Try your hand at O-O development.
T3 • Take the initial training courses.
TEACHING THE METHOD  §29.1 936
T3 is not a typo: after having trie d to apply O-O ideas to real d evelopment, trainees  
take the class again. O-O traini ng companies sometimes suggest this strategy to their  
customers, not always with succe ss since it susp iciously looks like a marketing  ploy to sell  
the same thing twice. But that is not the case.
The second iteration is what rea lly gets the concepts through. Although the first is  
necessary to provide the right ba ckground, it may not be fully effective; partly because of  
the mOOzak effect, your students may not quite internalize the concepts. Only when they  
have grappled with the day-to-day challenges of object-oriented  software construction —  
Is a new class necess ary for this concept ? Is this a proper use of inheritance ? Do these two  
features justify introd ucing a new node in the inheritance structure ? Is this design pattern  
from the course  relevant here ? — will they have the necessary preparation to listen  
properly. The second session will not, of course, be identical to the first (if anything, the  
audience’s questions will be mor e interesting), and might strad dle the border between  
training and consulting; but it i s really a second presentation  of the same basic material —  
not merely an advanced course following an elementary one.
In practice only the more enlightened companies are ready to ac cept the “teach it once,  
then teach it again” strategy. Others will dismiss the idea as a waste of resources. In my  
experience, however, the result is well worth the extra effort.  The strategy is the best I  
know to train developers who truly understand object technology  and can apply it  
effectively to serve the company’s needs.
The next principle addresses what  should be taught:
Some people assume that the cur riculum should start with object -oriented analysis.  
This is a grave mistake. A begin ner in object technology cannot  understand O-O analysis  
(except in the mOOzak sense of recognizing the buzzwords). To m aster O-O analysis, you  
must have learned the fundamenta l concepts — class, contracts, information hiding,  
inheritance, polymorphism, dynami c binding and the like — at th e level of  
implementation, where they are immediately applicable, and you must have used them to  
build a few O-O systems, initially small and then growing in si ze; you must have taken  
these projects all the way to co mpletion. Only after such a han ds-on encounter with the  
operational use of the  method will you be equipped to understan d the concepts of O-O  
analysis and their role in the seamless process of object-orien ted software construction.
Two more principles. F irst, do not limit you rselves to introduc tory courses:
Finally, do not consider developers alone:Training Topics principle
Especially in in itial training, focus on implementation and des ign.
Advanced Curriculum principle
At least 50% of a training budget should be reserved for non-in troductory  
courses.
§29.2   INTRODUCTORY COURSES 937
It is unrealistic, for a company  or group that is adopting obje ct technology on any  
scale, to hope to succeed by train ing developers only. Managers , regardless of the depth  
of their technical bac kground, must be intr oduced to the basic O-O ideas and apprised of  
their repercussions on  distribution of tasks, team organization , project lifecycle,  
economics of software development. The lifecycle discussion of the next chapter and,  
more exhaustively, management-oriented books such as [Goldberg 1995] , [Baudoin 1996]
and [M 1995] , are typical of the material to  be covered in such (usually sh ort) courses.
Here is an example of what manager education must include to av oid potential trouble,  
allow effective development and benefit the bottom line. The in dustry’s measures of  
productivity are still largely based, deep-down, on ratios of p roduced code to production  
effort. In a reuse-conscious software process, you may spend so me time improving  
software elements that  already work well to increase their potential for reuse in future  
projects. This is the generaliza tion task, an important step of  the lifecycle model  
presented in the next chapter. Often, such efforts will remove code, for example because  
you have given a common ancestor to two originally unrelated cl asses, moving  
commonality to that ancestor. In the productivity ratio, the nu merator decreases (less  
code) and the denominator increases (more effort)! Managers mus t be warned that the old  
measures do not tell the whole story, and that the extra effort  actually improves the  
software assets of the company. Without such preparation, serio us misunderstandings  
may develop, jeopardizing the su ccess of the best planned techn ical strategies.
29.2  INTRODUCTORY COURSES
Let us turn our attention now to the teaching of object technol ogy in an academic  
environment (although m any observations will  also be applicable  to industrial training).
As the software community recog nizes the value of the object-or iented approach, the  
question increasingly arises of when, where and how to include object-oriented concepts,  
languages and tools in a softwar e curriculum – university, coll ege or even high school. 
Phylogeny and ontogeny
When should we start?
The earlier the better. The obje ct-oriented met hod provides an excellent intellectual  
discipline; if you agree with its goals and techniques, there i s no reason to delay bringing  
i t  t o  y o u r  s t u d e n t s ;  y o u  s h o u l d  i n  f a c t  t e a c h  i t  a s  t h e  f i r s t  a pproach to software  
development. Beginning students react favorably to O-O teaching , not because it is trendy,  
but because the m ethod is clear and effective. 
This strategy is preferable to a  more conservative one whereby you would teach an  
older method first, then unteach  it in order to introduce O-O thinking. If you think object-
oriented development i s the right way to go,  there is no reason  to make a detour first. Manager Training principle
A training curriculum should inc lude courses for managers as we ll as 
software developers.
TEACHING THE METHOD  §29.2 938
Teachers may unconsciously tend to apply an idea  that was once popular in biology:  
that ontogeny (the story of the individual) repe ats phylogeny ( the story of the species); a  
human embryo, at various stages of its development, vaguely loo ks like a frog, a pig etc.  
Transposed to our subject, it means that a teacher who first le arned Algol, then went on to  
structured design and finally di scovered objects may want to ta ke his students through the  
same path. There is little justi fication for suc h an approach, which in elementary education  
would make students first learn to count in Roman numerals, onl y later to be introduced  
to more advanced “meth odologies” such as Ara bic numerals. If yo u think you know what  
the right approach is , teach it first. 
Paving the way for other approaches
One of the reasons for recommending (without fear of fanaticism  or narrow-mindedness)  
the use of object tec hnology right from the start is that, beca use the method is so general,  
it prepares students for the later introduction of other paradi gms such as logic and  
functional programming – which sh ould be part of any software e ngineer’s culture. If your  
curriculum calls for the teaching of traditional programming la nguages such as Fortran,  
Cobol or Pascal, it is  also preferable to introduce these later , as knowledge of the object-
oriented method will enable stud ents to use them in a safer and  more reasoned way. 
O-O teaching is also good preparation for a topic which will be come an ever more  
prevalent part of software educa tion programs: formal approache s to software  
specification, construction and verification, rooted in mathema tics and formal logic. The  
use of assertions and more gener ally of the Design by Contract approach is, in my  
experience, an effective way to raise the student s’  awareness o f the need for a sound,  
systematic, implementation-indep endent and at least partially f ormal characterization of  
software elements. Premature exp osure to the full machinery of a formal specification  
method such as Z or VDM may over whelm students and cause reject ion; even if this does  
not occur, students are unlikely to appreciate the merits of fo rmality until they have had  
significant software development experience. Object-oriented so ftware construction with  
Design by Contract enables stude nts to start producing real sof tware and at the same time  
to gain a gentle, progressive e xposure to for mal techniques.
Language choice
Using the object-orien ted method for introductory courses only makes sense if you can  
rely on a language and an environment that fully support the pa radigm, and are not  
encumbered by ghosts of the past . Note in particular that “hybr id” approaches, based on  
object-oriented extensions of ol der languages, are unsuitable f or beginning students, since  
they mix O-O concepts with unrelated remnants from other method s, forcing the teacher  
to spend much of the time on e xcuses rather than concepts.
In C-based langua ges, for example, just e xplaining why an array  and a pointer have  
to be treated as the same notion — a property having its roots in optimization techniques  
for older hardware architectures  — would consume precious time and energy, which will  
not be available for teaching the concepts of software design. More generally, students  
§29.2   INTRODUCTORY COURSES 939
would be encouraged, at the very  beginning of their training, t o reason in terms of low-
level mechanisms – addresses, pointers, memory , signals. They w ould inevitably spend  
much of their time, if they event ually produce a compilable pro gram, chasing various  
bugs. The approach would leave the  students perple xed and might  end up in disaster. 
An introductory course must do t he reverse: pres ent the student s with a clear,  
coherent set of practical principles. The notation must directl y support these principles,  
ensuring a one-to-one corresponde nce between method and languag e. Any time you spend  
explaining the language per se i s time lost. With a good langua ge, you explain the  
concepts, and use the n otation as the natur al way to apply them .
Although the main quali ty of an introductory language is its st ructural simplicity and  
its support of O-O ideas such as class-based modularization, de sign by contract, static  
typing and inheritance, you shoul d not underestimate the role o f syntactic clarity. C++ and  
Java texts are replete  with lines such as 
public static void main (String [] args {
if (this– >fd == –1 && !open_fd (this))
if ((xfrm = (char ∗)malloc (xfrm_len + 1 )) == NULL ) {
showing cryptic and confusing syntax relying on many special op erators. Beginners should  
not be subjected to such contortions, justified only by histori cal considerations; learning to  
program well is hard enough without  the interposed obstacle of a hostile notation.
David Clark from the University of Canberra went through this e xperience and  
posted some of his co nclusions on Usenet:
Last semester I taught the second half of a first year programming [course] using 
Java … My experience has been that stude nts do not find Java easy to learn . Time and  
again the language gets in the way of what I want to teach . Here are some examples :
• The first thing they see is public static void main  (String  [ ] args) throws  IOException
There are about 6 different concepts in that  one line which students are not yet ready  
to learn … 
• You get output for “free” , but have to jump through several hoops to input anything .
(import , declare , initialize .). The only way to read a number from the keyboard is to  
read a string and parse it . Again , this is something that cr ops up in the first lecture .
• Java treats the primitive data types (int, char, boolean , float, long,…) differently from  
other objects . There are Object-type equivalents (Integer , Boolean , Character etc.).
There is no relation between int and Integer . 
•T h e  String  class is a special case . (Again , for efficiency .) It is only used for strings  
that don't change . There is a StringBuffer  class for strings that do change . Fair 
enough . but there is no relationship between String  and StringBuffer . There are few  
features in common . 
• The lack of generics means that you are fo rever casting if you want to use a collection  
of elements such as Stack  or Hashtable . [These things ] are hurdles for beginning  
students , and distract them from the main learning outcomes of the course .
Prof. Clark goes on to compare t his experience with his practic e of teaching with the  
notation of this book, for which, he writes, “ I do virtually no language teaching beyond  
giving some ex amples of code ”.Examples from the 
basic book on Java , 
[Arnold 1996 ].
Exceprts from post-
ing of 15 October 1996 .
TEACHING THE METHOD  §29.3 940
The initial notations taught to students, so important to their  future vision, must  
always be simple and clear, to a llow in-depth un derstanding of the basic concepts. Even  
Pascal, the traditional choice o f computing scie nce departments  for introductory teaching,  
is preferable in this respect to  a hybrid language since it pro vides a solid, consistent basis,  
from which students can later mo ve to another solid, consistent  approach. It is of course  
even better, as note d, if the basis can be solid, consistent and O-O.
Some hybrid languages a re industrially impor tant; but they shou ld be taught later,  
when students have mastered the basic concepts. This is not a n ew idea: when computing  
science departments ad opted Pascal in the nineteen-seventies, t hey also included service  
courses to teach Fortran, Cobol o r PL/I as requested by industr y then. Similarly, a modern  
object-based curriculum may include a C++ or Java service cours e to satisfy downstream  
requirements and enable the stud ents to include the required bu zzwords on their résumés.  
Students will understan d C++ and Java better anyway after havin g been taught the  
principles of object technology using a pure O-O language. Intr oductory courses, which  
shape a student’s mind forever, m ust use the best  technical app roach.
Some teachers are tempted to use  C hybrids because of perceived  industry pressures.  
But this is inappropriat e for several reasons:
• Industry demands are notoriously volatile. A few years ago, ad s were all for things  
like RPG and Cobol. In late 1996 they were all for Java, but in  1995 no one had heard  
of Java. What will they list in 2010 or 2020? We do not know, b ut we must endow  
our students with capabilities th at will still be marketable th en. For this we must  
emphasize long-term design skill s and intellectu al principles.
• Starting with these skills and principles does not exclude tea ching specific approaches  
later. In fact it helps, as already noted. A student who has be en taught O-O concepts  
in depth, using an appropriate notation, will be a better C++ o r Java programmer than  
one whose first encounter with programming involved fighting wi th the language.
• The historical precedent of Pas cal around 1975 shows that comp uting science  
teachers can succeed with their own choices. At that time, no o ne in industry  
requested Pascal; in fact, almos t no one in indu stry had heard of Pascal. Industry, if  
anything, would have r equested one of the Three Tenors of the m oment: Fortran,  
Cobol and PL/I. The computing sc ientists chose to go with the b est technical  
solution, correspondi ng to the state of the art in programming methodology  
(structured programming). The res ult proved them right, as they  were able to teach  
students the abstract concepts a nd techniques of software devel opment while  
preparing them for learnin g new languages and tools.
29.3  OTHER COURSES
Beyond introductory courses, the  object-oriented method can pla y a role at many stages  
of a software curriculum. Let us  review the corr esponding uses.  
§29.3   OTHER COURSES 941
Terminology 
The organization of higher educat ion differs widely among count r i e s .  T o  a v o i d  a n y  
confusion we must firs t decide on a reasona bly universal termin ology to denote the  
various levels of study. Here is  some attempt at common ground:  
• High school (US), lycée, Gymnas ium, called seco ndary education  below. 
• First few years of university o r equivalent: this is called “u ndergraduate studies” in  
the US and other Anglo-Saxon countries ( Gakubu  in Japan). In France and countries  
influenced by its system it corr esponds to either the combinati on of classes  
préparatoires  with the first two years of engineering schools, or to the fir st and  
second cycles  of universities. In the German system it is the Grundstudium . The term  
“undergraduate” will be retained below. 
• Finally for the later years, l eading to advance d degrees, we c an use the US term  
“graduate”. (The rough equivalent s are “postgraduate” in the UK ; third cycle, DEA,  
DESS, options of engineering schools in France; Hauptstudium  in Germany;  
Daigakuin  in Japan.) 
Secondary and undergraduate studies
At the secondary or u ndergraduate le vel the object-oriented met hod can play a central role,  
as noted, in an introductory pr ogramming course. It can also he lp for many ot her courses.  
We may distinguish here between courses that can be entirely ta ught in an object-oriented  
way, and those which w ill benefit from some  partial use of obje ct-oriented ideas. 
Here are some of the s tandard courses that c an be taught in a f ully O-O way:
• Data structures and algorithms. Here the techniques of Design by Contract are  
fundamental: characterizing rout ines by assertions, specifying data structures with  
class invariants, ass ociating loop variant s and invariants with  algorithms. In  
addition, an innovativ e and powerful way to organize such a cou rse is to design it  
around an existing library  of software components from an existing object-oriented  
environment. Then instead of star ting from scratc h students can  learn by imitation  
and improvement. (More on this topic below.) 
• Software engineering. The objec t-oriented method provides an e xcellent framework  
t o  i n t r o d u c e  s t u d e n t s  t o  t h e  c h a llenges of industrial, multi-pe rson software  
development, and to evaluate the  benefits and limitations of pr oject management  
techniques, software metrics, so ftware economics, development e nvironments and  
the other techniques which the s oftware engineer ing literature discusses (in  
complement to object orientation)  as answers to this challenge.  
• Analysis and design. Clearly th is can be taught in a fully O-O  way; again Design by  
Contract is central. Courses should emphasize the seamless tran sition to  
implementation and maintenance.
• Introduction to grap hics; introduction t o simulation; etc.
Courses that may benefit from heavier or lighter object doses i nclude: operating  
systems (where the method helps understand the notion of proces s, the message passing  
paradigm, and the importance of i nformation hiding, clearly def ined interfaces and limited  
communication channels i n the design of prop er system architect ures); introduction to  
TEACHING THE METHOD  §29.4 942
formal methods (as noted above);  functional programming; logic programming (where the  
connection with asserti ons should be emphasized); introduction to artificial intelligence  
(where inheritance is a key conc ept for knowledge representatio n); databases (which  
should reserve a central place for the notion of abstract data type, and include a discussion  
of object-oriented databases). 
Even computer architecture courses are not immune from the infl uence of O-O ideas,  
as concepts of modularity, information hiding and assertions ca n serve to present the topic  
in a clear and convincing manner. 
Graduate courses 
A t  t h e  g r a d u a t e  l e v e l ,  m a n y  O - O  c o u r s e s  a n d  s e m i n a r s  a r e  p o s s i b le, covering more  
advanced topics: concu rrency, distributed systems, persistence,  databases, formal  
specifications, advance d analysis and design methods, configura tion management,  
distributed project manageme nt, program verification. 
A complete curriculum
This incomplete list shows the m ethod as being so ubiquitous th at it would make sense to  
design an entire software curricu l u m  a r o u n d  i t .  A  f e w  i n s t i t u t i ons have made some  
progress in that direction. No d oubt in the years to come someo ne will jump and convince  
the management of some unive rsity to go all the way. 
29.4  TOWARDS A NEW SOFTWARE PEDAGOGY
Not only does object technology affect what can be taught to st udents of software topics;  
the method also suggests new ped agogical techniq ues, which we w ill now explore.
A n  i m p o r t a n t  n o t e :  t h e  s t r a t e g i e s  d e s c r i b e d  i n  t h e  r e s t  o f  t h i s  c h a p t e r  a r e  s t i l l  
somewhat futuristic. I believe that they must and will become p revalent for teaching  
software, but their full applicat ion will require an infrastruc ture which is no t yet fully in  
place, in particular new textboo ks and different administrative  policies.
If you or your institution are not ready to apply such strategi es, this does not mean  
that you should remove objects from your teaching. You can stil l, as described in the  
preceding sections, in still variable doses  of object technology  in your courses while  
retaining compatibility with your current way of teaching. And you should read the rest of  
this chapter anyway since, even if you do not follow its more r adical suggestions, you  
might find an idea or two immediat ely applicable i n a more conv entional context.
The consumer-to-producer strategy
An O-O course on data structures  and algorithms can, as noted a bove, be organized around  
a library. This idea actually h as much broader applications.
A frustrating aspect of many cou rses is that teachers can only give introductory  
examples and exercises, so that students do not get to work on really interesting  
§29.4   TOWARDS A NEW SOFTWARE PEDAGOGY 943
applications. One can only get s o much excitement out of comput ing the first 25 Fibonacci  
numbers, or replacing all occurrences of a word by another in a  text, two typical exercises  
of elementary programming courses. 
With the object-oriented method,  a good O-O environment and, mo st importantly,  
good libraries, a different strat egy is possible if you give st udents access to the libraries  
early in the process. In this ca pacity students are just reuse consumers, and use the library  
components as black b o x e s  i n  t h e  s e n s e  d e f i n ed above; this assu mes that proper  
techniques are availab l e  f o r  d e s c r i b i n g  c o mponent usage without  showing the  
components’ internals.  Then students can start building meaning ful applications early:  
their task is merely to combine existing components and assembl e them into systems. In  
many respects this is a better introduction to the challenges a nd rewards of software  
development than the toy examples  which have been the mainstay of most introductory  
courses. 
Almost on day one of the course,  the students will be able to p roduce impressive  
applications by reusing existing software. Their first assignme nt may involve writing just  
a few lines — enough to call a pr e-built application, and yield ing striking results (devised  
by someone else!). It is desirable, by the way, to use librarie s that include graphics or other  
multimedia components, so as to make the outcome truly dazzling .
Later, students will be invited to go further. First they will be shown, little by little,  
the internals of some of the components. Then  they will be asked to make some extensions  
and modifications, either in the  classes themselves or in new d escendants. Finally  they 
will write their own classes (th e step that would have come fir st in a traditional curriculum,  
but should not occur until they h ave had ample exposure to the work of thei r elders).
This learning process may be called “progressive opening of the  black boxes” or,  
using a shorter name, the consum er-to-producer strategy. (“Outs ide-in” would also be an  
appropriate name.)
If you like automotive comparisons, think of someone who first learns to drive, then is  
invited to lift the hood and study, little by little, how the e ngine works, then will do repairs  
— and, much later, design his own cars.
For this process to work, good ab straction facilities must be p resent, allowing a  
consumer to understand  the essentials of a c omponent without un derstanding all of it. The  
notion of short form  of a class supports this idea by listing the exported features  with their  
assertions, but hiding implement ation properties. After student s have seen and understood  Consumer-to-producer strategy
S1 • Learn to use library classes, sol ely through their abstract spe cifications.
S2 • Learn to understand the int ernals of sele cted classes.
S3 • Learn to extend selected classes.
S4 • Learn to modify selected classes.
S5 • Learn to add your own classes.
TEACHING THE METHOD  §29.4 944
the short form, they may selectively explore the internals of t he class – again under the  
guidance of th e instructor. 
Abstraction
Most good introductory programmi ng textbooks pre ach abstraction . Many in fact include  
the word “abstraction” in their titles. This is because the aut hors, being experienced  
software professionals  and teachers, know that one cannot overc ome the difficulties of  
large-scale software d evelopment without mak ing constant effort s at abstraction.
Often, unfortunately, such preac hing is lost on the students, w ho simply see it as  
another exhortation to “be good”.  You can indeed handle the sma ll programming exercises  
favored by tradi tional teaching methods w ithout too much abstra ction effort. So why pay  
attention to the teacher’s musin gs about the importance of abst raction? They will not, or  
so it seems, improve your Grade Point Average. Only when they h ave moved to larger  
developments would the students be in a pos ition to benefit ful ly from this advice.
To preach is not the best way to teach. With the consumer-to-pr oducer strategy, based  
on libraries, abstraction is not something to pontificate on: i t  i s  a  p r a c t i c a l  a n d  
indispensable tool. Wi thout abstraction, one  cannot use librari es; the alternative would be  
to go into the source code, whic h is overwhelming (you would ne ver get to do your own  
application) and may not be ava ilable anyway. Only through the short form with its high-
level information and assertions — the library module in its ab stract form — can the  
students take a dvantage of a library class.
Having become used, right from th e start, to view classes throu gh abstract interfaces,  
the students will much more easily apply the same principles wh en they start developing  
their own classes.
Note once again that these results are only possible in an envi ronment supporting  
short forms, appropriate documentation and browsing tools, asse rtions, and distribution of  
libraries without the source.
Apprenticeship 
The consumer-to-producer strate gy is the application to softwar e teaching of a time-
honored technique: apprenticeshi p. As an apprentice you learn f rom the previous  
generation of master p ractitioners of your chosen craft, and on ce you have understood  
their techniques you try to do better if you can. For lack of a vailable masters, one-on-one  
apprenticeship is necessarily of limited applicability; but her e we do not need the masters  
themselves, just the r esults of their work , made available as r eusable co mponents. 
This approach is the continuatio n of a trend that had already i nfluenced the teaching  
of some topics in software educa tion, such as compiler construc tion, before object  
technology became  popular. In the seventies and early eighties,  the typical term project for  
a compiler course was the writin g of a compiler (or interpreter ) from scratch. The front-
end tasks of compiler constructi on, lexical analysis and parsin g, require such a large effort  
that in practice the compiler co uld only be for a very small to y language. Even so, few  
s t u d e n t s  e v e r  g o t  p a s t  p a r s i n g  t o  t h e  r e a l l y  i n t e r e s t i n g  p a r t s :  semantic analysis, code  
§29.4   TOWARDS A NEW SOFTWARE PEDAGOGY 945
generation, opti mization. Then tools for  lexical analysis and p arsing, such as Lex and  
Yacc, became widely available, e nabling students to spend less time on these front-end  
tasks. The producer-consumer str ategy generalizes  this change. 
The inverted curriculum
The consumer-to-producer strateg y has an interesting counterpar t in electrical  
engineering, whe re Bernard Cohen has suggested an “inverted cur riculum”. Criticizing  
the classical progression (field theory, then circuit theory, p ower, device physics, control  
theory, digital systems, VLSI de sign) as “reductionist”, the pr oponents of this approach  
suggest a more systems -oriented progr ession, which would succes sively cover:
• Digital systems, usi ng VLSI and CAD. 
• Feedback, concurrenc y, verification. 
• Linear systems and control. 
• Power supply and transmission , impedance matching requirements . 
• Device physics and technologies, using si mulation and CAD tech niques. 
The software education strategy suggested above is similar: rat her than repeating  
phylogeny, start by giving student s a user’s view of the highes t-level concepts and  
techniques that are actually appl ied in industrial environments , then, little b y little, unveil  
the underlying principles. 
A long-term policy 
The consumer-to-producer strategy has an interesting variant ap plicable, for application-
oriented courses such as operating systems, graphics, compiler construction o r artificial  
intelligence, by professors who ar e in a position to define a m ulti-year educ ational plan. 
T h e  i d e a  i s  t o  l e t  s t u d e n t s  b u i l d a system by successive enhanc ement and  
generalization, each year’s clas s taking over the collective pr oduct of the previous year  
and trying to build on it. This method has some obvious drawbac ks for the first class  
(which collectively serves as ad vanceman for future generations , and will not enjoy the  
same reuse benefits), and I must confess I have not yet seen it  applied in a systematic way.  
But on paper at least it is attr active. There hardly seems to b e a better way of letting the  
students weigh th e advantages and difficulties of reuse, the ne ed for buildin g extendible  
software and the challenge of imp roving on someone else’s work.  The experience will  
prepare them for the reality of s oftware development in their f uture company, where  
chances are they will be asked to perform maintenance work on a n existing system long  
before they are asked to develop a brand ne w system of their ow n. 
Even if the context does not per mit such a multi-year strategy,  instructors should try  
to avoid a standard pitfall. Man y undergraduate curricula inclu de a “software engineering”  
course, which often devotes a ke y role to a software project to  be carried out by the  
students, often in groups. Such project work is necessary, but often disappoi nting because  
of the time limitations due to its inclusion in a one-trimester  or one-semester course. When  
TEACHING THE METHOD  §29.5 946
administratively possible, it is  by far preferable to run such a project over an entire  
schoolyear, even if the total amo unt of allocated work is the s ame. Trimester projects, in  
particular, border on the absurd; they either stop at the analy sis or design stage, or result  
over the last few weeks in a rush to code at any cost and using  any technique that will  
produce a running program — often defeating the very purpose of  software engineering  
education. You need more time, i f only to let the students appr eciate the depth of the issues  
involved in building serious softw are. A year-long project, whe ther or not it is part of a  
longer-term policy, favors this process. It is more difficult t o fit into the typical curriculum  
than the standard course , but worth the fight. 
29.5  AN OBJECT-ORIENTED PLAN 
The idea of a long-term teaching strategy based on reuse, as we ll as the earlier suggestion  
of organizing an entire curriculu m around object-o riented conce pts, may lead to a more  
a m b i t i o u s  c o n c e p t  w h i c h  g o e s  b e y o n d  t h e  s c o p e  o f  s o f t w a r e  e d u c a tion to encompass  
research and development. Althoug h this concept will be appeali ng to certain institutions  
only, it deserves a little more thought.
Assume a university department ( computing science, information systems or  
equivalent) in search of a long- term unifying project — the kin d of project that produces  
better teaching, development of new courses, fac ulty research, sources of publication,  
Ph. D. theses, Master’s theses, undergraduate projects, collabo rations with industry and  
government grants.   Many a now well-respected department origi nally “put itself on the  
map” through such a coll ective multi-year effort. 
The object-oriented method provide s a natural basis for such an  endeavor. The focus  
of the work will not be compiler s, interpreters and development  tools (which may already  
b e  a v a i l a b l e  f r o m  companies) but libraries . What object technology needs most to  
progress today is application-orie nted reusable components, als o called domain libraries.  
A good O-O environment will already provide, as noted, a set of  general-purpose libraries  
covering such universal needs as  t h e  f u n d a m e n t a l  d a t a  s t r u c t u r e s and algorithms of  
computing science, gra phics, user interface design, parsing. Th is leaves open entire  
application domains, from Web browsing to multimedia, from fina ncial software to signal  
analysis, from computer-aided de sign to document processing, in  w h i c h  t h e  n e e d  f o r  
quality software com ponents is crying. 
The choice of such a library development project as a unifying effort for a university  
department presents several advantages: 
• Even though this is a long-term pursuit, partial results can s tart to appear early.  
Compilers and other tools tend t o be of the all-or-nothing cate gory: until they are  
reasonably complete, distributin g them may damage your reputati on more than it  
helps it. With libraries, this is not the case: just a dozen or  t w o  q u a l i t y  r e u s a b l e  
classes can render tremendous se rvices to their users, and attr act favorable attention. 
• Because an ambitious library is  a large project, there is room  for many people to  
contribute, from advan ced undergraduates to Ph. D. candidates, researchers and  
§29.6   KEY CONCEPTS STUDIED IN THIS CHAPTER 947
professors. This assumes of cour se that the application domain and the breadth of the  
library’s coverage have been cho sen judiciously so as to match the size of the  
available resources in peo ple, equipment and funds. 
• Talking about resources, the project may start with relatively  limited means but is a  
prime candidate to attract the a ttention of funding agencies. I t also offer s prospects  
of industry funding if the application domain is of direct inte rest to companies. 
•Building good libraries is a tec hnically exciting task, which r aises new scientific  
challenges, so that the output o f a successful project may incl ude theses and  
publications, not just software.  The intellectual challenges ar e of two kinds. First the  
construction of reusable components is one of the most interest ing and difficult  
problems of software engineering , for which the method brings s ome help but  
certainly does not answer all qu estions. Second, any successful  application library  
must rest on a taxonomy  of the application domain, requiring a long-term effort at  
classifying the known concepts i n that area. As is well known i n the natural sciences  
(remember the discussion of the history of taxonomy), classific ation is the first step  
towards understa nding. Developed for a n ew application area, su ch an effort, known  
as domain analysis , raises new and int eresting problems. 
• The last comment suggests the po ssibility of inter-disciplinar y cooperation with  
researchers in various  application domains , usually non-softwar e.
• Cooperation should begin with p eople working in neighboring fi elds. Many  
universities have two groups pursuing teaching and research in software issues, one  
(often “ computing science ” )  h a v i n g  m o r e  o f  a n  e n g ineering and scientific  
background, the other (often “ information systems ”) more oriented towards business  
issues. Whether these groups are  administratively separate or p a r t  o f  t h e  s a m e  
structure — both cases are common — the project may appeal to b oth, and provides  
an opportunity for collaboration. 
• Finally, a successful  library providing components for an impo rtant application area  
will be widely used and bring mu ch visibility to its originatin g institution. 
No doubt in the years to come a number of universities will sei ze on these ideas, and  
that the “X University Reusable Financial Components” or “Y Pol ytechnic Object-
Oriented Text Processing Library ” will (with better names than t h e s e )  b r i n g  t o  t h e i r  
institutions the modern equivale nt of what UCSD Pascal, Waterlo o Fortran and the MIT’s  
X Window system achieved in earlier eras for their respective s ponsors. 
29.6  KEY CONCEPTS STUDIED IN THIS CHAPTER
• In object-orient ed training, emphasize i mplementation and desi gn.
• In initial training for profess ionals, do not hesitate to repe at a session, with some time  
in-between for a ctual practice.
• Training in a company should in clude courses for managers as w ell as developers.See “APPENDIX: 
A HISTORY OF TAXONOMY”, 24.15, page 864 .
TEACHING THE METHOD  §29.7 948
• Beginning programming courses, a nd many others, may take advan tage of O-O  
techniques.
• For teaching, use a pure O-O lan guage, clear and simple, suppo rting the full extent  
of the technology, in pa rticular assertions.
• Courses should, as mu ch as possible, be ba sed on libraries of reusable components.
• The consumer-to-produ cer strategy ( similar to “inverted curric ulum” ideas),  
presents students with existing components, enabling them to wr ite advanced  
applications right from the sta rt, then lets students open the components, extend  
them, and produce new components by imitat ion through an appren ticeship process.
• More generally, a long-term library effort can be a unifying p roject for a department.
29.7  BIBLIOGRAPHICAL NOTES
The material in this chapter is derived from an article in the Journal of Object-Oriented  
Programming , of which a revised version was presented at TOOLS USA 93 and appears  
in the proceedings (see [M 1993c]  for the two references). Further material about education  
and training issues appears in the book Object Success [M 1995] , from which the term  
mOOzak  is taken, as well as some obs ervations regarding industry trai ning. 
Important articles about teaching  programming using O-O concept s include  
[McKim 1992]  and [Heliotis 1996] .
The notion of inverted curriculum for education in electrical e ngineering is due to  
Bernard Cohen [Cohen 1991] . I am grateful to Warren Yates, chairman of the Electrical  
Engineering Department at Univer sity of Technolo gy, Sydney, for  b r i n g i n g  i t  t o  m y  
attention. This chapter also ben efited from discussions with ma ny educators, including  
Christine Mingins, James McKim, Richard Mitchell, John Potter, Robert Switzer, Jean-
C la ud e B ou ss a rd ,  R og er  R ous s ea u,  David Riley, Ric hard Wiener, F iorella De Cindio,  
Brian Henderson-Seller s, Pete Thomas, Ray W eedon, John Kersthol t, Jacob Gore, David  
Rine, Naftaly Minsky, Peter Löhr, Robert Ogor, Robert Rannou.
An ongoing project is intended to pr oduce an introd uctory progr amming book-cum-
CD applying the “consumer-to-pro ducer strategy”, or “inverted c urriculum” principle [M 
199?] . But there are already a number  of good introdu ctory programmi ng textbooks based  
on O-O ideas; they were listed in an earlier chapter, but here t h e y  a r e  a g a i n ,  f o r  
convenience, without further comments: [Rist 1995] , [Wiener 1996] , [Gore 1996] , 
[Wiener 1997]  and [Jézéquel 1996] .The books were 
listed in the bibli-ography to chap-ter 2 , on page 35 .
Part E: 
Advanced topics
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
Part E complements our study of object techno logy basics by ex ploring some more  
leading-edge, but equally important topics: concurre ncy, distribution, client-server  
computing and the Internet ; persistence and databases; graphical interfaces.
30  
Concurrency , distribution , 
client-server and the Internet
L ike humans, computers can team up with their peers to achieve r esults that none of  
them could obtain alone; unlike humans, they can do many things  at once (or with the  
appearance of simultaneity), and do all of them well. So far, h owever, the discussion has  
implicitly assumed tha t the computation is sequential — proceeds along a single thread of  
control. We should now see what happens when this assumption no  longer holds, as we  
move to concurrent  (also known as parallel ) computation.
Concurrency is not a new subject , but for a long time interest in it remained mostly  
confined to four application area s: operating systems, networki ng, implementation of  
database management systems, and  high-speed scie ntific software . Although st rategic and  
prestigious, these tasks involve only a small subset of the sof tware development community.
Things have changed. Concurrency is quickly becoming a required  component of just  
about every type of application, including some which had tradi tionally been thought of as  
fundamentally sequential in nature. Beyond mere concurrency, ou r systems, whether or not  
client-server , must increasingly become distributed over networks, including the network  
of networks — the Internet . This evolution gives particular urgency to the central questi on 
of this chapter: can we apply object-oriented ideas in a concur rent and distributed context?
Not only is this possible: object technology can help us develo p concurrent and  
distributed applications  simply and elegantly.
30.1  A SNEAK PREVIEW
A s  u s u a l ,  t h i s  d i s c u s s i o n  w i l l  n o t  t h r o w  a  p r e - c o o k e d  a n s w e r  a t  you, but instead will  
carefully build a solut ion from a detailed analysis of the prob lem and an exploration of  
possible avenues, incl uding a few dead ends. Although necessary  to make you understand  
the techniques in depth, this th oroughness might  lead you to be lieve that they are complex;  
that would be inexcusa ble, since the concur rency mechanism on w hich we will finally  
settle is in fact characterized by almost incredible simplicity . To avoid this risk, we will  
begin by examining a summary of th e mechanism, wit hout any of t he rationale.
If you hate “spoilers”, preferring to start with the full state ment of the issues and to let the  
drama proceed to its dénouement step by step and inference by i nference, ignore the one-
page summary that follows and ski p directly to the next section .Warning : SPOILER !
(The next section is 
30.2, page 953 .)
CONCURRENCY , DISTRIBUTION, CLIENT-SERVER  AND THE INTERNET  §30 .1 952
The extension covering full-fledge d concurrency and distributio n will be as minimal  
as it can get starting from a seq uential notation: a single new  keyword — separate . How 
is this possible? We use the fun damental scheme of O-O computat ion: feature call, x  f (a), 
executed on behalf of som e object O1 and calling f on the object O2 attached to x, with the  
argument a. But instead of a single processor that handles operations on all objects, we  
may now rely on different processors for O1 and O2 — so that th e computation on O1 can  
move ahead without waiting for t he call to termi nate, since ano ther processor handles it.
Because the effect of a call now depends on whether the objects  are handled by the  
same processor or different ones, the software text must tell u s unambiguous ly what the  
intent is for any x. Hence the need for the new keyword: rather than just  x: SOME_TYPE , 
we declare x: separate  SOME_TYPE  to indicate that x is handled by a di fferent processor,  
so that calls of target x can proceed in parallel with the  rest of the computation. With such 
a declaration, any creation instruction  create  x  make (…) will spawn off a new processor  
— a new thread of control — to handle future calls on x.
Nowhere in the software text should we have to specify  which  processor to use.  All 
we state, through the separate  declaration, is that two objects are handled by different  
processors, since this radically affects the system’s semantics . Actual processor assignment  
can wait until run time. Nor do we settle too early on the exac t nature of processors: a  
processor can be implemented by a piece of hardware (a computer ), but just as well by a  
task (process) of the operating system, or, on a multithreaded OS, just a thread of such a  
task. Viewed by the software, “processor” is an abstract concep t; you can execute the same  
concurrent application on widely different architectures (time- sharing on one computer,  
distributed network with many computers, threads within one Uni x or Windows task …) 
without any change to its source text. All you will change is a  “Concurrency Configuration  
File” which specifies the last-minute mapping of abstract proce ssors to physical resources.
We need to specify synchronizat ion constraints. The conventions  are straightforward:
• No special mechanism is require d for a client to resynchronize  with its supplier after  
a separate call x  f (a) has gone off in parallel. The client will wait when and if it needs  
to: when it requests information  on the object through a query call, as in  
value  := x  some_query . This automatic mechanism is called wait by necessity .
• To obtain exclusive access to a  separate object O2, it suffice s to use the attached  
entity a as an argument to the co rresponding call, as in r (a).
• A routine preconditio n involving a separate argument such as a causes the client to  
wait until the prec ondition holds.
• To guarantee that we can contro l our software and predict the result (in particular,  
rest assured that class invariants will be maintained), we must  allow the processor in  
charge of an object to execute a t most one routine at any given  time.
• We may, however, need to interrupt  the execution of a routine to let a new , high-
priority client take over. This will cause an ex ception, so tha t the spurned client can  
take the appropriate co rrective measures — most likely retrying  after a while.
This covers most of the mechanism, which will enable us to buil d the most advanced  
concurrent and distributed appli cations through the full extent  of O-O techniques, from  
multiple inheritance to Design by Contract — as we will now stu dy in detail, forgetting  
for a while all that we have  read in this short preview.A complete sum-
mary appears in 30.11 , page 1025 .
§30.2   THE RISE OF CONCURRENCY 953
30.2  THE RISE OF CONCURRENCY
Back to square one. We must firs t review the various forms of c oncurrency, to understand  
how the evolution of our field r equires most software developer s to make concurrency part  
of their mindset. In addition to  the traditional concepts of mu ltiprocessing and  
multiprogramming, the past few ye ars have introduced two innova tive concepts: object  
request brokers and remote e xecution through the Net.
Multiprocessing
More and more, we want to use the formidable amount of computin g power available  
around us; less and less, we are willing to wait for the comput er (although we have become  
quite comfortable with  the idea that the computer is waiting fo r us). So if one processing  
unit would not bring us quickly e nough the result that we need,  we will want to rely on  
several units working in paralle l. This form of concurrency is known as multiprocessing.
Spectacular applications of mul tiprocessing have involved resea rchers relying on  
hundreds of computers scattered over the Internet, at times whe n the computers’  
(presumably consenting ) owners did not need them, to solve comp utationally intensive  
problems such as breaking cryptog raphic algorithms. Such effort s do not just apply to  
computing research: Hollywood’s insatiable demand for realistic  computer graphics has  
played its part in fueling progr ess in this area; the preparati on of the movie Toy Story , one 
of the first to involve artificia l characters only (only the vo ices are human), relied at some  
point on a network of more than one hundred high-end workstatio ns — more economical,  
it seems, than one hundred professional  animators.
Multiprocessing is also ubiquito us in high-speed scientific com puting, to solve ever  
larger problems of physics, engin eering, meteorology, statistic s, investment banking.
More routinely, many computing installations use some form of load balancing : 
automatically dispatching computations among the various comput ers available at any  
particular time on the local  network of an organization.
Another form of multiprocessing is the computing architecture k nown as client-
server computing , which assigns various specializ ed roles to the computers on a  network:  
the biggest and most expensive m achines, of which a typical com pany network  will have  
just one or a few, are “servers” handling shared databases, hea vy computations and other  
strategic central reso urces; the cheaper ma chines, ubiquitously  located wherever there is  
an end user, handle decentralizabl e tasks such as the human int erface and simple  
computations; they forward to th e servers any task that exceeds  their competence.
The current popularity of the client-server approach is a swing  of the pendulum away  
from the trend of the preceding decade. Initially (nineteen-six ties and seventies)  
architectures were centralized, forcing users to compete for re sources. The personal  
computer and workstation revolution of the eighties was largely  about empowering users  
with resources theretofore reserved to the Center (the “glass h ouse” in industry jargon).  
Then they discovered the obvious: a personal computer cannot do  everything, and some  
resources must  be shared. Hence the emergence of client-server architectures in the  
nineties. The inevitable cynical comment — that we are back to the one-mainframe-
many-terminals architecture of our youth, only with more expens ive terminals now called  
“client workstations” — is not r eally justified: the industry i s simply searching, through  
trial and error, for the proper tradeoff between decentralizati on and sharing.
CONCURRENCY , DISTRIBUTION, CLIENT-SERVER  AND THE INTERNET  §30 .2 954
Multiprogramming
The other main form of concurrenc y is multiprogramming, which i nvolves a single  
computer working on several tasks at once. 
If we consider general-purpose s ystems (excluding processors th at are embedded in  
a n  a p p l i c a t i o n  d e v i c e ,  b e  i t  a  w a s h i n g  m a c h i n e  o r  a n  a i r p l a n e  i nstrument, and single-
mindedly repeat a fixed set of operations), computers are almos t always multi-
programmed, performing operating system tasks in parallel with application tasks. In a  
strict form of multiprogramming the parallelism is apparent rat her than real: at any single  
time the processing unit is actua lly working on just one job; b ut the time to switch between  
jobs is so short that an outside o bserver can believe they proc eed concurrently. In addition,  
the processing unit itself may do  several things in parallel (a s in the advance fetch schemes  
of many computers, where each cl ock cycle loads the next instru ction at the same time it  
executes the current one), or may  actually be a combination of several processing units,  
so that multiprogramming becomes intertwined with multiprocessi ng.
A common application of multiprogramming is time-sharing ,  a l l o w i n g  a  s i n g l e  
machine to serve sever al users at once. But except in the case of very powerful  
“mainframe” computers this idea is considered much less attract ive now than it was when  
computers were a precious rarity . Today we consider our time to  be the more valuable  
resource, so we want the system to do several things at once ju st for us. In particular, multi-
windowing  user interfaces allow several applications to proceed in paral lel: in one window  
we browse the Web, in another we edit a document, in yet anothe r we compile and test  
some software. All this requires  powerful concurrency mechanism s.
Providing each computer user with  a multi-windowing, multiprogr amming interface  
is the responsibility of the operating system. But increasingly  the users of the software we  
develop want to have concurrency within one application . The reason is always the same:  
they know that computing power i s available by the bountiful, a nd they do not want to wait  
idly. So if it takes a while to load incoming messages in an e- mail system, you will want  
to be able to send an outgoing me ssage while this operation pro ceeds. With a good Web  
browser you can access a new sit e while loading pages from anot her. In a stock trading  
system, you may at any single tim e be accessing market informat ion from several stock  
exchanges, buying here , selling there , and monitoring a client’ s portfolio. 
I t  i s  t h i s  n e e d  f o r  i n t r a - a p p l i c a t ion concurrency which has sud denly brought the  
whole subject of concurrent comp uting to the forefront of softw are development and made  
it of interest far beyond its orig inal constituencies. Meanwhil e ,  a l l  t h e  t r a d i t i o n a l  
applications remain as important as ever, with new developments  in operating systems, the  
Internet, local area networks, and scientific computing — where  the continual quest for  
speed demands ever higher l evels of multiprocessing.
§30.2   THE RISE OF CONCURRENCY 955
Object request brokers
Another important recent development has been the emergence of the CORBA proposal  
from the Object Management Group, and the OLE 2/ActiveX archite cture from Microsoft.  
Although the precise goals, details and markets differ, both ef forts promise substantial  
progress towards dis tributed computing.
The general purpose is to allow applications to access each oth er’s objects and  
services as conveniently as poss ible, either locally or across a network. The CORBA effort  
(more precisely its CORBA 2 stage,  clearly the interesting one)  has also placed particular  
emphasis on interoperability:
• CORBA-aware applications can coöperate even if they are based on “object request  
brokers” from different vendors.
• Interoperability also applies to the language level: an applic ation written in one of the  
supported languages can access objects from an application writ ten in another. The  
interaction goes through an intermediate language called IDL (I nterface Definition  
Language); supported languages have an official IDL binding, wh ich maps the  
constructs of the language to those of IDL. 
IDL is a common-denominator O-O language centered on the notion  of interface. An  
IDL interface for a class is simil ar in spirit to a short form,  although more rudimentary  
(IDL in particular does not supp ort assertions);  it describes t he set of features available on  
a certain abstraction. From a class written in an O-O language such as the notation of this  
book, tools will derive an IDL i nterface, making the class and its instances of interest to  
client software. A client written in the same language or anoth er can, through an IDL  
interface, access across a networ k the features provided by suc h a supplier.
Remote execution
Another development of the late nineties is the mechanism for r emote execution through  
the World-Wide Web.
The first Web browsers  made it not just possible but also conve nient to explore  
information stored on remote com puters anywhere in the world, a nd to follow logical  
connections, or hyperlinks , at the click of a button. But this was a passive mechanism:  
someone prepared some informatio n, and everyone else accessed i t read-only.
The next step was to move to an active setup where clicking on a link actually  
triggers execution of a n operation. This assumes the presence, within the Web browser, of  
an execution engine wh ich can recognize the downloaded informat ion as executable code,  
and execute it. The execution engine can be a built-in part of the browser, or it may be  
dynamically attached to it in response to the downloading of in formation of the  
corresponding type. This lat ter solution is known as a plug-in  mechanism and assumes  
t h a t  u s e r s  i n t e r e s t e d  i n  a  p a r t i c u l a r  e x e c u t i o n  m e c h a n i s m  c a n  d ownload the execution  
engine, usually free, from the Internet. 
CONCURRENCY , DISTRIBUTION, CLIENT-SERVER  AND THE INTERNET  §30 .3 956
This idea was first made popular by Java in late 1995 and 1996;  Java execution  
engines have become widely available. Plug-ins have since appea red for many other  
mechanisms. An alternative to providing a specific plug-in is t o generate, from any source  
language, code for a widely avai lable engine, such as a Java en gine; several compiler  
vendors have indeed started to p rovide generators of Java “byte code” (the low-level  
portable code that the Ja va engine can execute).
For the notation of this book the two avenues have been pursued : ISE has a free execution  
engine; and at the time of writing a project is in progress to generate Java bytecode.
Either approach raises the potential of security problems: how much do you trust  
someone’s application? If you are not careful, clicking on an i nnocent-looki ng hyperlink  
could unleash a vicious program that destroys files on your com puter, or steals your  
personal information. More preci sely you should not, as a user,  be the one asked to be  
careful: the responsibility is on  the provider of  an execution engine and the associated  
library of basic facilities. Some  widely publicized Java securi ty failures in 1996 caused  
considerable worries about the issue.
The solution is to use carefully designed and certified executi on engines and libraries  
coming from reputable sources. Of ten they will have two version s:
• One version is meant for unlimited Internet usage, based on a severely restricted  
execution engine.
In ISE’s tool the only I/O library facilities in this restricte d tool only read and  
write to and from the terminal, not files. The “external” mecha nism of the  
language has also been removed, so that a vicious application c annot cause  
mischief by going to C, say, to perform file manipulations. The  Java “Virtual  
Machine” (the engine) is also draconian in what it permits Inte rnet “applets”  
to do with the file system of your computer.
• The other version has fewer or no such restrictions, and provi des the full power of  
the libraries, file I/O in particular. It is meant for applicat ions that will run on a secure  
Intranet (internal company netwo rk) rather than the wilderness of the Internet.
In spite of the insecurity spect er, the prospect of unfettered remote execution, a new  
step in the ongoing re volution in the way we distribute softwar e, has generated enormous  
excitement, which shows no sign of abating.
30.3  FROM PROCESSES TO OBJECTS
To support all these mind-bogglin g developments, requiring ever  more use of  concurrent  
processing, we need powerful software support. How are we going  to program these  
things? Object technology, o f course, suggests itself.
Robin Milner is said to have exc laimed, in a 1991 workshop at a n O-O conference,  
“I can’t understand why objects [of O-O languages] are not concurrent in the first place ”. 
Even if only in the second or th ird place, how do we go about m aking objects concurrent?Cited in [Matsuoka 
1993].
§30.3   FROM PROCESSES TO OBJECTS 957
If we start from non-O-O concurr ency work, we will find that it  largely relies on the  
notion of process . A process is a program unit th at acts like a special-purpose computer:  
it executes a certain algorithm,  usually repeating it until som e external event triggers  
termination. A typical example is the process that manages a pr inter, repeatedly executing
“Wait until there is at least a job in the print queue”
“Get the next print job an d remove it from the queue”
“Print the job”
Various concurrency models differ in how processes are schedule d and  
synchronized, compete for shared  hardware resources, and exchan ge information. In some  
concurrent programming  languages, you directly describe a proce ss; in others, such as  
Ada, you may also describe process types , which at run time are instantiated into  
processes, much as the classes o f object-oriented software are instantiated into objects.
Similarities
The correspondence seems indeed clear. As we start exploring ho w to combine ideas from  
concurrent programming and objec t-oriented software constructio n, it seems natural to  
identify processes with objects, and process types with classes . Anyone who has studied  
concurrent computing and discove rs O-O development, or the othe r way around, will be  
struck by the simila rities between these two technologies:
• Both rely on autonomous, encapsulated modules: processes or pr ocess types; classes.
• Like processes and unlike the subroutines of sequential, non-O -O approaches,  
objects will, from each activatio n to the next, retain the valu es they contain.
• To build reasonable concurrent systems, it is indispensable in  practice to enforce  
heavy restrictions on how modules can exchange information; oth erwise things  
quickly get out of hand. The O-O approach, as we have seen, pla ces similarly severe  
restrictions on inter-module communication.
• The basic mechanism for such communication may loosely be desc ribed, in both  
cases, under the general label of “message passing”. 
So it is not surprising that many people have had a “Eureka!” w hen first thinking,  
Milner-like, about making objects concurrent. The unification, it seems, should come  
easily.
This first impression is unfort unately wrong: after the similar ities, one soon stumbles  
into the discrepancies. 
Active objects
Building on the analogies just s ummarized, a number of proposal s for concurrent O-O  
mechanisms (see the bi bliographical notes) h ave introduced a no tion of “active object”.  
An active object is an object th at is also a process: it has it s own program to execute. In a  
definition from a book on Java:
Each object is a single , identifiable pr ocess-like entity (not unlike a Unix  
process ) with state and behavior . From : Doug Lea , 
“Concurrent Pro-gramming in Java” , 
Addison-Wesley , 
1996 .
CONCURRENCY , DISTRIBUTION, CLIENT-SERVER  AND THE INTERNET  §30 .3 958
This notion, however, ra ises difficu lt problems.
The most significant one is easy to see. A process has its own agenda: as illustrated  
by the printer example, it relen tlessly executes a certain sequ ence of actions. Not so with  
classes and objects. An object does not do one thing; it is a repository of services (the  
features of the generating class), and just waits for the next client to solicit one of those  
services — chosen by the client, not the object. If we make the  object active, it becomes  
responsible for the sc heduling of its operat ions. This creates a conflict with the clients,  
which have a very clear view of what the scheduling should be: they just want the supplier,  
whenever they need a particular service, to be ready to provide  it immediately!
The problem arises in non-object -oriented approac hes to concurr ency and has led to  
mechanisms for synchronizing processes — that is to say, specifying when and how each  
is ready to communicate , waiting if necessa ry for the other to be ready too. For example  
in a very simple, unbuffered producer-consumer scheme we may ha ve a producer  process  
that repeate dly executes
a scheme which we may also view  pictorially:
Communication occurs when both pr ocesses are read y for each oth er; this is  
sometimes called a handshake  or rendez-vous . The design of synchronization mechanisms  
— enabling us in particular to express precisely the instructio ns to “Make it known that  
process is ready” and “Wait for process to be ready”  — has been a fertile area of research  
and development fo r several decades.“Make it known that producer is not ready”
“Perform some computatio n that produces a value x”
“Make it known that producer is ready”
“Wait for consumer to be ready”
“Pass x to consumer ”
and a consumer  process that repe atedly executes
“Make it known that consumer is ready”
“Wait for producer to be ready”
“Get x from producer ”
“Make it known that consumer is not ready”
“Perform some computatio n that uses the value x”Handshake
A simple 
producer-
consumer 
schemeProduce
ConsumeWait
Communicateproducer consumer
Handshake
(pass x)Wait
Communicate
§30.3   FROM PROCESSES TO OBJECTS 959
All this is fine for p rocesses, the concurre nt equivalent of tr aditional sequential  
programs which “do one  thing”; indeed, a concurrent system buil t with processes is like a  
sequential system with several main programs. But in the object -oriented approach we  
have rejected the notion of main program and instead defined so ftware units that stand  
ready to provide any one of a number of possible features.
Reconciling this view with the notion of process  requires elabo rate synchronization  
constructs to make sure that each supplier is ready to execute a feature when the client  
needs it. The reconciliation is particularly delicate when both  client and supplier are active  
objects, since each has its own agenda.
All this does not make it impossible  to devise mechanisms based on the notion of  
active object, as evidenced by th e abundant literature on the s ubject (to which the  
bibliographical notes to this ch apter give many references). Bu t this evidenc e also shows  
the complexity of the proposed s olutions, of whi ch none has gai ned wide acceptance,  
suggesting that the active object approac h is not the right one .
Active objects clash with inheritance
Doubts about the suitability of the active object approach grow  as one starts looking at  
how it combines with other O-O m echanisms, especially inheritan ce.
If a class B i n h e r i t s  f r o m  a  c l a s s  A a n d  b o t h  a r e  a c t i v e  ( t h a t  i s  t o  s a y ,  d e s c r i b e  
instances that must be activ e objects), what happens in B to the description of A’s process?  
In many cases you will need to a dd some new instructions, but w ithout special language  
mechanisms this means that you will almost always have to redef ine and rewrite the entire  
process part — not an at tractive proposition.
H e r e  i s  a n  e x a m p l e  o f  s p e c i a l  l a nguage mechanism. Although the Simula 67  
language does not support concur rency, it has a notion of activ e object: a Simula class can,  
besides its features, include a set of instructions, called the  body of the class, so that we  
can talk of executing an object — meaning executing the body of  its generating class. The  
body of a class A can include a special instruction inner , which has no effect in the class  
itself but, in a proper descendant B, stands for the body of B. So if the body of A reads
some_initialization ; inner ; some_termination_actions
and the body of B reads
specific_B_actions
then execution of that bod y actually means executing
some_initialization ; specific_B_actions ; some_termina tion_actions
Although the need for a mechanis m of this kind is clear in a la nguage supporting the  
notion of active object, objecti ons immediately come to mind: t he notation is  misleading,  
since if you just read the body of B you will get a wrong view of what the execution does;  
it forces the parent to  plan in detail for its descendants, goi ng against basic O-O concepts  
(the Open-Closed principle); and  it only works in a single-inhe ritance language.See “Sequencing 
and inheritance”, page 1121 , as part of 
the discussion of Simula .
CONCURRENCY , DISTRIBUTION, CLIENT-SERVER  AND THE INTERNET  §30 .3 960
Even with a different notation, the basic problem will remain: how to combine the  
process specification of a class with those of its proper desce ndants; how to reconcile  
parents’ process specifications i n the case of mu ltiple inherit ance.
Later in this chapter we will see other problems, known as the “inheritance anomaly” and  
arising from the use of inherita nce with synchronization constr aints.
Faced with these difficulties, some of the early O-O concurrenc y proposals preferred  
to stay away from inheritance al together. Although justifiable as a temporary measure to  
help understand the issues by se parating concerns, this exclusi on of inheritance cannot be  
sustained in a definitive approa ch to the construction of concu rrent object-oriented  
software; this would be like cutting the arm because the finger  itches. (For good measure,  
some of the literature adds that inheritance is a complex and m essy notion anyway, as if  
telling the patient, after the operation, that having an arm wa s a bad idea in the first place.)
The inference that we may draw i s simpler and less extreme. The  problem is not  
object technology per se, in part icular inheritance; it is not concurrency; it is not even the  
combination of these ideas. What  causes trouble is the notion o f active object.
Processes programmed
As we prepare to get rid of active objects it is useful to note  that we will not really be  
renouncing anything. An  object is able to perform many operatio ns: all the features of its  
generating class. By turning it into a process, we select one o f these operations as the only  
one that really counts. There is  absolutely no benefit in doing  this! Why limit ourselves to  
one algorithm when we can have as many as we want?
Another way to express this obse rvation is that the notion of p rocess need not be a  
built-in concept in the concurre ncy mechanism; processes can be  programmed  simply as  
routines. Consider for example the concept of printer process c ited at the beginning of this  
chapter. The object-oriented view  tells us to focus on the obje ct type, printer, and to treat  
the process as just one routine, say live, of the corresponding class:
note
description : "Printers handling one print job at a time "
note: “A better version , based on a general class PROCESS , %
%appears below under the name PRINTER "
class
PRINTER_1
feature -- Status report
stop_requested : BOOLEAN do … end
oldest : JOB do … end
feature -- Basic operations
setup do … end
wait_  for_ job do … end
remove_oldest do … end
print ( j: JOB ) do … end“Synchronization for 
concurrent O-O com-putation”, page 980
§30.3   FROM PROCESSES TO OBJECTS 961
feature -- Process behavior
live
-- Do the printer thing.
do
from setup until stop_requested loop
wait_  for_ job; print (oldest ); remove_oldest
end
end
… Other features …
end
Note the provision for Other features : although so far live and the supporting features  
have claimed all our attention, w e can endow processes with man y other features if we  
want to, encouraged by the O-O approach developed elsewhere in this book. Turning  
PRINTER_1  objects into processes would me an limiting this freedom; that would be a  
major loss of expressive power , without any vi sible benefit.
By abstracting from this example,  which describes a particular process type simply  
as a class, we can try  to provide a more general description of  all process types through a  
deferred class — a behavior class  as we have often encountered in previous chapters.  
Procedure live will apply to all processes. We could leave it deferred, but i t is not too much  
o f  a  c o m m i t m e n t  t o  n o t e  t h a t  m o s t  p r o c e s s e s  w i l l  n e e d  s o m e  i n i t ialization, some  
termination, and in-between a ba sic step repeated some number o f times. So we can  
already effect a few things a t the most abstract level:
note
description : "The most general notion of process "
deferred class
PROCESS
feature -- Status report
over: BOOLEAN
-- Must executio n terminate now?
deferred
end
feature  -- Basic operations
setup
-- Prepare to execut e process operations ( default: nothing).
do
end
step
-- Execute basic p rocess operations.
deferred
end
CONCURRENCY , DISTRIBUTION, CLIENT-SERVER  AND THE INTERNET  §30 .3 962
wrapup
-- Execute termination opera tions (default: nothing).
do
end
feature -- Process behavior
live
-- Perform process lifecycle.
do
from setup until over loop
step
end
wrapup
end
end
A point of methodology: whereas step is deferred, setup  a n d  wrapup  a r e  e f f e c t i v e  
procedures, defined as doing not hing. This way we force every e ffective descendant to  
provide a specific implementation of step, the basic process action; but in the not  
infrequent cases that require no particular setup or terminatio n operation we avoid  
bothering the descendants. This choice between a deferred versi on and a null effective  
version occurs regularly in the design of deferred classes, and  you should resolve it based  
on your appreciation of the likely characteristics of descendan ts. A wrong guess is not a  
disaster; it will just lead to more effectings or more redefini tions in descendants.
From this pattern we m ay define a more sp ecialized class, cover ing printers:
note
description : "Printers handling one print job at a time "
note: “Revised version base d on class PROCESS "
class PRINTER inherit
PROCESS
rename over as stop_requested end
feature -- Status report
stop_requested : BOOLEAN
-- Is the next job in the que ue a request to shut down?
oldest : JOB
-- The oldest job in the queue
do … end
feature -- Basic operations
step
-- Process one job.
do
wait_  for_ job; print (oldest ); remove_oldest
end
§30.3   FROM PROCESSES TO OBJECTS 963
wait_  for_ job
-- Wait until job queue is not empty.
do
…
ensure
oldest /= Void
end
remove_oldest
-- Remove oldest  job from queue.
require
oldest /= Void
do
if oldest   is_stop_request then stop_requested  := True end
“Remove oldest  from queue”
end
print ( j: JOB )
-- Print j, unless it is just a stop request.
require
j /= Void
do
if not j  is_stop_request then “Print the text associated with j” end
end
end
The class assumes that a request to shut off the printer is sen t as a special print job j 
for which j  is_stop_request  is true. (It would be cleaner to avoid making print and 
remove_oldest aware of the special case of the  “stop request” job; this is ea sy to improve.)
The benefits of O-O modeling are apparent here. In the same way  that going from  
main program to classe s broadens our persp ective by giving us a bstract objects that are not  
limited to “doing just one thing”, considering a printer proces s as an object described by  
a class opens up the possibility  of new, useful features. With a printer we can do more than  
execute its normal printing operation as covered by live (which we should perhaps have  
renamed operate when inheriting it from PROCESS ); we might want to add such features  
as perform_internal_test , switch_to_Postscript_level_1  or set_resolution . The equalizing  
effect of the O-O method is as important here as in sequential software.
More generally, the classes sket ched in this sec tion show how w e can use the normal  
object-oriented mechanisms — cla sses, inheritance , deferred ele ments, partially  
implemented patterns — to implem ent processes. T here is nothing  wrong with the concept  
of process in an O-O context; indeed, we will need it in many c oncurrent applications. But  
rather than a primitive mechanis m it will simply be covered by a library class  PROCESS  
based on the version given earli er in this section, or perhaps several such classes covering  
variants of the notion.
For the basic new construct of c oncurrent object technology, we  must look elsewhere.Exercise E30.1, 
page 1035 .
CONCURRENCY , DISTRIBUTION, CLIENT-SERVER  AND THE INTERNET  §30 .4 964
30.4  INTRODUCING CONCURRENT EXECUTION
What — if not the notion of process — fundamentally distinguish es concurrent from  
sequential computation?
Processors
To narrow down the specifics of concurrency, it is useful to ta ke a new look at the figure  
which helped us lay the very fo undations of obje ct technology b y examining the three  
basic ingredients of  computation:
T o perform a computation is to use certain processors  to apply certain actions to 
certain objects . At the beginning of this book we discovered how object techno logy 
addresses fundamental issues of reusability and extendibility b y building software  
architectures in which actions a re attached to objects (more pr ecisely, object types) rather  
than the other way around.
What about processors? Clearly we need a mechanism to execute t he actions on the  
objects. But in sequential computation there is just one thread  of control, hence just one  
processor; so it is taken for gr anted and remain s implicit most  of the time.
I n  a  c o n c u r r e n t  c o n t e x t ,  h o w e v e r ,  w e  w i l l  h a v e  t w o  o r  m o r e  p r o c essors. This  
property is of course essential t o the idea of concurrency and w e  c a n  t a k e  i t  a s  t h e  
definition of the notion. This is  the basic answer to the quest ion asked above: processors  
(not processes) will be the prin cipal new concep t for adding co ncurrency to the framework  
of sequential object-o riented computation. A concurrent system may have any number of  
processors, as opp osed to just one for a  sequential system.
The nature of processors
Definition : processor
A processor is an auto nomous thread of control capable of suppo rting the  
sequential execution of instructions on one or more objects.The three forces 
of computation  
(This figure first 
appeared on page 101.) Action Object
Processor
§30.4   INTRODUCING CONCURRENT EXECUTION 965
This is an abstract notion, it sh ould not be confused with that  of physical processing  
device, for which the rest of th is chapter will use the term CPU , common in computer  
engineering to denote the proces sing units of computers. “CPU” is an abbreviation of  
“Central Processing Un it” even though there is most of the time  nothing central about  
CPUs. You can use a CPU to implement a processor; but the notio n of processor is much  
more abstract and general. A p rocessor can be, for example:
• A computer (with its  CPU) on a network.
• A  t a s k ,  a l s o  c a l l e d  p r o c e s s ,  a s  s u p p o r t e d  o n  o p e r a t i n g  s y s t e m s  such as Unix,  
Windows and many others.
• A coroutine. (Coroutines, cover e d  i n  d e t a i l  l a t e r  i n  t h i s  c h a p ter, simulate true  
concurrency by taking turns at execution on a single CPU; after  each interruption,  
each coroutine resumes its execu tion where it la st left it.) 
• A “thread” as supported by such multi-threaded operating syste ms as Solaris, OS/2  
and Windows NT.
Threads are mini-processes. A true process can itself contain m any threads, which it  
manages directly; the operating system (OS) only sees the proce ss, not its threads.  
Usually the threads of a process will all share the same addres s space (in object-oriented  
terms, they potentially have access to the same set of objects) , whereas each process has  
its own address space. We may view threads as coroutines within  a process. The main  
advantage of threads is efficienc y: whereas creating a process and synchronizing it with  
other processes are expensive operations, requiring direct OS i ntervention (to allocate the  
address space and the code of the process), the corresponding o perations on threads are  
much simpler, do not involve any expensive OS operations, and s o can be faster by a  
factor of several hundreds or  even several thousands.
The difference between processors and CPUs was clearly expresse d by Henry  
Lieberman (for a differ ent concurrency model):
The number of [ processors ] need not be bo unded in advance , and if there are  
too many [ processors ] for the number of real physical [CPUs ] you have on  
your computer system , they are automatically time-shared . Thus the user can  
pretend that processor resources are practically infinite . 
To avoid any misunders tanding, be sure to remember that through out this chapter the  
“processors” denote virtual threads of control; any reference t o the physical units of  
computation uses the term CPU.
At some point before or during y ou will need to assign computat ional resources to  
the processors. The mapping will  be expressed by a “Concurrency  Control File”, as  
described below, or associ ated library facilities.
Handling an object
Any feature call must be handled  (executed) by some processor. More generally, any  
object O2 is handled  by a certain processor, its handler ; the handler is responsible for  
executing all calls on O2 (all calls o f the form x  f (a) where x is attached to O2).[Lieberman 1987],  
page 22 . Square 
brackets signal differ-ences in terminology .
CONCURRENCY , DISTRIBUTION, CLIENT-SERVER  AND THE INTERNET  §30 .4 966
We may go further and specify th at the handler is assigned to t he object at the time  
of creation, and remains the same throughout the object’s life.  This assumption will help  
k e e p  t h e  m e c h a n i s m  s i m p l e .  I t  m a y  s e e m  r e s t r i c t i v e  a t  f i r s t ,  s i nce some distributed  
systems may need to support object migration  across a network. But we can address this  
need in at least  two other ways:
• By allowing the reassignment of a processor to a different CPU  (with this solution,  
all objects handled by a processor  will migrate together).
• By treating object migration as the creation of a new object.
The dual semantics of calls
With multiple processors, we fa ce a possible departure from the  usual semantics of the  
fundamental operation of object-o riented computation, feature c all, of one of the forms
x  f (a) -- if f  is a command
y := x  f (a) -- if f  is a query
As before, let O2 be the object attached to x at the time of the call, and O1 the object  
on whose behalf the call is execu ted. (In other words, the inst ruction in either form is part  
of a call to a certain  routine, whose execut ion uses O1 as its target.)
We have grown accustomed to unde rstanding the effect of the cal l as the execution  
of f  ’s body applied to O2, using a as argument, and returning a result in the query case. If  
the call is part of a sequen ce of instruct ions, as with
… previous_instruction ; x  f (a); next_instruction ; …
(or the equivalent in the qu ery case), the execution of next_instruction  will not commence  
until after the completion of f.
Not so any more with multiple pr ocessors. The very purpose of c oncurrent  
architectures is to enable the c lient computation to proceed wi thout waiting for the  
supplier to have completed its j ob, if that job is handled by a nother processor. In the  
example of print controllers, sk etched at the beginning of this  chapter, a client application  
will want to send a print request (a “job”) and continue immedi ately with its own agenda.
So instead of one call semantics we now have two cases:
• If O1 and O2 have the same hand ler, any further operation on O 1 (next_instruction ) 
must wait until the call termina tes. Such calls are said to be synchronous . 
• If O1 and O2 are handled by different processors, operations o n O1 can proceed as  
soon as it has initiated the call on O2. Such call s are said to  be asynchronous .
The asynchronous case is particularly interesting for a command , since the remainder
of the computation may not need a ny of the effects of the call on O2 until much later (if at  
all: O1 may just be responsible for spawning one or more concur rent computations and  
then terminating). For a query, w e need the result, as in the a bove example where we  
assign it to y, but as explained belo w we might be able to proceed concurrent ly anyway.
§30.4   INTRODUCING CONCURRENT EXECUTION 967
Separate entities
A general rule of software const ruction is that a semantic diff erence should always be  
reflected by a difference  in the software text.
Now that we have two variants of call semantics we must make su re that the software  
text incontrovertibly i ndicates which one is intended in each c ase. What determines the  
answer is whether the call’s target, O2, has the same handler ( the same processor) as the  
call’s originator, O1. So rather than the call itself we should  mark x, the entity denoting the  
target object. In accordance with  the static typing policy, dev eloped in earlier chapters to  
favor clarity and safety, the ma rk should appear in the declara tion of x.
This reasoning yields the only notational extension supporting concurrency. Along  
with the usual
x: SOME_TYPE
we allow ourselves t he declaration form
x: separate  SOME_TYPE
to express that x may become attached to objects ha ndled by a different processor . If a 
class is meant to be used only to  declare separate entities, yo u can also declare it as
separate class X … The rest as usual …
instead of just class X … or deferred class X ….
The convention is the same as for declaring an expanded status:  you can declare y as being  
of type expanded T, or equivalently just as T if T itself is a class declared as expanded  
class T… The three possibilities — expande d, deferred, separate — are m utually  
exclusive, so at most one qualifying keyword may appear before class .
It is quite remarkable that this addition of a single keyword s uffices to turn our  
sequential object-orie nted notation into one  supporting general  concurrent computation.
Some straightforward terminology. W e may apply the word “separa te” to various  
elements, both static (appearing in the software text) and dyna mic (existing at run time).  
Statically: a separate class  is a class declared as separate class  …; a separate type  is 
based on a separate class; a separate entity  is declared of a se parate type, or as separate  
T for some T; x  f (…) is a separate call  if its target x is a separate entity. Dynamically: the  
value of a separate entity is a separate reference ; if not void, it will be attached to an object  
handled by anothe r processor — a separate object .
Typical examples of se parate class include:
•BOUNDED_BUFFER , to describe a buffer structure  that enables various concurren t 
components to exchange data (some  components, the producers, de positing objects  
into the buffer, and others, the  consumers, acquiring objects f rom it).
•PRINTER , perhaps better called PRINT_CONTROLLER , to control one or more  
printers. By treating the print controllers as separate objects , applications do not need  
to wait for the print job to com plete (unlike early Macintoshes , with which you were  
stuck until the last page ha d come out of the printer).“Expanded types”, 
page 254 .
CONCURRENCY , DISTRIBUTION, CLIENT-SERVER  AND THE INTERNET  §30 .4 968
•DATABASE , which in the client part of a client-server architecture may serve to  
describe the database hosted by a distant server machine, to wh ich the client may  
send queries through the network.
•BROWSER_WINDOW , in a Web browser that allows you to spawn a new window  
where you can examine different Web pages.
Obtaining separate objects
In practice, as illustrated by the preceding examples, separate  objects will be of two kinds:
• In the first case an applic ation will want to spawn a new separate object, grabbing  
the next available processor. (Re member that we can always get a new processor;  
since processors are not materia l resources but abstract facili ties, their number is not  
bounded.) This is typically the case with BROWSER_WINDOW : you create a new  
window when you need one. A BOUNDED_BUFFER  or PRINT_CONTROLLER
may also be created in this way.
• An application may simply need to access an existing  separate object, usually shared  
between many different client s. This is the case in the DATABASE  example: the client  
application uses an entity db_server : separate DATABASE  to access the database  
through such separate calls as db_server   ask_query (sql_query ). The server must  
have at some stage obtained the value of server  — the database handle — from the  
outside. Accesses to existing BOUNDED_BUFFER  o r  PRINT_CONTROLLER
objects will use a similar scheme.
The separate object is said to be created in the first case and external in the second.
To obtain a created object, you s imply use the creation instruc tion. If x is a separate  
entity, the creation instruction
create  x  make (…)
will, in addition to its usual ef fect of creating and initializ ing a new object, assign a new  
processor to handle that object . Such an instruction is called a separate creation .
To obtain an existing external object, you will typically use a n external routine, such as
server (name : STRING ; … Other arguments …): separate  DATABASE
where the arguments serve to ide ntify the requested object. Suc h a routine will typically  
send a message over the network a nd obtain in return a referenc e to the object.
A word about possible implementations may be useful here to vis ualize the notion  
of separate object. Assume each of the processors is associated  with a task (process) of an  
operating system such as Windows  or Unix, with its own address space; this is of course  
just one of many concurrent architectures. Then one way to repr esent a separate object  
within a task is to use a sm all local object, known as a proxy :
§30.4   INTRODUCING CONCURRENT EXECUTION 969
The figure shows an object O1, instance of a class T with an attribute x: separate  U. 
The corresponding reference field  in O1 is concep tually attache d to an object O2, handled  
by another processor. Internally,  however, the reference leads to a proxy object, handled  
by the same processor as O1. The proxy is an internal object, n ot visible to the author of  
the concurrent application. It c ontains enough information to i dentify O2: the task that  
serves as O2’s handler, and O2’s address within that task. All operations on x on behalf of  
O1 or other clients from the sam e task will go through the prox y. Any other processor that  
also handles objects containing s eparate references to O2 will have its own proxy for O2.
Be sure to note that this is only one possible technique, not a  required property of the  
model. Operating system tasks with separate address spaces are j u s t  o n e  w a y  t o  
implement processors. With thread s, for example, the techniques  may be different.
Objects here , and objects there
When first presented with the notion of separate entity, some p eople complain that it is  
over-committing: “I do not want to know where the object reside s! I just want to request  
the operation, x  f (…), and let the machinery do the rest — execute f on x wherever x is.”
Although legitimate, this desire  to avoid over-commitment does not obviate the need  
for separate  declarations. It is true that the precise location of an object is often an  
implementation detail that shoul d not affect the software. But one “yes or no” property of  
the object’s location remains rel evant: whether the object is h andled by the same  processor  
or by another. This is a fundamental semantic difference since it determines whether calls  
on the object are synchronous or  asynchronous — cause the clien t to wait, or not. Ignoring  
this property in the software w ould not be a con venience; it wo uld be a mistake.
Once we know the object is separ ate, it should not in most case s  m a t t e r  f o r  t h e  
functionality of our software (although it may matter for its p erformance) whether the  
object belongs to another thread  o f  t h e  s a m e  p r o c e s s ,  a n o t h e r  p rocess on the same  
computer, another computer in th e same room, another room in th e same building, another  
site on the company’s private ne twork, or another Internet node  half-way around the  
world. But it matters that it is separate.Other
fields(non-separate)x: separate  U
(T)PROXY
OBJECT
(U)O1
O2Other
objects
Other
objectsAddress space 1
Address space 2A proxy for a 
separate object
CONCURRENCY , DISTRIBUTION, CLIENT-SERVER  AND THE INTERNET  §30 .4 970
A concurrency architecture
The use of separate  declarations to cover the funda mental boolean property “is thi s object  
here, or is it elsewhere?” while leaving room for various physi cal implementations of  
concurrency suggests a two-level  architecture, similar to what is available for the  
graphical mechanisms (with the Vision  library sitting on top of platform-specific  
libraries):
At the highest level the mechani sm is platform-i ndependent. Thi s is the level which  
most applications use, and which t h i s  c h a p t e r  d e s c r i b e s .  T o  p e r form concurrent  
computation, applications simply use the separate  mechanism.
Internally, the implementation w ill rely on some practical conc urrent architecture  
(lower level on the fig ure). The figure lis ts some possibilitie s:
• There may be an implementation using processes (tasks) as prov ided by the operating  
system. Each processor is associated with a process. This solut ion supports  
distributed computing: the process of a separate object can be on a remote machine  
as well as a local one. For non-distributed processing, it has the advantage that  
processes are stable and well known, and the disadvantage that they are CPU-
intensive; both the creation of a new process and the exchange of information  
between processes are expensive operations.
• There may be an implementation using threads. Threads, as alre ady noted, are a  
lighter alternative to processes, minimizing the cost of creati on and context  
switching. Threads, however, have  to reside on the same machine .
• A CORBA implementation is also possible, using CORBA distribut ion mechanisms  
as the physical layer to excha nge objects across the network.
• Other possible mechanisms include PVM (Parallel Virtual Machin e), the Linda  
language for concurrent programming, Java threads …
As always with such two-level ar chitectures, the correspondence  between high-level  
constructs and the actual platform mapping (the handle  in terms of a previous chapter) is  
in most cases automatic, so that application developers will se e the highest level only. But  Two-level 
architecture for 
concurrency 
mechanism
(See a similar archi-
tecture for graphical libraries on page 1067 .)Process-based 
handleThread-based 
handleCORBA-
based handleGeneral concurrency mechanism (SCOOP )
§30.4   INTRODUCING CONCURRENT EXECUTION 971
mechanisms must be available to let them access the lower level  if they need to (and, of  
course, are ready to renounc e platform-ind ependence).
Mapping the processors : the Concurrency Control File
I f  t h e  s o f t w a r e  d o e s  n o t  s p e c i f y  t h e  p h y s i c a l  C P U s ,  t h i s  s p e c i f ication must appear  
somewhere else. Here is a way to take care of it. This is only one possible solution, not a  
fundamental part of the approach ; the exact format is not essen tial, but any configuration  
mechanism will somehow have to p rovide the same information. 
Our example format is a “Concurre ncy Control File” (CCF) descri bing the  
concurrent computing resources a vailable to our software. CCFs are similar in purpose  
and outlook to Ace files used to control system assembly. A typ ical CCF look s like this:
creation
local_nodes :
system
"pushkin " (2): "c:\system1\appl   exe"
"akhmatova " (4): "/home /users /syst1 "
Current : "c:\system1\appl2   exe"
end
remote_nodes :
system
"lermontov ": "c:\system1\appl   exe"
"tiuchev " (2): "/usr/bin/syst2 "
end
end
external
Ingres_handler : "mandelstam " port 9000
ATM_handler : "pasternak " port 8001
end
default
port: 8001 ; instance : 10
end
Defaults are available for all properties of interest, so that each of the three possible parts  
(creation , external , default ) is optional, as well as the CCF as a whole.
The creation  part specifies what CPUs to use for separate cre ations (instru ctions of  
the form  create  x  make (…) for separate x). The example uses two CPU groups: local_
nodes , presumably covering local mach ines, and remote_nodes . The software can select a  
CPU group through a call such as
set_cpu_group ("local_nodes ")On Ace files see 
“Assembling a sys-tem”, page 198 .
CONCURRENCY , DISTRIBUTION, CLIENT-SERVER  AND THE INTERNET  §30 .4 972
directing subsequent separate creations to use the CPU group local_nodes until the next call  
to set_cpu_group . This procedure comes from a class CONCURRENCY providing facilities  
for controlling the mechanism; w e will encounter  a few more of its features below.
The corresponding CCF entry spe cifies what CPUs to use for local_nodes : the first  
two objects will be created on machine pushkin , the next four on akhmatova , and the next  
ten on the current machine (the one which executes the creation  instructions); after that  
the allocation scheme will repeat itself — two objects on pushkin  and so on. In the absence  
of a processor count, as with Current here, the value is taken from the instance  entry in  
the default part (here 10) if present, and i s 1 otherwise. The system used to create each  
instance is an execu table specified in e ach entry, such as c:\system1\appl   exe for pushkin
(obviously a machine runn ing Windows or OS/2).
In this example the processors a re all mapped to  processes. The  CCF also supports  
assigning processors to threads (in the thread-based handle) or  o t h e r  c o n c u r r e n c y  
mechanisms, although we  need not concern our selves with the det ails.
The external part specifies where to look for  existing external separate obj ects. The  
CCF refers to these object s through abst ract names, Ingres_handler  and ATM_handler  in 
the example, which the software will use as arguments to the fu nctions that establish a  
connection with such an obje ct. For example with the server function as assumed earlier
server (name : STRING ; … Other arguments …): separate  DATABASE
a call of the form server ("Ingres_handler ", …) will yield a separate object denoting the  
Ingres database server. The CCF indicates that the correspondin g object resides on  
machine  mandelstam  and is accessible on port 9000. I n the absence of a port speci fication  
the value used is drawn from the defaults  part or, barring that , a universal default.
The CCF is separate from the so ftware. You may compile a concur rent or distributed  
application without any referenc e to a specific hardware and ne twork architecture; then at  
run time each separate component  of the application will use it s CCF to connect to other  
existing components ( external  parts) and to creat e new components ( creation  parts).
This sketch of CCF con ventions has shown how  we can map the abs tract concepts  
of concurrent O-O computation — processors, created separate ob jects, external separate  
objects — to physical resources.  As noted, these conventions ar e only an example of what  
c a n  b e  d o n e ,  a n d  t h e y  a r e  n o t  p a r t  o f  t h e  b a s i c  c o n c u r r e n c y  m e c hanism. But they  
demonstrate that it is  possible to decouple the software archit ecture of a concurrent system  
from the concurrent hardware arc hitecture available at any part icular stage.
Library mechanisms
With a CCF-like approach, the ap plication softwa re will, most o f the time, not concern  
itself with the physical concurren cy architecture. Some applica tion developers may,  
however, need to exert a finer degree of control from within th e application, at the possible  
expense of dynamic reconfigurability. Some CCF functionalities must then be accessible  
directly to the application, ena bling it, for example, to selec t a specific process or thread  
for a certain processor. They will  be available th rough librari es as part of the two-level  
§30.4   INTRODUCING CONCURRENT EXECUTION 973
concurrency architecture; it doe s not raise any difficult probl em. We will encounter the  
need for more library mechan isms later in this chapter.
A t  t h e  o t h e r  e x t r e m e ,  s o m e  a p p l i c a t i o n s  m a y  w a n t  u n l i m i t e d  r u n - time 
reconfigurability. It is not en ough then to have the ability to  read a CCF or similar  
configuration informat ion at start-up time and then be stuck wi th it. But we cannot either  
expect to re-read the configuration before each operation, as t his would kill performance.  
The solution is once again to use a library mechanism: a proced ure must be available to  
read or re-read the con figuration information dynamically, allo wing the application to  
adapt to a new configu ration when (and only when) it is ready t o do so.
Validity rules : unmasking traitors
Because the semantics of calls i s different for separate and no n-separate objects, it is  
essential to guarantee that a n on-separate entity (declared as x: T for non-separate T) can 
never become attached to a separ ate object. Otherwise a call x  f (a) would wrongly be  
understood — by the compiler, am ong others — as synchronous, wh ereas the attached  
object is in fact separate and requires asynchro nous processing . Such a reference, falsely  
declared as non-separate while h aving its loyalties on the othe r side, will be called a  
traitor . We need a simple validity rule  to guarantee that our software  has no traitor — that  
every representative or lobbyist  of a separate power is duly re gistered as such with the  
appropriate authorities. 
The rule will have four parts. T he first part eliminates the ri sk of producing traitors  
through attachment, tha t is to say assignme nt or argument passi ng:
An attachment of target x and source y is either an assignment x := y o r  a  c a l l  
f (…, y, …) where the actual argument corresponding to x is y. Having such an attachment  
with y separate but not x would make x a traitor, since we could use x to access a separate  
object (the object attached to y) under a non-separate name, as i f it were a local object with  
synchronous call. The r ule disallows this.
Note that syntactically x is an entity but y may be any expression. This means that the rule  
assumes we have defined the notion of “separate expression”, in  line with previous  
definitions. A simple expression is an entity; more complex exp ressions are function calls  
(remember in particular that an infix expression such as a + b  is formally considered a  
call, similar to something like a  plus (b)). So the definition is immediate: an expression  
is separate if it is either a s eparate entity or a separate cal l.
As will be clear from the rest o f the discussion, permitting an  attachment of a non-
separate source to a separate ta rget is harmless — although usu ally not very useful.Separateness consistency rule (1)
If the source of an attachment (assignment instruction or argum ent passing)  
is separate, its target en tity must be separate too.
CONCURRENCY , DISTRIBUTION, CLIENT-SERVER  AND THE INTERNET  §30 .4 974
We need a complementary rule cove r i n g  t h e  c a s e  i n  w h i c h  a  c l i e n t passes to a  
separate supplie r a reference to a local  object. Assume the sep arate call
x  f (a)
where a, of type T, is not separate, although x is. The declaration of routine f, for the  
generating class of x, will be of the form
f (u: … SOME_TYPE )
and the type T of a must conform to SOME_TYPE . But this is not sufficient! Viewed from  
the supplier’s side (that is t o say, from the handler of x), the object O1 attached to a has a 
different handler; so unless the  corresponding formal argument u is declared as separate it  
would become a traitor, giving access to a separate object as i f it were  non-separate:
So SOME_TYPE  must be separate; for example it may be separate  T. Hence the  
second consis tency rule:
The issue only arises for arguments of reference type. The othe r case, expanded types,  
including in particular the  basic types such as INTEGER , is considered next.
As an application of the techniq ue, consider an object that spa wns several separate  
objects, giving them a way to rely later on its resources; it i s saying to them, in effect,  
“Here is my business card ; call me if you need to ” .  A  t y p i c a l  e x a m p l e  w o u l d  b e  a n  
operating system’s kernel that creates several separate objects  and stands ready to perform  
operations for them when they as k. The creation calls will be o f the form
create  subsystem   make (Current , … Other arguments …)Separateness consistency rule (2)
If an actual argument of a separate call is of a reference type , the 
corresponding formal  argument must be declared as separate.Passing a 
reference as 
argument to a 
separate calla O1
Processor 1
Processor 2(T)Here a is a reference  
to a local object .
xf (a)
u  f (u: …)Here u is a reference  
to a separate object .(the handler of x)
§30.4   INTRODUCING CONCURRENT EXECUTION 975
where Current  is the “business card” enabling subsystem  to remember its  progenitor, and  
ask for its help in ca se of need. Because Current  is a referenc e, the corresponding formal  
argument in make  must be declared as separate. Most likely, make  will be of the form
make ( p: separate PROGENITOR_TYPE ; … Other arguments …)
do
progenitor  := p
… Rest of subsystem initi alization operations …
end
keeping the value of t he progenitor argument in an attribute progenitor  of the enclosing  
class. The second separateness  consistency rule requires p to be declared as separate; so  
the first rule requires the same of attribute progenitor . Later calls for pr ogenitor resources,  
of the form progenitor   some_resource (…) will, correctly, be treated as separate calls.
A similar rule is needed  for function results:
Since the last two rules only a pply to actual arguments and res ults of reference types,  
we need one more rule for th e other case, expanded types:
In other words, the only expanded values that we can pass in a separate call are  
“completely expanded” objects, w ith no references to other obje cts. Otherwise we could  
again run into traitor trouble s ince attaching an expanded valu e implies copying an object:Separateness consistency rule (3)
If the source of an attachment is the result of a separate call  to a function  
returning a reference type, the target must  be declared as sepa rate.
Separateness consistency rule (4)
If an actual argument or result of a separate call is of an exp anded type, its  
base class may not include, directly or indirectly, any non-sep arate attribute  
of a reference type.
Passing to a 
separate call an 
object with 
referencesa O1
Processor 1
Processor 2xf (a)
 f (u: …)This is a reference  
to a local object .
(the handler of x)O2
u O'1This is a  
separate reference .
(fields copied  
from O1)
CONCURRENCY , DISTRIBUTION, CLIENT-SERVER  AND THE INTERNET  §30 .4 976
The figure illustrates the case in which the formal argument u is itself expanded.  
Then the attachment is simply a copy of the fields of the objec t O1 onto those of the object  
O'1 attached to u. Permitting O1 to contain a reference would produce a traitor field in O'1.  
The problem would also arise if O1 had a subobject with a refer ence; hence the mention  
“directly or indirectly” in the rule.
If the formal argument u is a reference, the attachme nt is a clone; the call would  
create a new object O'1 similar to the one on the last figure a nd attach reference u to it. In  
this case the solution  is to create the clon e explicitly on the  client’s side, before the call:
a: expanded  SOME_TYPE ; a1: SOME_TYPE
…
a1 := a; -- This clones the ob ject and attaches a1 to the clone.
x  f (a1)
As per the second validity r ule, the formal argument u must be of a separate reference  
type, separate SOME_TYPE  or conforming; the call  on the last line makes u a separate  
reference attach ed to the newly created clone on the client’s s ide.
Importing object structures
A consequence of the separatenes s consistency rules is that it is not possible to use the  
clone  function (from the universal class ANY) to obtain an object handled by another  
processor. The function is declared as
clone (other : GENERAL ): like other
-- New object, field-by -field identical to other
…
so that an attempt to use y := clone (x) for separate x would violate part 1 of the rule: x, 
which is separate, does not conform to other  which is not. This is what we want: a separate  
object running on a machine in V ladivostok may contain (non-sep arate) references to  
objects that are in Vladivostok too; but then if you could clon e it in Kansas City, the  
resulting object would contain traitors — references to those o bjects, now separate, even  
though in the generatin g class the correspo nding attributes are  not declared as separate. 
The following function, also in class GENERAL , enables us to clone separate object  
structures without p roducing traitors:
deep_import (other : separate GENERAL ): GENERAL
-- New object, field-by -field identical to other
…The effect of reat-
tachment in these cases was defined in “ATTACHMENT: REFERENCE AND VALUE SEMAN-TICS”, 8.8, page 261.
See “Object cloning 
and equality”, page 245.
§30.5   SYNCHRONIZATION ISSUES 977
The result is a non-separate obj ect structure, recursively dupl icated from the separate  
structure starting at other . For the reasons just explained, a shallow  import operation could  
yield traitors; so what we n eed is the equivalent of deep_clone  applied to a separate object.  
Function deep_import  provides it. It will produce a c opy of the entire structure, m aking 
all the object copies non-separa te. (It may of c ourse still con tain separate references if the  
original structu re contained references to objects handled by a nother processor.)
For the developers of distributed systems, deep_import  is a convenient and powerful  
mechanism, through which you can transfer possibly large object  structures across a  
network without the need to write any specialized software, and  with the guarantee that  
the exact structure (including cycles etc.) will be faithfully duplicated.
30.5  SYNCHRONIZATION ISSUES
We have our basic mechanism for starting concurrent executions (separate creation) and  
for requesting operations from th ese executions (the usual feat ure call mechanism). Any  
concurrent computation, object -oriented or not, must also provi de ways to synchronize
concurrent executions, that is t o say to define timing dependen cies between them.
If you are familiar with concurr ency issues, you  may have been surprised by the  
announcement that a sing le language mechanism, separate  declarations, is enough to add  
full concurrency support to our sequential object-oriented fram ework. Surely we need  
specific synchronization mechanis ms too? Actually no. The basic  O-O constructs suffice  
to cover a wide range of synchr onization needs, provided we ada pt the definit ion of their  
semantics when they are applied to separate elements. It is a t estimony of the power of the  
object-oriented method that it ad apts so simply and gracefully to concurrent computation.
Synchronization vs. communication
To understand how we should supp ort synchronization in object-o riented concurrency, it  
is useful to begin with a review  of non-O-O solutions. Processe s (the concurr ent units in  
most of these solu tions) need mechanisms of two kinds:
•Synchronization mechanisms enforce timing constra ints. A typical constraint mig ht 
state that a certain operation o f a process, such as accessing a database item, may  
only occur after a certain opera tion of another process, such a s initializing the item.
•Communication  mechanisms allow processes to e xchange information, which in t he 
object-oriented case will be in the form of objects (including the special case of  
simple values such as integers) or object structures.
A simple classification of appro aches to concurrency rests on t he observation that  
some of them focus on the synchr onization mechanism and then us e ordinary non-
concurrent techniques such as ar gument passing for communicatio n, whereas others treat  
communication as the fundamental i ssue and deduce synchronizati on from it. We may talk  
about synchronization-based  and communication-based mechanisms .You should be famil-
iar with the notions of shallow and deep clone ; see “Deep 
clone and compari-son”, page 247 .
CONCURRENCY , DISTRIBUTION, CLIENT-SERVER  AND THE INTERNET  §30 .5 978
Synchronization-based mechanisms
The best known and most elementa ry synchronization-based mechan ism is the  
semaphore , a locking tool for controlling  shared resource s. A semaphore is an object on  
which two operations are available: reserve  and free (traditionally called P and V, but more  
suggestive names are preferable). At any time the semaphore is either reserved by a certain  
client or free. If it is free and a client executes reserve , the semaphore becomes reserved  
by that client. If the client that has reserved it executes free, the semaphore becomes free.  
If the semaphore is reserved by a client and another executes reserve , the new client will  
wait until the semaphore is free again. The following table sum marizes this specification:
Events represented by shaded entries are not supposed to occur;  they can be treated either  
as errors or as having no effect.
The policy for deciding which cli ent gets through when two or m ore are waiting for  
a semaphore that gets freed may be part of the semaphore’s spec ification, or may be left  
unspecified. (Usually clients expect a fairness  property guaranteeing  t h a t  i f  e v e r y o n e  
gaining access to the semaphore u ltimately frees it no one will  wait forever.)
This description covers binary semaphores. The integer variant lets at most n clients  
through at any give n time, for some n, rather than at most one.
Although many practical developments still rely on them, semaph ores are widely  
considered too low-level for buil ding large, reliable systems. But they provide a good  
starting point for  discussing more a dvanced techniques.
Critical regions are a more abstract approach. A c ritical region is a sequence o f 
instructions that may be execute d by at most one client at a ti me. To ensure exclusive  
access to a certain object a you may write something like
hold  a then  … Operations involving fields of a …end
where the critical region is delimited by then … end . Only one client can execute the  
critical region at any given  time; others executing a hold  will wait.
Most applications need a m ore general variant, the conditional critical region , in 
which execution o f the critical region is  subject to a boolean condition. Consider a buffer  
shared by a producer, which can o nly write into the buffer if i t is not full, and a consumer,  
which can only read from it if it is not empty; th ey may use th e two respective schemes
hold buffer  when not buffer   full then “Write into buffer, m aking it not empty” end
hold buffer  when not buffer   empty then “Read from buffer, making it not full” end
Such interplay between input and output conditions cries for in troducing assertions  
and giving them a role in synchr onization, an idea to be exploi ted later in t his chapter.STATE
OPERATIONFree Reserved by 
meReserved by 
someone else
reserve Becomes 
reserved by me.I wait.
free Becomes free.Semaphore 
operations
§30.5   SYNCHRONIZATION ISSUES 979
Another well-known synchronizatio n-based mechanism, combining t he notion of  
critical region with the modular  structure of some modern progr amming languages, is the  
monitor . A monitor is a program module,  not unlike the packages of Mod ula or Ada. The  
basic synchronization mechanism is simple: mutual exclusion at the routine level. At most  
one client may execute  a routine of the monitor at any given ti me.
Also interesting is the notion of path expression . A path expression specifies the  
possible sequenc ing of a set of processe s. For example the expr ession
init ; (reader * | writer )+ ; finish
prescribes the followi ng behavior: first an init process; then a state in which at any time either  
one writer  process or any number of reader processes may be active; then a finish process.  
The asterisk * means any number of concurrent instances; the semicolon  ; indicates  
sequencing;  | means “either-or”;  + means any number of successive repetitions. An  
argument often cited in favor of path expressions is that they specify the processes and the  
synchronization separately, avoi ding interference between the d escription of  individual  
algorithmic tasks and the desc ription of their scheduling.
Yet another category of techniques for specifying synchronizati on relies on analyzing the  
set of states  through which a system or system component can go, and transit ions 
between these states. Petri nets , in particular, rely on graphical descriptions of the  
transitions. Although intuitive for simple hardware devices, su ch techniques quickly  
yield a combinatorial explosion i n the number of states and tra nsitions, and make it hard  
to work hierarchically (specif ying subsystems independently, th en recursively  
embedding their specifications in those of bigger systems). So they do not seem  
applicable to large, evolutionary software systems.
Communication-based mechanisms
Starting with Hoare’s “Communicat ing Sequential Processes” (CSP ) in the late seventies,  
most non-O-O concurrency work h as focused on communication-base d approaches.
The rationale is easy to underst and. If you have solved the syn chronization problem,  
you must still find a way to mak e concurrent units communicate.  But if you devise a good  
communication mechanism you might  very well have solved synchro nization too:  
because two units cann ot communicate unless the sender is ready  to send and the receiver  
ready to receive, communication i mplies synchronization; pure s ynchronization may be  
viewed as the extreme case of co mmunicating an empty message. I f your communication  
mechanism is general eno ugh, it will provide all the synchronization you need.
CSP is based on this “I communicate, therefore I synchronize” v iew. The starting  
point is a generalization of a f undamental concept of computing , input and output: a  
process receive s information v from a certain “channel” c through the construct c ? v; it 
sends information to a chann el through the construct c ! v. Channel input and output are  
only two among the po ssible examples of events .
For more flexibility CSP introdu ces the notion of non-determini stic wait,  
represented by the symbol , enabling a process to wait on  several possible events and  
execute the action associated wit h the first that occurs. Assum e for example a system  
enabling a bank’s customers to m ake inquiries and transfers on their accoun ts, and the  
bank manager to check what is going on:
CONCURRENCY , DISTRIBUTION, CLIENT-SERVER  AND THE INTERNET  §30 .5 980
(balance_enquiry  ? customer  → 
(ask_ password   customer  ? password →
(password_valid → (balance_out   customer  ! balance ) 
      (password_invalid → (denial   customer  ! denial_message )))
      transfer_request  ? customer  → …
      control_operation  ? manager  → …)
I n  t h e  i n i t i a l  s t a t e  t h e  s y s t e m  stands ready to accept one of t hree possible input  
events: a balance_enquiry  or transfer_request from a customer , or a control_operation
from a manager . The first event that occurs will trigger the behavior describ ed, using the  
same mechanisms, on the right of the corresponding arrow.
The right side of the arrow has only been filled in for the fir st event: after getting a  
balance_enquiry  relative to a certain customer , you send the customer  an ask_  password
event from which you expect to get the password ; you validate the password, as a result  
sending to the customer  one of two possible messages: balance_out , with the balance  as 
argument, or denial .
Once the event’s processing is co mplete, the system returns to its initial state,  
listening to possible input events.
The original version of CSP was a major influenc e on the concur rency mechanism  
of Ada, whose “tasks” are processes able to wait on several pos sible “entries” through an  
“accept” instruction. The Occam language, a direct implementati on of CSP, is the primary  
programming tool for the transputer , a family of microprocess ors designed specifically by  
Inmos (now SGS-Thomson) for the construction of highly concurre nt architectures.
Synchronization for concurrent O-O computation
Many of the ideas just  reviewed will help us find the right app roach to concurrency in an  
object-oriented context. In the final form of the solution you will recognize concepts  
coming from CSP as well as monit ors and conditional critical re gions.
The CSP emphasis on communicati on seems right for us, since the  central technique  
of our model of computation — ca lling a feature, with arguments , on an object — is a  
communication mechanism. But ther e is another reason for prefer ring a communication-
based solution: a sync hronization-based mechanism can conflict with inheritance.
This conflict is most obvious if we consider path expressions. The idea of using path  
expressions has attrac ted many researchers on O-O concurrency a s a way to specify the  
actual processing, given by the fe atures of a class, separately  from the synchronization  
constraints, given by path expre ssions. The pure ly computationa l aspects of t he software,  
which may have existed prior to the introduction of concurrency , will thus remain  
untainted by concurren cy concerns. So for example if a class BUFFER has the features  
remove  ( r e m o v e  t h e  o l d e s t  e l e m e n t  o f  t h e  b u f f e r )  a n d  put ( a d d  a n  e l e m e n t ) ,  w e  m a y  
express the synchronization through constraints such as
empty : {put}
partial : {put, remove }
full: {remove }The example reflects 
the most recent CSP rather than the origi-nal 1978 version; see bibliographical notes. On Ada con-currency see p. 1091.
Notation and exam-
ple from [Matsuoka 
1993],  which intro-
duced the term “inheritance anom-aly”. For more 
details on the exam-ple see exercise E30.3, page 1035 .
§30.5   SYNCHRONIZATION ISSUES 981
using a path-expression-like notation which lists three possibl e states and, for each of them,  
the permitted operations. But then assume you want a descendant  NEW_BUFFER  t o 
provide an extra feature remove_two  which removes two buffer items at a time (with a  
buffer size of at least three). Then you need an almost complet ely new set of states:
empty : {put}
partial_one : {put, remove } -- State in which the buff er contains exactly one item
partial_two_or_more : {put, remove , remove_two }
full: {remove , remove_two }
and if the routines specify what states they produce in each po ssible case, they must all be  
redefined from BUFFER  to NEW_BUFFER , defeating the purpo se of inheritance.
This problem, and similar ones identified by several researcher s, have been dubbed  
the inheritance anomaly , and have led some concurrent O-O language designers to view  
inheritance with suspi cion. The first versio n s  o f  t h e  P O O L  p a r a llel object-oriented  
language, for example , excluded inheritance  (see the bibliograp hical notes).
Concerns about the “in heritance anomaly” have sparked an abunda nt literature  
proposing solutions, which generally try to decrease the amount  of redefinition by looking  
for modular ways of specifying t he synchronization constraints,  so that descendants can  
describe the changes more increm entally, instead of having to r edefine everything.
On closer examination, however, the problem does not appear to be inheritance, or  
even any inherent conflict between inheritance and concurrency,  but instead the idea of  
specifying synchronization const raints separately from the rout ines themselves. (The  
formalisms discussed actually do  not quite meet this goal anywa y, since the routines must  
specify their exit states.)
To the reader of this book, fami liar with the principles of Des ign by Contract, the  
technique using explic it states and a list of the features appl icable in each state will look too  
low-level. The specifications of BUFFER  a n d  NEW_BUFFER obscure fundamental  
properties that we have learned to characterize through precond itions: put should state  
require not full; similarly, remove_two should state require count >= 2; and so on. This  
more compact and more abstract sp ecification is easier to expla in, to adapt (changing a  
routine’s precondition does not a ffect any other routine), and t o  r e l a t e  t o  t h e  v i e w s  o f  
outsiders such as customers. Sta te-based techniques appear more  restrictive and error-
prone. They also raise the risk of combinatorial explosion ment ioned in relation to Petri  
nets and other state-based models : for the above elementary exa mples the number of states  
is already three in one case and four in the other, suggesting that in a complex system it  
might become unmanageable. 
The “inheritance anomaly” only oc curs because such specificatio ns tend to be rigid  
and fragile: change an ything, and the whole  specification crumb les. 
At the beginning of this chapter we saw another apparent inheri tance-concurrency clash;  
but the culprit turned out to be the notion of active object. I n both cases inheritance is at  
odds not with concurrency but with a particular approach to con currency (active objects,  
state-based specifications); rather than dismissing or limiting  inheritance — cutting the  
arm whose finger itches — the solution is to look for better co ncurrency mechanisms.See “Active objects 
clash with inheri-tance”, page 959 .
CONCURRENCY , DISTRIBUTION, CLIENT-SERVER  AND THE INTERNET  §30 .6 982
One of the practical consequences of this discussion is that we  should try to rely, for  
synchronization in concurrent computation, on what we already h ave in the object-oriented  
model, in particular assertions. Preconditions will indeed play  a central role for  
synchronization, although we will need to adapt their semantics  from the sequential case.
30.6  ACCESSING SEPARATE OBJECTS
We now have enough back ground to devise the proper synchronizat ion mechanisms for  
our concurrent objec t-oriented systems.
Concurrent accesses to an object
The first question to address is how many executions may procee d concurrently on an  
object. The answer was in fact i mplicit in the definition of th e notions of processor and  
handler: if all calls to features  on an object are executed by its handler (the processor in  
charge of it), and a processor is  a single thread of execution,  it follows that at most one  
feature may be executing on a given object at any time.
Should we not allow several rout ines to execute concurrently on  a given object? The  
main incentive for answering no is to retain the a bility to reason o n our software.
The study of class correctness in  an earlier chapter provides t he proper perspective.  
We saw the lifecycle of  an object pictured as this:
In this view the object is exter nally observable only in the st ates marked as shaded  
squares: just after creation (S1), after every application of a  feature by a client (S2 and  
subsequent states). These have b een called the “stable times” o f the object’s life. A  
consequence was the formal rule: to prov e the correctness of th e class, we only have to  
v e r i f y  o n e  p r o p e r t y  f o r  e a c h  c r e a t i o n  p r o c e d u r e ,  a n d  o n e  p r o p e r t y  f o r  e a c h  e x p o r t e d  
feature. If p is a creation procedure, the property to check
{Default and prep}  Bodyp  {postp and INV}The life of an 
object  
(This figure first 
appeared on page 365.)create  a  make 
S1
S2
S3
S4a  f (…)
a  g (…)
a  f (…)create  a  make (…)
These rules have 
been slightly sim-plified . The full ver-
sions appear in “WHEN IS A CLASS COR-RECT?”, 11.9, page 369 .
§30.6   ACCESSING SEPARATE OBJECTS 983
meaning: if you exe cute the body of p when the object has been initialized to the default  
values and the precondition of p holds, you will end up satisfying the postcondition and  
the invariant. For an exported routine r, the property to check
{prer and INV}  Bodyr  {postr and INV}
meaning: if you execute r when the precondition and the i nvariant are satisfied, you wil l 
end up satisfying the postcon dition and the invariant.
So the number of things  to check is very limited; there are no complicated run-time  
scenarios to analyze. This is im portant even in a somewhat info rmal approach to software  
development, which still require s the ability to reason about t he software execution by  
examining the software text. The  informal versi on of the preced ing properties is that you  
can understand the class by look ing at its routines separately from each other —  
convincing yourself, h owever informally, that each routine will  deliver the intended final  
state starting from the expected initial state.
Introduce concurrent execution in to this simple, consistent wor ld, and all hell breaks  
loose. Even plain interleaving, in which we would start executi ng a routine, interrupt it in  
favor of another, switch back to the first and so on, would dep rive us from any ability to  
use straightforward re asoning on our software texts. We simply would not hav e any clue  
as to what can happen at run-time; trying to  guess would force us to examine all possible  
interleavings, immediat ely leading to a combinatorial explosion  of cases to consider.
So for simplicity and consistency we will let at most one routi ne execute on any  
particular object at any particular time. Note, however, that i n a case of emergency, or if a  
client keeps an object for too long, we should be able to interrupt the client, as long as  
we do so in a sufficiently violent way — triggering an exceptio n — to ensure that the  
unfortunate client will receive a  notification, e nabling it to take corrective action if  
appropriate. The mechanism of duels , explained later, offers that possibility.
The end of the discussion secti on examines whether any circumst ances would allow us  
to relax the prohibition of concurrent accesses to a single obj ect.
Reserving an object
We need a way for a client to obtain exclusive access to a cert ain resource, represented by  
a certain object.
An idea which seems attractive at  first (but will not suffice) would be simply to rely  
on the notion of separ ate call. Consider, executed on behalf of  a certain client object O1,  
the call x  f (…), for separate x a t t a c h e d  a t  r u n  t i m e  t o  O 2 .  O n c e  t h e  c a l l  h a s  s t a r t e d  
executing, we have seen that O1 can safely move to its next bus iness without waiting for  
the call’s termination ; but this execution  of the call cannot s tart until O2 is free for O1. So  
we might decide that before star ting the call the client will w ait until the target object is free.
Unfortunately this simple schem e is not suf ficient,  because it does not allow the  
client to decide how long to retain an object. Assume O2 is som e shared data structure  
such as a buffer, and the corresponding class provides procedur e remove to remove an  
element. A client O1 may need to remove two consecutive element s, but just writing
CONCURRENCY , DISTRIBUTION, CLIENT-SERVER  AND THE INTERNET  §30 .6 984
buffer   remove ; buffer   remove
will not do: between the two instructions, any other client can  jump in and perform  
operations on the shared structu re! So the two elements might n ot be adjacent.
One solution is to add to the generating class of buffer  (or of a descendant) a  
procedure remove_two  that removes two elements at once. But in the general case tha t is 
unrealistic: you cannot change yo ur suppliers for every synchro nization need of your own  
client code . There must be a way for the client to reserve a supplier obje ct for as long as  
it needs, using the supplier class as it is.
In other words, we need somethin g like a critical region mechan ism. The syntax  
introduced earlier was
hold a then actions_requiring_ exclusive_access end
or the conditional variant
hold a when a  some_property then actions_requiring_exclusive_access end
W e  w i l l ,  h o w e v e r ,  g o  f o r  a  s i m p l e r  a p p r o a c h ,  p e r h a p s  s u r p r i s i n g  at first. The  
convention will simply be that if a is a non-void separate exp ression a call of the form
actions_requiring_exclusive_access (a)
causes the caller t o wait until the ob ject attached to a is available. In other words, there is  
no need for a hold  instruction; to reserve a separa te object, you simply use it a s actual  
argument in a call.
Note that waiting only makes sense if the routine contains at l east one call x  some_routine  
on the formal argument x corresponding to a. Otherwise, for example if all it does is a  
“business card” assignment some_attribute  := x, there is no need to wait. This is specified  
in the full form of the rule, also involving preconditions, whi ch appears later in this chapter.
Other policies are possible, and  indeed some authors have propo sed retaining a hold
instruction (see the bibliographical notes). But the use of arg ument passing as the object  
reservation mechanism helps keep  the concurrency model simple a nd easy to learn. One  
of the observations justifying  this policy is that with the hold  scheme shown above it will  
be tempting for developers, in l ine with the general “Encapsula te Repetition” motto of  
O-O development, to gather in a routine the actions that requir e exclusive access to an  
object; this trend was foresee n in the above summary of the hold  instruction, where the  
actions appear as a single routine actions_requiring_exclusive_access . But then such a  
routine will need an argument re presenting the object; here we go further and consider that  
the presence of such an argument suffices to achieve object res ervation.
This convention also means th at, paradoxically enough, most separate calls do not  
need to wait . When we are executing the body of a routine tha t has a separa te formal  
argument a, we know that we have already reserved the attached object, so  any call with  
target a can proceed immediately. As we h ave seen, there is no need to wait for the call to  
terminate. In the general case , with a routine of the formOn critical regions 
see “Synchroniza-tion-based mecha-nisms”, page 978 .
“Separate call 
semantics”, page 996.
§30.6   ACCESSING SEPARATE OBJECTS 985
r (a: separate  SOME_TYPE )
do
…; a  r1 (…); …
…; a  r2 (…); …
end
an implementation can continue e xecuting the intermediate instr uctions without waiting  
for any of the calls to terminate, as long as it logs all the c alls on a so that they will be  
executed in the order requested. (We have yet to see how to wai t for a separate call to  
terminate if that is what we wan t; so far, we just start calls and never wait!)
If a routine has two or more separate arguments, a client call will wait until it can reserve  
all the corresponding objects. This requirement is hard on the comp iler, which will have  
to generate code using protocols for multiple simultaneous rese rvations; for that reason,  
an implementation might at first impose the restriction that a routine may have at most  
one separate formal argument. But if the full mechanism is impl emented it provides  
considerable benefits to applica tion developers; as a typical e xample, studied later in this  
chapter, the famous “dining philosophers” problem admits an alm ost trivial solution.
Accessing separate objects
The last example shows how to us e, as the target of a separate call, a formal argument,  
itself separate, of the enclosing routine r. An advantage is that we do not need to worry  
about how to get access to the target object: this was taken ca re of by the call to r, which  
had to reserve the obj ect — waiting if nece ssary until it is fr ee.
We can go further and make this scheme the only one for sep arate calls:
Remember that a call a  r (…) is separate if the target a is itself an entity or expression  
declared as separate. So if we have a separate entity  a we cannot call a feature on it unless  
a is a formal argument of the enclosing routine. If, for example , attrib is an attribute  
declared as separate, we must use, instead of attrib   r (…), the call rf  (attrib , …) with
rf  (x: separate  SOME_TYPE ; … Other arguments …)
-- Call r on x.
do
x  r (…)
end
This rule may appear to place an  undue burden on developers of concurrent  
applications, si nce it forces them to en capsulate all uses of s eparate objects in routines. It  
may indeed be possible to devise  a variant of this chapter’s mo del which does not include  
the Separate Call rule; but as you start using the model you wi ll, I think, realize that the  Separate Call rule
The target of a separate call must be a formal argument of the routine in  
which the call appears.
CONCURRENCY , DISTRIBUTION, CLIENT-SERVER  AND THE INTERNET  §30 .6 986
rule is in fact of great help. It  encourages developers to iden tify accesses to separate  
objects and separate them from th e rest of the computation. Mos t importantly, it avoids  
grave errors that would be almost bound to happen without it.
The following case is typical. A ssume a shared data structure —  such as, once again,  
a buffer — with features remove to remove an element and count  to query the number of  
elements. Then it is quite “natural” to write
if buffer   count >= 2 then
buffer   remove ; buffer   remove
end
The intent is presumably to remove two elements. But, as we hav e already seen, this will  
not always work — at least not unless we have secured exclusive  access to buffer . 
Otherwise between the time you test count and the time you execute the first remove , any 
other client can come in and remove an element, so that you wil l end up trying to apply  
remove  to an empty structure.
Another example, assuming that w e follow the style of previous chapters and include  
a feature item, side-effect-free, to return the element that remove  removes,
if not buffer   empty then
value  := buffer   item; buffer   remove
end
Without a protection on buffer , another client may a dd or remove an element  
between the calls to item and remove . If the author of the abo ve extract thinks that the  
effect is to access an element and remove it, he will be right some of the time; but if this  
is not your lucky day you will access an ele ment and remove ano ther — so that you may  
for example (if you repeat the ab ove scheme) access the same el ement twice! Very wrong.
By making buffer  an argument of the enclosing ro utine, we avoid these problems:  
buffer is guaranteed to be re served for the duratio n of the routine’s call.
Of course the fault in the examp les cited lies w ith the develop er, who was not careful  
enough. But without th e Separate Call rule s uch errors are too easy to make. What makes  
things really bad is that the run-time behavior is non-determin istic, since it depends on the  
relative speed of the clients. The bug will be intermittent, he re one minute, gone the next.  
Worse yet, it will probably occu r rarely: after all (using the first example) a competing  
client has to be quite lucky to squeeze in between your test of  count  and your first call to  
remove . So the bug may be very hard  to reproduce and isolate.
Such tricky bugs are responsible for the nightmarish reputation  of concurrent system  
debugging. Any rule that can significantly decrease their likel ihood of occurring is a big  
potential help.
With the Separate Call rule you will write the examples as the following procedures,  
assuming a separate type BOUNDED_BUFFER  detailed below:According to David 
Gries , “natural” is 
one of the most dan-gerous words in soft-ware discussions .
§30.6   ACCESSING SEPARATE OBJECTS 987
remove_two (buffer : BOUNDED_BUFFER )
-- Remove oldest two items.
do
if buffer   count >= 2 then
buffer   remove ; buffer   remove
end
end
get_and_remove (buffer : BOUNDED_BUFFER )
-- Assign oldest item to value , and remove it.
do
if not buffer   empty then
value  := buffer   item; buffer   remove
end
end
These procedures may be part of some application class; prefera bly, they will appear  
i n  a  c l a s s  BUFFER_ACCESS which encapsulates buffer ma nipulation operations, and  
serves as parent to ap plication classes need ing to use buffers of the appropriate type.
The procedures both se em to be crying for a precondition. We wi ll shortly see to it  
that they can get one.
Wait by necessity
A s s u m e  t h a t  a  s e p a r a t e  c a l l  s u c h  a s  buffer   remove has been started, after waiting if  
necessary for any separate arguments to become available. We ha ve seen that from then  
on it does not block the client, which can proceed with the res t of its computation. But  
surely the client may need to re synchronize with the supplier. When should we wait for  
the call to terminate?
It would seem that we need a special mechanism, as has indeed b een proposed by  
some concurrent O-O languages such as Hybrid, to reunite the pa rent computation with its  
prodigal call. But instead we ca n use the idea of wait by neces sity, due to Denis Caromel.  
The goal is to wait when we tr uly need to, but no earlier.
When does the client need to be sure that a call a  r (…), for separate a attached to a  
separate object O1, is  finished? Not when it is doing something  else on other objects,  
separate or not; not even necessarily when it has started a new  procedure call a  r (…) on 
the same separate object since, as we have seen, a smart implem entation can simply log  
such calls so that they will be processed in the order emitted (an essential re quirement, of  
course); but when we need to access some property of O1. Then  we require the object to  
be available, and all preceding c alls on it to ha ve been finish ed.
You will remember the division of features into commands  (procedures), which  
perform some transformation on the target object, and queries (functions and attributes)  
which return information about it. Command calls do not need to  wait, but query calls may.See the bibliographi-
cal notes .
CONCURRENCY , DISTRIBUTION, CLIENT-SERVER  AND THE INTERNET  §30 .6 988
Consider for example  a separate stack s and the successive calls
s  put (x1); … Other instructions  …; s  put (x2); … Other instructions …; value  := s  item
(which because of the Separate Ca ll rule must appear in a routi ne of which s is a formal  
argument). Assuming none of the Other instructions  uses s, the only one that requires us  
to wait is the last instruction since it needs some information  about the stack,  its top value  
(which in this case should be x2).
These observations yield the bas ic concept of wait by necessity : once a separate call  
has started, a client only needs to wait for its termination if  the call is to a query. A more  
precise rule will be given below , after we look at a practical example.
Wait by necessity (also called “lazy wait”, and similar to mech anisms of “call by  
necessity” and “lazy evaluation” familiar to Lispers and studen ts of theoretical computing  
science) is a convenient rule wh ich allows you to start paralle l computations as you need  
and avoid unnecessary waiting, bu t be reassured that the comput ation will wait when it must.
A multi-launcher
Here is a typical example showin g the benefits of wait by neces sity. Assume that a certain  
object must create a set of othe r objects, each of which goes o ff on its own:
launch (a: ARRAY [separate  X])
-- Get every element of a started.
require
-- No element of a is void
local
i: INTEGER
do
from i := a  lower until i > a  upper loop
launch_one (a @ i ); i := i + 1
end
end 
launch_one (p: separate X)
-- Get p started.
require
p /= Void
do
p  live
end 
If, as may well be the case, procedure live of class X describes an infinite process,  
this scheme relies on the guarantee that each loop iteration wi ll proceed immediately after  
starting launch_one , without waiting for the call t o terminate: otherwise the loop  would  
never get beyond its first iteration. One of the examples below  uses this scheme. 
Readers familiar with coroutine-ba sed discrete event simulation , studied in a later  
chapter, will recognize a scheme very close to what happens whe n you start a simulated  
process and want to gain control back, as permitted by Simula’s  detach  instruction.“The dining philos-
ophers”, page 1003 .
“Coroutine con-
cepts”, page 1118 .
§30.6   ACCESSING SEPARATE OBJECTS 989
An optimization
(This section examines a fine po int and may be skipped on first  reading.)
To wrap up this discussion of wai t by necessity we need to exam ine more carefully  
when a client should wait for a separate call to terminate.
We have seen that only query call s should cause waiting. But we  may go further by  
examining whether the query’s result is of an expanded type or a reference type. (For the  
s  item example, assuming s of type STACK [SOME_TYPE ], this is determined by SOME_
TYPE .) If the type is expand ed, for example if it is INTEGER or another of the basic types,  
there is no choice: we need the value, so the client computatio n must wait until the query  
has computed its result. But for  a  r e f e r e n c e  t y p e ,  o n e  c a n  i m a g ine that a smart  
implementation could still procee d while the result, a separate  object, is being computed;  
in particular, if the implementation uses proxies for separate objects, the proxy object itself  
can be created immediately, so that the reference to it is avai lable even if the proxy does  
not yet refer to the d esired separa te object.
This optimization, however, comp licates the conc urrency mechani sm because it  
means proxies must have a “ready or not” boolean attribute, and  all operations on separate  
r e f e r e n c e s  m u s t  w a i t  u n t i l  t h e  p r o x y  i s  r e a d y .  I t  a l s o  s e e m s  t o  p r e s c r i b e  a  p a r t i c u l a r  
implementation — through proxies . So we will not retain it as p art of the basic rule:
To account for the possible optimization just discussed, replac e “a call to a query ” 
by “a call to a query retu rning of ex panded type ”.
Avoiding deadlock
Along with several typical and i mportant examples of passing se parate references to  
separate calls, we have seen tha t it is also possible to pass n on-separate references, as long  
as the corresponding formal argum ents are declared as separate (since, on the supplier’s  
side, they represent f oreign objects, and we do not want any tr aitors). Non-separate  
references raise a risk of deadl ock and must be handled careful ly.
The normal way of passing non-separate references is what we ha ve called the  
business card  scheme: we use a separate call of the form x  f (a) where x is separate but a 
is not; that is to say, a is a reference to a local object of the client, possibly Current  itself;  
on the supplier side, f  is of the formWait by necessity
If a client has started one or more calls on a certain separate  object, and it  
executes on that object a call to a query, that call will only proceed after all  
the earlier ones have been completed, and any further client op erations will  
wait for the query c all to terminate. 
CONCURRENCY , DISTRIBUTION, CLIENT-SERVER  AND THE INTERNET  §30 .7 990
f (u: separate  SOME_TYPE )
do
local_reference  := u
end
where local_reference , also of type separate  SOME_TYPE , is an attribute of the enclosing  
supplier class. Later on, in routines other than f, the supplier may use local_reference  to 
request operations on objects on the original client’s side, th rough separate calls of the  
form local_reference   some_routine (…)
This scheme is sound. Assume, however, that f  did more, for example that it included  
a call of the form u  g (…) for some g. This is likely to produce deadlock: the client (the  
handler for the object attached to u and a) is busy executing f or, with wait by necessity,  
may be executing another call th at has reserved the same object .
The following rule will avoi d this kind of situation:
At present this is a only method ological guideline although it may be desirable to  
introduce a formal validity rule (an exercise asks you to explo re this idea further.) Some  
more comments on deadlocks app ear in the discu ssion section.
30.7  WAIT CONDITIONS
One synchronization rule remains  to be seen. It will deal with two questions at once:
• How can we make a client wait until a certain condition is sat isfied, as in conditional  
critical regions?
• What is the meaning of asserti ons, in particular preconditions , in a concurrent context?
A buffer is a separate queue
We need a working exam ple. To study what happens to assertions,  it is interesting to take  
a closer look at a not ion that is ubiquitous  in concurrent appl ication (and  ha s al r ea dy  
appeared informally several times in this chapter): bounded buffers . A bounded buffer,  
illustrated by the top figure on the facing page, allows differ ent components of a  
concurrent system to e xchange data, produced by some and consum ed by others, without  
forcing each producer that has generated an object to wait unti l a consumer is ready to use  
it, and conversely. Instead, commu nication occurs through a sha red structure, the buffer;  
producers deposit their wares i nto the buffer, and consumers ge t their material from it. In  
a bounded implementation the stru cture can only hold a certain number maxcount of 
items, and so it can get full. Bu t waits will only occur when a  consumer needs to consume  Business Card principle
If a separate call uses a non-separate actual argument of a ref erence type, the  
routine should only use the corresponding formal as source of a ssignments.
Exercise E30.4, page 
1035; see also E30.13, 
page 1036.
§30.7   WAIT CONDITIONS 991
and the buffer is empty, or when  a producer needs to produce an d the buffer is full. In a  
well-regulated system such events will be much more infrequent than with unbuffered  
communication, and their frequency  will decrease as the buffer’ s capacity grows. True, a  
new source of delays arises beca use buffer access must be exclu sive: at most one client  
may at any one time be performing a deposit ( put) or retrieval ( item, remove ) operation.  
But these are very simple and fa st operations, so any resulting  wait is typically short.
In most cases the time sequence in which objects have been prod uced is relevant to  
the consumers, so the buffer must maintain a first-in , first-out  policy (FIFO): an object  
deposited before another must be  retrieved before it. The behav ior is similar to that of train  
cars being added at one end of a  single track and removed at th e other end:
A typical implementation — not essential to the discussion, but g iving us a more  
concrete view — can use an array representation of size capacity  = maxcount + 1 , managed  
circularly; the integer oldest  will be the index of the oldest item, and next the index of the  
position to be used for inserting the next item that comes in. We can picture the array as  
being torn into a ring so that positions 1 and capacity  are conceptually adjacent:
The procedure put used by a produce r to add an item x will be implemented as
representation   put (x, next ); next  := (next \\ maxcount ) + 1
where \\ is the integer remainder operation; the query item used by consumers to obtain  
the oldest element simply returns representation @ oldest  (the array element at index  
oldest ); and procedure remove  simply executes oldest := (oldest  \\ maxcount ) + 1 . The Producers
produceConsumers
consume
The bounded queue 
of the Undoing design pattern used a similar representa-tion. See page 710.Bounded buffer
Bounded buffer 
implemented by 
an array1
maxcount
nextoldest
capacity
Occupied position
Free position
Reserved position
CONCURRENCY , DISTRIBUTION, CLIENT-SERVER  AND THE INTERNET  §30 .7 992
array entry at index capacity , shaded in gray on the figure, is kept free; this makes it  
possible to distinguish between the test for empty , expressed as next = oldest , and the test  
for full, expressed as (next \\ maxcount ) + 1 = oldest .
The structure, with its FIFO pol icy, and the circular array rep resentation, are of  
course not concurrency-specific: what we have is simply a bounded queue  similar to  
many of the structures studied i n preceding chapters. Writing t he corresponding class —  
directly applicable to the Undoing design pattern — is not hard ; here is a short form of the  
class, in simplified form (main  features only, header comments removed, principal  
assertion clauses only):
class interface BOUNDED_QUEUE [G] feature
empty , full: BOOLEAN
put (x: G)
require
not full
ensure
not empty
remove
require
not empty
ensure
not full
item: G
require
not empty
end
Obtaining from this description a class describing bounded buff ers is about as simple  
as we could dream:
separate class BOUNDED_BUFFER [G] inherit
BOUNDED_QUEUE [G]
end
The separate  qualifier applies only to the class where it appears, not its heirs. So a  
separate class may, as here, inherit from a non-separate one, a nd conversely. The  
convention is the same as with the other two qualifiers applica ble to a class: expanded
and deferred . As noted, the three properties are mutually exclusive, so tha t at most one  
of the qualifiers may appear before the keyword class .
We see once again the fundamenta l simplicity of concurrent O-O software  
development, and the smooth tran sition from sequential to concu rrent concepts, made  
possible in particular by the me thod’s focus on encapsulation. A bounded buffer (a notion  
for which you will find many com plicated descriptions if you lo ok at the concurrency  
literature) is nothing else than a bounded queue made separate.For an alternative 
technique see “Unconstrained genericity”, page 1181 .
§30.7   WAIT CONDITIONS 993
Preconditions under concurrent execution
Let us examine a typical use of a bounded buffer  buffer by a client, for example a producer  
that needs to deposit a certain object y using the procedure put. Assume that buffer  is an 
attribute of the enclosing class, having been declared, for som e type T which is also the  
type of y, as buffer : BOUNDED_BUFFER [T].
The client may for example have initialized buffer to a reference to the actual buffer  
passed by its creation procedure, using the business card scheme suggested earlier:
make (b: BOUNDED_BUFFER [T], …) do …; buffer  := b; … end
Because buffer , being declared of a separate t ype, is a separate entity, any call of the  
form buffer   put (y) is a separate call and has to appear in a routine of which buffer  is an 
argument. So we should instead use put (buffer , y) where put (a routine of the client class,  
not to be confused with the put of BOUNDED_BUFFER , which it calls ) is declared as
put (b: BOUNDED_BUFFER [T]; x: T)
-- Insert x into b. (First attempt.)
do
b  put (x)
end
Well, this is not quite right. Procedure put o f  BOUNDED_BUFFER  h a s  a  
precondition, not full. Since it does not make sense to try to insert x into b if b is full, we  
should mimic this prec ondition for our new p rocedure in the cli ent class:
put (b: BOUNDED_BUFFER [T]; x: T)
-- Insert x into b.
require
not b  full
do
b  put (x)
end
Better. How can we call this  procedure with a specific buffer  and y? We must make  
sure, of course, that the precon dition is satisfied on input. O ne way is to test:
if not full (buffer ) then put (buffer , y)- -  [PUT1]
but we could also rely on th e context of the call as in
remove (buffer ); put (buffer , y)- -  [PUT2]
where the post condition of remove  includes not full. (Example PUT2 assumes that its  
initial state sati sfies the appropri ate precondition, not empty , for remove  itself.)
Is this going to work? The answe r, disappointing in light of th e earlier comments  
about the unpredictability of bugs in concurrent systems, is maybe . Between the test for  
full and the call for put in the PUT1 variant, or between remove  and put in PUT2, any other  
client may have interfered and ma de the buffer full again. This  is the same flaw that  
required us, earlier on, to prov ide an object reservation mecha nism through encapsulation.
CONCURRENCY , DISTRIBUTION, CLIENT-SERVER  AND THE INTERNET  §30 .7 994
We could try encapsulation again by writing PUT1 or PUT2 as a p rocedure to which  
buffer  will be passed as argument, giving for PUT1:
put_if_possible (b: BOUNDED_BUFFER  [T]; x: T)
-- Insert x into b if possible; otherwise set was_   full to true.
do
if b  full then  was_  full:= True else
put (b, x); was_  full := False
end
end
But this does not really help me as a client. First, having to check was_    full on return is a  
nuisance; then, what do I do if it is true? Try again, probably  —  b u t  w i t h  n o  m o r e  
guarantee of result. What I probably want is a way to execute put when the buffer is  
indisputably non-full, even if I have to wait for this to be the case.
The precondition paradox
This situation that we have just  uncovered is disturbing becaus e it seems to invalidate, in  
a concurrent context, the basic methodological guideline for ge tting software right: Design  
by Contract. With a queue, that is to say in sequential computa tion, we have been used to  
precisely defined sp ecifications of mutu al obligations and benefits:
Implicit behind such contracts is a no hidden clause  principle: the precondition is  
the only requirement that a client must satisfy to get served. If you call put with a non-full  
queue, you are entitled to the r outine’s result, as expressed b y the postcondition.
But in a concurrent context, with a separate supplier such as a  BOUNDED_BUFFER , 
things are rather distressing for the client: however hard we t ry to please the supplier by  
ensuring its stated precondition, we can never be sure to meet its expectations! To execute  
correctly, however, the suppliers still need the precondition. For example the body of  
routine put in class BOUNDED_QUEUE  (which is the same as in BOUNDED_BUFFER ) 
will most likely not work unless full is guaranteed to be false.put OBLIGATIONS BENEFITS
Client(Satisfy precondition :)
Only call put (x) on a non-
full queue.(From postcondition :)
Get new, non-empty queue 
with x added.
Supplier (Satisfy postcondition :)
Update queue to add x and 
ensure not empty .(From precondition :)
Processing protected by 
assumption that queue not full.A contract : 
routine put for 
bounded 
queues
(From the 
example for stacks on page 342 .)
§30.7   WAIT CONDITIONS 995
To summarize: suppliers cannot do their work without the guaran tee that the  
precondition holds; but for sepa r a t e  a r g u m e n t s  t h e  c l i e n t s  a r e  unable  t o  e n s u r e  t h e s e  
preconditions. This may be called the concurrent precondition paradox .
There is a similar postcondition  paradox: on return from a separate call to put, we cannot  
any more be sure that not empty and other postcondition clauses hold for the client. These  
properties are satisfied just afte r the routine’s termination; but some other client may  
invalidate them before the caller gets restarted. Because the p roblem is even more serious  
for preconditions, which determine the correct execution of sup pliers, the rest of the  
discussion mainly considers preconditions.
The paradoxes only arise for separate formal arguments. For a n on-separate  
argument — in particular for an expanded value s uch as an integ er — we can continue to  
rely on the usual prop erties of assertions . But this not much c onsolation.
Although this has not yet been w idely recognized in the literat ure, the concurrent  
precondition paradox is one of t he central issues of concurrent  O-O software construction,  
and the futility of trying to retain habitual assertion semanti cs is one of the principal  
factors distinguishing concurrent computation from its sequenti al variants.
The precondition paradox may also a rise in situations that are not ordinarily thought of  
as involving concurrency, such as accessing a file. This is exp lored in an exercise.
The concurrent semantics of preconditions
To resolve the concurrent precondition paradox we assess the si tuation through three  
observations:
A1 • Suppliers need the preconditions to protect their routine bodie s. Here put will never  
work, in class BOUNDED_BUFFER  as in BOUNDED_QUEUE , unless the routine  
has the guarantee that on en try the queue is non-full.
A2 • S e p a r a t e  c l i e n t s  c a n n o t  r e l y  a n y  m o r e  o n  t h e  u s u a l  ( s e q u e n t i a l )  semantics of  
preconditions. Testing for full before calling your buffer supplier gives you no  
guarantee at all.
A3 • Because each client may be vying  with others for resource acces s, a client may be  
prepared to wait before it gets its resources — if this guarant ees correct processing  
after the wait.
The conclusion seems i nescapable: we still n eed preconditions, if only for the  
suppliers’ sake, but they must b e given a different semantics. Instead of being a  
correctness condition , as in the sequential context, a precondition a pplying to a se parate  
argument will be a wait condition . This will apply to what we may call “separate  
precondition clauses”:  any precondition clau se involving a call  whose target is a separate  
argument. A typical separa te precondition clause is not b  full for put.Exercise E30.6, 
page 1036 .
CONCURRENCY , DISTRIBUTION, CLIENT-SERVER  AND THE INTERNET  §30 .7 996
Here is the rule:
A separate object is free if it is not being used as an actual argument of a separate  
call (implying that no routin e is being executed on it).
The rule only causes waiting for separate arguments appearing a s call targets  
somewhere in the routine’s body (it uses the word “blocking” fo r the corresp onding objects  
since they can block the call from proceeding). With a routine of the “business card” form
r (x: separate  SOME_TYPE ) do some_attribute  := x end
or some other scheme that does n ot contain a call of the form x  some_routine , there is no  
need to wait on the actual  argument corresponding to x.
If there is such a call the short form of the class must reflec t it for the benefit of client  
authors. It will present the routine header as r (x: blocking SOME_TYPE )…
With this rule the above version of put in a client cla ss achieves the desired result:
put (b: BOUNDED_BUFFER [T]; x: T)
require  
not b  full
do 
b  put (x)
ensure  
not b  empty
end
A call of the form put (buffer, y ), from a producer client, will wait until buffer  is free  
(available) and not full. If buffer is free but full, the call canno t be satisfied; but some other  
client, a consumer, may get acces s to it (since the preconditio n of interest to consumers,  
not b  empty , will be satisfied in this case ); after such a client has remo ved an item, making  
the buffer non-full, the producer  client can now have its call executed.
Which client should the implementation let through if two or mo re satisfy the conditions  
of the rule (blocking objects free, preconditions satisfied)? S ome people, for fear of  
overspecifying, prefer to leave such decisions to the compiler,  while providing library  
features allowing an application to specify a pa rticular policy . It seems better to define a  
default first-in-first-out policy, which enhances portability a nd helps towards solving the  
issue of fairness. Library mechanisms can still be available to  application writers who  
wish to override the default.
Be sure to note that the special  semantics of preconditions as wait conditions only  
applies to what we have called separate precondition clauses, t h a t  i s  t o  s a y ,  c l a u s e s  
involving a condition of the form b  some_property  where b is a separate argument. A non-Separate call semantics
Before it can start executing the routine’s body, a separate ca ll must wait until  
every blocking object is free a nd every separate precondition c lause is satisfied.
In this definition, an object is blocking if it is attached to an actual argument,  
and the routine uses the corresponding formal as the target of at least one call.
§30.7   WAIT CONDITIONS 997
separate clause, such as i > = 0 where i is an integer, or b /= Void  even if b is separate (this  
does not involve a call on b), will keep its usual correctness semantics since the concurre nt 
precondition paradox does not ap ply in such cases: if the clien t ensures the stated  
condition before the call, it will still hold when the routine starts; if the condition does not  
hold, no amount of waiting wo uld change the situation.
Assertions , sequential and concurrent
The idea that assertions, and in  particular preconditions, may have two diffe rent semantics  
— sometimes correctness conditi ons, sometimes wait conditions —  may have surprised  
you. But there is no w ay around it: the sequential semantics is  inapplicable in the case of  
separate precond ition clauses.
One possible objection must be an swered. We have seen that a me re compilation  
switch can turn run-time assertion checking on or off. Is it no t dangerous, then, to attach  
that much semantic importance to preconditions in concurrent ob ject-oriented systems?  
No, it is not. The assertions ar e an integral part of the softw are, whether or not they are  
enabled at run time. Because in a correct sequential system the  assertions will always hold,  
we may turn off assertion checking for efficiency if we think w e have removed all the  
bugs; but conceptually the asser tions are still there. With con currency the only difference  
is that certain assertions — the  separate precondition clauses — may be violated at run  
time even for a correct system, and serve as wai t conditions. S o the assertio n monitoring  
options must not app ly to these clauses.
A validity constraint
To avert deadlock situations, we need to impose a validity cons traint on precondition and  
postcondition clauses. Assume we  permitted routi nes of the form  
f (x: SOME_TYPE )
require
some_property (separate_attribute )
do
…
end
where separate_attribute  is a separate attribute of the enclosing class. Nothing in thi s 
example, save separate_attribute , need be separate. The evaluation of f  ’s precondition,  
either as part of assertion monitoring for correctness, or as a  synchronization condition if  
the actual argument corresponding to x in a call is itself separate , could cause blocking if  
the attached object is not available.
This is not acceptable and is pro hibited by the following rule:
Assertion Argument rule
If an assertion contains a functi on call, any actual argument o f that call must,  
if separate, be a formal argum ent of the enclosing routine.See “Monitoring 
assertions at run time”, page 392 .
As a consequence, 
the assertion may 
not appear in a class 
invariant, which is not part of a routine.
CONCURRENCY , DISTRIBUTION, CLIENT-SERVER  AND THE INTERNET  §30 .8 998
States and transitions
The following figure summarizes some of the preceding discussio n by showing the  
various possible states in which objects and processors may be,  and how they will change  
state as a result of calls. 
A call is successful  if the handler of its target is  idle or suspended, all its non -void 
s e p a r a t e  a r g u m e n t s  a r e  a t t a c h e d  t o  f r e e  o b j e c t s ,  a n d  t h e  c o r r e s ponding separate  
precondition clauses, if any, are true. Note that this makes th e definitions of object and  
processor states mutually dependent.
30.8  REQUESTING SPECIAL SERVICE
We have completed the review of the basic communication and syn chronization policy.  
For more flexibility, it is usef ul to define a few mechanisms t hat will allow interrupting  
the normal processing in some cases.
Because these facilities are ad d-ons intended for convenience, rather than a part of  
the basic concurrency model, the y are available not as language  constructs but as library  
features. We will assume a class CONCURRENCY , which classes needing these special  
mechanisms can inherit. A simila r approach has already been use d twice in this book:
•To complement the basic exception handling rules when finer con trol is desired,  
through the library class EXCEPTIONS .
• To complement the default memor y management and garbage collec tion mechanism  
when finer control is desired , through the l ibrary class MEMORY .Successful call uses as target an 
object handled by this processorCall terminatesFREE RESERVED
IDLE BUSY
Call terminatesSuccessful call us es this object as 
separate argumentObject states
Processor states
SUSPENDEDCurrent routine attempts  
an unsuccessful call++
Same
as ++Object and 
processor states 
and transitions
“ADVANCED 
EXCEPTION HAN-DLING”, 12.6, page 431; “Class MEM-
ORY”, page 309 .
§30.8   REQUESTING SPECIAL SERVICE 999
Express messages
The ABCL/1 concurrent language in troduced the notion of “expres s message” for when  
we want to let a supplier object serve a certain VIP client imm ediately, even though the  
supplier may be busy w ith another client.
In some approaches an express me ssage will just interrupt the n ormal message, get  
serviced, and then let the normal message be resumed. But this is unacceptable, as we saw  
earlier in this chapter when we found out that at most one exec ution should be active on  
any object at any given time: th e express message, like any exp orted feature, needs an  
initial state satisfying the inv ariant; but who knows in what s tate the interrupted routine  
will be when it is forced to yie ld to the express message? And who knows what state the  
express message will produce as a  result? All this opens the wa y to what the discussion of  
static binding called “ one of the worst events that could occur during  the execution of a  
software system ”: producing an inconsistent  object. As we saw then: “ if such a situation  
can arise , we can no longer hope to predict what execution will do ”.
This does not mean, however, tha t we should reject the notion o f express message  
altogether. We may indeed need to  interrupt a client — either b ecause we have something  
more important to do with the ob ject it has reserved, or becaus e it is overextending its  
welcome to retain it. But such an interruption is not a polite request to step aside for a  
while. It is murder , at least attempted murder. To take our rival’s place we shoot  at it, so  
that it will die unless it can recover in the hospital. In soft ware terms, the interrupting  
client must cause an exception  in its rival, which will either retry (the hospital) or fail.
Such behavior, however, assumes that the challenger is somehow stronger than the  
holder. If not, the one  that will get an exception is the chall enger.
Duels and their semantics
The almost inescapable metaphor s uggests that instead of the “e xpress message”  
terminology we talk about the at tempt to snatch a shared object  from its current holder as  
a duel (the result, in an earlier era, of trying to snatch away someo ne’s legitimate spouse).  
An object has executed the instruction
r (b)
where b is separate. After possibly wai ting for the obj ect of its desi res, b, to become free,  
and for separate precondition clauses to hold, it has captured b, becoming its current  
holder . The execution of r on b has started on behalf of the holder, but is not finished.  
Another separate  object, the challenger , executes
s (c)
where c, also separate, is attached to the same object as the holder’s  b. Normally, the  
challenger will wait until the call to r is over. What if the challenger is impatient?[Yonezawa 1987a].
See “Concurrent 
accesses to an object”, page 982 .
The comments on 
static binding were on page 513.
See also “Permitting 
concurrent access?”,page 1031.
CONCURRENCY , DISTRIBUTION, CLIENT-SERVER  AND THE INTERNET  §30 .8 1000
Through procedures in class CONCURRENCY  we can provide the necessary  
flexibility. On the holder’s side we have yield , which means: “I am willing to release my  
hold if someone more worthy come s along”. Most holders, of cour se, are not so  
accommodating: unless it makes an explicit call to yield , a holder will retain its hold. To  
return to this default behavio r, you may use the procedure retain .
On the challenger’s side we can u se two kinds of request to get  special treatment:
•demand  means “now or never!”. If you cannot immediately capture the o bject of  
y o u r  d r e a m s  ( t h a t  i s  t o  s a y ,  i f  t h e  h o l d e r  h a s  n o t  c a l l e d  yield ), you will get an  
exception. (This is the old suicide threat trick, as in Così fan tutte .)
•insist  is more gentle: you try to inte rrupt the holder’s routine, but  if that is impossible  
you accept the common lot — waiti ng until the obj ect is freed.
To return to the defau lt behavior of waiting for the holder to finish, use wait_turn .
A call to one of these CONCURRENCY procedures will retain its effect until another  
s u p e r s e d e s  i t .  N o t e  t h a t  t h e  t w o  s e t s  o f  f a c i l i t i e s  a r e  n o t  e x c lusive; for example a  
challenger could use both insist  to request specia l treatment and yield  to accept being  
interrupted by another. A priori ty scheme can be added, so that  challengers w ill only defer  
to others with higher priorities , but we can igno re this refine ment here.
The following table shows the re sult of a duel — a conflict bet ween a holder and a  
challenger — in all possible case s. The default options and beh avior, in the absence of any  
call to CONCURRENCY procedures, are underlined .
The “holder’s routine” that gets  an exception in the two rightm ost bottom entries is  
the supplier routine be ing executed on behalf of the holder. In  the absence of a retry , it 
will pass on the exception to the  holder, and the  challenger wi ll get the object.
As you will remember, every kind of exception has a code, acces sible through class  
EXCEPTIONS . To distinguish an exception cau sed by one of the situations a ppearing in  
the above table, EXCEPTIONS provides the boolean query is_concurrency_interrupt .
Interrupt handling : the Secretary-Receptionist Algorithm
H e r e  i s  a n  e x a m p l e  u s i n g  d u e l s .  Assume a certain controller obj ect has started off a  
number of partner objects, and then proceeds with its own work,  which needs a certain  
resource shared . But the other objects may need access to the sh ared resource,  and the  
c o n t r o l l e r  i s  w i l l i n g  t o  i n t e r r u p t  i t s  c u r r e n t  t a s k  t o  l e t  a n y  of them proceed; when the  
partner is done, the controller resumes the last interrupted ta sk.Challenger →
↓ Holderwait_turn demand insist
retain Challenger waits Exception in 
challengerChallenger waits
yield Challenger waits Exception in holder’s routine. Exception in holder’s routine.Exercise E30.5, page 
1035, asks you to add priorities.
The semantics 
of duels
§30.8   REQUESTING SPECIAL SERVICE 1001
This general description covers among others the case of an ope rating system kernel  
(the controller) which starts off input-output processors (the partners), but does not wait  
for an I/O operation to complete, since I/O is typically severa l orders of magnitude slower  
than computation. When an I/O ope ration terminates, its process or can interrupt the kernel  
to request attention. This is the traditional interrupt-driven scheme for handling I/O — and  
the problem which gave the origin al impetus, many years ago, to  the study of concurrency.
The general scheme may be called the Secretary-Receptionist Algorithm  by analogy  
with what you find in many organi zations: a receptionist sits n ear the entrance to greet,  
register and direct visitors, bu t this is not a full-time job; the receptionist is  also entrusted  
with some other work, usually se cretarial. When a visitor shows  up, the receptionist  
interrupts his work, takes care o f the visitor, and then goes b ack to the interrupted task. 
Restarting a task after it has be en started and interrupted may  require some cleanup;  
this is why the followin g procedure passes to operate  the value of interrupted , which will  
enable operate to find out whether the current task has already been attempted . The first  
argument of operate , here next, identifies the task to perform. The procedure is assumed  
to be part of a class that inherits from both CONCURRENCY  (for yield  and retain ) and 
EXCEPTIONS  (for is_concurrency_interrupt ). Procedure operate  could take a long time to  
execute, and so is th e interruptible part.
execute_interruptibly
-- Perform own set of acti ons, but take interrupts
-- (the Secretary-Receptionist Algorithm).
local
done , next : INTEGER ; interrupted : BOOLEAN
do
from done  := 0 until termination_criterion loop
if interrupted then
process_interruption (shared ); interrupted  := False
else
next := done + 1 ; yield
operate (next, shared , interrupted )-- This is the interruptible part.
retain ; done  := next
end
end
rescue
if is_concurrency_interrupt then
interrupted  := True ; retry
end
end
Some of the steps performed by the controller may actually have  been requested by  
one of the interrupting partners. In an I/O interrupt, for exam ple, the I/O processor will  
signal the end of an operation and (in the input case) the avai lability of the data just read.  
CONCURRENCY , DISTRIBUTION, CLIENT-SERVER  AND THE INTERNET  §30 .8 1002
The interrupting partner may use the object shared  to deposit that information; to interrupt  
the controller, it will execute
insist ; interrupt (shared ); wait_turn
-- Request controller’s attention , interrupting it  if necessary . 
-- Deposit any needed information into the object shared .
This is the reason why process_interruption , like operate , uses shared  as argument:  
it may have to analyze the shared object to detect information passed by the interrupting  
partner. This will allow it, if n ecessary, to set up one of its  upcoming tasks, to be executed  
on behalf of that partner. Note that process_interruption , unlike operate , is not  
interruptible; any other partner that becomes ready while it is  executing will have to wait  
(otherwise some partner requests might get lost). So process_interruption  should only  
perform simple operations — regi stering information for future processing. If that is not  
possible, you may use a slight ly different scheme in which process_interruption  relies on  
a separate object other than shared .
We have one more precau tion to take. Although partners’ request s can be processed  
later (through calls to operate  in upcoming steps), it is essen tial that none o f these request s 
be lost. With the scheme as given, after a partner executes an interrupt , another one could  
do the same, overriding the info rmation deposited by the first,  before the controller has  
had the time to register that information by executing process_interruption . This case is  
not acceptable. To avoid it, we can just add to the generating class of shared  a boolean  
attribute deposited  with the associated setting an d resetting procedures. Then interrupt
will have the precondition not shared   deposited , so as to wait until the previous partner  
has been registered, and will execute the call shared   set_deposited before returning;  
process_interruption  will execute shared   set_not_deposited before exiting.
The partners are initialized by “business card” calls of the fo rm create  partner   make 
(shared , …) which pass them a reference to shared to be retained f or future needs.
Procedure execute_interruptibly has been spelled out in full, with the application-
specific elements represented by calls to routines operate , process_interruption , 
termination_criterion  that are assumed to be deferred, in the behavior class style. This 
prepares for the procedure’s pos sible inclusion into a concurre ncy library. 
About the rest of this chapter
With the presentation of the duel mechanism we have finished de fining the set of  
necessary concurrency tools. The r est of this chapter provides a n  e x t e n s i v e  s e t  o f  
examples, from diverse application areas, illustrating the use of these tools. After the  
examples you will find:
•A sketch of a proof rule, for m athematically-inc lined readers.
•A summary of the concurrency mechanism, with syntax, validity r ules and semantics.
•A discussion of the mechanism’s goals and of further work neede d.
•A detailed bibliography of other work in this area.30.10, page 1022 .
30.11, page 1025 .
30.12, page 1028 .
30.14, page 1033 .
§30.9   EXAMPLES 1003
30.9  EXAMPLES 
To illustrate the mechanism, her e  n o w  a r e  a  f e w  e x a m p l e s  c h o s e n  from diverse  
backgrounds — from traditional c oncurrent programming examples through large-scale  
multiprocessing to rea l-time applications.
The dining philosopher s
Dijkstra’s famous “dining philos ophers”, an artificial example meant to illustrate the  
behavior of operating system pro cesses vying for shared resourc es, is an obligatory part  
of any discussion on concurrency . Five philosophers around a ta ble spend their time  
thinking, then eating, then thi nking again and so on. To eat th e spaghetti, each needs access  
to the fork immediately to his left and to his right — creating  contention and possible  
deadlock.
The following class describes the philosopher’s behavior. Thank s to the mechanism  
for reserving objects through se parate arguments, there is esse ntially (in contrast with the  
usual solutions in the literatur e) no explicit s ynchronization code:The 
philosophers’ 
spaghetti plate
The class is defi-
nitely not what peo-
ple mean by “spaghetti code” .
CONCURRENCY , DISTRIBUTION, CLIENT-SERVER  AND THE INTERNET  §30 .9 1004
separate class PHILOSOPHER  creation 
make
inherit
GENERAL_PHILOSOPHER
PROCESS
rename setup as getup undefine getup end
feature  {BUTLER } 
step
-- Perform a philosopher’s tasks.
do
think
eat (left, right )
end
feature  {NONE } 
eat (l, r: separate  FORK )
-- Eat, having grabbed l and r.
do … end
end
The entire synchroniza tion requirement is em bodied by the call to eat, which uses  
arguments left and right  representing the two necessary f orks, thus reserving these obj ects. 
The simplicity of this solution comes from the mechanism’s abil ity to reserve several  
resources throug h a single call having several separate argumen ts, here left and right . If 
we restricted the separate arguments to at most one per call, t he solution would use one of  
the many published algorithms fo r getting hold o f two forks one  after the other without  
causing deadlock.
The principal procedure of class PHILOSOPHER  does not appear above since it  
comes from the behavior class PROCESS : procedure live, which as given in PROCESS
simply executes from  setup until  over loop step end, so all we need to redefine here is  
step. I hope you will enjoy the renaming of setup  as getup  — denoting the philosopher’s  
initial operation.
Thanks to the use of multiple obj ect reservation through argume nts, the solution  
described here does not produce  deadlock; but it is not guarant eed to be fair. Some of the  
philosophers can conspire to star ve the others. Here too the li terature provides various  
solutions, which may be integr ated into the above scheme. 
To avoid confusion of genres the  concurrency-independent featur es of a philosopher  
have been kept in a class GENERAL_PHILOSOPHER :The synchronization
Class PROCESS  
appeared on page 961. wrapup remains 
an empty procedure .
§30.9   EXAMPLES 1005
class GENERAL_PHILOSOPHER  creation  
make
feature  -- Initialization
make  (l, r: separate FORK )
-- Define l as left and r as right forks.
do
left := l; right  := r
end
feature {NONE } -- Implementation
left, right : separate  FORK
-- The two required forks
getup
-- Take any necessary in itialization action.
do … end
think
-- Any appropriate acti on or lack thereof.
do … end
end 
The rest of the system simply ta kes care of initialization and of describing the  
auxiliary abstractions. Forks hav e no immediately relevant prop erties: 
class  FORK end
A butler is used to set u p and start a session:
class  BUTLER creation  
make 
feature
count : INTEGER
-- The number of both phi losophers and forks
launch
-- Start a full session.
local
i: INTEGER
do
from i := 1 until i > count loop
launch_one (participants @ i ); i := i + 1
end
end 
CONCURRENCY , DISTRIBUTION, CLIENT-SERVER  AND THE INTERNET  §30 .9 1006
feature  {NONE } 
launch_one (p: PHILOSOPHER )
-- Let one philosopher s tart his actual life.
do
p  live
end
participants : ARRAY [PHILOSOPHER ]
cutlery : ARRAY [FORK ] 
feature  {NONE } -- Initialization
make (n: INTEGER )
-- Initialize a session with  n philosophers.
require
n >= 0
do
count  := n
create  participants   make (1, count ); create  cutlery   make (1, count )
make_philosophers
ensure
count = n
end
make_philosophers
-- Set up philosophers.
local
i: INTEGER ; p: PHILOSOPHER ; left, right : FORK
do
from i := 1 until i > count loop
p := philosophers @ i
left := cutlery @ i
right  := cutlery @ ((i \\ count ) + 1
create  p  make (left, right )
i := i + 1
end
end 
invariant  
count >= 0; participants   count = count ; cutlery   count = count 
end 
Note how launch  and launch_one , using a pattern discussed in the presentation of  
wait by necessity, rely on the property that the call p  live will not cause waiting, allowing  
the loop to proceed to  the next philosopher.See “A multi-
launcher”, page 988.
§30.9   EXAMPLES 1007
Making full use of hardware parallelism
The following example illustrate s how to use wait by necessity to draw the maximum  
benefit from any available hardw are parallelism. It shows a sop histicated form of load 
balancing  in which we offload computation  to many different computers on  a network.  
Thanks to the notion of processo r, we can rely on the concurren cy mechanism to choose  
these computers auto matically for us.
The example itself — computing th e number of nodes  in a binary tree — is of little  
practical value, but illustrates a general scheme that may be e xtremely useful for large,  
heavy computations such as those  encountered in cryptography or  advanced computer  
graphics, for which de velopers need all the resources they can get, but do not want to have  
to take care manually of the ass ignment of abstract computing u nits to actual  computers.
Consider first a class extract t hat does not involve concurrenc y:
class BINARY_TREE [G] feature
left, right : BINARY_TREE [G]
… Other features …
nodes : INTEGER
-- Number of nodes in this tree
do
Result  := node_count (left) + node_count (right ) + 1
end
feature  {NONE }
node_count (b: BINARY_TREE [G]): INTEGER
-- Number of nodes in  b
do
if b /= Void then Result  := b  nodes end
end
end
Function nodes  uses recursion to compute the number of nodes in a tree. The  
recursion is indirect, through node_count . 
I n  a  c o n c u r r e n t  e n v i r o n m e n t  o f f e r i n g  m a n y  p r o c e s s o r s ,  w e  c o u l d  offload all the  
separate node computations to di fferent processors. Declaring t h e  c l a s s  a s  separate , 
replacing nodes  by an attribute and introduc ing procedures does the job:
CONCURRENCY , DISTRIBUTION, CLIENT-SERVER  AND THE INTERNET  §30 .9 1008
separate class BINARY_TREE1 [G] feature 
left, right : BINARY_TREE1 [G]
… Other features … 
nodes : INTEGER
update_nodes
-- Update nodes to reflect the n umber of nodes in this tree.
do
nodes  := 1
compute_nodes (left); compute_nodes (right )
adjust_nodes (left); adjust_nodes (right )
end
feature  {NONE } 
compute_nodes (b: BINARY_TREE1 [G])
-- Update information abou t the number of nodes in  b.
do
if b /= Void then
b  update_nodes
end
end
adjust_nodes (b: BINARY_TREE1 [G])
-- Adjust number of nodes from those in b.
do
if b /= Void then nodes  := nodes + b   nodes end
end
end
The recursive calls to compute_nodes  will now be started in parallel. The addition  
operations wait for these two pa rallel computations to complete . 
If an unbounded number of CPUs ( physical processors) are availa ble, this solution  
seems to make the optimal possible use of the hardware parallel ism. If there are fewer  
CPUs than nodes in the tree, the speedup over sequential comput ation will depend on how  
well the implementation allocate s CPUs to the (virtual) process ors. 
The presence of two tests for vacuity of b may appear unpleasant. It results, however,  
from the need to separate the parallelizable part — the procedu re calls, launched  
concurrently on left and right  — from the additions, which by nature must wait for their  
operands to become ready. 
An attractive property of the solution is that it ignores the p ractical problem of  
assigning the actual computers. The software just allocates pro cessors as it needs to. (This  
is done in the creation instruct ions, not shown, which will app ear in particular in the  
insertion procedure: to insert a new element into a binary tree  you create a new node  
through  create  new_node   make (new_element ) which here, new_node being of the  On how to specify the 
mapping see “Map-ping the processors: the Concurrency Control File”, page 971.
§30.9   EXAMPLES 1009
separate type BINARY_TREE1 [G], will allocate a new proces sor to it.) The mapping of  
these virtual processo rs to the available ph ysical resources is  entirely automatic.
Locks
Assume you want to allow a number of clients (the “lockers”) to  obtain exclusive access to  
certain resources (the “lockable s”) without having to enclose t he exclusive access sections  
in routines. This wil l provide us with a s emaphore-like mechani sm. Here is a solution:
class LOCKER  feature 
grab (resource : separate  LOCKABLE ) is
-- Request exclusive a ccess to resource.
require
not resource   locked 
do
resource   set_holder (Current )
end 
release (resource : separate  LOCKABLE )
require
resource   is_held (Current )
do
resource   release
end
end
class LOCKABLE  feature  {LOCKER } 
set_holder (l: separate  LOCKER )
-- Designate  l as holder.
require
l /= Void
do
holder  := l
ensure
locked
end
locked : BOOLEAN
-- Is resource reserved by a locker?
do
Result  := (holder /= Void )
end
CONCURRENCY , DISTRIBUTION, CLIENT-SERVER  AND THE INTERNET  §30 .9 1010
is_held (l: separate  LOCKER ): BOOLEAN
-- Is resource reserved by  l?
do
Result  := (holder = l)
end
release
-- Release from current holder.
do
holder  := Void
ensure
not locked
end 
feature  {NONE } 
holder : separate  LOCKER 
invariant
locked_iff_holder : locked = (holder  /= Void)
end 
Any class describing resources will inherit from LOCKABLE . The proper  
functioning of t he mechanism assumes tha t every locker performs  sequences of grab  and 
release  o p e r a t i o n s ,  i n  t h i s  o r d e r .  O t h e r behavior will usually result in deadlock; this  
problem was mentioned in the discu ssion of semaphores as one of  the major limitations of  
this technique. But we can once again rely on the power of obje ct-oriented computation to  
enforce the required protocol; r ather than trusting every locke r to behave, we may require  
lockers to go th rough procedure use in descendants of the following behavior class:
deferred class LOCKING_PROCESS feature 
resource : separate  LOCKABLE
use
-- Make disciplined use of resource .
require
resource /= Void
do
from  create  lock ; setup until over loop
lock  grab (resource )
exclusive_actions
lock  release (resource )
end
finalize
end
§30.9   EXAMPLES 1011
set_resource (r: separate  LOCKABLE )
-- Select r as resource for use.
require
r /= Void
do
resource  := r
ensure
resource /= Void
end
feature  {NONE } 
lock: LOCKER
exclusive_actions
-- Operations executed while resource  is under excl usive access
deferred
end
setup
-- Initial action; by default: do nothing.
do
end
over: BOOLEAN
-- Is locking beha vior finished?
deferred
end
finalize
-- Final action; by de fault: do nothing.
do
end
end
An effective descendant of LOCKING_PROCESS  will effect exclusive_actions
and over, and may redefine setup  a n d  finalize . Note that it is desirable to write  
LOCKING_PROCESS  as a descendant of PROCESS .
Whether or not we go through LOCKING_PROCESS , a grab  does not take away the  
corresponding lockable  from all possible clients: it only exclu des other lockers that  
observe the protocol. To exclude any client from accessing a re source, you must enclose  
the operations accessing the res ource in a routine to which you  pass it as an argument. 
Routine grab  of class LOCKER  is an example of what has been called the business  
card scheme: passing to resource  a reference to the Current  locker, which the resource will  
keep as a separate reference.
Based on the pattern provided by  t h e s e  c l a s s e s ,  i t  i s  n o t  d i f f i cult to write others  
implementing semaphores under the ir various forms. Object-orien ted mechanisms help us  Exercise E30.7, 
page 1036 .
Exercise E30.7, 
page 1036 .
CONCURRENCY , DISTRIBUTION, CLIENT-SERVER  AND THE INTERNET  §30 .9 1012
help users of our classes avoid the classic danger of semaphore s: executing a reserve  on a 
resource and forgetting to e xecute the corresponding free. A developer using a behavior  
class such as LOCKING_PROCESS will fill in the de ferred operations t o cover the needs  
of his application, and can rely on the predefined general sche me to guarantee that each  
reserve will be properly followed  by the corresponding free.
Coroutines
Although not truly concurrent, at  least not in its basic form, our next example  is essential  
as a way to test the g eneral applicability o f a concurrent mech anism.
The first (and probably the only) major programming language to  include a coroutine  
construct was also the first object-oriented language, Simula 6 7; we will study its  
coroutine mechanism as part of the presentation of Simula. That  discussion will also  
present some examples of the  practical use of coroutines.
Coroutines emulate concurrency on  a sequential computer. They p rovide a form of  
program unit that, although simila r to the traditional notion o f routine, reflects a more  
symmetric form of communication:
• With a routine call, there is a master and a slave; the caller  starts a routine, waits for  
its termination, and picks up where it left; the routine, howev er, always starts from  
the beginning. The caller calls ; the routine returns .
• With coroutines, the relationship is between peers; coroutine a gets stuck in its work  
and calls coroutine b for help; b restarts where it last left, and continues until it is its  
turn to get stuck or it has proceeded as far as needed for the moment; then a picks up  
its computation. Instead of separate call and return mechanisms , there is a single  
operation resume  c, meaning: restart coroutine c where it was last interrupted; I will  
wait until someone  else resume s me.
This is all strictly sequential and meant to be executed on a s ingle process (task) of  
a single computer. But the ideas are clearly drawn from concurr ent computation; in fact  
an operating system running on a  single CPU will internally use  a  c o r o u t i n e - l i k e  
mechanism to implement such sche mes as time-sharing, multitaski ng and multithreading.
Coroutines may be viewed as a b oundary case of concurrency: the  poor man’s  
substitute to concurrent  computation when only one thread of co ntrol is available. It is  
always a good idea to check that a general-purpose mechanism de grades gracefully to  
boundary cases; so let us see ho w we can represent coroutines. The following two classes  
will achieve this goal.“Coroutine concepts”,
page 1118 (in the Sim-
ula chapter ). The 
resume  instruction 
comes from Simula .
Coroutine 
sequencing
resume  a resume  aresume  bresume  ba
b
§30.9   EXAMPLES 1013
separate class COROUTINE  creation 
make
feature  {COROUTINE } 
resume (i: INTEGER )
-- Wake up coroutin e of identifier i and go to sleep.
do
actual_resume (i, controller )
end
feature  {NONE } -- Implementation
controller : COROUTINE_CONTROLLER
identifier : INTEGER
actual_resume (i: INTEGER ; c: COROUTINE_CONTROLLER )
-- Wake up coroutin e of identifier  i and go to sleep.
-- (Actual work of resume ).
do
c  set_next (i); request (c)
end
request (c: COROUTINE_CONTROLLER )
-- Request eventual re-awakening by c.
require
c  is_next (identifier )
do
-- No action necessary
end
feature  {NONE } -- Creation  
make (i: INTEGER ; c: COROUTINE_CONTROLLER )
-- Assign i as identifier and  c as controller.
do
identifier  := i
controller  := c
end
end
CONCURRENCY , DISTRIBUTION, CLIENT-SERVER  AND THE INTERNET  §30 .9 1014
separate class COROUTINE_CONTROLLER  feature  {NONE } 
next: INTEGER
feature  {COROUTINE } 
set_next (i: INTEGER )
-- Select  i as the identifier of the ne xt coroutine t o be awakened.
do
next := i
end
is_next (i: INTEGER ): BOOLEAN
-- Is i the index of the next c oroutine to be awakened?
do
Result  := (next = i)
end
end 
One or more coroutines will share one coroutine controller (cre ated through a “once”  
function not shown here). Each co routine has an integer identif ier. To resume a coroutine  
of identifier i, procedure resume  will, through actual_resume , set the next attribute of the  
controller to i, and then block, waiting on the precondition next = j, where j i s  t h e  
coroutine’s own identifier. This ensures the desi red behavior. 
Although it looks like normal con current software, this solutio n ensures that (if all  
coroutines have different identif iers) at most one coroutine ma y proceed at any time,  
making it useless to allocate mo re than one physical CPU. (The controller could actually  
make use of its own CPU, but its actions are so simple as not t o warrant it.) 
The recourse to integer identifiers is necessary since giving resume  an argument of  
type COROUTINE , a separate type, would cause deadlock. In practice, you shoul d 
probably use unique declarations to avoid having to choose the values manually. Thi s use 
of integers also has an interesting consequence: if we allow tw o or more coroutines to have  
the same identifier, then with a single CPU we obtain a non-deterministic  mechanism: a  
call resume (i) will permit restarting any coroutine whose identifier has value  i. With more  
than one CPU a call  resume (i) will allow all coroutines of identifier i to proceed in parallel. 
S o  t h e  a b o v e  s c h e m e ,  w h i c h  f o r  a  single CPU provi des a coroutin e mechanism,  
doubles up in the case of severa l CPUs as a mechanism for contr olling the maximum  
number of proces ses of a certain type whi ch may be simultaneous ly active. 
An elevator control system
The following example shows a ca se where object technology and the mechanism defined  
in this chapter can be used to a chieve a pleasantly decentraliz ed event-driven architecture  
for a real-time application.
The example describes software f or an elevator control system, with several  
elevators serving many floors. The design below is somewhat fan atically object-oriented  
in that every significant type o f component in the physical sys tem — for example the  Exercise E30.10, 
page 1036 .
§30.9   EXAMPLES 1015
notion of individual bu tton in an elevator cabin, marked with a  floor number — has an  
associated separate class, so th at each corresponding object su ch as a button has its own  
virtual thread of control (proce ssor). This is getting close to  Milner’s wish, quoted at the  
beginning of this chap ter, of making all objects parallel. The benefit is that the system is  
entirely event-driven;  it does not need to include any loop for  examining repeatedly the  
status of objects, for  example wheth er any button has been pres sed. 
The class texts below are only s ketched, but provide a good ide a of what a complete  
solution would be. In most cases the creati on procedur es have n ot been included. 
This implementation of the elevator example, adapted to control  elevator displays on  
multiple screens and computers across the Internet (rather than  actual elevators), has been  
used at several conferences to de monstrate concurrent and distr ibuted O-O mechanisms.
Class MOTOR describes the motor associated w ith one elevator cabin, and the  
interface with the m echanical hardware: 
separate class MOTOR  feature {ELEVATOR } 
move ( floor : INTEGER )
-- Go to floor ; once there, report.
do
“Direct the physical device to move to floor ”
signal_stopped (cabin )
end
signal_stopped (e: ELEVATOR )
-- Report that elevato r stopped on level e.
do
e  record_stop (position )
end
feature  {NONE } 
cabin : ELEVATOR
position : INTEGER
-- Current floor level
do
Result  := “The current floor level, read from physical sensors”
end
end 
The creation procedure of this cl ass must associate an elevator , cabin , with every  
motor. Class ELEVATOR  includes the reve rse information through attribute puller , 
indicating the motor pulli ng the current elevator. 
The reason for making an elevato r and its motor separate object s is to reduce the  
grain of locking: once an elevator has sent a move  request to its motor, it is free again,  
thanks to the wait by necessity policy, to accept requests from  buttons either inside or  
outside the cabin. It will resyn chronize with it s motor upon re ceipt of a call to procedure  
record_stop , through signal_stopped . Only for a very short time will an instance of  
ELEVATOR  be reserved by a call from either a MOTOR  or BUTTON  object Milner quote : page 
956.
CONCURRENCY , DISTRIBUTION, CLIENT-SERVER  AND THE INTERNET  §30 .9 1016
separate class ELEVATOR  creation 
make
feature  {BUTTON } 
accept ( floor : INTEGER )
-- Record and pr ocess a request to go to floor .
do
record ( floor )
if not moving then process_request end
end
feature  {MOTOR } 
record_stop ( floor : INTEGER )
-- Record information that elevator has stopped on floor .
do
moving  := false ; position  := floor ; process_request
end
feature  {DISP ATCHER } 
position : INTEGER
moving : BOOLEAN
feature  {NONE } 
puller : MOTOR
pending : QUEUE [INTEGER ]
-- The queue of pe nding requests
-- (each identified by  the number of the d estination floor) 
record ( floor : INTEGER )
-- Record reque st to go to floor .
do
“Algorithm to insert reque st for floor i nto pending”
end
process_request
-- Handle next pendi ng request, if any.
local
floor : INTEGER
do
if not pending   empty then
floor  := pending   item
actual_process (puller , floor )
pending   remove
end
end
§30.9   EXAMPLES 1017
actual_process (m: separate  MOTOR ; floor : INTEGER )
-- Direct m to go to floor .
do
moving  := True ; m  move ( floor )
end
end 
Buttons are of two ki nds: floor buttons, which passengers press  to call the elevator  
to a certain floor, and cabin bu ttons, inside a cabin, which th ey press to make the cabin  
move to a certain floor. The two kinds send different requests:  for a cabin button, the  
request is directed to a specific cabin; for a floor button, it  can be handled by any elevator  
and so will be sent to a dispatcher object, which will poll the  various elevators to select  
one that will handle the request. (The selection algorithm is l eft unimplemented below  
since it is irrelevant to this d iscussion; the same applies to the algorithm used by elevators  
to manage their pending  queue of requests in class ELEVATOR  above.) 
Class FLOOR_BUTTON  assumes that there is only one button on each floor. It is not  
difficult to update the design t o support two but tons, one for up requests and the other for  
down requests. 
It is convenient althou gh not essential to have a common parent  BUTTON  for the  
c l a s s e s  r e p r e s e n t i n g  t h e  t w o  k i n d s  o f  b u t t o n .  R e m e m b e r  t h a t  t h e  features exported by  
ELEVATOR  to BUTTON  are, through the stan dard rules of selectiv e information hidin g, 
also exported to t he two descendants  of this class.
separate class BUTTON  feature 
target : INTEGER
end
separate class CABIN_BUTTON  inherit BUTTON  feature 
cabin : ELEVATOR
request
-- Send to associated elevator  a request to stop on level target .
do
actual_request (cabin )
end
actual_request (e: ELEVATOR )
-- Get hold of e and send a request to stop on level target .
do
e  accept (target ) 
end
end
CONCURRENCY , DISTRIBUTION, CLIENT-SERVER  AND THE INTERNET  §30 .9 1018
separate class FLOOR_BUTTON  inherit
BUTTON
feature
controller : DISP ATCHER
request
-- Send to dispatcher a request to stop on level target .
do
actual_request (controller )
end 
actual_request (d: DISP ATCHER )
-- Send to d a request to stop on level target .
do
d  accept (target ) 
end
end 
The question of switching button  lights on and off has been ign ored. It is not hard to  
add calls to routines whic h will take care of this. 
Here finally is class DISP ATCHER . To develop the algorithm that selects an elevator  
in procedure accept , you would need to let i t access the attributes position  and moving  of 
class ELEVATOR , which in the full system shoul d be complemente d by a boolean attribute  
going_up .  S u c h  a c c e s s e s  w i l l  n o t  c a u s e  a n y  p r o b l e m  a s  t h e  d e s i g n  e n s u r e s that  
ELEVATOR  objects never g et reserved for a long time.
separate class DISP ATCHER  creation 
make
feature  {FLOOR_BUTTON } 
accept ( floor : INTEGER )
-- Handle a request to s end an elevator to floor .
local
index : INTEGER ; chosen : ELEVATOR
do
“Algorithm to determine what  elevator should handle the
   request for floor ”
index  := “The index of the chosen elevator”
chosen  := elevators @ index
send_request (chosen , floor )
end
§30.9   EXAMPLES 1019
feature  {NONE } 
send_request (e: ELEVATOR ; floor : INTEGER )
-- Send to e a request to go to floor .
do
e  accept ( floor )
end
elevators : ARRAY [ELEVATOR ]
feature  {NONE } -- Creation  
make
-- Set up the array of elevators.
do
“Initialize array elevators”
end
end 
A watchdog mechanism
Along with the previous one, the  following example shows the me chanism’s applicability  
to real-time problems. It also p rovides a good illustration of the concept of duel.
We want to enable an object to perform a call to a certain proc edure action , with the  
provision that the call will be interrupted, and a boolean attr ibute failed  set to true, if the  
procedure has not comple ted its execution after t seconds. The only basic timing  
mechanism available is a procedure wait (t), which will execute for t seconds.
Here is the solution, using a duel. A class that needs the mech anism should inherit  
from the behavior class TIMED  and provide an effective version of the procedure  
action  w h i c h ,  i n  TIMED , is deferred. To let action  e x e c u t e  f o r  a t  m o s t  t seconds, it  
suffices to call timed_action (t). This procedure sets up a watchdog (an instance of  
class WATCHDOG ), which executes wait (t) and then interrupts its client. If, however,  
action  has been completed in the mean time, it is the c lient that inte rrupts the watchdog.
 deferred class TIMED  inherit
CONCURRENCY
feature  {NONE }
failed : BOOLEAN ; alarm : WATCHDOG
timed_action (t: REAL )
-- Execute action, b ut interrupt after t seconds if not complete.
-- If interrupted bef ore completion, set failed  to true.
do 
set_alarm (t); unset_alarm (t); failed  := False
rescue  
if is_concurrency_interrupt then failed  := True end
endAll routines with an 
argument t: REAL  
need the precondi-tion t >= 0, omitted 
for brevity.
CONCURRENCY , DISTRIBUTION, CLIENT-SERVER  AND THE INTERNET  §30 .9 1020
set_alarm (t: REAL ) is 
-- Set alarm to interrupt  current object after t seconds.
do
-- Create alarm if necessary:
if alarm = Void then  create  alarm end
yield ; actual_set (alarm , t); retain
end
unset_alarm (t: REAL )
-- Remove the last alarm set.
do
demand ; actual_unset (alarm ); wait_turn
end
action
-- The action to be performe d under watchdog control
deferred
end
feature  {NONE } -- Actual access to watchdog  
actual_set (a: WATCHDOG ; t: REAL )
-- Start up a to interrupt current object after t seconds.
do
a  set (t)
end
… Procedure actual_unset similar, left to the reader …
feature  {WATCHDOG } -- The interrupting operation  
stop
-- Empty action to let watchdog interrupt a call to timed_action
do -- Nothing end
end
separate class
WATCHDOG
feature  {TIMED }
set (caller : separate  TIMED ; t: REAL )
-- After t seconds, interrupt caller ; 
-- if interrupted befor e, terminate silently.
require
caller_exists : caller /= Void
local
interrupted : BOOLEAN
do
if not interrupted then wait (t); demand ; caller    stop; wait_turn end
rescue
if is_concurren cy_interrupt then interrupted  := True ; retry end
end See exercise E30.13, 
page 1036, about this procedure and the Business Card principle.
§30.9   EXAMPLES 1021
unset
-- Remove alarm (empty actio n to let client interrupt set).
do -- Nothing end
feature  {NONE }
early_termination : BOOLEAN
end
For clarity and to avoid mistakes every use of retain should, as here, include also the  
following retain , in the form yield ; “Some call”;  retain . Every use of demand (or insist ) 
should similarly be of the form demand ; “Some call”;  wait_turn . You can use behavior  
classes to enforce this rule.
Accessing buffers
As a last example, let us wrap up the example of bounded buffer s used several times in the  
presentation of the mechanism. We  have seen that the class coul d be declared as just  
separate  class  BOUNDED_BUFFER [G] inherit  BOUNDED_QUEUE [G] end, 
assuming the proper sequential BOUNDED_QUEUE  class.
To use a call such as q  remove  on an entity q of type BOUNDED_BUFFER [T], you 
must enclose it in a routine using q as formal argument. It may be useful for that purpose  
to provide a class BUFFER_ACCESS that fully encapsulates the notion of bounded buffer;  
application classes may inherit from BUFFER_ACCESS . There is nothing  difficult about  
this behavior class, but it provides a good example of how we c an encapsulate separate  
classes, directly derived from sequential ones such as BOUNDED_QUEUE , so as to  
facilitate their direct uses  by concurrent applications. 
note
description : “Encapsulation of acce ss to bounded buffers "
class  BUFFER_ACCESS [G] is 
put (q: BOUNDED_BUFFER [G]; x: G)
-- Insert x into q, waiting if necessary u ntil there is room.
require
not q  full 
do
q  put (x)
ensure
not q  empty
end
CONCURRENCY , DISTRIBUTION, CLIEN T-SERVER  AND THE INTERNET  §30 .10 1022
remove (q: BOUNDED_BUFFER [G])
-- Remove an element from q, waiting if necessary
-- until there is s uch an element. 
require
not q  empty
do
q  remove
ensure
not q  full
end
item (q: BOUNDED_BUFFER [G]): G
-- Oldest element not yet consumed
require
not q  empty
do
Result  := q  item
ensure
not q  full
end 
end 
30.10  TOWARDS A PROOF RULE
(This section is for mathematically-inclined readers only. Alth ough you may understand  
the basic ideas without having ha d a formal exposure to the the ory of programming  
languages, full understanding re quires that you be familiar wit h the basics of that theory,  
as given for example in [M 1990] , whose notations w ill be used here.)
The basic mathematical property of sequential ob ject-oriented c omputation was  
given semi-formally in the dis cussion of Desi gn by Contract:
{INV and pre} body {INV and post}
where pre, post and body  are the precondition, postcondi tion and body of a routine, and  
INV is the class invariant. With suitable axiomatization of the ba sic instructions this could  
serve as the basis of a fully fo rmal axiomatic semantics for ob ject-oriented software.
Without going that far, let us e xpress the property more rigoro usly in the form of a  
proof rule for calls. Such a rule is fundamental for a mathemat ical study of O-O software  
since the heart of object-orient e d  c o m p u t a t i o n  —  w h e t h e r  s e q u e n tial as before, or  
concurrent as we are now able to  achieve — is operations of the  form 
t  f (…, a, …)
which call a feature f, possibly with arguments such as a, on a target t representing an  
object. The proof rule for the s equential case m ay be informall y stated as follows:On first reading you 
may move to “DIS-CUSSION”, 30.12, page 1028 .
§30.10   TOWARDS A PROOF RULE 1023
For example, if we are able to p rove that the ac tual implementa tion of put in class  
BOUNDED_QUEUE , assuming not full  initially, produces a state satisfying not empty , 
then for any queue q and element a the rule allows us to deduce 
{not q  full} q  put (x) {not q  empty }
More formally, we may express th e basic proof rule as an adapta tion to the object-
oriented form of computation of Hoare’s procedure proof rule: 
{INV ∧ }  Body (r)  {INV ∧ }
{ }  Call (r)  { }
Here  INV is the class invariant,  Pre ( f ) is the set of precon dition clauses of  f and
Post ( f ) the set of its postcondition cl auses. Recall that an assertion  is the conjunction of  
a set of clauses, of the form 
clause1; …; clausen
The large “and” signs  indicate conjunction of all the  clauses. The actual arguments  
of f  have not been explicitly include d in the call, but the primed e xpressions such as  t  q'
indicate substit ution of the call’s actu al arguments for the fo rmal arguments of f. 
In the interest of conciseness, the rule is stated above in the  form which does not support  
proofs of recursive routines. Adding such support, however, doe s not affect the present  
discussion. For details of how to handle recursion, see [M 1990] .
The reason for considering the a ssertion clauses separately and  then “anding” them  
is that this form prepares the r ule’s adaptation , described nex t, to separate calls in the  
concurrent case. Also of interes t as preparation for the concur rent version is that you must  
take the invariant INV into account in the proof of th e routine body (above the line) , 
without any visible benefit for t he proof of the call (below th e line). More assertions with  
that property will appear in the concurrent rule. 
What then changes with concurren cy? Waiting on a precondition c lause occurs only  
for a precondition of the form t  cond , where t i s  a  f o r m a l  a r g u m e n t  o f  t h e  e n c l o s i n g  
routine, and is separate. I n a routine of the form If we can prove that the body of    f, started in a state satisfying the precondition  
of f, terminates in a state satisfyi ng the postcondition, then we c an deduce the  
same property for the above call, with actual arguments such as  a substituted  
for the correspo nding formal arguments, and every non-qualified  call in the  
assertions (of the form some_boolean_property ) replaced by the  
corresponding property on  t (of the form  t   some_boolean_property ).The basic 
sequential 
proof technique
p ∈Pre (r)p
q∈Post (r)q
p ∈Pre (r)p'
q∈Post (r)q'
CONCURRENCY , DISTRIBUTION, CLIEN T-SERVER  AND THE INTERNET  §30 .10 1024
f (…, a: T, …)
require
clause1 ; clause2 ; …
do 
…
end
any of the precondition clauses not involving any separate call  on a separate formal  
argument is a correctness conditi on: any client must ensure tha t condition prior to any call,  
otherwise the call is in error. Any precondition clause involvi ng a call of the form a  some_
condition , where a is a separate formal argument, is a wait condition which will c ause calls  
to block if it is not satisfied. 
These observations may be expres sed as a proof rule which, for separate  
computation, replaces the pr eceding sequential rule: 
{INV ∧ }  Body (r)  {INV ∧ }
{ }  Call (r)  { }
 
where Nonsep_pre ( f ) is the set of clauses in f  ’s precondition which do not involve any  
separate calls, an d similarly for Nonsep_post ( f ). 
This rule captures in part the e ssence of parallel computation.  To prove a routine  
correct, we must still prove the same conditions (those above t he line) as in the sequential  
rule. But the consequences on the properties of a call (below t he line) are different: the  
client has fewer properties to ensure before the call, since, a s discussed in detail earlier in  
this chapter, trying to ensure the separate part of the precond ition would be futile anyway;  
but we also obtain fewer guarantees on output. The former diffe rence may be considered  
good news for the client, t he latter is bad news. 
The separate clauses in precond itions and postco nditions thus j oin the invariant as  
properties that must be included as part of the internal proof of the routine body, but are  
not directly usable as p roperties of the call. 
The rule also serves to restore the symmetry between preconditi ons and  
postconditions, followi ng a discussion that highlighted the rol e of the preconditions.p ∈Pre (r)p
q∈Post (r)q
p ∈Nonsep_Pre (r)p'
q∈Nonsep_Post (r)q'
§30.11   A SUMMARY OF THE MECHANISM 1025
30.11  A SUMMARY OF THE MECHANISM
Here now is the precise descrip tion of the concurrency faciliti es presented in earlier  
sections. There is no new materi al in this secti on, which serve s only as reference and may  
be skipped on first reading. The  description consists of four p arts: syntax; validity  
constraints; semantics; library mechanisms. It extends the sequ ential O-O mechanisms  
developed in the p receding chapters.
Syntax
The syntactic extens ion involves just one new keyword, separate . 
A declaration of an entity or fu nction, which normally appears as 
x: TYPE
may now also be of the form 
x: separate  TYPE
I n  a d d i t i o n ,  a  c l a s s  d e c l a r a t i o n , which normally begins with on e of class  C, 
deferred  class  C a n d  expanded  class  C, may now also be of a new form:  
separate  class  C. In this case C will be called a separate class. It follows from the syntax  
convention that a class may be at most one of: separated, expan ded, deferred. As with  
expanded and deferred,  the property of being separate is not in herited: a class is separate  
or not according to its  own declaration, reg ardless of its pare nts’ separateness status. 
A type is said to be separate if  it is either based on a separa te class or of the form  
separate  T for some T (in which case it is not an error, although redundant, for T to be  
separate — again the same convention as for expanded). An entit y or function is separate  
if its type is separate. An expr ession is separate if it is eit her a separate entity or a call to  
a separate function. A  call or creation instruction is separate  if its target (an expression) is  
separate. A precondition clause i s separate if it involves a se parate call (whose target,  
because of rules tha t follow, can only be  a formal argument).
Constraints
A Separateness Consistency rule i n four parts governs the valid ity of separate calls:
• (1) If the source of an attachment (assignment instruction or assignment passing) is  
separate, its target enti ty must be separate too.
• (2) If an actual argument of a separate call is of a reference  type, the corresponding  
formal argument must be declared as separate.
• (3) If the source of an attachment is the result of a separate  call to a function returning  
a reference type, the target mu st be declared  as separate.
• (4) If an actual argument of a separate call is of an expanded  type, its base class may  
not include, directly or indirec tly, any non-separate attribute  of a reference type.On first reading you 
may move to “DIS-CUSSION”, 30.12, page 1028 .
CONCURRENCY , DISTRIBUTION, CLIENT-SERVER  AND THE INTERNET  §30 .11 1026
There is also a simple consisten cy rule on types (not given ear lier): in a type of the  
form separate  TYPE , the base class of TYPE  must be neither deferred nor expanded.
For a separate call to be valid, the target of the call must be  a formal argument of the  
enclosing routine.
If an assertion contains a funct ion call, any actual argument o f that call must, if  
separate, be a formal argument of  the enclosing routine, if any  (separate argument rule).
Semantics
Each object is handled by a proc essor, its handler. If the targ et t of a creation instruction is  
non-separate, the newly created object will be handled by the s ame processor as the  
creating object. If t is separate, the new object will be allocat ed to a new process or. 
Once it has been created, an object will at any time be in eith er of two states: free and  
reserved. It is free if no feature is being executed on it, and  no separate client is currently  
executing a routine that uses as actual argument a separate ref erence attached to it.
A processor will be in one of th ree states: idle, busy and susp ended. It is busy if it is  
executing a routine whose target i s an object that it handles. It becomes suspended if it  
attempts an unsuccessful call (d efined below) wh ose target is a n object that it handles.
The semantics of calls is affect ed only if one of more of the e lements involved —  
target and actual arguments — ar e separate. The discussion assu mes a call of the general  
form t  f (…, s, …) where f is a routine. (If f  is an attribute, we will assume for simplicity  
that it is called thro ugh an implicit funct ion returning its va lue.)
The call is executed as part of the execution of a routine on a  certain object C_OBJ , 
which may only be in a busy stat e at that stage. The basic noti on is the following:
Definition : satisfiable call
In the absence of CONCURRENCY  features (described next), a call to a routine  
f, executed on behalf of an object C_OBJ , is satisfiable if and only if every  
separate actual argument having a non-void value, and hence att ached to a  
separate object A_OBJ , satisfies the following two conditions if the routine  
uses the corresponding formal a s target of at least one call:
S1 •A_OBJ  is free or reserved by C_OBJ .
S2 • Every separate clause of the precondition of f has value true when  
evaluated for A_OBJ  and the actual arguments given. 
§30.11   A SUMMARY OF THE MECHANISM 1027
I f  a  p r o c e s s o r  e x e c u t e s  a  s a t i s f i a b l e  c a l l ,  t h e  c a l l  i s  s a i d  t o  be successful and  
proceeds immediately; C_OBJ  remains reserved, its processor remains in the busy state,  
every A_OBJ  becomes reserved, the target rem ains reserved, the target’s ha ndler 
becomes busy, and it starts execu ting the routine  of the call. When the call terminates,  
the target’s handler returns to its previous state (idle or sus pended) and each A_OBJ
object returns to its previous  state (free or reserved by C_OBJ ). 
If the call is not satisfiable, it is said to be unsuccessful; C_OBJ  enters the suspended  
state. The call attempt has no immediate effect on its target a nd actual arguments. If one  
or more earlier unsuccessful call s are now satisfiable, the pro cessor selects one of them to  
become successful as just descri bed. The default policy if more  than one is satisfiable is  
to select the one that h as been waiting longest.
The final semantic change is the definition of wait by necessit y: if a client has started  
one of more calls on a certain separate object, and it executes  on that object a call to a  
query, that call will only proceed after all the earlier ones h ave been completed, and any  
further client operations will wait for the query call to termi nate. (We have seen that an  
optimizing implementation might apply this rule only to queries  returning an expanded  
result .) When waiting for these calls to terminate, the client remain s in the “reserved” state.
Library mechanisms
Features of class CONCURRENCY  enable us in some cases t o consider that condition S 1
of the satisfiable call de finition holds even if A_OBJ  has been reserved by another object  
(the “holder”), assuming C_OBJ  (the “challenger’) has called demand or insist ; if as a  
result the call is considered sat isfiable, the holder will get an exception. This will only  
occur if the hol der is in a “yielding” state, which it can achi eve by calling yield .
To go back to the default non-yi elding state, the holder can ex ecute retain ; the 
boolean query yielding  indicates the current state. The challenger’s state is given b y the 
integer query Challenging  which may have the value Normal , Demanding  or Insisting .
To return to the default Normal  state the challenger can execute wait_turn . The 
difference between demand and insist affects what happens if the holder is not yielding : with 
demand  the challenger will get an exception; with insist  it simply waits as with wait_turn .
When these mechanisms cause an e xception in the holder or chall enger, the boolean  
query is_concurrency_exception  from class EXCEPTIONS  has value true.
CONCURRENCY , DISTRIBUTION, CLIEN T-SERVER  AND THE INTERNET  §30 .12 1028
30.12  DISCUSSION
As a conclusion to this presenta tion, let us review the essenti al criteria that should guide  
the development of a concurrent O-O mechanism. These criteria s erved as a basis for the  
approach presented here; in a few cases, as will be seen, some more work remains to be  
done to achieve their full sat isfaction. The goals include:
• Minimality of mechanism. 
• Full use of inheritance and othe r object-oriented techniques. 
• Compatibility with Design by Contract. 
• Provability. 
• Support for command -query distinction. 
• Applicability to many forms of concurrency. 
• Support for corou tine programming. 
• Adaptability through libraries. 
• Support for reuse of no n-concurrent software. 
• Support for deadlock avoidance. 
We will also take a final look at  the question of interleaving accesses to an object.
Minimality of mechanism
Object-oriented software constru ction is a rich and powerful pa radigm, which, as noted at  
the beginning of this chapter, intuitively seems ready to suppo rt concurrency. 
It is essential, then, to aim fo r the smallest possible extensi on. Minimalism here is  
not just a question of good lang uage design. If the concurrent extension is not minimal,  
some concurrency constructs will be redundant with the object-o riented constru cts, or will  
conflict with them, making the d eveloper’s task hard or impossi ble. To avoid such a  
situation, we must find the sm allest syntactic and semantic epsilon  t h a t  w i l l  g i v e  
concurrent execution c apabilities to our o bject-oriented progra ms.
The extension presented in the p receding sections is indeed min imal syntactically,  
since it is not possible to ad d less than one new keyword. 
Full use of inheritance and othe r object-oriented techniques
It would be unacceptable to have a concurrent object-oriented m echanism that does not  
take advantage of all O-O techniques, in particular inheritance . We have noted that the  
“inheritance anomaly” and other potential conflicts are not inh erent to concurrent O-O  
development but follow from spec ific choices of concurrency mec hanisms, in particular  
active objects, state-based models  and path-expression-like syn chronization; the  
appropriate conclusion is to reject these choices and retain in heritance.
§30.12   DISCUSSION 1029
We have repeatedly seen how inhe ritance can be used to produce high-level behavior  
class (such as PROCESS ) describing general patterns to be inherited by descendants. M ost 
of the examples would be impossible without  multiple inheritanc e.
Among other O-O techniques, info rmation hiding also plays a cen tral role.
Compatibility with Design by Contract
It is essential to retain the systematic, logic-based approach to software construction and  
documentation expressed by the principles of Design by Contract . The results of this chapter  
were indeed based on the study of assertions and how they fare in a concurrent context.
In that study we encountered a st riking property, the concurren t precondition  
paradox, which forced us to provi de a different semantics for a ssertions in the concurrent  
case. This gives an even more fundamental place to assertions i n the resulting mechanism.
Support for command-query separation
A principle of object-oriented software construction was develo ped in precedi ng chapters:  
Command-Query Separation. The principle enjoins us not to mix c ommands (procedures),  
which change objects, and queries (functions and attributes), w hich return information  
about objects but do not change t hem. This precludes side-effec t-producing functions.
It is commonly believed  that the principle cannot hold in a con current context, as for  
example you cannot write
next_element  := buffer   item
buffer   remove
and have the guarantee that the element removed by the second c all is the same that the  
first instruction assigned to next_item . Between the two instruc tions, another client can  
mess up with the shared buffer. Such examples are often used to  claim that one must have  
a side-effect-pr oducing function get, which will both return a n element and remove it.
This argument is plainly wrong. It is confusing two notions: ex clusive access and  
routine specification.  With the notation of this chapter, it is  easy to obtain exclusive access  
without sacrificing the Command-Q uery Separation principle: sim ply enclose the two  
instructions above, with buffer  replaced by b, in a procedure of formal argument b, and 
call that procedure with the attribute buffer  as argument. Or, if you do not require the two  
operations to apply to the same element, and want to minimize t he amount of time a shared  
resource is held, write two separate routines. This kind of  flexibility is important for t he 
developer. It can be provided, t hanks to a simple exclusive acc ess mechanism, whether or  
not functions may have side effects.“Objects as 
machines”, page 751.
CONCURRENCY , DISTRIBUTION, CLIEN T-SERVER  AND THE INTERNET  §30 .12 1030
Applicability to many forms of concurrency
A general criterion for the desi gn of a concurrent mechanism is  that it should make it  
support many different forms of concurrency: shared memory, mul titasking, network  
programming, client-server compu ting, distributed  processing, r eal time.
With such a broad set of application areas, a language mechanis m cannot be  
expected to provide all the answ e r s .  B u t  i t  s h o u l d  l e n d  i t s e l f  t o  a d a p t a t i o n  t o  a l l  t h e  
intended forms of concurrency. This is achieved by using the ab stract notion of processor,  
and relying on a disti nct facility (Concurre ncy Control File, l ibraries …) to adapt the  
solution to any particular hardw are architecture that you may h ave available.
Adaptability through libraries
Many concurrency mechanisms have  b e e n  p r o p o s e d  o v e r  t h e  y e a r s ;  some of the best  
known were reviewed at the begi nning of this chapter. Each has its partisans, and each may  
provide the best approach for  a certain problem area. 
It is important, then, that the proposed mechanism should suppo rt at least some of  
these mechanisms. More precisely, the solution must be general enough to allow us to  
program  various concurrency construct s in terms of that mechanism. 
Here the facilities of the object- oriented method should again be put to good use.  
One of the most important aspect s of the method is that it supp orts the construction of  
libraries for widely used schemes . The library construction fac ilities (classes, assertions,  
constrained and uncons trained genericity, multiple inheritance,  deferred classes and  
others) should allow us to expres s many concurrency mechanisms in the form of library  
components. Examples of such encapsulating mechanisms (such as the PROCESS  class 
and the behavior class for locks) have been presented in this c hapter, and the exercises  
suggest a few more.
One may expect that a number of libraries will be produced, rel ying on the basic  
tools and complementing them, to  support concurr ency models cat ering to specific needs  
and tastes.
W e have also seen the use of library classes such as CONCURRENCY  to provide  
various refinements to the basic  scheme defined by the language  mechanism.
Support for coroutine programming
As a special case, coroutines provide a form of quasi-concurren cy, interesting both in itself  
(in particular for simulation act ivities), and as a smoke test of the applicability of the  
mechanisms, since a general solu tion should adapt itself gracef ully to boundary cases. We  
have seen how it is possible, onc e again using the library cons truction mechanisms of  
object technology, to ex press coroutines based on the general c oncurrent mechanism.
§30.12   DISCUSSION 1031
Support for reuse of non-concurrent software
I t  i s  n e c e s s a r y  t o  s u p p o r t  t h e  r euse of existing , non-concurren t software, especially  
libraries of reusable software components.
We have seen how smooth the tran sition is between sequential cl asses such as  
BOUNDED_QUEUE  and their concurrent counterparts such as BOUNDED_BUFFER  (just 
write separate  class  BOUNDED_BUFFER [G] inherit  BOUNDED_QUEUE [G] end). 
This result is somewhat tempered  by the frequent desirability o f encapsulation classes such  
as our BUFFER_ACCESS . Such encapsulation seems useful, however, and may be an  
inescapable consequence of the s emantic differences between seq uential and concurrent  
computation. Also note that such wrapper classes are easy to wr ite.
Support for deadlock avoidance
One area in which more work remains necessary is how to guarant ee deadlock avoidance.
Deadlock potential is a fact of concurrent life. For example an y mechanism that can  
be used to program semaphore s (and a mechanism that is not powerful enough to emulate  
semaphores would be vie wed with suspicion) can cause deadlock, since semaphores are  
trivially open to t hat possibility.
The solution lies partly in the use of high-level encapsulation  mechanisms. For  
example a set of classes encapsulating semaphores, as was prese nted for locks, should  
come with behavior classes that automatically provide a free for every reserve , thereby  
guaranteeing deadlock avoidance for applications that follow th e recommended practice  
by inheriting from the behavior class. This is, in my experienc e ,  t h e  b e s t  r e c i p e  f o r  
deadlock avoidance.
This approach may not be suffici ent, however, and it may be pos sible to devise  
simple non-deadlock rules, automa tically checkable by a static tool. Such a rule (expressed  
as a methodological principle rat her than a language validity r ule, for fear it may be too  
restrictive) was given earlier: the Business Card  principle. But more is needed.
Permitting concurrent access?
A final note on one of the princ ipal properties of the approach : the requirement that at most  
one client may access any supplie r object at any given time, pr eventing interleaving of  
routines and requiring any VIP t reatment to use the duel mechan ism.
The rationale was clear: if any c hallenger client  can interrupt  th e e xe cu ti on  of  a  
routine at any time, w e lose the ability t o reason on our class es (through properties of the  
form {INV and pre} body {INV and post}) since the challenger can leave the object in an  
arbitrary state.
T h i s  o b j e c t i o n  w o u l d  d i s a p p e a r  i f we only permitted challengers  to execute a  
routine of a very special kind: an applicative  routine (in the sense defined for functions  
in earlier chapters) which does not modify the object or, if it  modifies it, cancels all its  
modifications before it leaves. This would assume a language me chanism to state that a  
routine is applicative, and comp ilers enforcing that property.Class BUFFER_
ACCESS was on 
page 1021 .
“Locks”, page 
1009 , and exercise 
E30.8, page 1036 .
“Concurrent 
accesses to an object”, page 982 .
CONCURRENCY , DISTRIBUTION, CLIEN T-SERVER  AND THE INTERNET  §30 .13 1032
30.13  KEY CONCEPTS INTRODUCED IN THIS CHAPTER 
• Concurrency and distribution ar e playing an inc reasing role in  most application areas  
of computers.
• Concurrency has many variants, including multiprocessing and m ultiprogramming.  
The Internet, the Web and object  request brokers bring even mor e possibilities.
• I t  i s  p o s s i b l e  t o  u s e  t h e  f u n d a m e n t a l  s c h e m e s  o f  o b j e c t  t e c h n o logy — classes,  
encapsulation, multipl e inheritance, deferred classes, assertio ns and so on — for the  
greatest benefit of developers o f concurrent and  distributed ap plications.
• No active-passive object distinc tion is necessary or desirable . Objects are by nature  
able to perform many operations; making them active would restr ict them to just one.
• A simple extension of the seque ntial object-oriented notation,  u s i n g  a  s i n g l e  
keywords ( separate ), covers all the major appl ication areas of concurrency.
• Each object is handled by a pro cessor. Processors are an abstr act notion describing  
threads of control; a system can  use as many processors as it w ants regardless of the  
number of available computing de vices (CPUs). It must be possib le to define the  
mapping from processors to CPUs o utside of the so ftware proper.
• An object handled by a different  processor is sa id to be separ ate.
• Calls on separate targets have a different semantics, asynchro nous rather than  
synchronous. For that r eason, any entity representing separate objects must be  
declared as such, u sing the keyword separate .
• Consistency rules, implying in particular that a separate enti ty may not be assigned  
to a non-separate one, ensure th at there are no “traitors” — th at no non-separate  
entity becomes attached  to a separate object.
• To achieve exclusive access to a separate object, it suffices to use the corresponding  
reference as an argumen t to a separate call (a call with a sepa rate target).
• T h e  t a r g e t  o f  a  s e p a r a t e  c a l l  m u s t  i t s e l f  b e  a  s e p a r a t e  f o r m a l  argument of the  
enclosing routine.
• Preconditions on separate targe ts cannot keep th eir usual sema ntics as c orrectness  
conditions (this is the “concurrent precondition paradox”). The y serve as wait  
conditions.
• The mechanism develop ed in this chapter covers multitasking, t ime-sharing, multi-
threading, client-server computing, distributed processing on n etworks such as the  
Internet, coroutines and  real-time applications.
§30.14   BIBLIOGRAPHICAL NOTES 1033
30.14  BIBLIOGRAPHICAL NOTES
The approach to concurrency desc ribed in this chapter evolved f rom a presentation at  
TOOLS EUROPE [M 1990a]  and was revised in [M 1993b] , from which some of the  
material in this chapter (examples in particular) was derived. It is now known as SCOOP  
for “Simple Concurrent Object-Oriented Programming”. John Potte r and Ghinwa Jalloul  
h a v e  d e v e l o p e d  a  v a r i a n t  t hat includes an explicit hold  instruction [Jalloul 1991]
[Jalloul  1994] . Wait by necessity was introduced by Denis Caromel [Caromel 1989] 
[Caromel 1993] .
The first implementation of the model described here was develo ped by Terry Tang  
and Xavier Le V ourch. Both contributed new insights.
A good textbook on the traditional approaches to concurrency is  [Ben Ari 1990] . 
Original references include: on semaphores, [Dijkstra 1968a] , which also introduced the  
“dining philosophers” problem; on monitors, [Hoare 1974] ; on path expressions, 
[Campbell 1974] . The original CSP model was described in [Hoare 1978] ; the book 
[Hoare 1985]  presents a revised mo del with special emphasis on its mathemat ical 
properties. Occam2 is described in [Inmos 1988] . A CSP and Occam archive is available  
at Oxford University: http://www .comlab .ox.ac.uk/archive /csp.html (I am grateful to Bill  
R o s c o e  f r o m  O x f o r d  f o r  h e l p  w i t h  d e t a i l s  o f  C S P ) .  C C S  ( C o m m u n i c ating Concurrent  
Systems) [Milner 1989]  is another influential mathem atically-based model. Although  
cited only in passing in this chapter, Carriero’s and Gelernter ’s Linda method and tool  
[Carriero 1990]  is a must know for anyone i nterested in concurrency.
A special issue of the Communications of the ACM  [M 1993a]  presents a number of  
important approaches to concurrent  object-oriented programming,  originally drawn from  
concurrency papers at va rious TOOLS conferences.
Another collection of papers tha t appeared at about the same ti me is [Agha 1993] . 
An earlier collective book edi ted by Yonezawa and Tokoro [Yonezawa 1987]  served as  
catalyst for much of the work in  the field and is still good re ading. Other s urveys include  
a thesis [Papathomas 1992]  and an article [Wyatt 1992] . Yet another compilation of  
contributions by many authors [Wilson 1996]  covers C++ concur rency extensions.
Hewitt’s and Agha’s actors model, which predates the ob ject-oriented renaissance  
and comes from a somewhat differ ent background, has influenced many concurrent O-O  
approaches; it is described in an article [Agha 1990]  and a book [Agha 1986] . Actors are  
computational agents similar to active objects, each with a mai l address and a behavior.  
A n  a c t o r  c o m m u n i c a t e s  w i t h  o t h e r s  t h r o u g h  m e s s a g e s  s e n t  t o  t h e i r mail addresses; to  
achieve asynchronous co mmunication, the messages are buffered. An actor processes  
messages through functions and by providing “replacement behavi ors” to be used in lieu  
of the actor’s earlier behavior after a certain message has bee n processed.
CONCURRENCY , DISTRIBUTION, CLIEN T-SERVER  AND THE INTERNET  §30 .14 1034
One of the earliest and most tho roughly explored  parallel objec t-oriented languages  
is POOL [America 1989] ; POOL uses a notion of active o bject, which was found to raise  
problems when combined with inheritance. For that reason inheri tance was introduced  
into the language only after a detailed study which led to the separation of inheritance and  
subtyping mechanisms. The design of POOL is also notable for ha ving shown, from the  
start, a strong concern for fo rmal language specification. 
Much of the important work in concurrent O-O languages has come  from Japan.  
[Yonezawa 1987] , already cited, contains the de scription of several influentia l Japanese  
developments, such as ABCL/1 [Yonezawa 1987a] . MUSE, an object-oriented operating  
system developed at the Sony Comp uter Science Laboratory, was p resented by Tokoro and  
his colleagues at TOOLS EUROPE 1989 [Yokote 1989] . The term “inheritance anomaly”  
was introduced by Matsuoka and Yonezawa [Matsuoka 1993] , and further papers by  
Matsuoka and collaborators wh ich propose various remedies.
Work on distributed systems has been particularly active in Fra nce, with the  
CHORUS operating system, of which [Lea 1993]  describes an objec t-oriented extension;  
the GUIDE language and system of Krakowiak et al. [Balter 1991] ; and the SOS system  
of Shapiro et al . [Shapiro 1989] . In the area of programming massively parallel  
architectures, prima rily for scientific a pplications, Jean-Marc  Jézéquel has developed the  
ÉPÉE system [Jézéquel 1992] , [Jézéquel 1996]  (chapter 9)], [Guidec 1996] .
A l s o  i n f l u e n t i a l  h a s  b e e n  t h e  w o r k  d o n e  b y  N i e r s t r a s z  a n d  h i s  c olleagues at the  
University of Genève ar ound the Hybrid language [Nierstrasz 1992]  [Papathomas 1992] , 
which does not have two categorie s of objects (active and passi ve) but relies instead on  
the notion of thread of control, called activity . The basic communication mechanism is  
remote procedure call, either synchronous or asynchronous.
Other important projects include DRAGOON [Atkinson 1991] , which, like the  
mechanism of this chapter, uses preconditions and postcondition s to express  
synchronization, and pSather [Feldman 1993] , based on the notio n of thread and a  
predefined MONITOR  class.
Many other developments would need to be added to this list. Fo r more complete  
s u r v e y s ,  s e e  t h e  r e f e r e n c e s  c i t e d  a t  t h e  b e g i n n i n g  o f  t h i s  s e c t ion. The proceedings of  
workshops regularly hel d at the ECOOP and OOPSLA conferences, s uch as [Agha 1988] , 
[Agha 1991] , [Tokoro 1992] ,  d e s c r i b e  a  v a r i e t y  o f  o n g o i n g research projects and are  
precious to anyone who  wants to find out what problems research ers consider most pressing.
The work reported in this chapte r has benefited at various stag es from the comments  
and criticism of many people. In addition to colleagues cited i n the first two paragraphs  
of this section they include Mor dechai Ben-Ari, Richard Bielak,  John Bruno, Paul  
Dubois, Carlo Ghezzi, Peter Löhr, Dino Mandrioli, Jean-Marc Ner son, Robert Switzer  
and Kim Waldén.
§E30.1   EXERCISES 1035
EXERCISES
E30.1  Printers
Complete the PRINTER  c l a s s ,  i m p l e m e n t i n g  t h e  j o b  queue as a bounded buffer and  
making sure queue manipulat ion routines as well as print d o  n o t  n e e d  t o  p r o c e s s  t h e  
special “stop requ est” print job ( print  may have not j  is_stop_request  as a precondition).
E30.2  Why import must be deep
Assume that a shallow impo rt mechanism (rather than deep_import ) were available.  
Construct an example that will p roduce an inconsistent structur e — one in which a  
separate object is  attached to a non- separate entity.
E30.3  The “inheritance anomaly”
In the BUFFER  example used to illustrate the “inheritance anomaly”, assume t hat each  
routine specifies the exit s tate in each case using a yield  instruction, as in
put (x: G)
do
“Add x to the data structure re presenting the buffer”
if “All positions n ow occupied” then
yield full
else
yield  partial
end
end
Write the corresponding scheme for remove . Then write the class NEW_BUFFER  with the  
added procedure remove_two  and show that the class must redefine both of the inherited  
features (along with the specifi cation of which features are ap plicable in which states).
E30.4  Deadlock avoidance (research problem )
Starting from the Business Card principle, investigate whether it is feasible to eliminate  
some of the possible d eadlocks by introduci ng a validity rule o n the use of non-separate  
actual arguments to separate cal ls. The rule should be reasonab le (that is to say, it should  
not preclude commonly useful schemes), enforceable by a compile r (in particular an  
incremental compiler), and eas ily explainable t o developers.
E30.5  Priorities
Examine how to add a priority scheme to the duel mechanism of c lass CONCURRENCY , 
retaining upward compa tibility with the semantics defined in th e presentation of  
procedures yield , insist  and related ones.Page 962 .
“Synchronization for 
concurrent O-O com-putation”, page 980.
Page 990 .
“Duels and their 
semantics”, page 999.
CONCURRENCY , DISTRIBUTION, CLIEN T-SERVER  AND THE INTERNET  §E3 0.6 1036
E30.6  Files and the precondition paradox
Consider the following simple ex tract from a routine manipulati ng a file:
f: FILE
…
if f /= Void and then  f  readable then
f  some_input_routine
-- some_input_routine  is any routin e that reads
-- data from the file; i ts precondition is readable .
end
Discuss how, in spite of the abs ence of obvious concurrency in this example, the  
precondition paradox can apply to it. ( Hint : a file is a separate persistent structure, so an  
interactive user or some other s oftware system can access the f ile in between the various  
operations performed by the extr act.) Discuss what can happen a s a consequence of this  
problem, and possible solutions.
E30.7  Locking
Rewrite the class LOCKING_PROCESS  as an heir of class PROCESS .
E30.8  Binary semaphores
Write one or more classes implem enting the notio n of binary sem aphore. ( Hint : start from  
the classes implementing locks.) As suggested at the end of the  discussion of locks, be sure  
to include high-level behavior classes, meant to be used throug h inheritance, which  
guarantee a correct pattern of reserve  and free operations.
E30.9  Integer semaphores
Write one or more classes implem enting the notio n of integer se maphore. 
E30.10  Coroutine controller
Complete the implementation of c oroutines by spelling out how t he controller is created.
E30.11  Coroutine examples
The discussion of Simula present s several exampl es of coroutine s. Use the coroutine  
classes of the present chapter  to implement these examples.
E30.12  Elevators
Complete the elevator example by  adding all the creation proced ures as well as the  
missing algorithms, in particular  for selecting floor requests.
E30.13  Watchods and the Business Card principle
Show that the procedure set of class WATCHDOG  violates the Busine ss Card principle.  
Explain why this  is all right. 
E30.14  Once routines and concurrency
What is the appropriate semantic s for once routines in a concur rent context: executed once  
per system execution, o r once per processor?Page 1010 . Class 
PROCESS  was on 
page 961 .
“Locks”, page 
1009 .
“Coroutines”, page 
1012.
“Coroutine con-
cepts”, page 1118 (in 
the Simula chapter ).
“An elevator control 
system”, page 1014
Page 1020 .
31   
Object persistence and databases
E xecuting an object-orien ted application means creating and mani pulating a certain  
number of objects. Wha t happens to t hese objects w hen the curre nt execution terminates?  
Transient  objects will disappear with the current session; but many appl ications also need  
persistent  objects, which will stay around from session to session. Persi stent objects may  
need to be shared by several app lications, raising the need for  databases .
I n  t h i s  o v e r v i e w  o f  p e r s i s t e n c e  i s s u e s  a n d  s o l u t i o n s  w e  w i l l  e x amine the three  
approaches that O-O developers h ave at their disposal for manip ulating persistent objects.  
They can rely on persistence mechanisms  from the programming language and  
development environment to get o bject structures to and from pe rmanent storage. They  
can combine object technology wit h databases of the most common ly available kind (not  
O-O): relational databases . Or they can use one of the newer object-oriented database  
systems , which undertake to transpose to  databases the basic ideas of object technology.
T h i s  c h a p t e r  d e s c r i b e s  t h e s e  t e c h n i q u e s  i n  t u r n ,  p r o v i d i n g  a n  o verview of the  
technology of O-O databases with emphasis on two of the best-kn own products. It ends  
with a more futuristic discussio n of the fate of  database ideas  in an O-O context.
31.1  PERSISTENCE FROM THE LANGUAGE
For many persistence needs it suffices to have, associated with  t h e  d e v e l o p m e n t  
environment, a set of mechanisms for storing objects in files a nd retrieving them from  
files. For simple objects such as integers and characters, we c an use input-output facilities  
similar to those of tr aditional programming.
Storing and retrieving object structures
As soon as composite objects enter the picture, it is not suffi cient to store and retrieve  
individual objects since they may contain references to other o bjects, and an object  
deprived of its dependents would  be inconsistent . This observat ion led us in an earlier  
chapter to the Persistence Closure principle, stating that any storage and retrieval  
mechanism must handle, together with an object, all its direct and indirect dependents. The  
following figure served to illustrate the issue:See “Deep storage: 
a first view of per-sistence”, page 250 .
OBJECT PERSISTENCE AND DATABASES  §31.1 1038
The Persistence Closure principl e stated that any mechanism tha t stores O1 must  
also store all the objects to whi ch it refers, directly or indi rectly; otherwise when you  
retrieve the structure you woul d get a meaningless value (“ dangling reference ”) in the  
loved_one  field for O1.
W e  s a w  t h e  m e c h a n i s m s  o f  c l a s s  STORABLE  which provide the corresponding  
facilities: store  to store an object structure and retrieved  to access it back. This is a  
precious mechanism, whose presen ce in an O-O environment is by itself a major  
advantage over traditional envir onments. The earlier discussion  gave a typical example of  
use: implementing the SA VE facility of an editor. Here is anoth er, from ISE’s own  
practice. Our compiler performs several passes on representatio ns of the software text.  
The first pass creates an intern al representation, known as an Abstract Syntax Tree (AST).  
Roughly speaking, the task of th e subsequent passes is to add m ore and more semantic  
i n f o r m a t i o n  t o  t h e  A S T  ( t o  “ d e c o rate the tree”) until there is enough to generate the  
compiler’s target code. Each pass finishes by a store ; the next pass starts by retrieving the  
AST through retrieved .
The STORABLE  mechanism works not only on files but also on network connecti ons 
such as sockets; it indeed  lies at the basis of the Net client-server library.
Storable format variants
Procedure store has several variants. One, basic_store , stores objects to be retrieved by the  
same system running on the same machine architecture, as part o f the same execution or  
of a later one. These assumptions make it possible to use the m ost compact format possible  
for representing objects.
Another variant, independent_store , removes all these assumptions; the object  
representation is platform-indep endent and syste m-independent. It consequently takes a  
little more space, since it must use a portable data representa tion for floating-point and  
other numerical values, and must include some elementary inform ation about the classes  
o f  t h e  s y s t e m .  B u t  i t  i s  p r e c i o u s  f o r  c l i e n t - s e r v e r  s y s t e m s ,  w h ich must exchange  (PERSON1 )"Almaviva" name
landlord
loved_one
(PERSON1 )"Figaro" name
landlord
loved_one
(PERSON1 )"Susanna" name
landlord
loved_oneO1
O2 O3The need for 
persistence 
closure
§31.2   BEYOND PERSISTENCE CLOSURE 1039
potentially large and complex col lections of objects among mach ines of widely different  
architectures, running entirely d ifferent systems. For example a workstation server and a  
PC client can run two different applications and communicate th rough the Net library, with  
the server application performin g the fundamental computations and the client application  
taking care of the user interfac e thanks to a graphical library  such as Vision .
Note that the storing part is th e only one to require several p rocedures — basic_store , 
independent_store . Even though the implementation of retrieval is different for each 
format, you will always use a single feature retrieved , whose implementation will detect  
the format actually used by the file or network data being retr ieved, and will automatically  
apply the appropriate retrieval algorithm.
31.2  BEYOND PERSISTENCE CLOSURE
The Persistence Closure principl e is, in theory, applicable to all forms of persistence. It  
makes it possible, as we saw, to preserve t he consistency of ob jects stored and retrieved.
In some practical cases, however , you may need to adapt the dat a structure before  
letting it be applied by mechanisms such as STORABLE o r  t h e  O - O  d a t a b a s e  t o o l s  
reviewed later in this chapter. O therwise you may  end up storin g more than you want.
The problem arises in particular  because of shar ed structures, as in this setup:
A relatively small data structure needs to be archived. Because  it contains one or more  
references to a large shared structure, the Persistence Closure  principle requires archiving  
that structure too. In some cases you may not want this. For ex ample, as illustrated by the  
figure, you could be doing some genealogical research, or other  processing on objects  
representing persons; a person object might, through an address field, reference a much  
bigger set of objects representing geographical information. A similar situation occurs in  
ISE’s ArchiText product, which enables users to manipulate structured documents , such as  
programs or specifications. Each document, like the FA M I LY  structure in the figure,  
contains a reference to a structure representing the underlying  grammar, playing the role  
of the CITY structure; we may want to store a document but not the grammar,  which already  
exists elsewhere and may b e shared by many documents.address
FA MI LY  structureCITY structureSmall structure 
with reference 
to big shared structure
OBJECT PERSISTENCE AND DATABASES  §31.2 1040
In such cases you may want to “cut out” the references to the s hared structure before  
storing the referring structure.  This is, however, a delicate p rocess. First, you must as always  
make sure that at retrieval time  the objects will still be cons istent — satisfy their invariants.  
But there is also a practical pro blem: to avoid complication an d errors, you do not really  
want to modify the original stru cture; only in the stored versi on should references be cut out.
Once again the techniques of obj ect-oriented software construct ion provide an  
elegant solution, based on the ideas of behavior class  r e v i e w e d  i n  t h e  d i s c u s s i o n  o f  
inheritance. One of the versio ns of the storin g procedure, custom_independent_store , has 
the same effect as independent_store  by default, but also lets  any descendant of a library  
class ACTIONABLE redefine a number of procedures which do nothing by default, su ch 
as pre_store which will be executed just be fore an object is stored and post_store  which  
will be executed after. So you can for example have pre_store  perform
preserve ; address  := Void
where preserve , also a feature of ACTIONABLE , copies the object safely somewhere.  
Then post_action  will perform a call to
restore
which restores the object from the preserved copy.
For this common case it is in fa ct possible to obtain the same effect through a call of  
the form
store_ignore ("address ")
where ignore  takes a field name as argumen t. Since the implementation of store_ignore  
may simply skip the field, a voiding the two-way copy of preserve and restore , it will be  
m o r e  e f f i c i e n t  i n  t h i s  c a s e ,  b u t  t h e  pre_store -post_store  mechanism is more general,  
allowing any actions bef ore and after storag e. Again, you must m a k e  s u r e  t h a t  t h e s e  
actions will not adversel y affect the objects.
You may in fact use a similar me chanism to remove an inconsiste ncy problem arising  
at retrieval time; it suffices to redefine the procedure post_retrieve which will be executed  
just before the retrie ved object rejoins the  community of appro ved objects. For example  
an application might redefine post_retrieve , in the appropriate class inheriting from  
ACTIONABLE , to execute something like
address  := my_city_structure   address_value (…)
hence making the objec t presentable again be fore it has had the  opportunity to violate its  
class invariant or  any informal consis tency constraint.
There are clearly some rules associated with the ACTIONABLE mechanism; in  
particular, pre_store  must not perform any change o f the data structure unless post_store
corrects it immediately thereafte r. You must also make sure tha t post_retrieve  will perform  
the necessary actions (oft en the same as those of post_store ) to correct any inconsistency  
introduced into the stored structure by pre_store . Used under these rules, the mechanism  
lets you remain faithful to the spirit of the Persistent Closur e principle while making its  
application more flexible. See “Deferred 
classes as partial implementations: the notion of behav-ior class”, page 503 .
§31.3   SCHEMA EVOLUTION 1041
31.3  SCHEMA EVOLUTION
A general issue arises in all ap proaches to O-O persistence. Cl asses can change. What if  
you change a class of which insta nces exist somewhere in a pers istent store? This is known  
as the schema evolution problem.
The word schema  comes from the relational database world, where it describes t he 
architecture of a database: its set of relations (as defined in  the next section) with, for every  
relation, what we would call its type — number of fields and ty pe of each. In an O-O  
context the schema will also be  the set of types, given here by  the classes.
Although some dev elopment environments and database systems hav e provided  
interesting tools for O-O schema  evolution, none has yet provid ed a fully satisfactory  
solution. Let us define the compo nents of a comprehensive appro ach.
Some precise terminology will be useful. Schema evolution  occurs if at least one  
class used by a system that attempts to retrieve some objects ( the retrieving system ) 
differs from its counterpart in t he system that stored these ob jects (the storing system ).  
Object retrieval mismatch, or just object mismatch for short, occurs when the retrieving  
system actually retrieves a part icular object w hose own generat ing class was different in  
the storing system. Object misma tch is an individual consequenc e ,  f o r  o n e  p a r t i c u l a r  
object, of the general phenomenon  of schema evolution for one o r more classes.
Remember that in spite of the terms “storing system” and “retri eving system” this whole  
discussion is applicable not only to storage and retrieval usin g files or databases, but also  
to object transmission over a network, as with the Net library. In such a case the more  
accurate terms would be “sending system” and “receiving system” .
To keep the discussion simple, we will make the usual assumptio n that a software  
system does not change while it is being executed. This means i n particular that all the  
instances of a class stored by a particular system execution re fer to the same version of the  
class; so at retrieval time either all of them will produce an object mismatch, or none of  
them will. This assumption is not  too restrictive; note in part icular that it does not rule out  
the case of a database that contains instances of many differen t versions of the same class,  
produced by different  system executions.
Naïve approaches
We can rule out two extreme app roaches to schema evolution:
• You might be tempted to forsake previously stored objects (sch ema revolution !). The  
developers of the new applicati on will like the idea, which mak es their life so much  
easier. But the users  of the application will not be amused.
• You may offer a migration path f rom old format to new, requiri ng a one-time, en masse  
conversion of old objects. Alth ough this solution may be accept able in some cases, it  
will not do for a large persiste nt store or one that must be av ailable continuously.
What we really need is a w ay to convert old objects on the fly  as they are retrieved  
or updated. This is the most gen eral solution, and the only one  considered in the rest of  
this discussion.An object’s generat-
ing class (or genera-
tor) is the class of 
which it is a direct instance . See “Basic 
form”, page 219 .
Exercise E31.1, page 
1062 , asks you to 
study the conse-quences of removing this assumption .
OBJECT PERSISTENCE AND DATABASES  §31.3 1042
If you happen to need en-masse c onversion, an on-the-fly mechan ism will trivially let you  
do it: simply write a small system that retrieves all the exist ing objects using the new  
classes, applying on-the-fly conve rsion as needed, and stores e verything.
On-the-fly object conversion
The mechanics of on-the-fly conversion can be tricky; we must b e particularly careful to  
get the details right, lest we end up with corrupted objects an d corrupted databases.
First, an application that retrieves an object and has a differ ent version of its  
generating class may not have the rights to update the stored o bjects, which may be just  
as well since other applications may still use the old version. This is not, howeve r, a new  
problem. What counts is that the objects manipulated by the app lication be consistent with  
their own class descriptions; an  on-the-fly conversion mechanis m will ensure this  
property. Whether to write back t he converted object to the dat abase is a separate question  
— a classical question of access privilege, which arises as soo n as several applications, or  
even several sessions of the sam e application, can access the s ame persistent data.  
Database systems, object-oriented or not, have proposed various  solutions
Regardless of write-b ack aspects, the newer and perhaps more ch allenging problem  
is how each application will deal  with an obsolete object. Sche ma evolution involves three  
separate issue s — detection, notification and correction:
•Detection  is the task of catching object m ismatches (cases in which a re trieved  
object is obsolete) a t retrieval time.
•Notification  is the task of making the retri eving system aware of the objec t 
mismatch, so that it will be abl e to react appropriately, rathe r than continuing with  
an inconsistent object (a likely cause of major trouble ahead!) .
•Correction is the task, for the retrieving system, of bringing the mismatc hed object  
to a consistent state that will make it a correct instance of t he new version of its class  
— a citizen, or at least a perman ent resident, of its system of  adoption.
All three problems are delicate. Fortunately, it is possible to  address them separately.
Detection
We can define two general cate gories of detection policy: nominal  and structural .
In both cases the problem is to detect a mismatch between two v ersions of an object’s  
generating class: the version us ed by the system that stored th e object, and the version used  
by the system which retrieves it.
In the nominal approach, each cl ass version is identified by a version name. This  
assumes some kind of registration mechanism, which may have two  variants:
• If you are using a configuration management system, you can re gister each new  
version of the class and get a version name in return (or speci fy the version  
name yourself).
§31.3   SCHEMA EVOLUTION 1043
• More automatic schemes are poss ible, similar to the automatic identificatio n facility  
of Microsoft’s OLE 2, or the tec hniques used to a ssign “dynamic  IP addresses” to  
computers on the Internet (for example a laptop that you plug i n temporarily into a  
new network). These techniques a re based on random number assig nments, with  
numbers so large as to make the likelihood of a c lash infinites imal.
Either solution requires some ki nd of central reg istry. If you want to avoid the  
resulting hassle, you will have t o rely on the structural appro ach. The idea here is to  
associate with each class version a class descriptor  deduced from the actual structure of  
the class, as defined by the clas s declaration, and to make sur e that whenever a persistent  
mechanism stores objects it also stores the associated  class descriptors . (Of course if you  
store many instances of a class y ou will only need to store one  copy of the class descriptor.)  
Then the detection mechanism is simple: just compare the class descriptor of each retrieved  
object with the new class descrip tor. If they are different, yo u have an object mismatch.
What goes into a class descriptor? There is some flexibility; t he answer is a tradeoff  
between efficiency and reliability. For efficiency, you will no t want to waste too much  
space for keeping class informati on in the stored structure, or  t o o  m u c h  t i m e  f o r  
comparing descriptors at retrieval time; but for reliability yo u will want to minimize the  
risk of missing an object mismat ch — of treating a retrieved ob ject as up-to-date if it is in  
fact obsolete. Here are va rious possible strategies:
C1  • At one extreme, the class descriptor could just be the class n ame. This is generally  
insufficient: if the generator o f an object in the storing syst em has the same name  
as a class in the retrieving sys tem, we will accept the object even though the two  
classes may be totally incompati ble. Trouble will  inevitably fo llow.
C2  • At the other extreme, we might use as class descriptor the ent ire class text — perhaps  
not as a string but in an appropriate internal form (abstract s yntax tree). This is clearly  
the worst solution for efficiency, both in space occupation and  in descriptor  
comparison time. But it may not even be right for reliability, since some class  
changes are harmless. Assume for example the new class text has  added a routine,  
but has not changed any attribute or invariant clause. Then not hing bad can happen  
if we consider a retrieved object up-to-date; but if we detect an object mismatch we  
may cause some unwarranted trouble (such as an exception) in th e retrieving system.
C3  • A more realistic approach is to make the class descriptor incl ude the class name and  
the list of its attributes, each  characterized by its name and its type. As compared  
to the nominal approach, there is still the risk that two compl etely different classes  
might have both the same name an d the same attributes, but (unl ike in case C 1) 
such chance clashes are extremel y unlikely to happen in practic e.
C4  • A variation on C 3 would include not just the attribute list but also the whole c lass 
invariant. With the invariant y ou should be assu red that the ad dition or removal of  
a routine, which will not yield a detected object mismatch, is harmless, since if it  
changed the semantics of the cla ss it would affec t the invarian t.
C3 is the minimum reasonable policy , and in usual cases seems a g ood tradeoff, at  
least to start.
OBJECT PERSISTENCE AND DATABASES  §31.3 1044
Notification
What should happen when the dete ction mechanism, nominal or str uctural, has caught an  
object mismatch?
We want the retrieving system to know, so that it will be able to take the appropriate  
correction actions. A library me chanism will add r e s s  t h e  p r o b l e m. Class GENERAL
(ancestor of all classes) must include a procedure
correct_mismatch
do
…See full version below …
end
with the rule that any detection of an objec t mismatch will cau se a call to correct_mismatch
on the temporarily retrieved versi on of the object. Any class c an redefine the default  
version of correct_mismatch ; like a creation procedure, a nd like any redefinition of the  
default exception handling procedure default_rescue , any redefinition of correct_mismatch
must ensure the inva riant of the class.
What should the default version of correct_mismatch  do? It may be tempting, in the  
name of unobtrusiveness, to give it an empty body. But this is not appropriate, since it  
would mean that by default objec t retrieval mismatches will be ignored — leading to all  
kinds of possible abnormal behavi or. The better g lobal default is to raise an exception:
correct_mismatch
-- Handle object retrieval mismatch.
do 
raise_mismatch_exception
end
where the procedure called in th e body does what  its name sugge sts. It migh t cause some  
unexpected exceptions, but this is better than letting mismatch es go through undetected.  
A project that wants to override  this default behavior, for exa m p l e  t o  e x e c u t e  a  n u l l  
instruction rather than raise an  exception, can always redefine  correct_mismatch , at its  
own risk, in class ANY. (As you will remember, develop er-defined classes inherit from  
GENERAL  not directly but through ANY, which a project or insta llation can customize.)
For more flexibility, there is also a feature mismatch_information  of type ANY, defined as  
a once function, and a procedure set_mismatch_information (info: ANY ) which resets its  
value. This makes it possible to provide correct_mismatch with more information, for  
example about the various pr eceding versions of a class.
If you do expect object mismatches for a certain class, you wil l not want the default  
exception behavior for that class: instead you will redefine  correct_mismatch  so as to  
update the retrieved object. This  is our last task: correction.correct  in this proce-
dure name is not an adjective but a verb , 
as in “Correct this mismatch, fast !”. See
“Grammatical cate-gories”, page 881 .
“THE GLOBAL 
INHERITANCE STRUCTURE”, page 580 .
§31.3   SCHEMA EVOLUTION 1045
Correction
How do we correct a object that ha s been found, up on retrieval,  to cause a mismatch? The  
answer requires a careful analys is, and a more sophisticated ap proach than has usually  
been implemented by existing systems or proposed in the literat ure.
The precise situation is this: the retrieval mechanism (through  feature retrieved  of 
class STORABLE , a database operation, or any o ther available p rimitive) has c reated a  
new object in the retrieving sys tem, deduced from a stored obje ct with the same  
generating class; but it has als o detected a mismatch. The new object is in a temporary  
state and may be inconsistent; it  may for example  have lost a f ield which was present in  
the stored object, or gained a fi eld not present in the origina l. Think of it as a foreigner  
without a visa.
Such an object state is similar to the intermediate state of an  object being created —  
outside of any persistence consideration — by a creation instru ction create  x  make (…), 
just after the object’s memory cell has been allocated and init ialized to default values, but  
just before make  has been called. At that stage the object has all the required  components  
but is not yet ready for acceptance by the community since it m ay have inconsistent  
values in some of its fields; it is, as we saw, the official pu rpose of a creation procedure  
make  to override default initializations as may be needed to ensure  the invariant.
Let us assume for simplicity tha t the detection technique is st ructural and based on  
a t t r i b u t e s  ( t h a t  i s  t o  s a y ,  p o l i c y  C 3 as defined earlier), alth ough the discussion will  
transpose to the other  solutions, nominal o r structural. The mi smatch is a consequence of  
a change in the attribute proper ties of the class. We may reduc e it to a combination of any  
number of attribute additions  and attribute removals . (If a class change  is the replacement  
of the type of an attribute, we can consider it as a removal fo llowed by an addition.) The  
figure above shows one a ddition and one removal.
Attribute removal does not raise any apparent difficulty: if th e new class does not  
include a certain attribute pres ent in the old class, the corre sponding object fields are not  
needed any more and we may simpl y discard them. In fact procedu re correct_mismatch
does not need to do anything for such fields, since the retriev al mechanism, when creating  
a tentative instance o f the new class, will have discarded them ; the figure shows this for  
the bottom field — rather, non- field — of the i llustrated objec t.Object 
mismatchThe attribute for this field 
was not in the stored version ; the field has been 
initialized to the default value for the attribute’s type .
The stored object had a field 
here, but the new version of 
the class has removed the corresponding attribute ; 
so the field has been lost.The attributes for these two  
fields have not changed from  
the stored object’s generating  
class to the new version .0.0
See “The role of cre-
ation procedures”, page 371 .
OBJECT PERSISTENCE AND DATABASES  §31.3 1046
We might of course be a bit more concerned about the discarded fields; what if they were  
really needed, so that the object will not make sense without t hem? This is where having  
a more elaborate detection  policy, such as structural policy C 4 which takes the invariant  
into account, would be preferable.
The more delicate case is when the new class has added  an attribute, which yields a  
new field in the retrieved objec ts, as illustrated by the top f ield of the object in the  
preceding figure. What do we do w ith such a field? We must init ialize it somehow. In the  
systems I have seen offering som e support for schema evolution and object conversion,  
the solution is to use  a conventional default as initialization  value (the usual choices: zero  
for numbers, empty for strings).  But, as we know from earlier d iscussions of similar  
problems — arising for example in the context of inheritance — this may be very wrong!
Our standard example was a class ACCOUNT  with attributes deposits_list   and 
withdrawals_list  ; assume that a new version adds an attribute balance  and a system using  
this new version attempts to ret rieve an instance created from the previous version.
The purpose of adding the balance  attribute is clear: instead of having to recompute  
an account’s balance o n demand we keep it in the object and upd ate it whenever needed.  
The new class invariant reflects this through a clause of the f orm
balance = deposits_list   total – withdrawals_list   total
But if we apply the default init ialization to a r etrieved objec t’s balance  field, we will  
get a badly inconsistent result,  whose balance field does not a gree with the record of  
deposits and withdrawals. On the above figure, balance  is zero as a result of the default  
initialization; to agree with the  deposits and wi thdrawals show n, it should be 1000 dollars.
Hence the importance of having the correct_mismatch  mechanism. In such a case the  
class will simply redefine the procedure as
correct_mismatch
-- Handle object retr ieval mismatch by co rrectly setting up balance
do
balance  := deposits_list   total – withdrawals_list   total
end
If the author of the new class has not planned for this case, t he default version of  
correct_mismatch  will raise an exception, causing the application to terminate abnormally  
unless a retry (providing another recovery poss ibility) handles it. This is th e right outcome,  
since continuing  execution could destroy the integrity of the e xecution’s object structure —  
and, worse yet, of the persistent object structure, for example  a database. In the earlier  
metaphor, we wi ll reject the object unless we can assign it a p roper immigration status.See “Uniform Access”,
page 55 , and “Defini-
tion and example”, page 363 .
Retrieving an 
account object
(What is wrong 
with this  
picture ?)0.0Old fields
New field (initialized to  
default value of its type )withdrawals_listdeposits_list
balance$900 $850 $250
$300 $700
§31.4   FROM PERSISTENCE TO DATABASES 1047
31.4  FROM PERSISTENCE TO DATABASES
Using STORABLE ceases to be sufficient for true database applications. Its lim itations  
have been noted in the earlier discussion: there is only one en try object; there is no support  
for content-based queries; each call to retrieved  re-creates the entire structure, with no  
sharing of objects between succe ssive calls. In a ddition, there  is no support in STORABLE  
for letting different client app lications access the same persi stent data sim ultaneously. 
Although various extens ions of the mechanism can alleviate or r emove some of  
these problems, a full -fledged solution requires taking advanta ge of database technology.
O-O or not, a set of mechanisms for storing and retrieving data  items (“objects” in a  
general sense) deserves being ca lled a database management syst em if it supports the  
following features:
• Persistence: objects can outlive the termination of individual  program sessions using  
them, as well as computer failures.
• Programmable structure: the system treats objects as structure d data connected by  
c l e a r l y  d e f i n e d  r e l a t i o n s .  U s e r s  o f  t h e  s y s t e m  c a n  g r o u p  a  s e t  of objects into a  
collection, called a database, a nd define the structure of a pa rticular database.
• Arbitrary size: there is no built-in limit (such as could resu lt from a computer’s main  
memory size or addressing capabil ity) to the numb er of objects in a database.
• Access control: users  can “own” objects and  define access righ ts to them.
• Property-based querying: mechan isms enable users and programs to find database  
objects by specifying their abst ract properties rather than the ir location.
• Integrity constraints: users can  define some semantic constrai nts on objects and have  
the database system enforce these constraints.
• Administration: tools are available to monitor, audit, archive  a n d  r e o r g a n i z e  t h e  
database, add u sers, remove users, p rint out reports.
• Sharing: several users or progr ams can access the database sim ultaneously.
• Locking: users or programs can obtain exclusive access (read o nly, read and write)  
to one or more objects.
• Transactions: it is possible to  define a sequence of database operations, called a  
transaction, with the guarantee that either the whole transacti on will be executed  
normally or, if it fails, it wil l not have visibl y affected the  state of the database.
The standard transaction example is a money transfer from a ban k account to  
another, requiring two operations — debiting the first account and crediting  
the second — which must either succeed together or fail togethe r. If they fail,  
any partial modification, such as debiting the first account, m ust be canceled;  
this is called rolling back  the transaction.
The features listed are not exha ustive; they reflect what most current commercial  
systems offer, and what users have come to expect.
OBJECT PERSISTENCE AND DATABASES  §31.5 1048
31.5  OBJECT-RELATIONAL INTEROPERABILITY
By far the most common form of database systems today is the relational  kind, based on  
ideas developed by E. F. C odd in a 1970 article.
Definitions
A relational database is a set of relations , each containing a set of tuples (or records ). A 
relation is also known as a table  and a tuple as a row because it is convenient to present a  
relation in tabular form, as in
Each tuple is made of a number of fields . All the tuples in a relation have the same  
number and types of fields; in the example the first and last f ields are strings, the other two  
are integers. Each field is  identified by a name: title, date and so on in the above BOOKS  
example. The field names, or eq uivalently the columns, are know n as attributes .
Relational databases are usually normalized , meaning among othe r things that every  
field is a simple value (such as an integer, a real, a string, a date); it cannot be a reference  
to another tuple.
Operations
The relational model of databases comes with a relational algebra which defines a number  
of operations on relations. Thre e typical operations are select ion, projection and join.
Selection yields a rel ation containing a subset of the rows of a given relation, based  
on some condition on the fields. Applying the selection conditi on “pages  less than 400” to  
BOOKS yields a relation made of BOOKS ’s first, second and last tuples. 
The projection of a relation al ong one or more attributes is ob tained by ignoring all the  
other fields, and removing any duplicate rows in the result. If  we project the above relation  
along its last attribute we obtain a one-field relation with th ree tuples, "STENDHAL",  
“FLAUBERT" and "BALZAC"; if we project it along its first three  attributes the result is a  
three-field relation, deduced from the above by removing the la st column.
The join of two relations is a composite relation obtained by s electing type-
compatible attributes in each of  them and combining rows that m atch for these attributes.  
Assume that we als o have a relation AUTHORS :title date pages author
"The Red and the Black" 1830 341 "STENDHAL"
"The Charterhouse of Parma" 1839 307 "STENDHAL"
"Madame Bovary" 1856 425 "FLAUBERT"
"Eugénie Grandet" 1833 346 "BALZAC"The BOOKS  
relation
Some authors , nota-
bly Date , use “attri-
bute name” for attribute and “attri-bute” for field .
§31.5   OBJECT-RELATIONAL  INTEROPERABILITY 1049
Then the join of BOOKS  and AUTHORS  on the matchi ng attributes author and name
is the following  relation:
Queries
The relational model permits que ries — one of th e principal dat abase requirements of our  
earlier list — through a standardized language called SQL, with  two forms: one to be used  
directly by humans, the  other (“embedded SQL”) to be used by pr ograms. Using the first  
form, a typical SQL query
select  title, date , pages  from BOOKS
yielding the titles, dates and page numbers of all recorded boo ks. As you will have noted,  
such a query is, in the relationa l algebra, a pro jection. Anoth er example
select title, date , pages , author  where pages < 400
corresponding in the r elational algebra to a selection. The que ry
select
title, date , pages , author , real_name , birth , date
from  AUTHORS , BOOKS  where
author = name
is internally a join, yielding th e same result as the join exam ple given earlier.name real_name birth death
"BALZAC" "Honoré de Balzac" 1799 1850
"FLAUBERT" "Gustave Flaubert" 1821 1880
"PROUST" "Marcel Proust" 1871 1922
"STENDHAL" "Henri Beyle" 1783 1842
title date pages author/name real_name birth death
"The Red and the Black" 1830 341 "STENDHAL" "Henri Beyle" 1783 1842
"The Charterhouse of Parma" 1839 307 "STENDHAL" "Henri Beyle" 1783 1842
"Madame Bovary" 1856 425 "FLAUBERT" "Gustave Flaubert" 1821 1880
"Eugénie Grandet" 1833 346 "BALZAC" "Honoré de Balzac" 1799 1850The AUTHORS 
relation
Join of BOOKS 
and AUTHORS 
relations on 
author and 
name  fields
OBJECT PERSISTENCE AND DATABASES  §31.6 1050
Using relational databases with object-oriented software
The concepts of relational datab ases, as just sketched, bear a marked resemblance to the  
basic model of O-O computation. We can associate a relation wit h a class, and a tuple of  
that relation with an object — an instance of that class. We ne ed a class library to provide  
us with the operations of relati onal algebra (corresponding to embedded SQL).
A number of object-oriented env ironments provide such a library  for C++, Smalltalk  
or (with the Store  library) the notation of this b ook. This approach, which we ma y call  
object-relational interoperabilit y, has been used successfully by many developments. It is  
appropriate in eith er of the following circumstances:
• Y o u  a r e  w r i t i n g  a n  o b j e c t - o r i e n ted system which must use and p ossibly update  
existing corporate data, stored in relational databases. In suc h a case there is no other  
choice than using an objec t-relational interface.
• Your O-O software needs to stor e object structures simple enou gh to fit nicely in the  
relational view of things.  (Reasons why it might not fit are expla ined next.)
If your persistence requirements  fall outside of these cases, y ou will experience what  
the literature calls an impedance mismatch  between the data model of your software  
development (object-or iented) and the data model of your databa se system (relational).  
You may then find it useful to t ake a look at th e newest develo pment in the database field:  
object-oriented database systems.
31.6  OBJECT-ORIENTED DATABASE FUNDAMENTALS
The rise of obj ect-oriented databases has  been fueled by three incentives:
D1  • T h e  d e s i r e  t o  p r o v i d e  o b j e c t - o r iented software developers with  a  p e r s i s t e n c e  
mechanism compatible w ith their development method — to remove the 
impedance mismatches.
D2  • The need to overcome conceptual  limitations of relational data bases.
D3  • T h e  a t t e m p t  t o  o f f e r  m o r e  a d v a n ced database facilities, not pr esent in earlier  
systems (relational or not), but  made possible and necessary by  the general  
technological advance of the computer field.
The first incentive is the most obvious for someone whose backg round is O-O  
software development when he comes to the persistence question.  But it is not necessarily  
the most important. The other two are pure database concerns, i ndependent of the  
development method.
T o study the concept of O-O database let us start by examining the limitations of  
relational systems (D 2) and how they can fail to mee t the expectations of an O-O  
developer (D 1), then move on to innovative co ntributions of the O-O database  movement.
§31.6   OBJECT-ORIENTED DATABASE FUNDAMENTALS 1051
Where relational databases stop
It would be absurd to deny the c ontribution of relational datab ase systems. (In fact,  
whereas the first publications on O-O databases in the eighties  tended to be critical of  
relational technology,  the more recent trend is to describe the  t w o  a p p r o a c h e s  a s  
complementary.) Relational syste ms have been one of the princip al components in the  
growth of information technology since the seventies, and will be around for a long time.  
They are well adapted to situati ons involving da ta, possibly la rge amounts thereof, where
R1 • The structure of the data is re gular: all objects of a given t ype have the same number  
and types of components.
R2 • The structure is simple: the co mponent types all belong to a s mall set of predefined  
possibilities.
R3 • T h e s e  t y p e s  a r e  d r a w n  f r o m  a  s m all group of predefined possibi lities (integers,  
strings, dates …), each with fixed s pace requirements.
A typical example is a census or taxpayer database with many ob jects representing  
persons, each made of a fixed se t of components for the name (s tring), date of birth (date),  
address (string), salary (intege r) and a few more properties.
Property R 3 r u l e s  o u t  m a n y  m u l t i m e d i a ,  C A D - C A M  a n d  i m a g e  p r o c e s s i n g  
applications, where some data el ements, such as image bitmaps, are of highly variable  
sizes, and sometimes very large.  It also precludes, as a result  of the “normal form”  
requirements enf orced by existing commer cial tools, the possibi lity for an object to refer  
to another object. This is of course a dramatic limitation when  compared to what we have  
come to taking for gra nted in the discussions of this book: whe never we had
the object-oriented model made i t easy to access indirect prope rties of an object, such as  
redblack   author   birth_year  (yielding 1783 if redblack  is attached to the object on the left  
of the figure). A relational description will not be able to re present the reference field  
author , whose value is the denot ation of another object. 
There is a workaround in the relational model, but it is heavy and impractical. To  
represent the above situation,  you will have two relations, BOOKS  and AUTHORS , as 
introduced a few pages back. Then, to connect the two relations , you may perform a join, 
which was also shown in the firs t part of this discussion, usin g matching fields author  for 
the first relation and name  from the second.An object with a 
reference to 
another object"The Red and the Black"
1830title
date
(BOOK3 )341 pages
(WRITER )"Stendhal"
"Henri Beyle"name
real_name
1783 birth
1842 deathauthor
OBJECT PERSISTENCE AND DATABASES  §31.6 1052
To answer questions such as “What is the birth year of the auth or of The Red and the  
Black ?” the relational implementation will have to compute joins, pr ojections etc.; here  
we can use the join seen earlier and then  project along the date attribute.
This technique works and is wide ly used, but it is only applica ble for simple  
schemes. The number of join oper ations would quickly become pro hibitive in a system  
that must regularly handle querie s with many indirections, as “ How many rooms are there  
in the previous house of the man ager of the department from whi ch the lady who  
graduated at the top of my wife’ s youngest maternal uncle’s und ergraduate class was  
reassigned when the parent compa ny went through its second roun d of venture funding?”  
— no particular problem in an O-O  system’s run-time network of objects.
Object identity
The simplicity of the relational  model follows in part from the  identification of objects  
with their values. A relati on (table) is a subset of A × B × … for some sets A, B, …, where  
× represents cartesian product; i n other words eac h one of the e lements of the relation —  
each object — is a tuple <a1, b1, …> where a1 is an element of A and so on. But such an  
object has no existence other than its value; in particular, in serting an object into a relation  
has no effect if the relation al ready has an identical tuple. F or example inserting <"The Red 
and the Black ", 1830 , 341 , "STENDHAL "> into the above BOOKS  relation does not  
change the relation. This is very different from the dynamic mo del of O-O computation,  
where we can have two identical objects:
As you will remember, equal (obj1, obj2 ) will have value true if obj1 and obj2 are 
references attached to these objects, but obj1 = obj2  will yield false.
Being identical is not the same as being the same (ask any iden tical twins). This  
ability to distinguish between the two notions is part of the m odeling power of object  
technology. It relies on the notion of object identity : any object has an existence  
independent of its contents.
Visitors to the Imperial Palace in Kyoto are told both that the  buildings are very ancient  
and that each is rebuilt every hundred years or so. With the no tion of object identity there  
is no contradiction: the object is the same even if its content s have changed.
You are the same individual a s ten years ago even if none of th e molecules that made up  
your body then remains in it now.The join example was 
on page 1049.
Separate but 
equal
(Both bottom refer-
ences are attached 
to the same object .)"The Red and the Black"
1830title
date
(BOOK3 )341 pages
author"The Red and the Black"
1830
(BOOK3 )341title
date
pages
authorO1 O2
§31.6   OBJECT-ORIENTED DATABASE FUNDAMENTALS 1053
We can express object identity in  the relational model, of cour se: just add to every  
object a special key field, guara nteed to be unique among objec ts of a given type. But we  
have to take care of it explicit ly. With the O-O model, object identity is there by default.
In non-persistent O-O software c onstruction, support for object  identity is almost  
accidental: in the simplest impl ementation, each object resides  at a certain address, and a  
reference to the object uses tha t address, which serves as immu table object identity. (This  
is not true any more in implemen tations, such as  ISE’s, which m ay move objects around  
for effective garbage collection ; object identity is then a mor e abstract concept.) With  
persistence, object identify bec omes a distincti ve factor of th e object-oriented model.
Maintaining object ide ntity in a shared data bases raises new pr oblems: every client  
that needs to create objects must obtain a unique identity for them; this means that the  
module in charge of assigning id entities must be a shared resou rce, creating a potential  
bottleneck in a highl y concurrent setup.
The threshold model
From the preceding observations follows what has been called th e threshold model of  
object-oriented databases: the mi nimum set of properties that a  database system must  
satisfy if it deserves at all to  be called O-O. (More advanced features, also desirable, will  
be discussed next.) There are f our requirements for meeting the  threshold model:  
database, encapsula tion, object identity  and references . The system must:
T1  • Provide database func tionality, as define d earlier in this cha pter.
T2  • Support encapsulation, that is t o say allow hiding the interna l properties of objects  
and make them accessible through an official interface.
T3  • Associate with each ob ject an identification that is unique in  the database.
T4  • Allow an object to contain references to other objects.
Notable in this list is the abse nce of some object-oriented mec hanisms that we know  
are indispensable to the method, in particular inheritance. But  this is not as strange as  
might appear at first. All depends on what you expect from a da tabase system. A system  
at the threshold lev el might be a good O-O database engine , providing a set of  
mechanisms for storing, retrieving and traversing object struct ures, but leaving any higher  
knowledge about the sem antics of these objec ts, such as the inh eritance relations, to the  
design and programming  language and the deve lopment environment .
The experience of early O-O database systems confirms that the database engine  
approach is reasonable. Some of the first systems went to the o ther extreme and had a  
complete “data model” with an associated O-O language supportin g inheritance,  
genericity, polymorphism and so on. The vendors found that thes e languages were  
competing with O-O design and programming languages, and tended  t o  lose such 
competitions (since a database language, will likely be less ge neral and practical than one  
designed from the start as a universal programming language); t hey scurried in most cases  
to replace these proprietary offerings with interfaces to the m ain O-O languages.After [Zdonik 1990].
OBJECT PERSISTENCE AND DATABASES  §31.6 1054
Additional facilities
Beyond the threshold model a num ber of facilities are desirable . Most commercial  
systems offer at least some of them.
The first category includes direct support for more advanced pr operties of the O-O  
method: inheritance (single or multiple), typing, dynamic bindi ng. This does not require  
more elaboration for the readers of this book. Other facilities , reviewed next, include:  
object versioning, schema evolut ion, long transactions, locking , object-oriented queries.
Object versioning
Object versioning is the ability to retain earlier states of an  object after procedure calls  
have changed the state. This is particularly important as a res ult of concurrent accesses.  
Assume that an object O1 contains a reference to an object O2. A client changes some  
fields of O1, other than the refe rence. Another client changes O2. Then if the first client  
attempts to follow the reference , it may find a version of O2 t hat is inconsistent with O1.
Some O-O database systems address this problem by treating ever y object  
modification as the creation of a new object, thereby maintaini ng access to older versions.
Class versioning and schema evolution
Objects are not the only element s to require versioning: over t ime, their generating classes  
may change too. This is the problem of schema evolution, discus sed at the beginning of  
this chapter. Only a few O-O dat abase systems provide full supp ort for schema evolution.
Long transactions
The concept of transaction has a lways been important in databas e systems, but classical  
transaction mechanisms have  been directed towards short  transactions: those which begin  
and end with a single operation performed by a si ngle user duri ng a single session of a  
computer system. The archetypal example, cited at the beginning  of this chapter, is  
transferring a certain amount of money from one bank account to  another; it is a  
transaction, since it requires an  all-or-nothing outcome: eithe r both operatio ns (debiting  
one account and crediti ng the other) succeed, or both fail. The  time it will take is on the  
order of seconds (less if we ignore user interaction).
Applications in the general idea of design  of complex systems, such as CAD-CAM  
(computer-aided design and manufa cturing of engin eering product s) and computer-aided  
software engineering, raise the need of long transactions, whose du ration may be on the  
order of days or even months. Du r i n g  t h e  d e s i g n  o f  a  c a r ,  f o r  e xample, one of the  
engineering teams may have to ch eck out the carburetor part to perform some changes,  
and check it back in a week or two later. Such an operation has  all the properties of a  
transaction, but the techniques d eveloped for short transaction s are not directly applicable.
The field of software developmen t itself has obvious demand for  long transactions,  
arising each time several people  or teams work on a common set of modules. Interestingly,  
database technology has not been  widely applied (in spite of ma ny suggestions in the  
literature) to software  development. The sof tware field has ins tead developed for its own  
purposes a set of configuratio n management  tools which address the specific issues of  
software component management, but also duplicate some standard  database functions,  
§31.7   O-O DATABASE SYSTEMS: EXAMPLES 1055
most of the time without the ben efit of database technology. Th is situation, surprising at  
first look, has a most  likely explanation: the absence of suppo rt for long transactions in  
traditional database management systems. 
Although long transactions may not conceptually require object technology, recent  
efforts to support them have com e from O-O database systems, so me of which offer a way  
to check any object in a nd out of a database.
Locking
Any database management system m ust provide some form of lockin g, to ensure safe  
concurrent access and updating. E arly O-O database systems supp orted page-level
locking, where the operating sys tem determines the scope of a l ock; this is inconvenient  
for large objects (which may ext end over several pages) and sma ll objects (which may fit  
several to a page, so that locki ng one will also lock the other s). Newer systems provide  
object-level  locking, letting a client appli cation lock any object individu ally.
Recent efforts have tried hard to minimize  the amount of locking that occurs in actual  
executions, since locking may ca use contention and slow down th e operation of the  
database. Optimistic locking  is the general name for a class of policies which try to avoid  
placing a lock on an object a priori, but instead execute the p ossibly contenti ous operations  
o n  a  c o p y ,  t h e n  w a i t  a s  l o n g  a s  p o s s i b l e  t o  u p d a t e  t h e  m a s t e r  c opy, locking it and  
reconciling conflicting updates at that time if necessary. We w ill see below an advanced  
form of optimist ic locking in th e Matisse case.
Queries
Database systems, it was recalle d earlier, support queries. Her e object-oriented systems  
can offer more flexibility than relational ones in the presence  of schema evolution.  
Changing the schema of a relational database often means that y ou must change the query  
texts too and recompile them if appropriate. In an O-O database , the queries are relative  
to objects; you query the instances of a certain class with res pect to some of their features.  
Here instance has, at least on  option, its general sen se covering both direct  instances of a  
class and instances of its prope r descendants; so if you add a descendant to a class the  
original queries  on that class will be a ble to retrieve instanc es of the new descendant.
31.7  O-O DATABASE SYSTEMS: EXAMPLES
Since the mid-eighties a number of object-oriented database pro ducts have appeared. Some  
of the best-known product names are Gemstone, Itasca, Matisse, Objectivity, ObjectStore,  
Ontos, O2, Poet, Versant. More recently a few companies such as UniSQL h ave introduced  
object-relational systems in an effort to reconcile the best of  both approaches; the major  
relational database vendors are also proposing or announcing co mbined solutions, such as  
Informix’s Illustra (based in part on UC Berkeley’s POSTGRES pr oject) and Oracle’s  
announced Oracle 8 system.
To facilitate interoperability, a  number of O-O database vendor s have joined forces  
in the Object Database Management Group , which has proposed the ODMG standard to  
unify the general inter face of O-O databases  and their query la nguage.
Let us take a look at two particularly interesting systems, Mat isse and Versant.
OBJECT PERSISTENCE AND DATABASES  §31.7 1056
Matisse
MATISSE, from ADB Inc., is an object-oriented database system w ith support for C, C++,  
Smalltalk and the notation of this book. 
Matisse is a bold design with man y non-conventional ideas. It i s particularly geared  
towards large database s with a rich semantic  structure and can manipulate very large  
objects such as images, films an d sounds. Although it supports basic O-O concepts such  
as multiple inheritance, Matisse refrains from imposing too man y constraints on the data  
model and instead serves as a po werful O-O database engine in t he sense defined earlier  
in this chapter. Some of  the strong points are:
• An original represent ation technique that makes it possible to  s p l i t  a n  o b j e c t  —  
especially a large object — over several disks, so as to optimi ze access time.
• Optimized object placement on disks.
• An automatic duplication mechan ism providing a software soluti on to hardware  
fault tolerance: objects (rather  than the disks themselves) can  be mirrored across  
several disks, with automatic r ecovery in case of a disk failur e.
• A built-in object version ing mechanism (see below).
• Support for transactions.
• Support for a client-server arc hitecture in which a central se rver manages data for a  
possibly large number of clients, which keep a “cache” of recen tly accessed objects.
Matisse uses an original approach  to the problem of minimizing locks. The mutual  
exclusion rule enforced by many systems is that several clients  may read an object at once,  
but as soon as one client starts  writing no other client may re ad or write. The reason,  
discussed in the concurrency cha pter, is to preserve object int egrity, as expressed by class  
invariants. Permitting two client s to write simultaneously coul d make the object  
inconsistent; and if a client is  in the middle of writing, the object may be in an unstable  
state (one that does not satisfy the invariant), so that anothe r client reading it may get an  
inconsistent result.
Writer-writer locks are clearly i nevitable. Some systems, howev er, make it possible  
to breach the reader-writer excl usion by permitting read operat ions to occur even in the  
presence of a write lock. Such o perations are appropriately cal led dirty reads .
Matisse, whose designers were clearly obsessed with the goal of  minimizing locks,  
has a radical solution to this i ssue, based on object managemen t: no write operations . 
Instead of modifying an existing object, a write operation (one , that is, which appears as  
such to the client software) will create a new object. As a res ult, it is possible to read  
objects without any loc king: you will access  a certain version of the database, unaffected  
by write operations that may occ ur after you start the read. Yo u are also able to access a  
number of objects with the guarantee that they will all belong to the same version of the  
database, whereas with a more tra ditional approach you would ha ve to use global locks or  
transactions, and incur  the resulting perfo rmance penalties, to  achieve the same result.The official spelling 
is all upper case.
§31.7   O-O DATABASE SYSTEMS: EXAMPLES 1057
A consequence of this policy is the ability to go back to earli er versions of an object  
or of the database. By default, older versions are kept, but th e system provides a “version  
collector” to get rid of unwanted versions.
Matisse provides interesting mechanisms for managing relations.  If a class such as  
EMPLOYEE  has an attribute supervisor : MANAGER , Matisse will on request maintain the  
inverse links automati cally, so that you can access not only th e supervisor of an employee  
but also all the employees managed  by a supervisor. In addition , the query facilities can  
retrieve objects through  associated keywords.
Versant
Versant, from Versant Object Tec hnology, is an ob ject-oriented database system with  
support for C++, Smalltalk and the notation of this book. Its d ata model and interface  
language support  many of the principal c oncepts of O-O developm ent, such as classes,  
multiple inheritance, feature re definition, feature renaming, p olymorphism and genericity.
V e r s a n t  i s  o n e  o f  t h e  d a t a b a s e  s ystems conformin g to the ODMG s tandard. It is  
meant for client-server architect ures and, like Matisse, allows  caching of the most recently  
accessed information, at the page level on t he server side and at the object level for clients.
The design of Versant has devoted  particular attention to locki ng and transactions.  
Locks can be placed on individua l objects. An application can r equest a read lock, an  
update lock or a write lock. Upda te locks serve to avoid deadlo ck: if you have a read lock  
and want to write, you should first request an update lock, whi ch will be granted only if  
no other client has done so; this  still lets othe r clients read , until you request a write lock,  
which you are guaranteed to get. Going directly from read lock to write lock could cause  
deadlock: two clients each waiti ng indefinitely for the other t o release its lock.
The transaction mechanism provid es for both short and long tran sactions; an  
application may check out an object for any period. Object vers ioning is supported, as well  
as optimisti c locking.
The query mechanism makes it possible to query all instances of  a class, including  
instances of its prope r descendants. As noted earlier, this mak es it possible to add a class  
without having to redefine the q ueries applying to its previous ly existing ancestors.
Another interesting Ve rsant capability is the event notificatio n mechanism, which  
you can use to make sure that ce rtain events, such as object up date and deletion, will cause  
applications to receive a notifi cation, enabling them to execut e any associated actions that  
they may have define d for that purpose.
Versant provides a rich set of d ata types, including a set of p redefined collection  
classes. It permits schema evolut ion, with the convention that new fields are initialized to  
default values. A set of indexing and query mechanisms is avail able.
OBJECT PERSISTENCE AND DATABASES  §31.8 1058
31.8  DISCUSSION: BEYOND O-O DATABASES
Let us conclude this review of persistence issues with a few mu sings on poss ible future  
evolutions. The observations that follow are tentative rather t han final; they are meant to  
prompt further reflection rather  than to provide concrete answe rs.
Is “O-O database” an oxymoron?
The notion of database proceeds from a view of the world in whi ch the Data sit in the  
middle, and various programs are permitted to access and modify such Data:
In object technology, however, we have learned to understand da ta as being entirely  
defined by the applicable operations:
The two views seem incompatible!  The notion of data existing in dependently of the  
programs that manipulate them (“d ata independence”, a tenet rea ffirmed in the first few  
pages of every database textbook)  is anathema to the object-ori ented developer. Should we  
then consider that “object-orien ted database” is an oxymoron?
Perhaps not, but it may be worthwhile to explore how, in a dogm atic O-O context, we  
could obtain the effect of databases without really having data bases. If we define  
(simplifying to the barest essentials the definition of databas es given earlier in this chapter)The database 
view
DATAProgram
Program
ProgramProgramProgram
The O-O viewf1 f2 f3 g1 g2 g3 h1 h2 h3
DATA A DATA B DATA C
 “FROM PER-
SISTENCE TO DATABASES”, 31.4,page 1047.
§31.8   DISCUSSION: BEYOND O-O DATABASES 1059
DATABASE = PERSISTENCE + SHARING
the dogmatic view woul d consider the second component, data sha ring, as incompatible  
with O-O ideas, and fo cus on persistence onl y. Then we would ad dress the sharing needs  
through a different technique: c oncurrency! The picture becomes
Following  O-O principles, the persistent data are implemented as a set o f objects —  
instances of some abstract data types — and controlled by a cer tain server system. Client  
systems that need to manipulate the data will do so through the  server; because the setup  
requires sharing and concurrent access, the clients will treat the server as separate  in the  
sense defined by the  discussion of concu rrency. For example:
flights : separate  FLIGHT_DATABASE ; …
flight_details ( f: separate  FLIGHT_DATABASE ; 
rf: REQUESTED_FLIGHTS ): FLIGHT
do
Result  := f  flight_details (rf )
end
reserve ( f: separate FLIGHT_DATABASE ; r: RESERVATION )
do
f  reserve (r); status  := f  status
end
Then the server side requires no sharing mechanism, only a gene ral persistence  
mechanism. We may also need tool s and techniques to handle such  matters as object  
versioning, which are indeed persistence  rather than database issues.
The persistence mechanism could then become extremely simple, s hedding much of  
the baggage of databases. We might even con sider that all objects are persistent by  
default ; transient objects become the exception, handled by a mechanis m that generalizes  
garbage collection. Such an appr oach, inconceivable when databa se systems were  f1 f2 f3
PERSISTENT
DATAClient Client Client
ServerSeparating 
persistence from sharing
On concurrency and 
the separate  mecha-
nism see chapter 30 .
OBJECT PERSISTENCE AND DATABASES  §31.9 1060
invented, becomes less absurd wit h the constant decrease of sto rage costs and the growing  
availability of 64-bit virtual a ddress spaces where, it has bee n noted, “ one could create a  
new 4-gigabyte object , the size of a full address spac e on a conventional 32-bit processor ,
once a second for 136 years and not ex haust the availa ble namespace . This is sufficient to  
store all the data associated  with almost any application dur ing its entire lifetime .”
All this is speculative, and provides no proof that we should r enounce the traditional  
notion of database. There is no n eed to rush and sell your shar es of O-O database  
companies yet. Consider  this discussion as an intellectual exer cise: an invitation to probe  
further into the widely accepted  notion of O-O database, examin ing whether the current  
approach truly succeeds i n removing the dreaded impedance mismatches  between the  
software development method and th e supporting data storage mec hanisms. 
Unstructured information
A final note on databases. With the explosion of the World-Wide  Web and the appearance  
of content-based search tools (of which some well-known example s, at the time of writing,  
are AltaVista, Web Crawler and Yahoo) it has become clear that w e  c a n  a c c e s s  d a t a  
successfully even in the absence of a database.
Database systems require that before you store any data for fut ure retrieval you first  
convert it into a strictly defin ed format, the database schema.  Recent studies, however,  
show that 80% of the electronic data in companies is unstructur ed (that is to say, resides  
outside of databases, typically in text files) even though data b a s e  s y s t e m s  h a v e  b e e n  
around for many years. This is wh ere content-based tools interv ene: from user-defined  
c r i t e r i a  i n v o l v i n g  c h a r a c t e r i s t i c  w o r d s  a n d  p h r a s e s ,  t h e y  c a n  r etrieve data from  
unstructured or minimally structured documents. Almost anyone w ho has tried these tools  
has been bedazzled by the speed at which they can retrieve info rmation: a second or two  
suffices to find a needle in a b ytestack of thousands of gigaby tes. This leads to the  
inevitable question: do we rea lly need structured databases?
The answer is still yes. Unstruc tured and structured data will coexist. But databases  
are no longer th e only game in town; more and more, sophisticat ed query tools will be able  
to retrieve information even if it is not in the exact format t hat a database would require.  
To write such tools, of course , object technology is our best b et.
31.9  KEY CONCEPTS STUDIED IN THIS CHAPTER
• An object-oriented environment should allow objects to be pers istent — to remain in  
existence after the session creating them has terminated.
• A persistence mechanism should offer schema evolution  to convert retrieved objects  
on the fly if their generating class has changed (“object misma tch”). This involves  
three tasks: detection, notification, correction. By default, a  mismatch should cause  
an exception.
• Beyond persistence, many applications need database support, o ffering concurrent  
access to clients.Quotation from 
[Sombrero-Web].
§31.10   BIBLIOGRAPHICAL NOTES 1061
• Other properties of databases include querying, locking and tr ansactions.
• It is possible to use O-O development in conjunction with rela tional databases, through  
a simple correspondence: classes  to relations, objects to tuple s.
• To gain full use of object technology and avoid impedance mism atches between the  
development and the data model, you may use object-oriented dat abases.
• Two interesting O-O database systems were studied: Matisse, pr oviding original  
solutions for object versioning and redundancy, and Versant, pr oviding advanced  
locking and transaction mechanisms.
• In a more tentative part of th e discussion, some questions wer e raised as to the true  
compatibility of database principles with the O-O view, and the  need for accessing  
unstructured as well as structured data.
31.10  BIBLIOGRAPHICAL NOTES
The original paper on th e relational model is [Codd 1970] ; there are many books on the  
topic. Probably the best-known database textbook, with particul ar emphasis on the  
relational model, is [Date 1995] , the sixth edition of a book  originally published in the  
mid-seventies. Another useful general-purpose text is [Elmasri 1989] .
[Waldén 1995]  c o n t a i n s  a  d e t a i l e d  p r a c t i c a l  d i s c u s s i o n  o f  h o w  t o  m a k e  o b j e c t -
relational interoperability work. [Khoshafian 1986]  brought the question of object identity  
to the forefront of O-O database discussions.
A good starting point f or understanding the goals of object-ori ented database  
systems and reading some of the original papers is [Zdonik 1990] , a collection of  
contributions by some of the pioneers in the field, whose intro ductory chapter is the source  
of the “threshold model” concept  used in the present chapter. T he widely circulated “O-O  
Database System Manifesto” [Atkinson 1989] , the result of the collaboration of a number  
of experts, has been influential  in defining the goals of the O -O database movement. There  
are now a number of textbooks on the topic; some of the best kn own, in order of  
publication, are: [Kim 1990] , [Bertino 1993] , [Khoshafian 1993] , [Kemper 1994] , 
[Loomis 1995] . For further, regularly updated references, Michael Ley’s on-l ine 
bibliography of database systems [Ley-Web]  is precious. Klaus Dittrich’s group at the  
University of Zürich maintains  a “mini-FAQ” about O-O databases  a t http ://
www .ifi.unizh .ch/groups /dbtg/ObjectDB /ODBminiF AQ .html. [Cattell 1993]  describes the  
ODMG standard. For an appraisal, somewhat jaded, of the achieve ments and failures of  
O-O databases by one of the pioneers of the field, see [Stein 1995] .
This chapter has benefited from important comments by Richard B ielak, particularly  
on schema evolution, Persistence C l o s u r e ,  q u e r i e s  i n  O - O  d a t a b a ses, Versant and  
Sombrero. Its presentation of Versant is based on [Versant 1994] , that of Matisse on  
[ADB  1995]  (see also http://www .adb.com/techovw /features .html). I am indebted to Shel  
Finkelstein for helping me with  t h e  f e a t u r e s  o f  M a t i s s e .  O2 is described in
[Bancilhon  1992] . The Sombrero project [Sombrero-Web]  has explored the implications  
of large address spaces on tradi tional approaches to persistenc e and databases. 
OBJECT PERSISTENCE AND DATABASES  §E31.1 1062
A preview of some of this chapte r’s material on schema evolutio n appeared as  
[M 1996c] . The questioning of how well O-O  and database concepts really match comes  
from two unpublished keynote lectures, presented in 1995 at TOO L S  U S A  a n d  t h e  
European Software Engineering Conference [M 1995d] .
EXERCISES
E31.1  Dynamic schema evolution
Study how to extend the schema ev olution techniques developed i n this chapter to account  
for the case in which classes of a software system may change d uring the system’s execution.
E31.2  Object-oriented queries
Discuss the form that queries may take in an object-oriented da tabase management system.
32  
Some O-O techniques for 
graphical interactive applications
Famous Designer has recent ly designed an automobile . It has neither a  
fuel gauge , nor a speedometer , nor any of the idiotic controls that plague  
other modern cars . Instead , if the driver makes a mistake , a large “?”
lights up in the middle of the dashboard . “The experienced driver ”, says 
Famous , “will usually know what went wrong ”.
Unix folklore. (Instead of “ Famous Designer  ”, the  
original names one of the prin cipal contributors to Unix.)
E legant user interfaces  have become a require d part of any succe ssful software product.  
Advances in display hardware, er gonomics (the study of human fa ctors) and software have  
taken advantage of interaction te chniques first pioneered in th e seventies: multiple  
windows so you can work on sever al jobs, mouse or other fast-mo ving device so you can  
show what you want, menus to spe ed up your choices, icons to re present important  
notions, figures to display info rmation visually, buttons to re quest common operations.
The acronym GUI, for Graphical U ser Interface, has come to serv e as a general  
slogan for this style of interaction. Related buzzwords include  WYSIWYG ( What You See  
Is What You Get ), WIMP ( Windows, Icons, Menus, Pointing device ) and the phrase “direct  
manipulation”, characterizing applications which give their use rs the impression that they  
work directly on the object s shown on the screen. 
These impressive techniques, not long ago accessible only to us ers of a few  
advanced systems running on expen sive hardware, have now become  a l m o s t  
commonplace even on the most ordinary personal computers. So co mmonplace and  
popular, in fact, that a softwar e developer can hardly expect a ny success from a product  
that uses just a line- oriented interface, or even one that is f ull-screen but not graphical. 
Yet until recently the construct ion of interactive applications  offering advanced  
graphical facilities re mained so difficult as to justify what m ay be called the Interface  
Conjecture : the more convenient and easy an applicatio n appears to its us ers, the harder it  
will be for its developers to build. 
One of the admirable advances of the software field over the pa st few years has been  
to start disproving the interface conjecture through  the appearance of good tools s uch as  
interface builders.
SOME O-O TECHNIQUES FOR GRAPHI CAL INTERACTIVE APPLICATIONS  §32 .1 1064
More progress remains necessary in this fast-moving area. Objec t technology can  
help tremendously, and in fact the fields denoted by the two bu zzwords, GUI and O-O,  
have had a closely linked history. Simply stated, the purpose o f this chapter is to disprove  
the Interface Conjectur e, by showing that to be user-friendly a n application does not have  
to be developer-hostile. Object- oriented techniques will help u s concentrate on the proper  
data abstractions, suggest some of these abstractions, and give  us the ability to reuse  
everything that can be reused.
A complete exploration of O-O tec hniques for building graphical  and interactive  
applications would take a book o f its own. The aim of the prese nt chapter is much more  
modest. It will simply select a few of the less obvious aspects  of GUI building, and  
introduce a few fundamental tec hniques that you should find wid ely applicable if your  
work involves designin g graphical systems.
32.1  NEEDED TOOLS 
What tools do we  need for building useful  and pleasant interact ive applications? 
End users, application developers and tool developers 
First, a point of terminology to  avoid any confusion. The word “user” (one of the most  
abused terms in the computer fie ld) is potentially misleading h ere. Certain people, called  
application developers , will produce interactive applications to be used by other peo ple, 
to be called end users ; a typical end user would be a dentist’s assistant, using a sy stem 
built by some application develo per for recordin g and accessing  patient history. The  
application developers themselves will rely, for their graphica l needs, on tools built by the  
third group, tool developers . The presence of three categor ies is the reason why “user”  
without further qualification is  ambiguous: the end users are t he application developers’  
users; but the application devel opers themselves are the tool d evelopers’ users.
An application is an interactive system produce d by a developer. An end user w ho 
uses an application will do so by starting a session, exercisin g the application’s various  
facilities by providin g the input of his c hoice. Sessions are t o applications what objects are  
to classes: individu al instances of a general pattern. 
This chapter analyzes the require ments of developers who want t o provide their end  
users with useful appl ications offering gr aphical interfaces. 
Graphical systems, window systems, toolkits 
Many computing platforms offer s ome tools for building graphica l interactive  
applications. For the graphical part, libraries are available t o implement designs such as  
GKS and PHIGS. For the user inte rface part, basic window system s (such as the Windows  
Application Programming  Interface, the Xlib API under Unix and the Presentation  
Manager API under OS/2)  are too low-level to make direct use co nvenient for application  
developers, but they are complemented by “toolkits”, such as th ose based on the Motif  
user interface protocol.
§32.1   NEEDED TOOLS 1065
All these systems fulfill useful needs, but they do not suffice  to satisfy developers’  
requirements. Among their limitations: 
• They remain hard to use. With Motif-based toolkits, developers  must master a multi-
volume documentation describing hundreds of predefined C functi ons and structures  
bearing such awe-inspiring names as XmPushButtonCallbackStruct  — with the B of 
Button  in upper case, but the b o f  back in lower case — or XmNsubMenuId . The 
difficulties and insecurities of C are compounded by the comple xity of the toolkit.  
Using the basic Application Programming Interface of Windows is  similarly tedious:  
to create an application, you mu st write the application’s main  loop to get and dispatch  
messages, a window procedure to catch user events, and other lo w-level elements.
• Although the toolkits cover user interface objects — buttons, menus and the like —  
some of them offer little on graphics (geometrical figures and transformations). To add  
true graphics to the interf ace is a significant effort. 
• The toolkits are incompatible with each other. Motif, the Wind ows graphics and  
Presentation Manager, although based on essentially similar con cepts, differ in many  
ways, some significant (in Windows and PM creating a user inter face object displays  
it immediately, whereas under Motif you first build the corresp onding structure and  
then call a “realize” operation to display it), some just a mat ter of convention (screen  
coordinates are measured from th e top left in PM , from the bott om left in the others).  
Many user interface conventions also vary. Most of these differ ences are a nuisance to  
end users, who just want something that works and “looks nice”,  and do not care  
whether window corners are sharp or slightly rounded. The diffe rences are an even  
worse nuisance to developers, who must choose between losing pa rt of their potential  
market or wasting precious dev elopment time on porting efforts.  
The library and the application builder 
To answer the needs of developers and enable them to produce ap plications that will  
satisfy their end users, we must  go beyond the toolkits and pro vide portable, high-level  
tools that relieve developers fr om the more tedious and repetit ive parts of their job,  
allowing them to devote  their creativity to  the truly innovativ e aspects. 
The toolkits provide a good basi s, since they support many of t he needed  
mechanisms. But we must hide the ir details and complement them with more usable tools. 
The basis of the solution is a l ibrary of reusable classes, sup porting the fundamental  
data abstractions identified in t his chapter, in particular the  notions of window, menu,  
context, event, command, state, application. 
For some of the tasks encountere d in building an application, d evelopers will find it  
convenient to work not by writing  software texts in the traditi onal fashion, but by relying  
on an interactive system, called an application builder, which will enable them to express  
their needs in a graphical, WYSIWIG form; in other words, to us e for their own work the  
interface techniques that they o ffer to their users. An applica tion builder is a tool whose  
end-users are themselves develop ers; they use the application b uilder to build the parts of  
SOME O-O TECHNIQUES FOR GRAPHI CAL INTERACTIVE APPLICATIONS  §32 .2 1066
their systems that may be specif ied visually and interactively.  The term “application  
builder” indicates that this tool is far more ambitious than pl ain “interface builders”, which  
only cover the user interface of  an application. Our applicatio n builder must go further into  
expressing the structure and sem antics of an application, stopp ing only where software  
text becomes the only reasonable solution. 
In defining the library and the application builder, we should be guided, as always,  
by the criteria of reusability and extendibility. This means in  particular that for every data  
abstraction identified below (su ch as context, command or state ) the application builder  
should provide two tools: 
• For reusability, a catalog  (event catalog, context catalog, state catalog …) containing  
predefined representatives of the abstraction, which developers  can include directly  
into their applications. 
• For extendibility, an editor  (context editor, command editor, state editor …) enabling  
developers to produce their own variants, either from scratch o r more commonly by  
pulling an element from a cat alog and then modifying it. 
Using the object-oriented approach 
In the object-oriented approach to software construction, the k ey step is to find the right  
data abstractions: the types of objects which characterize appl ications in the given area. 
T o  a d v a n c e  o u r  u n d e r s t a n d i n g  o f  g r a p h i c a l  u s e r  i n t e r f a c e s  a n d  d evise good  
mechanisms for buildin g applications, we must explore the corre sponding abstractions.  
Some are obvious; others w ill prove more subtle. 
Each of the abstractions encount ered below will yield at least one class in the library.  
Some will yield a set of classes , all descending from a common ancestor describing the  
most general notion. For example , the library includes several classes describing variants  
of the notion of menu. 
We will first examine the overall  structure of a portable graph ics library; then  
consider the main graphical abst ractions covering the geometric al objects to be displayed,  
and the “interaction objects” supp orting event-driven dialogues ; finally we will study the  
more advanced abstractions descr ibing applications: command, st ate, application itself. 
32.2  PORTABILITY AND PLATFORM ADAPTATION
Some application developers want a portable libra ry, which will  enable them to write a  
single source text that will then  adapt automatically to the lo ok-and-feel of many  
platforms, at the price of a rec ompile but without any change. Others want the reverse: to  
gain full access to all the specific “controls” and “widgets” o f a particular platform such  
as Microsoft Windows, but in a c onvenient fashion (rather than at the typically low level  
of the native libraries). Yet ot hers want a bit of both: portab ility as the default, but the  
ability to go native when needed.
With a careful design, relying on a two-layer structure, we can  try to satisfy all of them:
§32.2   PORTABILITY AND PLATFORM ADAPTATION 1067
To make things more concrete the  figure shows the names of the corresponding  
components in ISE’s environment,  but the idea is applicable to any graphical library. At  
the top level ( Vision ) there is a portable graphical library; at the bottom level yo u find  
specialized libraries, such as WEL  for Windows, adapted t o one platform only.
WEL and other bottom-level libraries can be used directly, but they also serve as the  
platform-depende nt component of the top level: Vision  mechanisms are implemented  
through WEL on Windows, MEL on Mot if and so on. This technique has several  
advantages: for the application developers, it fosters compatib ility of concepts and  
techniques; for the t ool developers, it removes unneeded duplic ations, and fa cilitates the  
implementation of the top level (which relies on clean, abstrac t, assertion-equipped and  
inheritance-rich O-O libraries su ch as WEL, rather than interfa cing directly with the C  
level, always a dangerous propo sition). The conn ection between the two levels relies on  
the handle  design pattern developed in an earlier chapter.
Application deve lopers have a choice of level:
• If you want to ensure portability, use the higher layer. This is also of interest to  
developers who, even if they work for a single platform, want t o benefit from the higher  
degree of abstraction provided by high-level libraries such as Vision .
• If you want to have direct access to all the specific mechanis ms of a platform (for  
example the many “controls” provided by Windows NT), go to the corresponding  
lower-layer library.
T h e  l a s t  c o m m e n t  t o u c h e s  o n  a  d e l i c a t e  i s s u e .  H o w  m u c h  p l a t f o r m -specific  
functionality do you lose by relying on a portable library? The  answer is necessarily a  
tradeoff. Some early por table libraries used an intersection (or “lowest common  
denominator”) approach,  limiting the facilities offered to thos e that were present in native  
form in all the platforms supported. This is usually not enough . At the other extreme the  
library authors might use the union  approach: provide every s ingle mechanism of every  
supported platform, using explicit algorithms to simulate the m echanisms that are not  
natively available on a particular platform. This policy would produce an enormous and  
redundant library. The answer has to be somewhere in-between: t he library authors must  
decide individua lly , for every mechanism present on some platfo rms only, whether it is  
important enough to warrant writ ing a simulation on the other p latforms. The result must  
be a consistent library, simple enough to be used without knowl edge of the individual  
platforms, but powerfu l enough to produce i mpressive visual app lications.WEL
(Windows)MEL
(Motif)PEL
(Presentation 
Manager)Platform-independent library (Vision )Graphical 
libraries 
architecture
(See a similar archi
tecture for concur-rency , page 970 .)
See “AN APPLICA-
TION: THE HANDLETECHNIQUE”, 24.3, page 817 .
SOME O-O TECHNIQUES FOR GRAPHI CAL INTERACTIVE APPLICATIONS  §32 .3 1068
For application develo pers, one more criterion in choosing betw een the two layers is  
performance. If your main reason for considering the top layer is abstraction rather than  
portability, you must be aware that including the extra classes  will carry a space penalty  
(any time penalty should be negl igible with a well-designed lib rary), and decide whether  
it is worthwhile. Clearly, a one- platform library such as WEL w ill be more compact.
Finally, note that the two solut ions are not completely exclusi ve. You can do the bulk  
of your work at the top level an d provide some platform-specifi c goodies to u sers working  
on your top-selling platform. Th is has to be done carefully, of  course; carelessly mixing  
portable and non-portable elements would soon cancel any expect ed benefits, even partial,  
of portable development. An elegant design pattern (which ISE h as applied to some of its  
libraries) relies on assignment attempt. The idea is this. Cons ider a graphical object known  
through an entity  m whose type is at the top level, say MENU . Any actual object to which  
it will become attached at run time will be, of course, platfor m-specific; so it will be an  
instance of a lower-layer class, say WEL_MENU . To apply platform-specific features you  
need an entity, say wm, of this type. You can u se the following scheme:
wm ?= m
if wm = Void then
… We are not on Windows! Do n othing, or something else … 
else
… Here we may apply any WEL_MENU (i.e. Windows-specific)
     feature to wm …
end
We can picture this scheme as a way to go into the Windows-only  room. The room  
is locked, to prevent you from claiming, if someone finds you t h e r e ,  t h a t  y o u  j u s t  
wandered into it by accident. Yo u are permitted to enter, but y ou must ask for the key,  
explicitly and politely. For suc h official and conditional requ ests to enter a special-purpose  
area, the key is as signment attempt.
32.3  GRAPHICAL ABSTRACTIONS
Many applications will use graph ical figures, often representin g objects from  an external  
system. Let us see a simple set of abstractions that will cover  this need.
Figures 
First we need a proper set of abs tractions for the graphical pa r t  o f  a n  i n t e r a c t i v e  
application. To keep things simp le, this discuss ion will assume  two-dimensional graphics. 
Geographical maps provide an exce llent model. A map (of a count ry, a region, a city)  
provides a visual representation of some reality. The design of  a map uses several levels  
of abstraction: 
§32.3   GRAPHICAL ABSTRACTIONS 1069
• We must view the reality behind the model (in an already abstr acted form) as a set of  
geometrical shape or figures . For a map the figures represent rivers, roads, towns and  
other geographical objects. 
• The map will describe a certain  set of figures, which may be c alled the world . 
• The maps will show only a part o f the world — one or more area s which we will call  
windows , and assume to be rectangular. For example a map can have one main 
window devoted to a country, and subsidiary windows devoted to large cities or  
outlying parts (as with Corsica in  maps of France or Hawaii in maps of the USA). 
• Physically the map appears on a physical display medium, the device . The device is  
usually a sheet of paper, but we may also use a computer screen . Various parts of the  
device will be devoted to the various  windows.  
The graphical 
abstractions
WORLD
WINDOW
DEVICEFigures
WindowsWindow1
Window2Window3
Window4
SOME O-O TECHNIQUES FOR GRAPHI CAL INTERACTIVE APPLICATIONS  §32 .3 1070
The four basic concepts — WORLD , FIGURE , WINDOW , DEVICE  — transpose  
readily to general graphical appl ications, where the world may contain arbitrary figures of  
interest to a certain computer ap plication, rather than just re presentations o f geographical  
objects. Rectangular areas of th e world (windows) will be displ ayed on rectangular areas  
of the device (the  computer screen). 
The figure on the previous page shows the three planes: world ( bottom), window  
(middle) and device (top). The not ion of window plays a central  role, as each window is  
associated both with an area of the world and with an area of t he device. Windows also  
cause the only signific ant extension to the  basic map concepts:  support for hierarchically  
nested windows. Our windows will be permitted to have subwindow s, with no limit on the  
nesting level. (No nesting  appears in the figure.) 
Coordinates 
We need two coordinate systems: d e v i c e  c o o r d i n a t e s  a n d  w o r l d  c o ordinates. Device  
coordinates measure the position s of displayed items on the dev ice. On computer screens,  
they are often measured in pixel s; a pixel (picture element) is  the size of a small dot,  
usually the smallest  displayab le item. 
There is no standard f or the unit of world coordinates, and the re should not be since  
the world coordinate system is b est left for application develo pers to decide: an  
astronomer may wish to work in l ight years, a ca rtographer in k ilometers, a biologist in  
millimeters or microns.
Because a window captures part o f a world, it will have a certa in world position  
(defined by the x a n d  y world coordinates of its top-le ft corner) and a certain extent  
(horizontal and vertical lengths of the parts of the world cove red). The world position and  
the extent are exp ressed in world coo rdinate units. 
Because the window is displayed on part of a device, it has a c ertain device position  
(defined by the x and y device coordinates of its top-l eft corner) and a certain size on the  
device, all expressed in device coordinate units . For a window with no parent, the position  
is defined with respect to the device; for a subwindow , the pos ition is always defined  
relative to the parent. Thanks to  this convention, any applicat ion that uses windows may  
run with the whole screen to itsel f as well as in a previously allocated window. 
Operations on windows 
To take care of the hierarchical nature of windows we make clas s WINDOW  an heir of  
class TWO_WAY_TREE ,  a n  i m p l e m e n t a t i o n  o f  t r e e s .  A s  a  r e s u l t ,  a l l  h i e r a r c h i c a l  
operations are readily available  as tree operations: add a subw indow (child), reattach to a  
different enclosing window (pare nt) and so on. To set the world  and device positions of a  
window, we will use one  of the following pr ocedures (all with t wo arguments):
Set absolute position Move, relative to current position
Position in world go pan
Position on device place_  proportional
place_  pixelmove_  proportional
move_  pixel
§32.4   INTERACTION MECHANISMS 1071
The _   proportional procedures interpret the values of their arguments as fractions  of 
the parent window’s height and width; arguments to the other pr ocedures are absolute  
values (in world coordinates for go a n d  pan, in device coor dinates for the _  pixel
procedures). Procedures are simi larly available to set the exte nt and size of a window. 
Graphical classes and operations 
All classes representing figures  are descendants of a deferred class FIGURE ; standard  
features include display , hide, translate , rotate , scale .
It is indispensable to keep the set of figure types extendible,  allowing application  
developers (and, indirectly, end  users of graphical tools) to d efine new types. We have  
seen how to do this: provide a class COMPOSITE_FIGURE , built by multiple inheritance  
from FIGURE  and a container type such as LIST [FIGURE ].
32.4  INTERACTION MECHANISMS 
Let us now turn our attention to how our applications will inte ract with users. 
Events 
Modern interactive applications are event-driven : as the interactive user causes certain  
events to occur (for example by entering text at the keyboard, moving the mouse or  
pressing its buttons), certa in operations get executed. 
Innocuous as this description may seem, it represents a major d eparture from more  
traditional styles of interactio n with users. In the old style (which is still by far the most  
common), a program that needed i nput from its user would get it  by repeatedly executing  
scenarios of the form 
… Perform some computation …
print ("Please type in the va lue for parameter xxx. ")
read_input
xxx := value_read
… Proceed with the computation, u ntil it again needs a value fro m the user …
In the event-driven s tyle, roles are reve rsed: operations occur  n o t  b e c a u s e  t h e  
software has reached a preset stage of its execution, but becau se a certain e vent, usually  
triggered by the intera ctive user, has caused execution of a ce rtain component of the  
software. Input determines the so ftware’s execution rather than  the reverse. 
The object-oriented style of soft ware development plays an impo rtant role in making  
such schemes possible. Dynamic bi nding, in particular, enables the software to call a  
feature on an object under the u nderstanding that the form of t he object will determine how  
it will handle the feature. The feature may be associated with an event and t he object to a  
command; more on this below. 
The notion of event is important enough in this discussion to y ield a data abstraction.  
An event object (instance of the EVENT  class) will represent a user action; examples are  
key press, mouse movement, mouse  button down, mouse button up. These predefined  
events will be part of  the event catalog. 
SOME O-O TECHNIQUES FOR GRAPHI CAL INTERACTIVE APPLICATIONS  §32 .5 1072
In addition, it must be possible  to define custom events, which  a software component  
may send explicitly by a p rocedure call of the form raise (e). 
Contexts and user interface objects 
GUI toolkits offer a number of predefined “User Interface Objec ts”: windows, menus,  
buttons, panels. Here is a  simple example, an OK button.
Superficially, a user interface object is just a figure. But un like the figures seen above  
it usually has no rela tion with the underly ing world: its role is limited to the handling of  
user input. More precisely, a use r interface objec t provides a special case of context . 
To understand the need for the notion of context, we must remem ber that an event  
generally does not suffice to de termine the software’s response . Pressing a mouse button,  
for example, will give different results depending on where the  mouse cursor is. Contexts  
are precisely those conditions w hich determine the responses th at an application  
associates with events. 
In general, then, a context is simply a boolean value — a value  which will be true or  
false at any instan t of the softwar e’s execution. 
The most common contexts are associated with user interface obj ects. A button such  
as the one above defines the boo lean condition “is the mouse cu rsor inside the button?”, a  
context. Contexts of thi s kind will be written IN (uio), where uio is the user interface  
object. 
For every context c its negation not c  is also a context; not IN (uio) is also called  
OUT  (uio). The context ANYWHERE  is always true; its negation NOWHERE  is never true. 
Our application builder should t hen have a context catalog, whi ch will include  
ANYWHERE  and contexts of the form IN (uio) for all commonly useful interface objects  
uio.  I n  a d d i t i o n ,  w e  m a y  w i s h  t o  e n able application developers to define their own  
contexts; the application builder will provide a context editor  for this purpose. Among  
other facilities, the context ed itor makes it po ssible to obtai n not c  for any c (in particular  
a c from the catalog). 
32.5  HANDLING THE EVENTS 
We now have the list of events, and the list of contexts in whi ch these events may be  
significant. We must describe what to do as a response to these  events. The r esponses will  
involve commands  and transition labels . A button
OK
§32.5   HANDLING THE EVENTS 1073
Commands 
Recognizing the notion of command  as an important abstraction i s a key step in producing  
good interactive applications. 
This notion was studie d as part of the Undoing case study. As y ou remember, a  
command object represen ts the information n eeded to execute a u ser-requested operation  
and, if undoing is s upported, cancel it.
To the features defined in the e arlier discussion, we will add the attribute exit_label , 
explained below.
Basic scheme
With contexts, events and command s we have the basic ingredient s to define the basic  
operation of an interactive app lication, which our application builder should support: an  
application deve loper will select the valid context-event combi nations (which events are  
recognized in which contexts) and, for every one of them, defin e the associated command.
This basic idea can provide the f irst version of an application  builder. There should  
be catalogs of contexts and event s (based on the underlying too lkit) as well as commands  
(provided by the development env ironment, and available for app lication developers to  
extend). A graphical metaphor shou ld make it possible to select  a  c o n t e x t - e v e n t  
c o m b i n a t i o n ,  f o r  e x a m p l e  l e f t - c l i c k  o n  a  c e r t a i n  b u t t o n ,  a n d  s e l e c t  a  c o m m a n d  t o  b e  
executed in response.
States
For a fully general scheme we sh ould include an extra level of abstraction, giving the  
Context-Event- Command-State  model of interactive gr aphical applications.
In an application a given contex t-event combination does not al ways have the same  
effect. For example, you might fi nd yourself durin g a session i n a situation where part of  
the screen looks like this: “Command as a 
class”, page 699.
An exit 
command
Quit editing last_drawing ?
OK Cancel
SOME O-O TECHNIQUES FOR GRAPHI CAL INTERACTIVE APPLICATIONS  §32 .5 1074
In this state the application re cognizes various events in vari ous contexts; for  
example you may click on a figur e to move it, or request the Sa ve command by clicking  
on the OK button shown . If you choose this l atter possibility, a new panel appears:
At this stage only two context-event combinations will be accep ted: click ing on the  
“OK” or on the “Cancel” button of the new panel. All others hav e been disabled (and the  
application has dimmed the rest of the figure as a reminder tha t everything but the two  
buttons is temporarily inactive).  What happened is that the ses sion has entered a new state  
of the application. States, also called modes , are a familiar notion in discussions of  
interactive systems, but are sel dom defined precisely. Here we have the seeds for a formal  
definition: a state is characterized by a set of acceptable con text-event combinations and  
a set of commands; for each cont ext-event combination, the stat e defines the associated  
command. This will be restated a s a mathematical  definition bel ow. 
Many interactive applications, g raphical or not, will have seve ral states.
A typical example is the well-known Vi editor under Unix. Since this tool is not graphical,  
events are simply key presses (each keyboard key triggering a d ifferent event) and the  
contexts are various possible cursor positions (under a charact er, at beginning of line, at  
end of line etc.). A rough analysis of Vi indicates at least fo ur states: 
• In the basic state (which is also the initial one for an end u ser who calls the editor  
on a new or existing file), typing a letter key will, in most c ases, directly execute a  
command associated with the letter. For example, typing x deletes the character at  
cursor position, if any. Some keys cause a transition to anothe r state; for example  
typing a colon  : leads to the command state, typing i leads to the insertion state, and  
typing R leads to the replacement state. Some letters cause unaccepted events; for  
example (unless it has been expressly defined as a macro) the l etter z has no effect. Confirming a 
command
Quit editing last_drawing ?
Cancel
Overwrite existing file
last_drawing ?
OK CancelOK
§32.5   HANDLING THE EVENTS 1075
• In the command state, only one is available, at the bottom of the Vi window; it  
serves to enter commands such as “save” or “restart”. 
• In the insertion state, any key corresponding to a printable c haracter is acceptable  
as an event; the corresponding character will be inserted into the text, causing  
displacement of any existing text to its right. The ESCAPE key gets the session back  
to the basic state. 
• Replacement state is a variant of insertion state in which the  characters that you type  
overwrite rather than displace the ones already in  place. 
The literatur e on user interfaces is critical o f states because they can be confusing to  
users. An early article on the Sm alltalk user interface contain ed a picture of the article’s  
author wearing a T-shirt that re ad “Don’t mode me in!”. It is i ndeed a general principle of  
sound user interface design to ensure that at every stage of a session end users should have  
as many commands as possible at  their disposal (instead of havi ng to change state before  
they can execute certain important commands). 
In accordance with this principle, a good design will try to mi nimize the number of  
states. The principle does not mean, however, that this number should always be one. Such  
an extreme interpretation of the “don’t mode me in” slogan coul d in fact decrease the  
quality of the user int erface, as too many unrelated commands a vailable at the same time  
may confuse end users. Furthermo re, there may be good reasons t o restrict the number of  
c o m m a n d s  i n  a  c e r t a i n  s i t u a t i o n  ( for example when the applicati on needs an urgent  
response from it s end user). 
States, in any case, sh ould be explicit for the developers, and  usually for the end  
users as well. This is the only way to enable developers to app ly the user in terface policy  
of their choice — wheth er of the strongly anti-modal persuasion  or more tolerant. 
S o  o u r  a p p l i c a t i o n  b u i l d e r  w i l l  provide developers with an expl icit STATE
abstraction; as for the other ab stractions, there will be a sta te catalog, containing states that  
have proved to be of g eneral use, and a state editor, enabling developers to define new  
states, often by modifying states  extracted from the catalog. Partial state 
diagram for Vi
REPLACEMENTINSERTION
BASIC
xd dpPD  … iaI  …RC  …q-Return wq-Return … 
(macros)
ReturnEscape
Escape:
Initial state
Exit transitionState transitionEscapeCOMMAND
The article was in  
the special Smalltalk 
issue of Byte  
[Goldberg 1981] .
SOME O-O TECHNIQUES FOR GRAPHI CAL INTERACTIVE APPLICATIONS  §32 .6 1076
Applications 
The last major data abstraction is the notion of application. 
All the previous abstractions were intermediate tools. What dev elopers really want  
to build is applications. A text processing system, an investme nt banking system, a factory  
control system are examples of applications. 
To describe an application, we n eed a set of states, transition s between these states,  
and the indication of which state is the initial one (in which all sessions will begin). We  
have seen that a state associates a certain response with every  accepted context-event pair;  
the response, as noted, includes a command. To build complete a pplications, we may also  
need to include in a response so me indication of the context-ev ent pair which led to the  
response, so that different comb inations may trigger transition s to different states. Such  
information will be call ed a transition label. 
With states and transition labels we may build the transition d iagram describing an  
entire application, such as the partial diagram for Vi shown on  the preceding page.
Context-Event-Command-State: a summary
The abstractions just defined can se rve as the basis for a powe rful interactive application  
builder — not just an interface  builder, but a tool that enables application developers to  
build entire applications graphic ally; they will explore visual  catalogs of contexts, events  
and, most importantly , commands; selecting the desired elements  graphically, they will  
build the desired context-event-c ommand associations through a simple drag-and-drop  
mechanism until they have  a complete application.
Because simple applicat ions can often rely on just one state, t he application builder  
should make the notion of state as unobtrusive as possible. Mor e advanced applications,  
however, should be able to use a s many states as they need, and  (if only for interface  
consistency) to derive a new sta te incrementally from an existi ng one.
32.6  A MATHEMATICAL MODEL
Some of the concepts presented i nformally in this chapter, in p articular the notion of state,  
have an elegant mathematical des cription based on the notion of  finite function  and the  
mathematical t ransformation known as currying .
Because these results are not used in the rest of the book, and  mostly of interest to  
readers who like to explore the mathematical models of software  concepts, the  
corresponding sections  are not printed here but appear in elect ronic form in the CD-ROM  
accompanying this book, as a supplementary chapte r entitled “mathematical background” , 
an extract from [M 1995e] .
32.7  BIBLIOGRAPHICAL NOTES
The ideas for an application bu ilder sketched in this chapter d erive largely from ISE’s  
Build  application buil der, described in detail in [M 1995e] , which also discusses in detail  
the underlying mathematical model. (This is the manual from whi ch the extra chapter on  
the CD-ROM was extracted.)
Part F: 
Applying the method in various 
languages and environments
 
 
 
 
 
 
 
 
 
 
 
 
 
 
Previous chapters ha ve developed hand in hand the object-oriented method and the  
supporting notation. Part F will study how to realize th e ideas, or emulate them, in  
some of the most popular languages a nd environments. There are three broad  
categories. Object-oriented languages  such as Smalltalk support many of the  
fundamental concepts. Classical languages  such as Fortran are not O-O at all, but  
people who must still use them (for variou s reasons, ofte n not technical)  may want to  
apply as many O-O ideas as fe asible within the limitations  of these older approaches.  
Somewhere in-between, encapsulatio n languages  such as Ada provide a first step to  
object orientation, essentia lly limited to modules based on abstract data  types, but  
without classes or inheritance.  
 
 
Although the logical progression is from Clas sical to Encaps ulation to O-O, it will be  
convenient to start with Encapsulation lang uages, focusing on Ada 83, as it provides a  
good reference to assess techniques applicable in classical languages, the category that  
will follow; we will end with a review of  some of the principa l O-O languages other  
than the notation of this book.
33  
O-O programming and Ada
In the nineteen-seventies, advances in programming methodology b rought about a new  
generation of languages combining  t h e  c o n t r o l  s t r u c t u r e s  o f  A l g ol 60 and the data  
structuring constructs  of Algol W and Pascal with better system  structuring fa cilities and  
support for information hiding. Although their precise traits d iffer, these languages share  
a common spirit and may be collectively called the encapsulation languages . (They are  
also known in the lite rature as “object-based”, a terminology t hat will be discussed in the  
next chapter.)
Although a complete list of encap sulation languages would be lo ng, only a few have  
developed a sizable user communit y. Five deserve particular att ention: Modula-2 , a 
successor to Pascal designed at t h e  S w i s s  F e d e r a l  I n s t i t u t e  o f  Technology by Niklaus  
Wirth, creator of Algol W, Pascal itself and (later) Oberon; CLU , developed at MIT under  
the direction of Barbara Liskov, which comes closest to realizi ng object-oriented concepts  
but lacks inheritance; Mesa , a Xerox effort with particular emphasis on describing inter-
module relationships of large systems; Alphard , by Mary Shaw, William Wulf and Ralph  
London of Carnegie-Mellon Univer sity, which included an asserti on mechanism; and Ada.
We will limit our study of how t o approach O-O techniques in en capsulation  
languages to Ada, which , besides having attracted the most atte ntion, is also the most  
complete (and complex) of these languages, embodying in some fo rm most of the features  
found in the others. Modula-2, fo r example, does not offer gene ricity or ov erloading.
33.1  A BIT OF CONTEXT
Ada was a response to a crisis p erceived in the mid-seventies b y the software policy-
makers of the US Department of Defense (DoD). They noted in par ticular that the various  
branches of the military were us ing more than 450 programming l anguages, many of them  
technically obsolete, gravely hamper ing contractor management, programmer training,  
technical progress , software quality and cost control.
Bearing in mind the successful precedent of COBOL (the result, in the late fifties, of  
a DoD call for a COmmon Business -Oriented Language), they put o ut successive versions  
o f  a  R e q u e s t  F o r  P r o p o s a l s  f o r  a  modern software engineering la nguage capable of  
supporting embedded real-time a pplications. A fir st winnowing o ut of the several dozen  
initial responses led to four candidate designs, sealed and col or-coded for fairness. The  
field was narrowed down to two, f inally leading in 1979 to the selection of the Green  
language designed  by Jean D. Ichbiah and his group at CII-Honey well Bull in France  
(today’s Bull). Following a few y ears’ experience w i t h  t h e  f i r s t industrial  
implementations, the language wa s revised and ma de into an ANSI  standard in 1983.
O-O PROGRAMMING AND ADA  §33.1 1080
Ada (as Green was renamed) began a new era in language design. Never before had  
a language be subjected to such intense examination before bein g released. Never before  
(in spite of some valiant efforts by the PL/I team) had a langu age been treated like a large-
scale engineering project. Worki ng groups comprising the best e xperts in many countries  
spent weeks reviewing the propos als and contributed — in those pre-Internet days —  
reams of comments. Like Algol 60 a generation earlier, Ada rede fined not just the  
language landscape but the v ery notion of l anguage design.
A recent revision of Ada has yiel ded a new language, now offici ally called Ada 95,  
which will be described at the end of this chapter. In the rest  of the discussion, as elsewhere  
in this book, the name Ada with out further qualification refers  to the preceding version,  
Ada 83, by far the most  widely used today.
Has Ada been successful? Yes and no. The DoD got what it had co mmissioned:  
thanks to a rigorous i mplementation of the  “Ada mandate”, Ada b ecame in a few years the  
dominant technical lan guage in the various b ranches of the US m ilitary, and of the military  
establishment of some other coun tries too. It has also achieved  significant use in such non-
military government agencies as NASA and the European Space Age ncy. But except for  
some inroads in compu ting science ed ucation — aided in part by DoD incentives — the  
language has only had limited su ccess in the rest of the softwa re world. It would probably  
have spread more widely were it not for the competition of the very ideas des cribed in this  
book: object technolog y, which burst into the scene just as Ada  and the industry were  
becoming ripe for each other.
The careful observer of language  history can detect two ironies  here. The first is that  
the designers of Ada were well aware of O-O ideas; although thi s is not widely known,  
Ichbiah had in fact written one of the first compilers for Simu la 67, the original O-O  
language. As he has since explai ned when asked why he did not s ubmit an O-O design to  
the DoD, he estimated that in the competitive bidding context o f Ada’s genesis such a  
design would be considered so far off the mainstream as to stan d no chance of acceptance.  
No doubt he was right; indeed one can still marvel at the audac ity of the design accepted  
by the DoD. It would have been reasonable to expect the process  to lead to something like  
an improvement of JOVIAL (a sixt ies’ language for military appl ications); instead, all  
four candidate languages were bas ed on Pascal, a language with a distinct academic flavor,  
and Ada embodied bold new design ideas in many areas such as ex ceptions, genericity and  
concurrency. The second irony is t hat the Ada mandate, meant to  force DoD software  
projects to catch up with progres s in software engineering by r etiring older  approaches,  
has also had in the ensuing year s the probably unintended effec t of slowing down the  
adoption of newer  (post-Ada) technology by the military-aerospa ce community.
The lessons of Ada remain irreplaceable, and it is a pity that many of the O-O languages  
of the eighties and nineties did not pay more attention to its emphasis on software  
engineering quality. However obvious, this comment is all the m ore necessary because the  
occasion for discussing Ada in this book is often to contrast s ome of its solutions with those  
of O-O development — as will agai n happen several times in this  chapter. The resulting  
critiques of Ada techniques should be viewed less as reproach t han as homage to the  
precursor against which any new solution must naturally be asse ssed.
§33.2   PACKAGES 1081
33.2  PACKAGES 
Each of the encapsulation languag es offers a modular construct for grouping logically  
related program elements. Ada cal ls it a package; corresponding  notions are known as  
modules in Modula-2 and Me sa, and clusters in CLU. 
A class was defined as both a structural system component — a m odule — and a  
type. In contrast, a package is o nly a module. An earlier discu ssion described this  
difference by noting that packages are a purely syntactic notion, whereas classes also have  
a semantic  v a l u e .  P a c k a g e s  p r o v i d e  a  w a y  t o  d i s t r i b u t e  s y s t e m  e l e m e n t s  ( v ariables,  
routines …) into coherent subsystems; but t h e y  a r e  o n l y  n e e d e d  f o r  r e a d a b ility and  
manageability of the software. The decomposition of a system in to packages does not  
affect its semantics: one can tr ansform a multi-package Ada sys tem into a one-package  
system, producing exactly the sam e results, through a purely sy ntactical operation —  
removing all package boundaries, expanding generic derivations (as explained below) and  
resolving name clashes  through renaming. Classes, for their par t, are also a semantic  
construct: besides providing a u nit of modular d ecomposition, a  class describes the  
behavior of a set of run-time obj ects; this semantics is furthe r enriched by polymorphism  
and dynamic binding.
An Ada package is a free association of program elements and ma y be used for  
various purposes. Sens ible uses of this notion include writing a package to gather: 
•A set of related con stants (as with facility inheritance). 
• A library of routin es, for example a mat hematical library. 
• A  s e t  o f  v a r i a b l e s ,  c o n s t a n t s  a nd routines describing the impl ementation of one  
abstract object, or a fixed numb er of abstract objects, accessi ble only through  
designated operations (as we will do in Fort ran in the next cha pter). 
• An abstract data type implementation. 
The last use is the most interesting for this discussion. We wi ll study it through the  
example of a stack pack age, adapted from an  example in the Ada reference manual. 
33.3  A STACK IMPLEMENTATION 
Information hiding is supported in Ada by the two-tier declarat ion of packages. Every  
package comes in two parts, officially called “specification” a nd “body”. The former term  
is too strong for a construct th at does not support any formal description of package  
semantics (in the form of asser tions or similar mechanisms), so  we  wi ll  u se  th e mor e  
modest word “interface”. 
The interface lists the public p roperties of the package: expor ted variables,  constants,  
types and routines. For routines  it only gives the headers, lis ting the formal arguments and  
their types, plus the result type for a function, as in: 
function  item (s: STACK ) return  X;See “Packages”, 
page 90 .
“Modules and 
types”, page 170 .
“Facility inheri-
tance”, page 832 .
The standard Ada term 
for “routine” is “sub-program” . We keep the 
former for consistency with other chapters .
O-O PROGRAMMING AND ADA  §33.3 1082
The body part of a package provi des the routines’ implementatio ns, and adds any  
needed secre t elements. 
A simple interface 
A first version of the interface  part of a stack  package may be  expressed as follows. Note  
that the keyword package  by itself introduces a package interface; the body, which will  
appear later, is introduced by package body . 
package REAL_STACKS  is
type STACK_CONTENTS is array (POSITIVE range  < >) of FLOAT ;
type STACK (capacity : POSITIVE ) is
record
implementation : STACK_CONTENTS (1. . capacity );
count : NATURAL  := 0;
end record ;
procedure  put (x: in FLOAT ; s: in out  STACK );
procedure  remove (s: in out  STACK );
function  item (s: STACK ) return  FLOAT ;
function  empty (s: STACK ) return  BOOLEAN ;
Overflow , Underflow : EXCEPTION ;
end REAL_STACKS ;
This interface lists expo r t e d  e l e m e n t s :  t h e  t y p e  STACK  for declaring stacks, the  
auxiliary type STACK_CONTENTS  used by STACK , the four basic routines on stacks, and  
two exceptions. Client packages will only rely on the interface  (provided their  
programmers have some idea of the  semantics associated with the  routines).
This example suggests seve ral general observations: 
• It is surprising to see all the  details of stack representatio n, as given by the  
declarations of types STACK  and STACK_CONTENTS , appear in what should be a  
pure interface. We will see shortly the reason for this problem  and how to correct it.
• Unlike the classes of object-or iented languages , a package doe s not by itself define  
a type. Here you must se parately define a type STACK . One consequence of this  
separation, for the programmer wh o builds a package around an a bstract data type  
implementation, is the need to invent two different names — one  for the package and  
one for the type. Another conseq uence is that the routines have  one more argument  
than their object-orie nted counterparts: here they all act on a  stack s, implicit in the  
stack classes given in earlier chapters.
• A declaration may define not only the type of an entity, but a lso its initial value. Here  
the declaration of count  in type STACK  prescribes an initial value of 0. It obviates  
the need for an explicit initia lization operation corresponding  to creation; this would  
not be the case, however, if a l ess straightforward initializat ion were required. 
§33.3   A STACK IMPLEMENTATION 1083
• A few details of Ada are needed to understand the type declara tions: POSITIVE  and 
NATURAL  denote the subtypes of INTEGER  covering positive and non-negative  
integers, respectively; a type specification of the form array (TYPE range  < >), 
where < > is known as the Box symbol, describes a template for array type s. To 
derive an actual type from such a template, you choose a finite  subrange of TYPE ; 
this is done here in STACK , which uses the subrange 1. .capacity  o f  POSITIVE . 
STACK  is an example of a parameterized type; any declaration of an e ntity of type  
STACK  must specify an actual value for capacity , as in 
s: STACK (1000 ) 
• In Ada, every routine argument must be characterized by a mode : in, out or in out , 
defining the routine’s rights on the correspondi ng actual argum ents (read-only,  
write-only or update). In the ab sence of an expl icit keyword, t he default mode is in. 
• Finally, the interface also s pecifies two exception names: Overflow  and Underflow . 
An exception is an error condition that the programmer has deci ded to treat  
separately from the normal flow of control. The interface of th e package should list  
any exceptions that may be raised by the package’s routines and  propagated to  
clients. More on the Ada e xception mechanism below.
Using a package 
Client code using the package is  based on the interface. Here i s an example from some  
package needing a stack of real numbers: 
s: REAL_STACKS   STACK (1000 );
REAL_STACKS   put (3.5, s); …;
if REAL_STACKS   empty  (s) then …;
An Ada environment must be able to compile such client code eve n if only the  
interface of REAL_STACKS , not its body, is available. 
Syntactically, note how each use of an entity from this package  (where “entities”  
here include type names such as STACK  as well as routine name s) must repeat the name  
of package REAL_STACKS , using dot notation. This coul d become tedio us, hence the  
need for a more implicit form of  qualification. If you include the directive
use REAL_STACKS ;
at the beginning of th e client packa ge, you may writ e the above  extract more simply as 
s: STACK (1000 );
put (3.5, s); …;
if empty (s) then …;
You still need the full form, however, for any entity whose nam e conflicts with the  
name of another accessible to the client package (that is to sa y, declared in that package  
itself or in another su pplier listed in a use directive). 
O-O PROGRAMMING AND ADA  §33.3 1084
Some of the Ada literature advises programmers to stay away fro m the use directive  
altogether on the grounds that it hampers clarity: an unqualifi ed reference such as empty  (s)
does not immediately tell the reader what supplier empty  comes from ( REAL_STACKS  in 
the example). The equivalent in the object-oriented approach, s empty , unambiguously  
indicates the supplier through the type of s.
A similar problem does arise in the O-O world because of inheri tance: when you see a  
name in a class, it may refer to a feature declared in any ance stor. But we saw a technique  
that solves this problem at leas t in part: the notion of flat f orm.
Implementation 
The body of the REAL_STACKS  package might be declared along the following lines.  
Only one routine i s shown in full. 
package body  REAL_STACKS  is
procedure  put (x: in FLOAT ; s: in out  REAL_STACK ) is
begin
if s  count = s  capacity then
raise  Overflow
end if ;
s  count  := s  count + 1 ;
s  implementation (count ) := x;
end put;
procedure  remove (s: in out  STACK ) is
… Implementation of remove  …
end remove ;
function  item (s: STACK ) return  X is
… Implementation of item …
end item ;
function  empty (s: STACK ) return  BOOLEAN  is
… Implementation of empty  …
end empty ;
end REAL_STACKS ;
Two properties apparent in this e xample will be developed in mo re detail below: the  
use of exceptions to handle a ru n-time error by raising a speci al condition and treating it  
separately; and the ne ed for the body to repeat most of the int erface information (routine  
headers) that already ap peared in the interface.
Genericity
The package as given is too spec ific; it should be made applica ble to any type, not just  
FLOAT . To turn it into a generic pack age, use the following syntax:“FLATTENING THE 
STRUCTURE”, page 541.
§33.4   HIDING THE REPRESENTATION: THE PRIV ATE STORY 1085
generic
type G is private ;
package  STACKS  is
… As before, replacing  all occurrences of FLOAT  by G …
end STACKS ;
The generic  clause is heavier syntax than our O-O notation for generic cla sses 
(class C [G]…) because it offers more options . In particular, the parameters  declared in  
a generic  clause may represent not just types but also routines. The app endix on  
genericity vs. inheritance will discuss these possibilities.
The generic  clause is not repeated  in the package body , which will be iden tical to the  
version given earlier, exce pt for the substitution of G for FLOAT  throughout. 
The is private  specification directs the rest of the package to treat G as a private type.  
This means that entities of the type may only be  used in operat ions applicable to all Ada  
types: use as source or target of an assignment, as operand of an equality test, as actual  
argument in a routine, and a few other special operations. This  is close to the convention  
used for unconstrained formal ge neric parameters in our notatio n .  I n  A d a ,  o t h e r  
possibilities are also available.  In particular ,  you can restri ct the operations further by  
declaring the parameter as  limited private , which essentially bars  all uses other than as  
actual argument to a routine. 
Although called a package, a gene rically parameterized module s uch as STACKS  is 
really a package template, since clients cannot use it directly ; they must derive an actual  
package from it by prov iding actual generic parameters. We may define a new version of  
our stack-of-reals package thro ugh such a generic derivation:
package  REAL_STACKS_1 is new  STACKS (FLOAT );
Generic derivation is the princi pal Ada mechanism for adapting modules. It is  
somewhat inflexible, since you can only choose between generic modules (parameterized,  
b u t  n o t  d i r e c t l y  u s a b l e )  o r  u s a b le modules (not extendible any more). In contrast,  
inheritance allows arbitrary ext ensions to existing modules, ac cording to the Open-Closed  
principle. Appendix B pursues the comparison further.
33.4  HIDING THE REPRESENTATION: THE PRIV ATE STORY
Package STACKS , as given, fails to implement t he principle of information hid ing: the  
declarations of types STACK  a n d  STACK_CONTENTS  a r e  i n  t h e  i n t e r f a c e ,  a l l o w i n g  
clients to access the representa tion of stacks d irectly. For ex ample, a client might include  
code of the form 
[1]
use REAL_STACKS_1 ;…
s: STACK ; …
s  implementation (3) := 7.0; s  last := 51;
grossly violating the underlying  abstract data type specificati on. See appendix B .
O-O PROGRAMMING AND ADA  §33.4 1086
Conceptually, the type  declarations belong  in the body. Why did  we not put them  
there in the first place? The ex planation requires that we look , beyond the language, at  
programming envir onment issues. 
One requirement on the Ada desi gn, already mentioned, was that it should be  
possible to compile pack ages separately and, moreover, to compi le a client of any package  
A as soon as you have access to the interface of A, but not necessarily to its body. This  
favors top-down design: to proceed with the work on a module, i t suffices to know the  
specification of the facilities i t needs; actual implementation s may be provided only later. 
So if you have access to the interface of REAL_STACKS_1 (that is to say, the  
interface of STACKS , of which REAL_STACKS_1  is just a generic derivation) you must be  
able to compile one of its clients. Such a client will contain declarations of the form 
use REAL_STACKS_1 ;…
s1, s2: STACK ; …
s2 := s1;
which the poor compile r cannot prope rly handle unl ess it knows what size is taken up by  
an object of type STACK . But that can only be determined from the type declarations fo r 
STACK  and the auxiliary type STACK_CONTENTS . 
Hence the dilemma that faced the designers of Ada: conceptually , such declarations  
belong to the inferno — the body;  but implementa tion concerns s eem to require their  
inclusion in the parad ise — the interface. 
The solution retained was to cre ate a purgatory: a special sect ion of the package that  
is physically tied to the interface, and compiled with it, but marked in such a way that  
clients may not refer to its elements. The purgatory section is  called the private part of the  
interface; it is introduced by the keyword private  ( a l s o  u s e d ,  a s  w e  s a w  a b o v e ,  a s  a  
qualifier for protected types). Any declaration appearing in th e private part is unavailable  
to clients. This scheme is illust rated by our final version of the stack package interface: 
generic
type G is private ;
package  STACKS  is
type STACK (capacity : POSITIVE ) is private ;
procedure  put (x: in G; s: in out  STACK );
procedure  remove (s: in out  STACK );
function  item (s: STACK ) return  G;
function  empty (s: STACK ) return  BOOLEAN ;
Overflow , Underflow : EXCEPTION ;
§33.4   HIDING THE REPRESENTATION: THE PRIV ATE STORY 1087
private
type STACK_VALUES is array (POSITIVE range  < >) of G;
type STACK (capacity : POSITIVE ) is
record
implementation : STACK_VALUES (1. .capacity );
count : NATURAL  := 0;
end record
end STACKS ;
Note how type STACK  must now be declared twice: first in the non-private part of  
the interface, where it is only specified as private ; then again in the private part, where  
the full description i s given. Without the first declaration, a  line of the form s: REAL_
STACK  would not be legal in a client,  since clients on ly have access  to entities declared in  
the non-private part. This first  declaration only specifies the  type as private , barring  
clients from accessing any proper ty of stack objects other than  universal operations such  
as assignment, equality test and  use as actual argument. This i s consistent with the  
discussion of information hiding.
Type STACK_VALUES  is purely internal, and irrelevant to clients: so it need only  be 
declared in the package body.
Make sure to understand that the information in the private par t should really be in  
the package body, and only appea rs in the packag e specification  for reasons of language  
implementation. With the new form of STACKS  client code such as  [1], which directly  
accessed the represe ntation in a client, becomes invalid. 
Authors of clients modules can see the internal structure of STACK  instances, but  
they cannot take advantage of it  in their modules. This can be tantalizing (although one  
may imagine that a good Ada envi ronment could hide this part fr o m  a  c l i e n t  a u t h o r  
requesting interface information about the class, in the manner  of the short  tool of earlier  
chapters). While surprising to newcomers, the policy does not c ontradict the rule of  
information hiding: as was pointed ou t during the d iscussion of  that rule, the goal is not  
physically to prevent c lient authors from r eading about the hid den details, but to prevent  
them from using  these details.
Someone who would like to make things sound very complicated co uld summarize  
by the following two sentences (t o be spoken very quickly to im press friend and foe): The  
private section of the public part of a package lists the imple mentation of those conceptually  
private types which must be declared in the public part althoug h their implementation is not  
publicly available. In the non-private part, these types are de clared private.[1] was on page 1085 .
See “common mis-
understanding” dis-cussed on page 52 .
O-O PROGRAMMING AND ADA  §33.5 1088
33.5  EXCEPTIONS 
The STACKS  g e n e r i c  p a c k a g e  l i s t s  t w o  e x c e p t i o n s  i n  i t s  i n t e r f a c e :  Overflow  a n d 
Underflow . More generally, you may deal with error conditions by definin g arbitrary  
exception names; Ada also includes predefined exceptions, trigg ered by the hardware or  
the operating system, for such ca ses as arithmetic overflow or exhaustion of memory. 
Some elements of the Ada excepti on mechanism were introduced in  the chapter on  
exceptions, so that we can limit ourselves to a brief examinati on of how exceptions fit in  
the Ada approach to software construction.
Simplifying the control structure 
Exceptions as they exist in Ada are a technique for dealing wit h errors without impairing  
the control structure of normal processing. If a program perfor ms a series of actions, each  
of which may turn out to be impossible because of some erroneou s condition, the resulting  
control structure may end up looking like
action1 ;
if error1 then
error_handling1 ;
else
action2 ;
if error2 then
error_handling2 ;
else
action3 ;
if error3 then
error_handling3 ;
else
…
The Ada exception mechanism is a n effort to fight the complexit y of such a scheme  
— where the elements that perfor m “useful” tasks sometimes look  like a small archipelago  
in an ocean of error-handling co d e —  by  se pa ra t in g t he  ha ndl i ng  of errors from their  
detection. There must still be t ests to determine whether a cer tain erroneous condition has  
occurred; but the only action to  take then is to  raise a certai n signal, the exception, which  
will be handled  elsewhere. 
Raising and handling an exception 
To raise exceptions rather than h andle errors in place, you may  rewrite the extract as:
action1 ;
if error1 then  raise  exc1 ; end;
action2 ;“How not to do it — 
an Ada example”, 
page 415 .
Like others in this 
chapter , this exam-
ple follows Ada’s use of the semicolon as an instruction terminator .
§33.5   EXCEPTIONS 1089
if error2 then  raise  exc2 ; end;
action3 ;
if error3 then  raise  exc3 ; end;
…
When an instruction raise  exc is executed, control does n ot flow to the instructions  
that would normally follow, but is transferred to an exception handler . This disruption of  
the normal flow of control explains why the else… clauses are no longer necessary here.  
An exception handler is a specia l paragraph of a block or routi ne, of the form 
exception
when  exc1 , … => treatment1 ;
when  exc2  … => treatment2 ;
…
The handler that a raise  exc will select is the first one that handles exc in the dynamic  
chain, that is to say the list of units beginning with the rout ine or block containing the raise
and continuing with its calle r, its caller’s caller etc.
A handler is said to handle exc if exc appears in one of its when  clauses (or it has a  
clause of the form when others ). If there is such a handler, the correspondin g instructions  
(after the => symbol) are executed and the en closing routine returns control  to its caller,  
or terminates if it is the main program. (Ada does have a notio n of main program.) If no  
handler in the dynamic chain handles exc, execution terminates a nd control goes back to  
the operating system, which pres umably will print out an error message.
Discussion 
It is interesting to compare the  Ada exception mechanism with t he one developed in the  
chapter on exceptions earlier in this book. There are technical  differences and differences  
of methodology.
The technical differences, apart from the different ways of dis criminating between  
exceptions (multiple when  c l a u s e s  vs. inheriting from class EXCEPTIONS ), involve  
retrying, which the O-O design considered sufficiently importan t  t o  w a r r a n t  a  s p e c i a l  
in st ru ct i on , wh er e as  Ada  h as  n o d i re ct  s up po rt  f or  it  a nd  r eq ui res goto instructions or  
similar control structures.The call chain
(This figure origi-
nally appeared on page 418 .)r0r1
r2
r3
r4Routine call or  
block execution
See chapter 12 .
O-O PROGRAMMING AND ADA  §33.5 1090
The methodological difference fo llows from the strong policy th at we adopted,  
l e a d i n g  t o  t h e  D i s c i p l i n e d  E x c e p tion Handling principle that re quires every exception  
handler, apart from the rare case of a “false alarm”, to end in  either retrying  or official  
failure  (“organized panic”). Ada is les s strict in this respect, and w e saw that as a  
consequence it is possible to mis use exceptions by executing a seemingly normal return  
without having handled the problem.
The need to avoid such dangerous  situations led us to a basic r ule, worth repeating:
More generally, exceptions in the Ada spirit are control struct ures, helping to  
separate the handling of abnormal situations  f r o m  t h e i r  d e t e c t i on and hence to keep  
software structure simple. In pr actice, however, this hope is o ften disappointed.
W h e n  y o u  w r i t e  raise  some_exception , you may have the impression of freeing  
yourself from the messy and boring task of taking care of stran ge cases, and instead  
concentrate on the core of the a lgorithm, handling normal cases . But raising an exception  
does not by itself solve the  problem. Exceptions in the STACKS package are typical. An  
attempt to push an element into a full stack raises exception Overflow , and an attempt to  
access an element of an  empty stack raises Underflow . How will you handle Underflow , 
the exception raised by a call to remove  or item on an empty stack? As we saw in the  
discussion of Design by Contract , the routines themselves canno t reasonably contain a  
handler ( item d o e s  n o t  k n o w  w h a t  t o  d o  w h e n  a p p l i e d  t o  a n  e m p t y  s t a c k ) ;  s o  t he 
responsibility lies with the cli ent, which should include code of the form 
[2]
use REAL_STACKS ;
procedure  proc (…) is
s: STACK ; …
begin
… remove (s); …
exception
when  Underflow => action1 ;
…
end proc;
So the client must specify exact ly what happens in the erroneou s case. Omitting the  
when  Underflow  clause would be a design error.  C o m p a r e  t h i s  w i t h  t h e  u s u a l ,  n on-
exception-based form of  the call (written in  the syntax of the rest of this book): 
[3]
if not s  empty then  s  remove else action1 end
(or a variant which detects the error a posteriori). Form [2], using exceptions , differs from  
[3] in two a spects only:Ada exception rule
The execution of any  Ada exception handle r should en d by either  executing  
a raise  instruction or ret rying the enclosin g program unit.Page 417 .
Initially on page 
416.
The raise  instruc-
tions appeared in REAL_STACKS , the 
initial variant of STACKS , page 
1084 .
“The a posteriori 
scheme”, page 800.
§33.6   TASKS 1091
• The code for handling the error, action1 , is textually separate from the calls that may  
raise the error; 
• Error handling is the same for all such calls if more than one . 
On the first point, although it is desirable to avoid the deepl y nested if… then … else… 
error-handling structures cited at the beginning of this chapte r, the place in the algorithm  
where an error is detected is often the one that has the best i nformation to handle the error;  
and if you separate the two you may need to use complicated con trol structures for cases  
that require restarting or resuming processing.
On the second point, if a routin e contains more than one call t o remove , the way to  
deal with empty stacks will unli kely be the same in each case.
There are two general styles  of exception usage: the control structure style , which  
views exceptions as a normal mec hanism to handle all but the mo st common cases; and  
the abnormal case style , which reserves them for unpred ictable situations, when all ot her 
mechanisms have failed. The rescue/retry approach described earli er in this book tends  
to favor the abnormal case style, although it can be used for t he other style as well. Ada  
exception handling is m ore geared towards the control structure  style.
You will decide for yourself whic h of the two styles you prefer ; you should in any  
case remember, from this discussion and the earlier ones, not t o place any naïve hope in the  
use of exceptions. With or withou t an exception mechanism, run- time errors are a fact of  
system life, which the softwar e must handle explicitly. A good methodological approach,  
supported by an effective excepti on mechanism, can help; but so me of the complexity is  
inherent to the problem of erro r handling, and no magical wand will make it go away.
33.6  TASKS
Besides packages , Ada offers another int eresting modular constr uct: the task. Tasks are the  
basic Ada mechanism fo r handling con currency; the underlying co ncurrency model is  
close to the CSP approach describ ed in the concurrency chapter.  But they also deserve a  
mention purely for their modular concepts, since they actually come closer than packages  
to supporting object -oriented concepts. 
Syntactically, tasks share many aspects of packages. The main d ifference is that a  
task is not just a modular unit but the representation of a pro cess, to be executed in parallel  
with other processes. So besides making up a  syntactical unit i t also describes a semantic  
component — unlike a pac kage, and like a class.
L i k e  a  p a c k a g e ,  a  t a s k  i s  d e c l a r e d  i n  t w o  p a r t s ,  i n t e r f a c e  a n d  body. Instead of  
routines, a task specification in troduces a number of entries. To the client, entries look like  
procedures; for exampl e, the interface of a  buffer manager task  may be 
task BUFFER_MANAGER  is
entry  read (x: out G);
entry  write (x: in G);
end BUFFER_MANAGER ;See “Precondition 
design: tolerant or demanding?”, page 354 .
On CSP see “Com-
munication-based mechanisms”, page 979.
O-O PROGRAMMING AND ADA  §33.7 1092
(Tasks may not be ge neric, so that type G has to be globally available, or a generic  
parameter of an enclosing package.) It is only the implementati on of entries that  
distinguishes them from procedures: in the body, accept instructions will specify  
synchronization and other constra ints on execution of the entri es; here, for example, we  
might prescribe that only one read or write  may proceed at any point in time, that read
must wait until the buf fer is not empty, and write  until it is not full. 
Besides individual tasks you may also specify a task type , and use it to create as many  
tasks — instances of the task type — as you need at run time. T his makes tasks similar to  
classes, without inheritance. One can indeed conceive of an Ada  realization of O-O concepts  
which would represent classes by task types and objects by thei r instances (perhaps even  
using accept  instructions with different conditions to emulate dynamic bind ing). Because  
in sequential O-O computation we may expect classes to have man y instances, this exercise  
is mostly of academic interest, given the overhead of creating a new process in current  
operating systems. Perhaps some day, in massively parallel hard ware environments … 
33.7  FROM ADA TO ADA 95
The Ada 95 version of the languag e is a major revision intended  in particular to add O-O  
concepts. There is in fact no not ion of class in the sense of t his book (module cum type),  
but support for inheri tance and dynamic bind ing for record type s.
O-O mechanisms of Ada 95: an example
The package text at the top of the facing page illustrates some  of the Ada 95 techniques;  
its meaning should be clear eno ugh to a reader of this book. To  derive a new type with  
more fields (the Ada 95 form of inheritance), you must have dec lared a type, such as  
ACCOUNT , as tagged ; this of course contradicts the Open-Closed principle, since y ou 
must know in advance which types may have descendants and which  may not. A new type 
may be derived from only one type; that is to say, there is no multiple inheritance. Note the  
syntax ( null record , with, surprisingly, no end) for a derived type that adds no attribute. 
Tagged types remain declared as records. The basic property of most O-O languages  
— that operations on a type become part of that type, and in fa ct, as we saw in the  
discussion of abstract data types, define  the type — is not in force here: the routines that  
apply to a tagged type appear outside of its declaration, and t ake as argument a value of  
that type. (In languages generally recognized as object-oriente d, deposit  etc. would be part  
of the declaration of ACCOUNT  and compound part of SAVINGS_ACCOUNT ; they would  
not need their first arguments.) Here the only link between the  routines and the type is that  
they must be declared as part of the same package; they do not even have to appear next to  
each other. Only the layout conventions, in the above example, indicate to the reader that  
certain routines are conceptually  attached to certain tagged re cord types.
T h i s  i s  d i f f e r e n t  f r o m  t h e  u s u a l  v i e w  o f  O - O  s o f t w a r e  c o n s t r u c t ion. Although a  
tagged record type and  the associated routin es are, from a theo retical perspective, part of  
the same abstract data type, they do not form a syntactical uni t — contradicting the  
Linguistic Modular Units princip le, which suggested a close ass ociation between the  
modularizing concept and th e syntactical structure.“Linguistic Modular
Units”, page 53 .
§33.7   FROM ADA TO ADA 95 1093
package Accounts  is
type MONEY  is digits 12 delta 0.01;
type ACCOUNT is tagged private ;
procedure  deposit (a: in out ACCOUNT ; amount : in MONEY );
procedure  withdraw (a: in out ACCOUNT ; amount : in MONEY );
function  balance (a: in ACCOUNT ) return MONEY ;
type CHECKING_ACCOUNT is new ACCOUNT with  private ;
function  balance (a: in CHECKING_ACCOUNT ) return MONEY ;
type SAVINGS_ACCOUNT is new ACCOUNT with  private ;
procedure  compound (a: in out SAVINGS_ACCOUNT ; period : in Positive );
private
type ACCOUNT is tagged
record
initial_balance : MONEY  := 0.0;
owner : String (1. .30);
end record ;
type CHECKING_ACCOUNT is new ACCOUNT with null record ;
type SAVINGS_ACCOUNT is new ACCOUNT with
record
rate: Float ;
end record ;
end Accounts ;
The appearance of a new declaration for balance  for SAVINGS_ACCOUNT  signals  
a redefinition. Procedures withdraw  and deposit  are not redefined. As you will have  
recognized, this means that Ada 95 uses the overloading  mechanism to obtain the O-O  
effect of routine redefinition . There is no syntactical mark (such as redefine ) to signal a  
routine redefinition: to find out that function balance differs for SAVINGS_ACCOUNT  
from its base version in ACCOUNT , you must scan the text of the entire package. Here, of  
course, each routine version appears next to the corresponding type, with indentation to  
highlight the relationship, but this is a style convention, not  a language rule.
A tagged type can be declared as abstract , corresponding to the  notion of deferred  
class; you may make a routine abstract  too instead of giving it a body.
A function returning a result of  an abstract type must be abstr act itself. This rule may  
seem strange at first, appearing to preclude writing an effecti ve function retu rning, say, the  
top of a stack of figures, assuming FIGURE  is abstract. In Ada, however, the result of such  
a function will typi cally be not of type FIGURE but of an “access type” describing  
references to instances of FIGURE . Then the function can be effective.
You can apply dynamic binding to  entities of a tagged type, as in:An Ada 95 
package
The package may be 
better split off into three , with “child 
packages” for checking and sav-ings accounts . See 
next page .
“OVERLOADING 
AND GENERIC-ITY”, 4.8, page 93 .
O-O PROGRAMMING AND ADA  §33.7 1094
procedure  print_balance (a: in ACCOUNT   'Class ) is
-- Print current balance.
begin
Put (balance (a));
New_Line ;
 end print_balance ;
You must request the dynamic bin ding explicitly by declaring th e routine as a  
“classwide operation”, as represented by the 'Class  qualification to the t ype of its argument;  
this is similar to the C++ obl igation to declare any dynamicall y bound function as “virtual”,  
except that here it is  the client that must choose between stat ic and dynamic binding.
Ada 95 allows you to define a “child package” A  B of an existing package A. This  
enables the new package to obtain features from A and add its own extensions and  
modifications. (This concept is o f course close to inheritance — but distinct.) Instead of  
declaring the three account type s in a single package as on the  preceding page, it is indeed  
probably better to split the package into three, with Accounts   Checking introducing  
CHECKING_ACCOUNT  and its routines, and Accounts   Saving  doing the same for  
SAVINGS_ACCOUNT .
Ada 95 and object technology: an assessment
If you come to Ada 95 from a bac kground in object technology, y ou will probably find the  
language befuddling at first. Aft er a while, you should be able  t o  m a s t e r  t h e  v a r i o u s  
language mechanisms enabling you  t o  o b t a i n  t h e  e f f e c t s  o f  s i n g l e inheritance,  
polymorphism and dynamic binding.
The price to pay , however, is complexity . T o Ada 83, a sophisti cated construction,  
Ada 95 has added a whole new set of constructs with many potent ial interactions both  
between themselves and with the old constructs. If you come fro m the O-O side and are  
used to the pristine simplicity  of the notion of class, you wil l find that you have to learn  
the intricacies of at least five  concepts, each covering some o f the aspects of classes:
• Packages, which are modules but not types, can be generic, and  offer something  
resembling inheritance : child packages (as well as a number of other options not  
detailed above, such as  the possibility of declaring a child pa ckage as private ).
• Tagged record types, which are types but not modules, and have  a  f o r m  o f  
inheritance, although unlike classes they do not allow the synt actical inclusion of  
routines into a type declaration.
• Tasks, which are modul es but not types and  have no inheritance .
• Task types, which are modules a nd types, but cannot be generic  (although they can be  
included in generic packages) and have no inheritance.
• “Protected types” (a notion we have not yet encountered), whic h are types and may
include routines, as in“The C++ 
approach to bind-ing”, page 513 .
§33.7   FROM ADA TO ADA 95 1095
protected type  ANOTHER_ACCOUNT_TYPE  is
procedure deposit (amount : in MONEY );
function  balance  return MONEY ;
private
deposit_list : …; …
end ANOTHER_ACCOUNT_TYPE ;
making them at first similar to classes — but with no inheritan ce.
The combination of interacting p ossibilities is mind-boggling. Packages, for  
example, still have, in addition  to the notion of child package , the Ada mechanisms of use
and with , with explanations s uch as this one from  a tutorial text:
Private children are intended for “i nternal” packages th at should only be  
“with'ed” by a restrict ed number of packages . A private child can only be  
“with'ed” by the body of its parent or by descendants of the private child's  
parent . In exchange for such a restrictive requirement , a private child gets a  
new authority : a private child's specification au tomatically sees both the public  
and private parts of all of its ancestors' specifications .
No doubt it is possible to make sense of such explanations. But  is the result worth  
the trouble? 
It is interesting to note that Jean Ichbiah, the creator of Ada , resigned publicly from the  
Ada 95 reviewing group after trying in vain for several years t o keep the extensions  
simple. His long resignation letter includes comments such as: A massive increase in  
complexity will result from 9X [later renamed Ada 95]  adding one or more additional  
possibilities where Ada now offers two . For example , 9X adds : […] access parameters ,
to in, out, and in out; tagged types , to normal types ; dispatched subprogram calls , to 
normal subprogram calls ; use type clause , to use package clauses ; [Other examples  
skipped; overall 12 were included.] With 9X , the number of interactions to consider is  
close to 60 ,000 since we have 3 or more possibilities in each case (that is , 310 ). 
The basic concepts of object tec hnology, for all their power, a re strikingly simple.  
Ada 95 may be the most ambitious  effort so far to make them app ear complicated.
Discussion: module and type inheritance
As a side observation following from this study of Ada 95, it i s interesting to note that the  
Ada 95 design has found it necessary, along with the “inheritan ce” mechanism for tagged  
record types, to introduce the notion of child package. Ada, of  course, has always kept  
module and type concepts separate, whereas classes are both. Bu t then Ada 95  
methodologists will suggest that when you introduce a descendan t type such as  
SAVINGS_ACCOUNT  you should declare it, for clarity and modularity, not in the original  
package ( Accounts ) but in a child package. If you generalize this advice, you wi ll end up  
creating, along with the type hie rarchy, a module hierarchy whi ch follows it faithfully.From  
[Wheeler-Web].
O-O PROGRAMMING AND ADA  §33.7 1096
With the classes of object tech nology, such questions do not ar ise; classes being  
modules, there is by construction only one hierarchy.
The choices of Ada 95 show yet a nother example of the popular v iew that “ one 
should separate type inhe ritance from code reuse ”. Instead the insight of object  
technology since Si m u l a  h a s  b e e n  t o  unify  concepts: module and type, subtyping and  
module extension. Like  any other bold unification of notions th eretofore considered  
completely distinct, this idea c an be scary at times, hence the  attempts to reintroduce the  
distinction. But they would deprive us of the remarkable simpli fication that O-O ideas  
have brought to the understanding of software architecture.
Towards an O-O Ada
That Ada 95 seems hard to teach and to manage does not mean the  idea of making Ada  
more O-O is doomed; one should s imply set reasonable goals and keep a constant concern  
for simplicity and consistency. The Ada community might try aga in to develop an object-
oriented extension, wh ich should be accompan ied by the removal of a few facilities to  
keep the language size  palatable. Two genera l directions are po ssible:
• The first idea, close in spirit to what the design of Ada 95 h as attempted to achieve,  
is to keep the package structure  and introduce a notion of clas s that would generalize  
Ada’s record types, with support for inheritance and dynamic bi nding. But these  
should be true classes, including  the applicable routines. Such  an extension would be  
similar in principle to that which led from C to C++. It should  strive for minimalism,  
trying to reuse as much as possi ble of the existing mechanisms (such as with  and use
for packages), rather than intro ducing new facilities which wou ld then cause the  
interaction problems mentioned by Ichbiah.
•The other approach wou ld build on an observation made in the pr esentation of tasks  
earlier in this chapter. It was noted then that task types are close in spirit to classes,  
since they may have instances created at run time; but structur ally they have most of  
the properties of packages (visi bility and information hiding r ules, separate  
compilation). This suggests addi ng a modular unit that, roughly , has the syntax of  
packages and the semantics of cla sses; think of it as a package -class, or as a task type  
that does not need to be concurr ent. The notion of “protected t ype” may be a starting  
point; but of course, it should be integrate d into the existing  mechanism.
Exercises at the end of this chapter ask you (if, like many sof tware people , you like  
dabbling in language design exper iments, if only to gain a bett er understanding of existing  
languages and, through them, of software is sues) to explore the se possibilities further.“ONE MECHA-
NISM, OR MORE?”, 24.6, page 833 ; “The two 
styles”, page 608 .
A thesis by Mats 
Weber explores the idea of package types. See the link in www.adahome.com/Resources/Research/Research.html.
Exercises 33.4 and 
E33.5, page 1098 .
§33.8   KEY CONCEPTS INTRODUCED IN THIS CHAPTER 1097
33.8  KEY CONCEPTS INTRODUCED IN THIS CHAPTER 
• Ada, studied as a representativ e of the class of “encapsulatio n languages” which also  
includes Modula-2, off ers modular decomposit ion constructs: pac kages (and tasks). 
• The emphasis is on information hiding: interface and implement ation are  
declared separately. 
• Genericity increases the flexibility of packages. 
• Conflicts between methodologica l requirements and language imp lementation  
concerns give rise to the “private” section, a conceptually sec ret element that is  
syntactically include d in the interface.. 
• The package is a pure ly syntactic mechanism. Modules remain di stinct from types.  
No inheritance mechanism is possible. 
• Exceptions separate error detec tion from error handling, but p rovide no magic  
solution to the proble m of run-time errors. 
• The Ada exception mechanism shou ld only be used in a disciplin ed fashion; any  
execution of an exception handler  should terminate by either re trying the operation  
or signaling  failure to the caller. 
• Task types could in principle b e used to implement classes wit hout inheritance, but  
this solution is not practical i n most current e nvironments. 
• Ada 95 enables the definition o f a new record type as being de rived from an existing  
type, with support for r outine redefinition , polymorphism and d ynamic binding.
33.9  BIBLIOGRAPHICAL NOTES 
[Booch 1986a]  discusses (under the label “object-oriente d design”, but not u sing classes,  
inheritance, polymorphism etc.) how to obtain some of the benef its of object orientation  
in Ada.
The official reference on Ada is [ANSI 1983] , recommended neither as bedtime  
reading nor as introductory mate rial. Numerous books are availa ble to fulfill the latter need. 
References on the othe r modular languages mentioned at the begi nning of this  
chapter are [Mitchell 1979]  for Mesa, [Wirth 1982]  for Modula-2, and [Liskov 1981]  for 
C L U .  S e e  a l s o  [Liskov 1986]  on programming methodology, based on CLU. The  
reference on Alphard is [Shaw 1981] .
The Ada 95 reference manual is available on-line at [Ada 95-Web] . [Wheeler-Web] 
is an on-line tutorial (prelude to an announced book). For a co mmented list of Ada 95  
textbooks, see [Feldman-Web] .  I  a m  g r e a t l y  i n d e b t e d  t o  Richard Riehle and Magnus  
Kempe for clarifying a number of  points about Ada 95; the views  expressed are as usual  
my own. Magnus Kempe is the so urce of the reference to Mats Weber’s thesis.
O-O PROGRAMMING AND ADA  §E33.1 1098
EXERCISES
E33.1  Winning the battle without privates
The Ada compilation problem that gives rise to the private  construct might appear to  
affect object-oriented languages  as well if the underlying envi ronment supports separate  
compilation of classes. In fact, the problem seems to be worse because of inheritance: a  
variable declared of type C may at run time refer t o instances not only of C but of any  
descendant class; since any desc e n d a n t  m a y  a d d  i t s  o w n  a t t r i b u t es, the size of these  
instances is variable. If C is a deferred class, it is not even possible to assign a defau lt size  
to its instances. Explain why, in spite of these remarks, the o bject-oriented no tation of this  
book does not need a languag e construct similar to the private  mechanism of Ada. ( Hint : 
your discussion should consider i n particular the following not ions: expanded vs. 
reference types; deferred classe s; and the techniques used in o ur O-O framework to  
produce abstract class specificat ions without req uiring class a uthors to write two separate  
module separate parts.) Discuss the tradeoffs involved in both solutions. Can you suggest  
other approaches to the prob lem in the Ada framework? 
E33.2  Generic routine parameters
Generic parameters to Ada packages may be not just types but al so routines. Explain the  
relevance of this possibility to  the implementation of object-o riented concepts, and its  
limitations. (See also appendix B.) 
E33.3  Classes as tasks (for Ada programmers)
Rewrite class COMPLEX  as an Ada task type. Show examp les using the resulting type.
E33.4  Adding classes to Ada 
(This language design exercise a ssumes a good knowledge of Ada 83.) Devise an  
adaptation of Ada (83) that keep s the notion of package but ext ends records to classes with  
polymorphism, dynamic binding an d inheritance (single or multip le?), in line with general  
O-O principles.
E33.5  Package-classes
(This language design exercise assumes a good knowledge of Ada 83.) Using task types  
as inspiration, devise an adapta tion of Ada (83) supporting pac kages that can be  
instantiated at run time and henc e can play the role of classes , with polymorphism,  
dynamic binding and inheritance.“HIDING THE REP-
RESENTATION: THE PRIVATE STORY”, 33.4, page 1085 .
“Legitimate side 
effects: an exam-ple”, page 759 .
34  
Emulating object technology in 
non-O-O environments
F ortran, Cobol, Pascal, C, Basic, PL/I and even assembly languag e still account for a  
large part of the software being written or updated today. Clea rly, a project using one of  
these languages will not be able to draw the full benefits of o bject technology, as this would  
require a notation such as the one we have studied in this book , and the supporting  
compiler, environment and libraries. But people who are require d to use pre-O-O tools,  
often because of non-technical constraints, can still gain insp iration from object technology  
and use some of its concepts to improve the quality of their so ftware development.
This chapter presents the techniques of object emulation  t ha t  m ay  en ab le  yo u t o  
approximate some of ob ject technology. It will particularly exa mine the case of Fortran,  
Pascal and C. (Ada and other enc apsulation langua ges were discu ssed in the preceding  
chapter; the following one covers O-O languages such as Simula,  Smalltalk, Objective-C,  
C++ and Java.) This presentation will be directly applicable if  you must use one of these  
languages. But it extends further:
• If you use another non -O-O language not on this list, such as Basic or Cobol, you  
should not have too much trouble transposing the concepts.
• Even if you are able to use an O-O language, the following dis cussion can give you  
a better grasp of the innovations of object technology and of t he supporting  
implementation techniques (which  often make use, internally, of  older languages).
34.1  LEVELS OF LANGUAGE SUPPORT 
In assessing how programming lan guages succeed in supporting ob ject-oriented concepts,  
we may distinguish three broad categories (ignoring the lowest level, mostly containing  
assembly languages, which does no t even support a  routine const ruct):
•T h e  functional level comprises languages whose unit of decomposition is the routine , 
a functional abstraction capturi ng a processing st ep. Data abst raction is handled, if at  
all, through definitions  of data structures, either local to a routine or global.
• Languages at the encapsulation  level provide a way to group a set of routines and  
data declarations in a syn tactical unit, called a module  or package ; typically each unit  
can be compiled separately. This  was discussed i n some detail f or Ada.
EMULATING OBJECT TECHNOLOGY IN NON-O-O ENVIRONMENTS   §34.2 1100
• Then we find object-oriented  languages. This is not the p lace to be fussy about what  
exactly it takes to deserve this label — chapter 2 defined a set of criteria, and of  
course all of part C was devoted to analyzing O-O mechanisms in detail —, but we  
should at the very leas t expect some suppo rt for clas ses, inher itance, polymorphism  
and dynamic binding.
For the second category, encapsulation languages, which support s a data  
abstraction mechanism but no classes, inheritance, polymorphism  or dynamic  
binding, you will find that the literature commonly uses the te rm object-
based , introduced in an article by Pe ter Wegner. Because the English  words  
based  and oriented  do not readily evoke the con ceptual difference between  
encapsulation techniques and O-O languages, “object-based” is a  little hard to  
justify, especially to newcomer s. Although either terminology i s acceptable  
once you have defined the conventions, I have in the end decide d to stick here  
to the phrases “encapsulation languages” and “object-oriented l anguages”,  
which more clearly conjure up the conceptual difference.
While we are on the subject of t erminology: the t erm “functiona l language” is  
ambiguous since other parts of the literature apply it to a cla ss of languages, based on  
mathematical principles and ofte n deriving directly or indirect ly from Lisp, which use  
side-effect-free functions instea d of imperative constructs suc h as procedures and  
assignments. To avoid any confusion, the present book always us es the term applicative
to denote this progra mming style. The word function in our use of “functional language”  
is to be contrasted with object , not (as when “functional” is a synonym for “applicative”)  
with procedure .  ( T o  m a k e  a  c o n f u s i n g  s i t u a t i o n  w o r s e ,  i t  i s  q u i t e  c o m m o n  t o  s ee 
“procedural” taken to mean “not object-oriented”! There is, how ever, no basis for such  
terminology; “procedura l” normally means “imperative”, as oppos ed to applicative; all  
the common O-O languages, includi ng the notation of this book, are quite procedural.)
A general comment on O-O emulation. In its most basic form, obj ect technology is  
“programming with abstract data types”. You can apply a rudimen tary form of the ideas,  
even at the func tional level, by defining a set of strict metho dological guidelines requiring  
every data access to go through routines. This a ssumes that you  start from an object-
oriented design  that has defined ADTs and their  features; then you will write a set of  
routines representing these features — put, remove , item, empty  in our standard stack  
example — and require all client  modules to go through these ro utines. This is a far cry  
from object technology proper, an d can only work under the assu mption that everyone in  
the team behaves; but, if you la ck any kind of l anguage support , it can be a start. We will  
call this technique the disciplinary approach .
34.2  OBJECT-ORIENTED PROGRAMMING IN PASCAL?
Pascal, introduced in 1970 by Nik laus Wirth, has been for many years the dominant  
language for teaching introductory  programming in computing sci ence departments, and  
has influenced many of the subsequent language designs. Pascal is definitely a functional  
language in the se nse just defined.See [Wegner 1987].
§34.2   OBJECT-ORIENTED PROGRAMMING IN PASCAL? 1101
Pascal proper
How much of the object-oriented approach can you implement in P ascal?
Not much. The Pascal program str ucture is based on a completely  different  
paradigm. A Pascal program consi sts of a sequence of paragraphs , appearing in an  
immutable order: labels, constan ts, types, variables, routines (procedures and functions),  
and executable instruct ions. The routines themselves have the s ame structure, recursively. 
This simple rule facilitates one -pass compilation. But it dooms  any attempt at using  
O-O techniques. Conside r  w h a t  i t  t a k e s  t o  i m p l e m e n t  a n  A D T ,  s u c h as the standard  
example of stacks represented by arrays: a few constants such a s the array size, one or a  
few types such as the record typ e describing the stack implemen tation, a few variables  
such as the pointer to the stack  top, and a few routines repres enting the operations on the  
abstract data type. In Pascal, t hese elements wi ll be scattered  all over the program: all the  
constants for various abstract data types together, all the typ es together and so on. 
The resulting program s tructure is the opposite of O-O designs.  Using Pascal would  
contradict the Linguistic Modula r Units principle, which expres ses that any modular  
policy you choose must be suppor ted by the available language c onstructs, for fear of  
damaging composability, decompos ability and other modularity re quirements. 
So if we take Pascal as defined by its official standard, there  is little we can do to  
apply O-O techniques this language beyond what was called the d isciplinary approach  
above: imposing a strict methodol ogical rule for data accesses.
Modular extensions of Pascal
Beyond standard Pascal, many comme rcially availabl e versions re move the restrictions on  
the order of declarations and inc lude support for some form of module beyond the routine,  
including separate com pilation. Such modules may contain more t han one routine,  
together with associated constant s, types and routines. The res ulting languages and  
products, more flexible and power ful than Pascal,  are Pascal on ly by name; they are not  
standardized, and in fact resemb le more an encapsulation langua ge such as Modula-2 or  
Ada, to which the applicable dis cussion is that of the precedin g chapter.
Object-oriented extensions of Pascal
Over the years a number of compa nies have offere d object-orient ed extensions of Pascal,  
loosely known as “Object Pascal” . Two are particularly signific ant:
• Apple’s version, originating fr om a language originally called  Clascal  and used for  
some of the software i n Apple’s Macintosh and its Lisa predeces sor.
• Borland’s version of Pascal, most recently adapted as the prog ramming language for  
Borland’s Delphi  environment.
The preceding discussion does not really apply to such language s since — even  
more than with the modular extensions — their connection to the  o r i g i n a l  P a s c a l  i s  
essentially their name, syntactic  style, and statically typed a pproach. Borland Pascal, in  
particular, is an O-O language with exception handling. It does  not, however, support any  
of the mechanisms of genericity , assertions, garbage collection  and multiple inheritance.“Linguistic Modular 
Units”, page 53 .
EMULATING OBJECT TECHNOLOGY IN NON-O-O ENVIRONMENTS   §34.3 1102
34.3  FORTRAN
FORTRAN should virtually elim inate coding and debugging
FORTRAN Preliminary Report , IBM, November 1954
The oldest surviving programming language, Fortran remains wide ly used for scientific  
computation. Shockingly perhaps for people who went on from it to such “structured”  
languages as Pascal, you can in fact get a little more O-O fril ls in Fortran, although this is  
partly thanks to facilities that may be considered low-level an d were intended for other goals.
Some context
Fortran was initially designed, as a tool for programming the I BM 704, by an IBM team under  
John Backus (later also instrumen tal in the description of Algo l), with a first general release  
in 1957. Fortran II followed, int roducing subroutines. Fortran IV solidified the language in  
1966 (Fortran III, 704-specific, was not widely distributed), a nd was standardized by ANSI.  
The next revision process led to Fortran 77, actually approved in 1978, with better control  
structures and some simplificati ons. An even longer revision yi elded Fortran 90 and Fortran  
95, which have been diversely me t and have not q uite replaced t heir predecessors.
For most people with a computing  science degree earned after th e First World War,  
Fortran is old hat, and they wou ld rather be cau ght reading the  Intel 4044 User’s Manual  
than admit they kno w anything about FORMAT  and arithmetic IF instructions. In reality,  
however, quite a few programmed in Fortran at some stage, and m any other people who  
are programmers by any objective criterion,  even if their busin ess card reads “theoretical  
physicist”, “applied mathematici an”, “mechanical engineer” or e ven, in a few cases,  
“securities analyst”, u se Fortran as their primary tool day in and day out. Fortran remains  
in common use not only for maintaining old software but even fo r starting new projects.
To the outsider it sometimes seem s that scientific programming — the world of  
Fortran — has remained aloof fro m much of the evolution in soft ware enginee ring. This  
is partly true, partly not. The low level of the language, and the peculiar nature of scientific  
computing (software pr oduced by people who,  although scientists  by training, often lack  
formal software education), have  resulted in some software of l ess than pristine quality.  
B u t  s o m e  o f  t h e  b e s t  a n d  m o s t  r o b u s t  s o f t w a r e  a l s o  c o m e s  f r o m  t hat field, including  
advanced simulations of extremel y complex proces ses and stagger ing tools for scientific  
visualization. Such products are  no longer limit ed to delicate but small numerical  
algorithms; like their counterpa rts in other application areas,  they often manipulate  
complex data structures, rely on  database technology, include e xtensive use r interface  
components. And, surprising as i t may seem, they  are still ofte n written in Fortran.
The COMMON  technique
A Fortran system is made of a ma in program and a number of rout ines (subroutines or  
functions). How can we provide a semblance of data abstraction?
The usual technique is  to represent the da ta through a so-calle d COMMON  block, a  
Fortran mechanism for making dat a accessible to any routine tha t cares to want it, and to  
implement each of the associat ed exported features (such as put etc. for stacks) through a  
separate routine. Here for example is a sketch of a put routine for a stack of real numbers:Cited in [Wexelblat 
1981].
The official name is 
FORTRAN, althoughthe less obtrusive form is commonly used too.
§34.3   FORTRAN 1103
SUBROUTINE RPUT (X)
REAL X
C
C PUSH X ON TOP OF REAL STACK
C
COMMON /STREP / TOP , STACK (2000 )
INTEGER TOP
REAL STACK
C
TOP = TOP + 1
STACK (TOP) = X
RETURN
END
This version does not have any o verflow control; clearly it sho uld be updated to test  
for TOP going over the array size. (The  next version will correct this .) The function to  
return the top element is
INTEGER FUNCTION RITEM
C
C  TOP ELEMENT OF REAL STACK
C
COMMON /STREP / TOP , STACK (2000 )
INTEGER TOP
REAL STACK
RITEM = STACK (TOP)
RETURN
END
which would similarly need to test for underflow (empty stack).  REMOVE  a n d  o t h e r  
features will follow the same pa ttern. What unites the differen t routines, making sure that  
they access the same data, is si mply the name of the common blo ck, STREP . (It is in fact  
possible, in different routines, to pretend that the same commo n block contains data of  
different types and sizes if the  total memory occupied somehow coincides, although in a  
family-oriented book like this o ne it is probably preferable to  avoid going into details that  
might not be entirely suitable for the younger members of the a udience).
The limitations are obvious: this implementation describes one abstract object  (one 
particular stack of reals), not an abstract data type of which the software can create  
arbitrarily many instances at run time, as with a class. The Fo rtran world is very static: you  
must dimension all the arrays (he re to 2000, a number picked ar bitrarily). Because there  
is no genericity, you should in principle declare a new set of routines for each type of  
stack; hence the names RPUT and RITEM , where the R stands for Real. One can work  
around some of th ese problems, but not wit hout considerable eff ort.A C at the first 
position on a line introduces a comment .
EMULATING OBJECT TECHNOLOGY IN NON-O-O ENVIRONMENTS   §34.3 1104
The multiple-entry subroutine technique
The COMMON -based technique, as you will ha ve noted, violates the Linguist ic Modular  
Units principle. In a system’s m odular structure, the routines are physically independent  
although conceptually related. Yo u can all too easily update on e and forget the others.
It is in fact possible to improve on this situation (without re moving some of the other  
limitations just listed) through a language trait legalized by Fortran 77: multiple entry  
points to a single routine.
This extension — which was proba bly introduced for different pu rposes, but may be  
redeemed for the “good cause” — enables Fortran routines to hav e entry points other than  
the normal routine header. Client  r o u t i n e s  m a y  c a l l  t h e s e  e n t r y  p o i n t s  a s  i f  t h e y  w e r e  
autonomous routines, an d the various entries may indeed have di fferent arguments.  
Calling an entry will start exec ution of the routine at the ent ry point. All entries of a routine  
share the persistent data of the routine; a persistent data ite m, which in Fortran 77 must  
appear in a SAVE  directive, is one whose value is  retained from one activation of a routine  
to the next. W ell, you see where we are driving: we can use thi s technique to define a  
module that encapsulates an abst r a c t  o b j e c t ,  a l m o s t  a s  w e  w o u l d  i n  o n e  o f  t h e  
encapsulation lan guages. In Ada, for example, we could write a package with a data  
structure declaration,  such as a stack representation, and a se t of routines that manipulate  
these data. Here we will simulate the package with a subroutine , the data structure with a  
set of declarations that we make persistent through a SAVE , and each Ada routine (each  
feature of the corresp onding class in an O- O language) with an entry. Each such entry must  
be followed by the corresp onding instruct ions and a RETURN :
ENTRY (arguments )
… Instructions …
RETURN
so that the various entry-delimi ted blocks are disjoint: contro l never flows from one block  
to the next. This is a restricted use of entry points, which in  general are meant to allow  
entering a routine at any point  and then continui ng in sequence . Also note that clients will  
never call the enclosing subrouti ne under its own name; they wi ll only call the entries.
The main difference with the preceding COMMON -based solution is that all the  
features of the underl ying abstract data typ e now appear in the  same syntactical unit. The  
second part of the facing page shows an example implementing an  abstract object (stack  
of reals). The calls from a c lient will look like this:
LOGICAL OK
REAL X
C
OK = MAKE ()
OK = PUT (4.5)
OK = PUT (–7.88)
X = ITEM ()
OK = REMOVE ()
IF (EMPTY ()) A = B
§34.3   FORTRAN 1105
Look at this text for just a second, from a distance; you could  almost believe that it is  
the use of a class, or at least of an objec t, through its abstr act, officially def ined interface! 
A Fortran routine and its entry points must be either all subro utines, or all functions. Here  
since EMPTY  and ITEM  must be functions, all other entries are also declared as func tions,  
including MAKE  whose result is  useless.
C -- IMPLEMENTATION OF ONE
C -- ABSTRACT STACK OF REALS
C
 INTEGER FUNCTION RSTACK ()
P ARAMETER (SIZE =1000 )
C
C -- REPRESENTATION
C
REAL IMPL (SIZE )
INTEGER LAST
SAVE IMPL , LAST
C
C -- ENTRY POINT DECLARATIONS
C
LOGICAL MAKE
LOGICAL PUT
LOGICAL REMOVE
REAL ITEM
LOGICAL EMPTY
C
REAL X 
C
C -- STACK CREATION
C
ENTRY MAKE ()
MAKE = .TRUE .
LAST = 0
RETURN 
C
C -- PUSH AN ITEM
C
ENTRY PUT (X)
IF (LAST  .LT. SIZE ) THEN
PUT = .TRUE .
LAST = LAST + 1
IMPL (LAST ) = X
ELSE
PUT = .FA L S E .
END IF
RETURNC -- REMOVE TOP ITEM
C
ENTRY REMOVE (X)
IF (LAST  .NE. 0) THEN
REMOVE = .TRUE .
LAST = LAST – 1
ELSE
REMOVE = .FA L S E .
END IF
RETURN
C
C- -  T O P  I T E M
C
ENTRY ITEM ()
IF (LAST  .NE. 0) THEN
ITEM = IMPL (LAST )
ELSE
CALL ERROR
      ('ITEM : EMPTY STACK' )
END IF
RETURN
C
C -- IS STACK EMPTY?
C
ENTRY EMPTY ()
EMPTY = (LAST  .EQ. 0)
RETURN
C
END A stack module 
emulation in 
Fortran
EMULATING OBJECT TECHNOLOGY IN NON-O-O ENVIRONMENTS   §34.4 1106
This style of programmi ng can be applied successfully to emulat e the encapsulation  
techniques of Ada or M odula-2 in contexts where you have no cho ice but to use Fortran.  
It suffers of course from  stringent limitations: 
• No internal calls are permitted : whereas routines in an object -oriented class usually  
rely on each other for their impl ementations, an entry call iss ued by another entry of  
the same subroutine would be understood as an instance of recur sion — anathema to  
Fortran, and run-time disaster in many implementations.
• As noted, the mechanism is stric tly static, suppo rting only on e abstract object. It may  
be generalized to allow for a fi xed number of objects (by trans forming every variable  
into a one-dimensional array, and adding a dimension to every a rray). But there is no  
portable support for dynamic object creation. 
• In practice, it seems that some Fortran environments (two deca des after Fortran 77  
was published!) do not deal too w ell with multiple-entry subrou tines; in particular  
debuggers do not always know how t o keep track of multiple entr ies. Before  
applying this technique to a pr oduction development, check with  the local Fortran  
guru to find out whether it is w ise to rely on this facility in  your environment.
• Finally, the very idea of hijacking a language mechanism for p urposes other than its  
probable design objective raises  dangers of confusion and error s. 
34.4  OBJECT-ORIENTED PROGRAMMING AND C
Born in a log cabinet, C quickly  rose to prominence. Although m ost people interested in  
both C and object technology hav e focused on the O-O extensions  of C discussed in the  
next chapter (C++, Objective-C, Java), it remains interesting t o see how C itself can be  
made to emulate O-O concepts, if only to understand the techniq ues that have made C so  
useful as a stepping stone towar ds the implement ation of more a dvanced languages.
Some context
C was designed at AT&T’s Bell La boratories as a portable langua ge for writing operating  
systems. The first version of Un ix had used assembly language, but a portable version  
soon appeared necessary, and C w as designed around 1970 to make  it possible. It was  
derived from ideas found in BCPL, a language of the sixties whi ch, like C, can be  
mentioned in the same breath as “high-level”, “m achine-oriented ” and “portable”: high-
level thanks to contro l structures comparabl e  t o  t h o s e  o f  A l g o l  or Pascal; machine-
oriented because you can manipulate data at the most elementary  level, through addresses,  
pointers and bytes; portable bec ause the machine-oriented conce pts are so defined as to  
cover a wide variety  of computer types.
C ’ s  t i m i n g  c o u l d  n o t  h a v e  b e e n  b e t t e r .  I n  t h e  l a t e  s e v e n t i e s  U n ix became the  
operating system of choice for ma ny universities, and C spread with it. Then in the eighties  
the microcomputer revolution bur st out, and C was ready to serv e as its lingua franca  — 
more scalable than Bas ic, more flexible than Pascal. At the sam e time Unix also enjoyed  
some commercial success, and along with Unix still came C. In a  few years, a boutique  
product became the dominant langua ge in large segments of the c omputing industry,  
including much of where the action really was.
§34.4   OBJECT-ORIENTED PROGRAMMING AND C 1107
Anyone interested in the progres s of programming languages — ev en people who do  
not care too much for the language itself — has a political deb t to C, and sometimes a  
technical one as well:
• Politically, C ended the fossil ized situation that prevailed i n the programming  
language world until around 1980 . No one in industry wanted to hear (particularly  
after the commercial failure of A lgol) about anything else than  the sacred troika,  
Fortran for science, Cobol for business and PL/I for true blue shops. Outside of  
academic circles and a few R&D departments, any attempt at sugg esting other  
solutions was met with as much e nthusiasm as if it were a propo sal to introduce a  
third brand of Cola drink. C bro ke that mindset, making it acce ptable to think of the  
programming language as  something you choose from a reasonably broad and  
evolving catalog. (A few years later, C itself became so entren ched that in some  
circles the choices seemed to ha ve gone from three to one, but it is the fate of  
successful subversives  that they become the new Establishment.)
• Technically, the portability and  machine-closeness of C have m ade it an attractive  
solution as a target language of  compilers for higher-level lan guages. The first C++  
and Objective-C implementations used this approach, and compile rs for many other  
languages, often having no visibl e connection to C, have follow ed their example.  
The advantages for the compiler writers and their users are: po rtability, since you can  
have a single C-generating compi ler for your language and use C  compilers  
(available nowadays for almost any computer architecture) to ta ke care of platform  
dependencies; efficiency, since you can rely on the extensive o ptimization  
techniques that have been implem ented in good C compilers; and ease of integration  
with ubiquitous C-base d tools and components.
With time, the contradiction between the two views of C — high- level programming  
language, and portable assembly language — has become more acut e. Recent evolution  
of the ANSI standard for C (firs t published in 1 990, following the earlier version known  
as K&R  from the authors of the first C  book, Kernighan and Ritchie) h ave made the  
language more typed — and hence less convenient for its use as a compiler’s target code.  
It has even been announced that f orthcoming versions will have a notion of class,  
obscuring the separation from C++ and Java.
Although an O-O extension of C simpler than C++ and Java may be  desirable, one  
can wonder whether this evolutio n is the right one for C; a hyb rid C-based O-O language  
w i l l  a l w a y s  r e m a i n  a  s trange contraption, whereas the idea of a  s i m p l e ,  p o r t a b l e ,  
universally available, efficiently  compilable machine-oriented language, serving both as  
a target language for high-level  compilers and as a low-level t ool for writing very short  
routines to access operating sys tem and machine-dependent facil ities (that is to say, for  
doing the same thing that assembly language used to do for C, o nly at the next level)  
remains as useful as it ever was.[Kernighan 1978], 
[Kernighan 1988].
EMULATING OBJECT TECHNOLOGY IN NON-O-O ENVIRONMENTS   §34.4 1108
Basics 
As with any other language, you can apply to C the “disciplinar y” technique of restricted  
data access, requiring all uses of data structures to go throug h functions. (All routines in  
C are functions; proce dures are viewed as functions with a “voi d” result type.) 
Beyond this, the notion of file may serve to implement higher-l evel modules. Files  
are a C notion on the borderline  between the language and the o perating system. A file is  
a compilation unit; it may conta in a number of functions and so me data. Some of the  
functions may be hidden from othe r files, and some made public.  This achieves  
encapsulation: a file may contain all the elements pertaining t o the implementation of one  
or more abstract objects, or an abstract data ty pe. Thanks to t his notion of file, you can  
essentially reach the encapsulation  language level in C, as if you had Ada or Modula-2.  
As compared to Ada, however, you  will be missing genericity and  the distinction between  
specification and implementation parts. 
In practice, a commonly used C technique is rather averse to O- O principles. Most  
C programs use “header files”, which describe shared data struc tures. Any file needing the  
data structures will gain access to them through an “include” d irective (handled by the  
built-in C preproce ssor) of the form 
#include  <header . h>
where header .h is the name of the header file ( .h is the conventional suffix for such file  
names). This is concep tually equivalent to copying the whole he ader file at the point  
where the directive appears, and  allows the including file to a ccess directly the data  
structure definitions of the header file. As a result the C tra dition, if not the  language itself,  
encourages client modules to ac cess data structures through the ir physical representations,  
which clearly contradicts the p rinciples of information hiding and data abstraction. It is  
possible, however, to use header files in a more disciplined fa shion, enforcing rather than  
violating data abstraction; they can even help you go some way towards defining interface  
modules in the style w e studied for Ada in t he preceding chapte r.
Emulating objects 
Beyond the encapsulation level, one of the more specialized and  low-level features of C  
— the ability to manipulate point ers to functions — can be used  to emulate fairly closely  
some of the more advanced proper ties of a true O-O approach. Al though it is sufficiently  
delicate to suggest that its proper use is by compilers for hig her-level languages rather than  
C programmers, it does d eserve to be known.
In we take a superfici al look at the notion of object as it exi sts in object technology,  
we might say that “every object has access to the operations ap plicable to it”. This is a little  
naïve perhaps, but not altogethe r wrong conceptually. If, howev er, we take this view  
literally , we find that C directly supports the notion! It is p ossible for an instance of a  
“structure type” of C (the equivalent of record types in Pascal ) to contain, among its fields,  
pointers to functions.  
§34.4   OBJECT-ORIENTED PROGRAMMING AND C 1109
F o r  e x a m p l e ,  a  C  s t r u c t u r e  t y p e  REAL_STACK  may be declared by the type  
definition 
typedef struct 
{
/∗ Exported features ∗/
void (∗remove ) ();
void (∗put) ();
float  (∗item) ();
BOOL (*empty ) ();
/∗ Secret features (i mplementation) ∗/
int count ;
float  representation [MAXSIZE ];
}
REAL_STACK ;
The braces { } delimit the components of the structure type; float introduces real  
numbers; procedures are declared as functions with a void result type; comments are  
delimited by /∗ and ∗/. The other asterisks ∗ serve to de-reference pointers; the idea in  
the practice of C programming is that you add enough of them un til things seem to work,  
and if not you can always try a & or two. If this still does not succeed, you will usually  
find someone who knows what to do.
Here the last two components are an integer and an array; the o thers are references  
t o  f u n c t i o n s .  I n  t h e  d e c l a r a t i o n  a s  w r i t t e n ,  t h e  c o m m e n t s  a b o u t  e x p o r t e d  a n d  s e c r e t  
features apply to the emulated class, but e verything is in fact  available to clients.
Each instance of the type must be initialized so that the refer ence fields w ill point to  
appropriate functions . For example, if my_stack  is a variable of this type and C_remove is 
a stack popping function, you may assign to the remove field of the my_stack  object a  
reference to this function, as follows: 
my_stack    remove = C_remove
I n  t h e  c l a s s  b e i n g  e m u l a t e d ,  f e a t u r e  remove has no argument. To enable the
C_remove  function to access th e appropriate stack object, you must decl are it ascountC_remove (…)
{…}C_put (…)
{…}
C_item (…)
{…}C_empty (…)
{…}
representationput
remove
empty
itemCLASS
INSTANCE
1A C object with 
function references
EMULATING OBJECT TECHNOLOGY IN NON-O-O ENVIRONMENTS   §34.4 1110
C_remove (s)
REAL_STACK s ;
{
… Implementation of remove operation …
}
so that a client may apply remove to a stack my_stack  under the form 
my_stack    remove (my_stack )
More generally, a routine rout which would have n arguments in the class will yield  
a C function C_rout  with n+1 arguments. An object-oriented routine call of the form 
x   rout (arg1, arg2, …, argn)
will be emulated as 
x   C_rout (x, arg1, arg2, …, argn)
Emulating classes
The preceding technique will work  to a certain extent. It can e ven be extended to  
emulate inheritance.
But it is inapplicable to any se rious development: as illustrat ed in the figure of the  
preceding page, it implies that every instance  of every class physically contains  
references to all the routines a pplicable to it. The space over head would be prohibitive,  
especially with inheritance. 
To bring this overhead down to an  acceptable level, notice that  the routines are the  
s a m e f or  a l l i ns t an ce s o f  a cl as s.  So we m ay  i nt ro du ce  f or  ea c h  c la s s a  r un -t im e d at a  
structure, the class descriptor , containing references to the routines; we can implement it  
as a linked list or an array. The  space requirements decrease d ramatically: instead of one  
pointer per routine per object, w e can use one pointer per rout ine per class , plus one 
pointer per object  giving access to the class desc riptor, as shown by the figure at the top  
of the following page.
Timewise we pay the price of an indirection: as shown in the fi gure, you have to go  
through the descriptor to find th e function applicable to an ob ject. The space economy and  
the simplification seem well worth this penalty.
There is no secret about it: the technique just sketched is wha t has made C useful as  
an implementation vehicle for ob ject-oriented languages, starti ng with Objective-C and  
C++ in the early eighties. The a bility to use function pointers , combined with the idea of  
grouping these pointers in a clas s descriptor shared by an arbi trary number of instances,  
yields the first step towards implementing O-O  techniques. 
This is only a first step, of cou r s e ,  a n d  y o u  m u s t  s t i l l  f i n d  t echniques for  
implementing inheritance (multip le inheritance in particular is  not easy), genericity,  
exceptions, assertions and dynami c binding. To ex plain how this  can be done would take  
another book. Let us, however, n ote one important property, ded ucible from what we have  Exercise E34.3, page 
1112.
§34.4   OBJECT-ORIENTED PROGRAMMING AND C 1111
seen so far. Implementing dynami c binding, regar dless of the de tails, will re quire run-time  
access to the type of each object , to find the proper variant o f the feature f   in a dynamically  
bound call x    f (…) (written here in O-O notation). In other words: in addition to its official  
fields, defined explicitly by the  software develo per through ty pe declarations, each object  
will need to carry an extra internal field, generated by the co mpiler and accessible only to  
the run-time system, indicating the type of the object. Well, with the approach just  
defined, we already have a possi ble implementation of this type  field — as a pointer to the  
class descriptor. This is the r eason why the above figure uses the label type for such fields.
O-O C: an assessment 
This discussion has sh own that implementat ion techniques are av ailable in C to emulate  
object-oriented ideas. But it does not mean that programmers sh ould use these techniques.  
As with Fortran, the emulation d oes violence to the language. C ’s main strength is, as  
noted, its availability as a “str uctured assembly  language” (a successor to BCPL and  
Wirth’s PL/360), portable, reaso nably simple and efficiently in terpreted. Its basic concepts  
are very far from those of  object-oriented design.
The danger in trying to force an object-oriented peg into a C h ole is to get an  
inconsistent construction, impai ring the software development p rocess and the quality of  
the resulting pr oducts. Better use C for what it does well: sma ll interfaces to low-level  
hardware or operating system facilities, and machine-generated target code; then when the  
time comes to apply object tech nology we should use a tool desi gned for that purpose.countC_remove (…)
{…}C_put (…)
{…}
C_item (…)
{…}C_empty (…)
{…}
representationtype
count
representationtype
count
representationtypeCLASS
DESCRIPTORput
remove
empty
item
CLASS INSTANCESC objects 
sharing a class 
descriptor
EMULATING OBJECT TECHNOLOGY IN NON-O-O ENVIRONMENTS   §34.5 1112
34.5  BIBLIOGRAPHICAL NOTES
Techniques for writing Fortran p ackages based on the principles  of data abstraction are  
described in [M 1982a] .  T h e y  u s e  r o u t i n e s  s h a r i n g  COMMON  blocks, rather than  
multiple-entry routines. They go further in their  implementatio n of object-oriented  
concepts than the tec hniques described in th is chapter, thanks to the use of specific library  
mechanisms that provides the equ ivalent of dynamically allocate d class instances. Such  
mechanisms, however, require a significant investment, and will  have to be ported anew  
to each platform type.
I am indebted to Paul Dubois for pointing out that the multiple -entry Fortran  
technique, although definitely part of the standard, is not alw ays supported well by  
current compilers.
[Cox 1990]  (originally 1986) contains a di scussion of C techniques for th e 
implementation of obje ct-oriented concepts. 
The basic reference on the histo ry of classical programming lan guages is a  
conference proceedings [Wexelblat 1981] ; see [Knuth 1980]  for the earliest efforts.
EXERCISES
E34.1  Graphics objects (for Fortran programmers)
W r i t e  a  s e t  o f  F o r t r a n  m u l t i p l e - e n t r y  r o u t i n e s  t h a t  i m p l e m e n t  b asic graphics objects  
(points, circles, polygons). For  a  s p e c i f i c a t i o n  of the abstrac tions involved and the  
associated operations, you may r ely on the GKS graphics standar d. 
E34.2  Genericity (for C programmers)
How would you transform the C emulation of a “real stack” class  de cl a ra t io n i nt o an  
emulated generic declaration, eas y to adapt to stacks of any ty pe G rather than just float ? 
E34.3  Object-oriented programming in  C (term project) 
Design and implement a simple ob ject-oriented extension of C us ing the ideas of this  
chapter. You may write either a pre-processor, translating an e xtended version of the  
language into C, or a function pa ckage that does not change the  language itself. 
Approach the problem through three successive refinements: 
• I m p l e m e n t  f i r s t  a  m e c h a n i s m  a l l o w i n g  o b j e c t s  t o  c a r r y  t h e i r  o w n references to  
available routines. 
• Then see how to factor routine re ferences at the class level. 
• Finally, study how to add singl e inheritance to  the mechanism.  
35  
Simula to Java and beyond: major 
O-O languages and environments
E ncouraged by the intro duction of Simula in 1 967, a number of ob ject-oriented  
languages have appeared on the sc ene, highlighti ng various aspe cts of the approach. This  
chapter reviews some of the lang uages that have attracted the m ost attention: Simula;  
Smalltalk; C++ and other O -O extensions of C; Java.
The literature still lacks an in-depth comparative study of imp ortant O-O languages.  
The ambition of this chapter is of necessity more modest. In pa rticular, the space allotted  
to each language is not an indication of the language’s practic al significance, and some of  
the most publicized will indeed get a fairly short treatment. O ur goal is to learn about issues
and concepts , finding them where we can, even if that means turning our att ention for a  
while to one of the less hyped approaches. The risk of under-re presenting one of the  
principal players is not great, since one only has to look arou nd to pick up articles and books  
describing it in generous detail. The real risk would be the re verse: to miss a promising idea  
just because the language supporting it (say Simula) does not c urrently enjoy top favor. In  
its coverage of notable languages, then, this survey is not equ al-opportunity; it is instead,  
in its choice of notable langua ge traits, a case of affirmative  action.
Even when the concepts are the same or similar, the terms used to denote them in  
official language descriptions c an vary. The discussion will us e the native terms when they  
reflect language peculiarities; for simplicity and consistency,  however, it uses the  
terminology of the rest of this b o o k  ( d e s i g n e d  a s  a n  a t t e m p t  a t  unification) when  
differences are unimpor tant. For example you will read about Si mula routines, procedures  
and functions, althoug h the corresponding terms in official Sim ula usage are procedure,  
untyped procedure and typed procedure.
35.1  SIMULA
The undisputed founder of the Ho use of Classes (Object Palace) is Simula, whose design  
was completed (if we i gnore a few later upda tes, entirely minor ) in 1967. T his may seem  
hard to believe: a full-fledged object-oriented language was ar ound, and implemented,  
before  structured programming, before P arnas had published his articl es on information  
hiding, many years before anyone had come up with the phrase “a bstract data type”. The  
Vietnam War was still a page-4 i tem; barricades had not yet spr ung up in the streets of  
Paris; a mini-skirt could still cause a stir: away by the North ern shores of the Baltic a few  
SIMULA TO JA V A AND BEYOND:  MAJOR O-O LANGUAGES AND ENVIRONMENT S  §35.1 1114
fortunate software developers le d by a handful o f visionaries w ere already profiting from  
the power of classes, inheritance,  polymorphism, dynamic bindin g and most of the other  
marvels of objec t orientation.
Background
Simula is actually a second design. In the early sixties, a lan guage now known as Simula 1
was developed to support the pro gramming of discrete-event simu lations. Although not  
quite object-oriented in the full sense of the term, it already  showed some of the key  
insights. “Simula” proper is Sim ula 67, designed  in 1967 by Kri sten Nygaard and Ole-
Johan Dahl from the University o f Oslo and the Norwegian Comput ing Center (Norsk  
Regnesentral). Nygaard has expla ined since how t he decision to keep the name was meant  
to ensure continuity with the previous language and the link to  its user community; but an  
unfortunate effect was that for a long time that name evoked fo r many people the image  
of a language meant only for discrete-event simulation — a rela tively narrow application  
area — even though Simula 67 is definitely a general-purpose pr ogramming language,  
whose only simulation-specific f eatures are a handful of instru ctions and a SIMULATION  
library class, used by a minor ity of Simula developers.
The name was shortened to just S imula in 1986; the current stan dard is from 1987.
Availability
Simula is often presented as a respectable but defunct ancestor . In fact it is still alive and  
enjoys the support of a small but  enthusiastic community. The l anguage definition is  
maintained by the “Simula Standa rds Group”. Compilers are avail able for a variety of  
hardware and software environments from several companies, most ly Scandinavian.
Major language traits
We will take a general look at the basic properties of Simula. To some readers Simula will  
be passé, and the author of this  book will not feel insulted if  you skip to the next section,  
on Smalltalk. But if you do want  to gain a full appreciation of  object technology you will  
find Simula worth your time; the concepts are there in their or iginal form, and a few of  
them show possibilities that may  not yet, thirty years later, h ave been fully exploited.
Simula is an object-oriented ext ension of Algol 60. Most correc t Algol programs are  
also correct Simula programs. In particular, the basic control structures are those of Algol:  
loop, conditional, switch (a mult iple branch instruction, low-l evel precursor to Pascal’s  
case instruction). The basic data ty pes (integer, real etc.) are al so drawn from Algol.
Like Algol, Simula uses at the highest level a traditional soft ware structure based on  
the notion of main pr ogram. An executable program is a main pro gram containing a  
number of program units (routine s or classes). Simula environme nts do support, however,  
a form of separate class compilation.
Simula uses full block structure  in the Algol 60 style: program  units such as classes  
may be nested within one another.
§35.1   SIMULA 1115
All Simula implementations suppo rt automatic garbage collection . There is a small  
standard library, including in pa rticular two-way linked lists used by the SIMULATION  
class studied later in this chapter.
As in the notation of this book,  the most common entities of no n-basic types denote  
references to class instances, r a t h e r  t h a n  t h e  i n s t a n c e s  t h e m s e lves. Instead of being  
implicit, however, th is property is emphasi zed by the notation.  You will declare the type  
of such an entity as ref (C), rather than just C, for some class C; and the corresponding  
operations will use special symbols:  :– for an assignment where integer or real operands  
would use  :=; == rather than  = for equality;  =/= rather than /= for inequality. An earlier  
chapter presented the rationale for and agai nst this convention .
To create an instance, you will use, rather than a creation ins truction, a new expression:
ref (C) a; …; a :– new C
Evaluation of the new expression creates  an instance of C and returns a reference to  
it. A class may have arguments ( playing the role of the argumen ts to creation  procedures  
in our notation), as in
class C (x, y); integer  x, y
begin … end;
In this case, the new expression must pr ovide corresponding  actual arguments:
a :– new C (3, 98)
The arguments may then be used in routines of the class; but un like with creation  
instructions this gives only one initialization mechanism.
Besides routines and attributes, a class may contain a sequence  of instructions, the  
body  of the class; if so, the new call will execute these instructions. We will see how to  
use this possibility to make cla sses represents process-like co mputational elements rather  
than just passive objects as i n most other O-O languages.
No assertion mechanism is provid ed. Simula suppo rts single inhe ritance; to declare  
B as an heir of A, use
A class B;
begin … end
To redefine a feature of a class  in a descendant class, simply provide a new  
declaration; it will take preced ence over the original one. (Th ere is no equivalent to the  
redefine clause.)
The original version of Simula 6 7 did not have explicit informa tion hiding  
constructs. In more recent versions, a feature declared as protected  will be unavailable to  
clients; a protected feature w hich is further declared as hidden  will also be unavailable to  
proper descendants. A non-protect ed feature may be protected by  a proper descendant, but  
a protected feature may not be re -exported by pro per descendant s.
Deferred features are offered in  the form of “virtual routines” , appearing in a virtual
paragraph at the beginning of the class. It is not necessary to  declare the arguments of a  See “References and 
simple values”, page 272 .
SIMULA TO JA V A AND BEYOND:  MAJOR O-O LANGUAGES AND ENVIRONMENT S  §35.1 1116
virtual routine; this means that different effective definition s of a virtual routine may have  
different numbers and types of ar guments. For exa mple, a class POLYGON  might begin
class POLYGON ;
virtual : procedure  set_vertices
begin
…
end
allowing descendants to provide a variable number of arguments of type POINT  f o r 
set_vertices : three for TRIANGLE , four for QUADRANGLE  etc. This flexibility implies  
that some of the t ype checking must b e done at run time.
C++ users should beware of a possible confusion: although inspi red by Simula, C++ uses  
a different meaning for the word virtual . A C++ function is virtual if it is meant to be  
dynamically bound (it is, as we have seen, one of the most cont roversial aspects of C++  
that you must specify this requirement explicitly). The C++ app roximation to Simula’s  
virtual procedures is calle d a “pure virtual function”.
Simula supports polymorphism: if B is a descendant of A, the assignment a1 :– b1 is 
correct for a1 of type A and b1 of type B. (Interestingly enough , assignment attempt is  
almost  there: if the type of b1 is an ancestor of the type of a1, the assignment will work if  
the run-time objects have the pr oper conformance  relationship —  source descendant of  
target; if not, however, the result will be a run-time error, r ather than a special value which,  
as with assignment attempt, the software could detect and handl e.) By default, binding is  
static rather than dynamic, except for virtual routines. So if f is a non-virtual feature  
declared at the A level, a1  f will denote the A version of f even if there is a different version  
in B. You can force dynamic binding by using the qua construct, as in
(a1 qua B)  f
This, of course, loses the autom atic adaptation of every operat ion to its target. You  
may however obtain the  desired dynamic bindi ng behavior (which may largely be  
considered a Simula invention) b y declaring polymorphic routine s as virtual. In many of  
the examples that we have studied, a polymorphic routine was no t deferred but had a  
default implementation right fro m the start. To achieve the sam e effect, the Simula  
developer will add an intermedia te class where the routine is v irtual.
As an alternative to using qua, the inspect  instruction makes it possible to perform  
a different operation on an entity a1, depending on the actual type of the corresponding  
object, which must be a d escendant of the type A declared for a1:
inspect a1
when  A do …;
when  B do …;
…
This achieves the same effect bu t assumes that the set of desce ndants of a class is  
frozen, and runs into conflict with the Open-Closed principle“The C++ 
approach to bind-ing”, page 513 .
§35.1   SIMULA 1117
An example
The following class extracts illu strate the general flavor of S imula. They are drawn from  
the solution to the problem o f full-screen entry systems.
class STATE ;
virtual:
procedure  display ;
procedure  read ;
boolean procedure  correct ;
procedure  message ;
procedure  process ;
begin
ref (ANSWER ) user_answer ; integer  choice ;
procedure  execute ; begin
boolean  ok;
ok := false ;
while  not ok do begin
display ; read ; ok := correct ;
if not ok then message (a)
end while ;
process ;
end execute
end STATE ;
class APPLICATION (n, m);
integer  n, m;
begin
ref (STATE ) array  transition (1:n, 0:m–1);
ref (STATE ) array  associated_state (1:n);
integer  initial ;
procedure  execute ; begin
integer  st_number ;
st_number  := initial ;
while  st_number /= 0 do begin
ref (STATE ) st;
st := associated_state (st_number ); st  execute ;
st_number  := transition (st_number , st  choice )
end while
end execute
…
end APPLICATIONChapter 20 . Com-
pare with the final class texts in “AN OBJECT-ORI-ENTED ARCHI-TECTURE”, 20.5, page 684 .
The original STATE  
class appeared on page 686 .
The original APLI-
CATION class 
appeared on page 690.
SIMULA TO JA V A AND BEYOND:  MAJOR O-O LANGUAGES AND ENVIRONMENT S  §35.1 1118
Coroutine concepts
Along with basic O-O mechanisms,  Simula offers an interesting n otion: coroutines.
The notion of coroutine was pres ented in the discussion of conc urrency. Here is a  
brief reminder. Coroutines are m odeled after parallel processes  as they exist in operating  
systems or real-time software. A  process has more conceptual au tonomy than a routine; a  
printer driver, for example, is entirely responsible for what h appens to the printer it  
manages. Besides being in charge  of an abstract object, it has its own lifecycle algorithm,  
often conceptually in finite. The rough form of the printer proc ess could be something like
from some_initialization  loop forever
“Obtain a file to be printed”; “Print it”
end
In sequential programming, the relationship between program uni ts is asymmetric: a  
program unit calls another, which  will execute completely and r eturn to the caller at the  
point of call. Communication bet ween processes is more equal: e ach process pursues its  
own life, interrupting itself to  provide information to, or get  information from another. 
Coroutines are similarly designed, but for execution on a singl e thread of control.  
(This sequential emulation of parallel execution is called quasi-parallelism .) A coroutine  
that “resumes” another interrupts its own execution and restart s its colleague at its last  
point of interruption; the inter rupted coroutine  may itself be later resumed.
Coroutines are particularly usef ul when each of several related  activities has its own  
logic; each may be described as a sequential process, and the m aster-slave relationship  
implied by routines is not adequate. A frequent example is an i nput-to-output  
transformation in which different constraints are placed on the  structure of the input and  
output files. Such a case w ill be discussed below.
Simula represents coroutines as instances of classes. This is a ppropriate since  
coroutines almost always need pe rsistent data, and often have a n associated abstract  
object. As we noted earlie r, a Simula class has a body , made of one or m ore instructions.  
In a class representing a passiv e data abstraction, it will onl y serve as initialization of the  
class instances (the equivalent o f our creation p rocedure); but  in a coroutine it will be the  
description of a process. The bo dy of a coroutine is usually a loop of the form“Coroutines”, page 
1012 .
For a more complete 
description of a printer process see “Processes pro-grammed”, page 960 .
Coroutine 
sequencing
(This figure 
appeared originally on page 1012 .)resume  a resume  a
resume  b resume  ba
b
§35.1   SIMULA 1119
while continuation_condition  do begin
… Actions …;
resume  other_coroutine ;
…Actions …
end
For some of the corout ines in a system the continuation _condition  is often True to yield  
the equivalent of an infinite pr ocess (although at least one co routine should terminate).
A system based on coroutines generally has a main program that first creates a  
number of coroutine objects, an d then resumes one of them:
corout1  :– new C1; corout2  :– new C2; …
resume corouti
The evaluation of each new expression create s an object and starts executing its  
body . But the quasi-parallel nature of coroutines (as opposed t o the true parallelism of  
processes) raises an i nitialization pr oblem: with processes, ea ch new would spawn off a  
new process and return control to  the caller; but here only one  coroutine may be active at  
any given time. If the new expression started the corouti ne’s main algorithm, the above  
main thread would neve r recapture control; for example it would  never get a chance to  
create C2 after spawning off C1.
Simula addresses this problem through the detach  instruction. A coroutine may  
execute a detach to give control back to the un it that created it through a new. Coroutine  
bodies almost always be gin (after initializ ation instructions i f needed) with a detach , 
usually followed by a loop. After executing its detach , the coroutine will become  
suspended until th e main program or another coroutine resume s it.
A coroutine example
Here is an illustration of the kind of situation in which corou tines may prove useful. You  
are requested to print  a sequence of real numbers, given as inp ut; but every eighth number  
(the eighth, the sixteenth, the twenty-fourth etc.) is to be om itted from the output.  
Furthermore, the output must app ear as a sequence of lines, wit h six numbers per line  
(except for the last line if the re are not enough numbers to fi ll it). So if in denotes the n-th 
input item, the out put will start as
i1 i2 i3 i4 i5 i6
i7 i9 i10 i11 i12 i13
i14 i15 i17 etc.
Finally, the output should only include the first 1000 numbers thus determined.
This problem is representative of coroutine use because it conc eptually involves  
three processes, each with its specific logic: the input, where  the constraint is to skip every  
eighth item; the output, where the constraint is to go to the n ext line after every sixth item;  
and the main program, which is r equired to process 1000 items. Traditional control  
structures are not good at combining such processes with widely  different constraints. A  
coroutine solution, o n the other hand, will work smoothly.On the parallel 
scheme see “A multi-launcher”, page 988 .
SIMULA TO JA V A AND BEYOND:  MAJOR O-O LANGUAGES AND ENVIRONMENT S  §35.1 1120
Following the preceding analysis, we may use three coroutines: the producer
(input), the printer  (output) and the controller . The general structure is:
begin
class  PRODUCER begin  … See next … end PRODUCER ;
class  PRINTER begin  … See next … end PRINTER ;
class  CONTROLLER begin  … See next … end CONTROLLER ;
ref (PRODUCER ) producer ; ref (PRINTER ) printer ; ref (CONTROLLER ) controller ;
producer  :– new PRODUCER ; printer  :– new PRINTER ; controller  :– new CONTROLLER ;
resume  controller
end
This is a main program, in the usual sense; it creates an insta nce of each of the three  
coroutine classes and resume s one of them, the controller. Here are the classes:
class CONTROLLER ; begin
integer  i;
detach ;
for i := 1 step 1 until  1000 do resume  printer
end CONTROLLER ;
class  PRINTER ; begin
integer  i;
detach ;
while  true do
for i := 1 step 1 until  8 do begin
resume  producer ;
outreal (producer   last_input );
resume  controller
end;
next_line
end
end PRINTER ;
class PRODUCER ; begin
integer  i; real last_input , discarded ;
detach ;
while  true do begin
for i := 1 step 1 until  6 do begin
last_input  := inreal ; resume  printer
end;
discarded  := inreal
end
end PRODUCER ;This scheme will not 
work if the program runs out of input before having printed 1000 output items . See exercise 
E35.1, page 1139 .
§35.1   SIMULA 1121
Each class bo dy begins with detach  to allow the main program to proceed with the  
initialization of other coroutines. Procedure outreal  prints a real number; function inreal
reads and returns the next real on input; the extract assumes a  procedure next_line  that 
goes to the next line on input.
Coroutines fit well with the oth er concepts of object-oriented software construction.  
Note how decentralized the above  scheme is: each process minds its own business, with  
limited interference from the ot hers. The producer takes care o f generating candidates  
from the input; the printer takes care of the output; the contr oller takes care of when to  
start and finish. As usual, a good check of the quality of the solution is the ease of  
extension and modification; it i s indeed straigh tforward here t o add a coroutine that will  
check for end of  input (as requested by an exercise). Coroutine s take decentralization, the  
hallmark of O-O architec tures, one step further.
The architecture could be made e ven more decentralized. In part icular, the processes  
in the above structure must still activate each other by name; ideally they should not have  
to know about each other except to  communicate requested inform ation (as when the  
printer obtains last_input  from the producer). The simul ation primitives studied below  
allow this; after that, the solu tion is to use a full concurren cy mechanism, such as  
described in an earlier chapter.  As you will remember, its plat form-independence means  
that it will work for coroutines as well as true parallelism.
Sequencing and inheritance
Even if it does not use coroutine mechanisms ( detach , resume ), a Simula class may have  
a body (a sequence of i nstructions) in addition to its features , and so may take on the  
behavior of a process in additio n to its usual role as an abstr act data type implementation.  
When combined with inheritance, t his property leads to a simple r version of what the  
discussion of concurrency called the inheritance anomaly , to which Simula, thanks to its  
limitation to single rather than multiple inheritance and corou tines rather than full  
parallelism, is able to pr ovide a language solution.
For a class C let bodyC be the sequence of instruct ions declared as body of C and 
actual_bodyC the sequence of instructions executed for every creation of an  instance of C. 
If C has no parent, actual_bodyC is just bodyC. If C has a parent A (it can have at most one)  
then actual_bodyC is by default the se quence of instructions
actual_bodyA; bodyC
In other words, ancestors’ bodies are executed in the order of inheritance. But this  
default may not be what you want.  To supersede it, Simula offer s the inner  instruction  
which denotes the heir’s body, so  that the default policy is eq uivalent to having an inner
at the end of the pare nt’s body. If instead you write the body of A as
instructions1; inner ; instructions2
then (assuming A itself has no parent) the execution of C will execute not its bodyC as 
written in the class but its actual_bodyC defined as
instructions1; bodyC; instructions2On the use of a con-
currency mechanism to describe corou-tines see “Corou-tines”, page 1012 .
“Synchronization 
for concurrent O-O computation”, page 980.
SIMULA TO JA V A AND BEYOND:  MAJOR O-O LANGUAGES AND ENVIRONMENT S  §35.1 1122
Although the reasons for this f acility are clear, the conventio n is rather awkward:
• In many cases descendants would need to create their instances  differently from their  
ancestors. (Remember POLYGON  and RECTANGLE .)
• Bodies of descendants, such as C here, become hard to und erstand: just reading  
bodyC does not really tell you w hat the execution will do.
• In addition, of course, the conv ention would not transpose eas ily to multiple  
inheritance, alt hough this is not an imme diate concern in Simul a.
Such difficulties with inner are typical of the conseq uences of making objects  
active, as we found out whe n discussing concurrency.
Almost all object-oriented langu ages after Simula have departed  from the inner 
convention and treated object in itialization as a procedure.
Simulation
True to its origins, Simula includes a set of primitives for di screte-event simulation. It is  
n o  a c c i d e n t ,  o f  c o u r s e ,  t h a t  t h e  f i r s t  O - O  l a n g u a g e  w a s  i n i t i a l ly meant for simulation  
applications; more than in any other area, this is where the mo deling power of the object-
oriented method can illustrate itself.
A simulation  software system analyzes and pr edicts the behavior of some ext ernal 
system — an assembly line, a che mical reaction, a computer oper ating system, a ship … 
A discrete-event simulation  software system simulates s uch an external system as  
having, at any time, a state  that can change in response to events  occurring at discrete  
instants. This differs from continuous  simulation, which views th e state as continuously  
evolving. Which of these two mode ling techniques is best for a given external system  
depends not so much on whether th e system is inherently continu ous or discrete (often a  
meaningless question) as on what models we are able to devise f or it.
Another competitor to discrete-event simulation is analytical  modeling, whereby  
you simply build a mathematical model of the external system, t hen solve the equations.  
This is a very different approach . With discrete-event simulati on, you run a software  
system whose behavior simulates the behavior of the external sy stem: to get more  
significant results, you will in crease the length of the period  that you simulate in the  
external system’s life, and so y ou will run the simulation long er. This is why analytical  
models are usually more efficient . But many physical systems ar e too complex to admit  
realistic yet tractable mathemat ical models; then simulation is  the only possibility.
Many external systems lend thems elves naturally to discrete eve nt simulation. An  
example is an assembly line, whe re typical event s may include a  new part being entered  
into the line, a worke r or machine performing a certain operati on on one or more parts, a  
finished product being removed from the line, a failure causing  the line to stop. You may  
use the simulation to answer ques tions about the modeled physic al systems: how long  
does it take (average, minimum, maximum, standard deviation) to  p r o d u c e  a  f i n i s h e d  “Active objects 
clash with inheri-tance”, page 959 .
§35.1   SIMULA 1123
product? How long will a given piece of machinery remain unused ? What is the optimum  
inventory level? How l ong does it take to re cover from a power failure?
The input to a simulation is a se quence of events with their oc currence times. It may  
come from measurements on the ex t e r n a l  s y s t e m s  ( w h e n  t h e  s i m u l a t i o n  i s  u s e d  t o  
reconstruct and analy ze past phenomena, for example a system fa ilure); more commonly,  
it is produced by random number generators accord ing to some ch osen statistical laws.
A discrete-event model must keep  track of external system time,  also called  
simulated time , representing the time taken by  external system operations suc h as 
performing a certain task on a certain part, or the instants at  which certain events such as  
equipment failure will occur. Simulated time should not be conf used with the computing  
time  needed to execute the  simulation system. F or the simulation sy stem, simulated time  
is simply a non-negative real variable, which the simulation pr ogram may only increase  
by discrete leaps. It is availabl e in Simula through the query time, managed by the run-
time system and modifi able through some of t he procedures seen next.
Feature time and other simulation-specific fe atures come from a library cla ss 
SIMULATION , which may be used as parent by  another class. Let us call “si mulation  
class” any class that is a descendant of SIMULATION .
In Simula, you may also apply inheritance to blocks: a block wr itten under the form  
C begin  … end has access to all the features declared in class C. SIMULATION  is often  
used in this way as parent of a complete program rather than ju st a class. So we can also  
talk of a “simulation program”.
First, SIMULATION  contains the declaration of a class PROCESS . (As noted earlier,  
Simula class declarations may be nested.) An instance of PROCESS  represents a process  
of the external system. A simulation class can declare descenda nts of PROCESS , which  
we will call “process classes”, and their instances just “proce sses”. Among other  
properties, a process may be link ed to other processes in a lin ked list (which means that  
PROCESS  is a descendant of the Si mula equivalent of class LINKABLE ). A process may  
be in one of the fol lowing four states:
•Active , or currently executing.
•Suspended , or waiting to be resumed.
•Idle, or not part of the system.
•Terminated .
A n y  s i m u l a t i o n  ( t h a t  i s  t o  s a y ,  a n y  i n s t a n c e  o f  a  d e s c e n d a n t  o f  SIMULATION ) 
maintains an event list , containing event notices .  E a c h  e v e n t  n o t i c e  i s  a  p a i r  
<process , activation_time >, where activation_time  indicates when the process  m u s t  b e  
activated. (Here and in the rest of this section any mention of  time, as well as words such as  
“when” or “currently”, refer to simulated time: the external sy stem’s time, as available  
through time.) The event list is sorted by increasing activation_time ; the first process is  
active, all others are suspended.  Non-terminated processes whic h are not in the  list are idle.
SIMULA TO JA V A AND BEYOND:  MAJOR O-O LANGUAGES AND ENVIRONMENT S  §35.1 1124
The basic operation on processes is activation, which schedules  a process to become  
active at a certain time by inserting an event notice into the event list. Apparently for  
syntactical reasons, this opera tion is not a call to a procedur e of class SIMULATION , but 
a specific instruction using the keyword activate  or reactivate . (A procedure call would  
seem to be a more consistent approach; in fact the standard def ines the semantics of  
activate  through a fictitious p rocedure text. ) The basic form of the in struction is
activate some_   process schedu ling_clause
where some_   process  is a non-void entity of type conforming to PROCESS . The optional  
scheduling_clause  is of one of
at some_time
delay  some_   period
before  another_   process
after another_   process
The first two forms specify the position of the new event notic e by its activation time  
(the sorting criterion for the event list); the new activation time is max (time, some_time )
in the at form and max (time, time + some_   period ) in the delay  form. The new event  
notice will be inserted after any  other already present in the list with the same activation  
time, unless you specify prior . The last two forms specify the position with reference to  
another process in the list. A missing scheduling_clause  is equivalent to delay  0.
A process may activate itself at a later time by specifying its elf as the target process  
some_   process . In this case the keyword should be reactivate . This is useful to represent  
an external system task that tak es some simulated time — but of  course no computer time.  
S o  i f  y o u  w a n t  t o  s i m u l a t e  a  t a s k that a worker takes three min utes (180 seconds) to  
perform, you can let the corresponding process worker  execute the instruction
reactivate  worker delay  180
This case is so common as to justify a special syntax, avoiding  explicit self-reference:
hold (180)
with exactly the  same effect.
As you may have guessed, processe s are implemented as coroutine s; the simulation  
primitives internally use the coroutine primitives that we have  reviewed. The effect of  
hold (some_   period ), for example, may be approximate ly described (in syntax simila r to 
the notation of this bo ok but extended with resume ) asp1
7:26p7
8:32p2
9:57p4
9:57An event list
Procedure hold is 
part of the SIMU-
LATION  class .
§35.1   SIMULA 1125
-- Insert new event notic e into event list at  position determined  by its time:
my_new_time  := max (time, time + some_   period )
create  my_reactivation_notice   make (Current , my_new_time )
event_list   put (my_reactivation_notice )
-- Get first element of ev ent list and remove it:
next := event_list   first; event_list   remove_first
-- Activate chosen process, adv ancing time if necessary:
time := time    max (next  when ); resume  next   what
assuming the follo wing declarations:
my_new_time : REAL ; my_reactivation_notice , next : EVENT_NOTICE
class  EVENT_NOTICE creation make feature
when : REAL -- i.e. time
what : PROCESS
make (t: REAL ; p: PROCESS )
do when  := t; what  := p end
end
If a process becomes suspended by reactivating it self at a late r time, execution will  
resume the first suspended process (the one with the earliest r eactivation time) and, if its  
reactivation time is after the c urrent time, correspondingly ad vance the current time.
As this example shows, the simulation primitives, although base d on the coroutine  
primitives, belong to a higher le vel of abstracti on; whenever p ossible it is preferable to use  
them rather than relying directly on coroutine mechanisms. In p articular you may view  
hold (0) as a form of resume  through which you let the und erlying event list mechanism  
pick the process to be resumed, rather than specifying it expli citly.
A simulation example
Process classes and the simulation primitives provide an elegan t mechanism for modeling  
external-world processes. Consider as an illustration a worker who may be asked to do  
either one of two tasks. Both may take a variable amount of tim e; the second requires  
switching on a machine m, which takes 5 minutes, and waiting for the machine to do its job.
PROCESS  class WORKER begin
while  true do begin
“Get next task type i and task duration d ”;
if i = 1 then
activate m delay  300; reactivate  this WORKER after  m;
end;
hold (d)
end while
end WORKERExercise E35.2, 
page 1139 .
The Simula notation 
this C, used within a 
class C, is the equiv-
alent of Current as 
used in the rest of this book .
SIMULA TO JA V A AND BEYOND:  MAJOR O-O LANGUAGES AND ENVIRONMENT S  §35.2 1126
The operation “get next task typ e and task durat ion” will usual ly obtain th e requested  
value from a pseudo-random number generator, using a specified statistical distribution.  
The Simula library includes a number of generators for common s tatistical laws. The type  
of m is assumed to be some process class MACHINE  representing the behavior of  
machines. All actors o f a simulation will be  similarly represen ted by  process classes.
Simula: an assessment
Like Algol 60 before it, Simula has made its contribution less by its commercial success  
than through its intel lectual influence. The latter is everywhe re; both in theory (abstract  
data types) and in practice, most of the developments of the pa st twenty years are children  
or grandchildren of th e Simula ideas. As to the lack of widespr ead commercia l success, a  
number of reasons can be invoked , but the most important one by  far is as regrettable as  
it is obvious: like a few major i nventions before it, Simula ca me too soon. Although a  
significant community immediately recognized the potential valu e of the ideas, the  
software field as a whole was not ready.
Thirty years later, as should be clear from the preceding overv iew, many of these  
ideas are as timely as ever.
35.2  SMALLTALK
The ideas for Smalltalk were laid out around 1970 at the Univer sity of Utah by Alan Kay,  
then a graduate student and part of a group that was particular ly active in graphics, when  
he was asked to look at an Algol 60 compiler that had just been  delivered to the department  
from Norway. Poring over it, he realized that the compiler actu ally went beyond Algol and  
implemented a set of notions tha t seemed directly relevant to K ay’s other work. The  
supported Algol extension was, o f course, Simula. When Kay late r joined the Xerox Palo  
Alto Research Center (PARC), he used the same principles as the  basis for his vision of an  
advanced personal computing envi ronment. The other two principa l contributors to the  
early development of Smalltalk at Xerox PARC were Adele Goldber g and Daniel Ingalls.
Smalltalk-72 evolved into Smallta lk-76, then Smalltalk-80, and versions were  
developed for a number of machines — initially Xerox hardware b ut later industry-
standard platforms. Today Smallta lk implementations are availab le from several sources.
Language style
As a language, Smalltalk combine s the influence of Simula with the free, typeless style of  
Lisp. The emphasis is on dynamic  binding. No typ e checking is p erformed: in contrast  
with the approach emphasized in t his book, the determination of  whether a routine may be  
applied to an object onl y occurs at run time.
This, by the way , is not the sta ndard Smalltalk terminology. A routine is called a  
“method” in Smalltalk; applying a  routine to an object is calle d “sending a message” to  
the object (whose class must fin d the appropriate method to han dle the message).
§35.2   SMALLTALK 1127
Another important feature that d istinguishes the  Smalltalk styl e from what we have  
studied in this book is the lack  of a clear-cut distinction bet ween classes and objects.  
Everything in the Smalltalk syste m is an object, including the classes themselves. A class  
is viewed as an instance of a hi gher-level class called a metac lass. This allows the class  
hierarchy to encompass all eleme nts in the system; at the root of the hierarchy is the  
highest-level class, called object . The root of the subtree containing only classes is the  
metaclass class . The arguments for th is approach include:
• Consistency: everything in Smal ltalk follows fr om a single con cept, object.
• Environment effectiveness: makin g classes part of the run-time  context facilitates  
the development of symbolic debuggers, browsers and other tools  that need run-time  
access to class texts
• Class methods: it is possible to define methods that apply to the class rather than to  
its instances. Class methods may  be used to provide special imp lementations for  
standard operations like new which allocates ins tances of the class.
An earlier discussion considered  the arguments for other , more static approaches,  
showing different ways to obtain the same results.
Messages
Smalltalk defines three main forms  of messages (and associated methods): unary, keyword  
and binary. Unary  messages express ca lls to routines with out parameters, as in
acc1 balance
which sends the message balance  to the object associated with acc1 . This is equivalent to  
the notation acc1   balance  used in Simula and this book. Messages may, as here, return  
values. Keyword  messages represent calls to routines wi th arguments, as in
point1 translateBy : vector1
window1 moveHor : 5 Vert : –3
The use of upper-case letters in the middle of a word, giving i dentifiers such as  
translateBy , is part of the established Sma lltalk style. Note how the mess age name is  
collapsed with the keyword for t he first argument. The correspo nding syntax in Simula or  
our notation wo uld have been  point1   translate (vector1 ) and window1   move (5, –3).
Binary  messages, similar to the infix functions of Ada and the notati on of this book,  
serve to reconcile the “everythi ng is an object”  approach with more traditional arithmetic  
notations. Rather than
2 addMeTo : 3
m o s t  p e o p l e ,  a t  l e a s t  f r o m  t h e  o l d e r  g e n e r a t i o n s  w h o  l e a r n e d  a r ithmetic before object  
technology, still prefer to write 2+3. Smalltalk’s binary message s permits this latter form  
as essentially a synonym for the  former. There is a snag, howev er: precedence. The  
expression a + b  c means (a + b )  c. Smalltalk developers can use parentheses to re-
establish standard precedence. U nary messages take precedence o ver binary messages, so  
that window1 height + window2 height has the expected meaning.“Metaclasses”, 
page 168 .
SIMULA TO JA V A AND BEYOND:  MAJOR O-O LANGUAGES AND ENVIRONMENT S  §35.2 1128
In contrast with Simula and the language of this book, Smalltal k classes may only  
export methods (routines). To ex port an attribute, you must wri te a function that gives  
access to its value. A typical example is
x | |
↑ xx
y | |
↑ yy
scale : scaleFactor | |
xx <– xx ∗ scaleFactor
yy <– yy ∗ scaleFactor
Methods x and y return the values o f the instance variables (attributes) xx and yy. The 
up arrow ↑ means that the following expres sion is the value to be returne d by the method  
to the sender of the corre sponding mes sage. Method scale  takes an argument, scaleFactor . 
The vertical bars | | would delimit local varia bles if there were any.
Inheritance is an important part  of the Smalltalk approach, but  e x c e p t  f o r  s o m e  
experimental implementations it is limited to single inheritanc e. To enable a redefined  
method to call the orig inal version, Smallta lk allows the devel oper to refer to the object  
viewed as an instanc e of the parent clas s through the name super , as in
aFunction : anArgument |…|
… super  aFunction : anArgument …
It is interesting to compare thi s approach with the techniques based on Precursor  and 
repeated inheritance.
All binding is dynamic.  In the absence of static typing, errors  resulting from sending  
a message to an object that is not equipped with a proper metho d to handle it will cause  
run-time failure, rather than  being caught by a compiler.
Dynamic typing also renders irrelevant some of the concepts dev eloped earlier in  
this book: Smalltalk does not need language support for generic ity since a generic  
structure such as a stack may co ntain elements o f any type with out any static coherence  
checks; neither are deferred rout ines meaningful, since if the software includes a call x f
(the equivalent of x  f ) there is no static rule requir ing any particular class to pro vide a  
method f. Smalltalk provides, however, a run-time mechanism to raise an  error if a class  
C receives a message corresponding  to a method whose effective d efinitions only appear  
in proper descendants of C. (In the rest of this book, C would be a deferred class, and  
instances would only be created for non-deferred descendants of  C.) For example, we  
could implement rotate  in a class FIGURE  by
rotate : anAngle around : aPoint | |
self shouldNotImplement
The method shouldNotImplement  is included in th e general class object  and returns  
an error message. The notation self denotes the current object.Exercise E35.5, 
page 1140 . See 
“Keeping the origi-nal version of a redefined feature”, page 555 .
§35.2   SMALLTALK 1129
Environment and performance
Much of Smalltalk’s appeal has come from the supporting program ming environments,  
among the first to include innov ative interaction techniques (m any of them devised by  
other Xerox PARC proje cts around the time of  the original Small talk development) which  
h a v e  n o w  b e c o m e  c o m m o n p l a c e :  m u l tiple windows, icons, integrati o n  o f  t e x t  a n d  
graphics, pull-down me nus and use of the mo use as a pointing an d selecting device. Such  
staples of current O-O environment tools such as browsers, insp ectors and O-O debuggers  
trace some of their roots to Smalltalk environments.
As with Simula, all commercial implementations support garbage collection.  
Smalltalk-80 and subsequent imple mentations are a lso renowned f rom their libraries of  
basic classes, covering importa nt abstractions such as “collect ions” and “dictionaries”,  
and a number of gr aphical co ncepts. 
The lack of static typing has pr oved a formidable obstacle to t he efficiency of  
software systems developed in Sm alltalk. Although modern Smallt alk environments, no  
longer solely interpretative, pro vide some mechanisms for compi ling methods, the  
unpredictability of run-time targe t types deprives most Smallta lk developers of a number  
of crucial optimizations that are readily available to compiler s for statically typed  
languages (such as setting up arrays of functions references an d hence ensuring constant-
time resolution of dyn amic binding, as discussed in the chapter  on inheritance). Not  
surprisingly, many Smalltalk proj ects have report ed efficiency problems. In fact, the  
common misconception that object t e c h n o l o g y  c a r r i e s  a  p e r f o r m a n c e  p e n a l t y  c a n  b e  
attributed in part to experienc e with Smalltalk environments.
Smalltalk: an assessment
Smalltalk was instrumental in as sociating intera ctive technique s with the concepts of  
object technology, turning the a bstract objects of Simula into visual objects that became  
suddenly comprehensible and appe aling to a larger audience. Sim ula had impressed  
programming language and programming metho dology experts; Small talk, through the  
famous August 1981 issue of Byte, dazzled the masses.
Considering how dated the concepts of Smalltalk appear today, t he commercial  
success that it enjoyed in the early nineties is remarkable. It  can be partly attributed to two  
independent a contrario  phenomena:
• The “try the next one on the li st” effect. Many people who wer e initially drawn to  
object technology by the eleganc e of the concepts were disappoi nted with hybrid  
approaches such as C++. When loo king for a better embodiment of  the concepts,  
they often went to the approach that the computer press has con sistently presented  
as the pure O-O approach: Smalltalk. Many a Smalltalk developer is in deed someone  
who “just says no” to C or C-like development.
• The decline of Lisp. For a long  time, many companies relied on  Lisp variants (along  
with Prolog and a few other appr oaches grounded in Artificial I ntelligence) for side  
projects involving qui ck development of prototypes and experime nts. Starting in the  
mid-eighties, however, Lisp larg ely faded from the scene; Small talk naturally  
occupied the res ulting vacuum.
SIMULA TO JA V A AND BEYOND:  MAJOR O-O LANGUAGES AND ENVIRONMENT S  §35.3 1130
The last observation provides a good idea of the scope of the S malltalk approach.  
Smalltalk is an excellent tool f or prototyping and experimentat ion, especially when visual  
interfaces are involved (it competes in this area with more rec ent tools such as Borland’s  
Delphi or Microsoft’s Visual Bas ic). But it has largely remaine d uninfluenced by later  
developments in software engineering methodology, as attested b y the absence of static  
typing, assertion mechanisms, dis ciplined exception handling, d eferred classes, all of  
which are important fo r mission-critical systems — or simply an y system whose proper  
run-time behavior is important t o the organization that has dev eloped it. The performance  
problems noted above do not help.
The lesson is clear: it would not in my opinion be reasonable t oday for a company to  
entrust a significant productio n development to Smalltalk.
35.3  LISP EXTENSIONS
Like many other pre-O-O language s, Lisp has served as the basis  for several object-
oriented extensions; in fact ma ny of the earliest O-O languages  after Simula and Smalltalk  
were Lisp-based or Lisp-like. This is not surprising, since Lis p and its implementations  
have for many years offered mechanisms that directly help the i mplementation of object-
oriented concepts, and  have taken much longer to find their way  into mainstream  
languages and their environments:
• A highly dynamic approach  to the creation of objects.
• Automatic memory manageme nt with garbag e collection.
• Ready implementation of t ree-like data structures.
• Rich development envi ronments, such as Interlisp in the sevent ies and its  
predecessors in th e previous decade.
• Run-time selection of operation s, facilitating the implementat ion of dynamic binding.
The conceptual distance to O-O c oncepts is, then , shorter if yo u start from Lisp than  
if you start from C, Pascal or Ad a, so that the term “hybrid” c ommonly used for O-O  
extensions of these la nguages, such as the C-based hybrids whic h we will review in the  
next sections, is less appropriate for extensions of Lisp.
Artificial Intelligence applicat ions, the prime application of L i s p  a n d  L i s p - l i k e  
languages, have found in O-O con cepts the benefits of flexibili ty and scalability. They  
have taken advantage of Lisp’s uniform representation for progr ams and data to extend the  
object-oriented paradigm with no tions such as “meta-object prot ocol” and “computational  
reflection” which apply some of the O-O principles not just to the description of run-time  
s t r u c t u r e s  ( o b j e c t s )  b u t  a l s o  t o  t h e  s o f t w a r e  s t r u c t u r e  i t s e l f  (classes), generalizing the  
Smalltalk concept of metaclass and continuing the Lisp traditio n of self-modifying  
software. For most developers, h owever, these concepts are a li ttle far-off, and they do not  
blend too well with the software engineering emphasis on a stri ct separation between the  
static and dynamic pictures.
§35.4   C EXTENSIONS 1131
Three main contenders were vying for attention in the world of O-O Lisp in the  
eighties: Loops , developed at Xerox, initially for the Interlisp environment; Flavors , 
developed at MIT, available on se veral Lisp-oriented architectu res; Ceyx , developed at  
INRIA. Loops introduced the inte resting concept of “data-orient ed programming”,  
whereby you may attach a routine  to a data item (such as an att ribute). Execution of the  
routine will be trigge red not only by an e xplicit call, but als o whenever the i tem is accessed  
or modified. This opens the way t o event-driven computation, a further step towards  
decentralizing software architectures.
The unification of the various approaches came with the Common Lisp Object  
System or CLOS (pronounced C-Los  by most people), an extension of Common Lisp  
which was the first obj ect-oriented la nguage to have an ANSI st andard.
35.4  C EXTENSIONS
Much of the late nineteen-eighti es transformatio n of object tec hnology from an attractive  
idea into an industrial practice  can be attributed to the emerg ence and tremendous  
commercial success of languages that added object-oriented exte nsions to the stable stem  
of a widely available non-O-O language, C. The first such effor t to attract widespread  
attention was Objective-C; t he best known today is C++.
The language styles reflect two r adically different approaches to the problem of  
“hybrid” language design, so called because it combines O-O mec hanisms with those of  
a language based on entirely dif ferent principles. (Examples of  h y b r i d s  b a s e d  o n  
languages other than C include A da 95 and Borla nd Pascal.) Obje ctive-C illustrates the  
orthogonal  approach: add an O-O layer to the existing language, keeping t he two parts as  
independent as po ssible. C++ illustrates the merged  approach, intertwining concepts from  
both. The potential adv antages of each styl e are clear: the ort hogonal appro ach should  
make the transition easier, avoi ding unexpected interferences; the merged approach  
should lead to a more consistent language.
Both efforts capitalized on the success of C, which had rapidly  become one of the  
dominant languages in the industry . The appeal to managers was obvious, based on the  
prospect of turning C programmer s into O-O developers without t oo much of a culture  
shock. The model (evoked by Brad  Cox) was that of the C and For tran preprocessors such  
as Ratfor which, in th e seventies, enabled part of the software  community to become  
familiar with concepts of “struc tured programming” while contin uing to work in familiar  
language frameworks.
Objective-C
Designed at Stepstone Corporati on (originally Productivity Prod ucts International) by Brad  
Cox, Objective-C is a largely o rthogonal addition of Smalltalk concepts onto a C base. It  
was the base language for the NEXTSTEP workstation and operatin g system. Although  
obscured in part by the success of C++, Objective-C has retaine d an active user community.
SIMULA TO JA V A AND BEYOND:  MAJOR O-O LANGUAGES AND ENVIRONMENT S  §35.4 1132
As in Smalltalk, the emphasis is on polymorphism and dynamic bi nding, but current  
versions of Objective-C have departed from the Smalltalk model by offering static typing  
as an option (and for some of them, somewhat surprisingly, stat ic binding as well). Here  
is an example of Objective-C syntax:
= Proceedings : Publication {id date , place ; id articles ;}
+ new {return [[super new ] initialize ]}
– initialize {articles = [OrderedCollection new ]; return self ;}
– add : anArticle {return [contents add : anArticle ];}
– remove : anArticle {return [contents remove :anArticle ];}
– (int) size {return [contents size ];}
=:
Class Proceedings  is defined as heir to Publication  (Objective-C supports single  
inheritance only). The braces in troduce attributes (“instance v ariables”). The next lines  
describe routines; self, as in Smalltalk, denotes the current instance. The name id denotes,  
in the non-statically typed variant, a general class type for a ll non-C objects. Routines  
introduced by +, known as “class methods” as in S malltalk, are meant for the cl ass; this is  
the case here with the creation operation new. Others, introduced by –, are normal “object  
methods” that send messages to instances of the class.
Stepstone’s Objective-C is equipped with a library of classes i nitially patterned after  
their Smalltalk counterparts. Man y other classes are also avail able for NEXTSTEP.
C++
Originally designed by Bjarne St roustrup at AT&T Bell Laborator ies (an organization  
previously renowned, a mong other accomplishm ents, for its devel opment of Unix and C),  
C++ quickly gained, starting aro und 1986, a leading position fo r industrial developments  
aiming to obtain some of the bene fits of object technology whil e retaining compatibility  
with C. The language has remained almost fully upward-compatible with C (meaning that  
a valid C program is also, in no rmal circumstanc es, a valid C++  program).
Early C++ implementations were s imple preprocessors that remove d O-O constructs  
to yield plain C, based on techn iques sketched in the preceding  chapter. Today’s  
compilers, however, are  native C++ implementations; it has in f act become hard to find a  
C compiler that is not also a C++ compiler, requiring the user who just wants a basic C  
compiler to turn on a special “n o C++ constructs” compilation o ption. This is a measure  
among many of the success of the  approach. Compilers are availa ble from many sources  
and for many platforms.
Originally, C++ was an attempt a t providing a better version of  C, improved in  
particular through a class const ruct and a stronger form of typ ing. Here is a class example:
§35.4   C EXTENSIONS 1133
class  POINT  {
float xx , yy;
public :
void translate (float, float );
void rotate (float);
float x ();
float y ();
friend void p_translate (POINT , float , float );
friend void p_rotate (POINT , float );
friend float p_x (POINT );
friend float p_y (POINT );
};
The first four routines are the normal, object-oriented interfa ce of the class. As  
shown by this example, the class declaration only shows the hea ders of these routines, not  
their implementations (somew hat as in the output of the short  command studied in earlier  
chapters). The routine implementations must be defined separate ly, which raises questions  
of scope for both compil ers and human readers.
The other four routines are exam ples of “friend”  routines. This  notion is peculiar to  
C++ and makes it possib le to call C++ routines from normal C co de. Friend routines will  
need an extra argument represent ing the object to which an oper ation is applied; this  
argument is here of type POINT , meaning pointer to POINT .
C++ offers a rich set of  powerful mechanisms:
• Information hiding, inc luding the ability to hide features fro m proper des cendants.
• Support for inheritance. Origin al versions supported single in heritance only, but now  
the language has multi ple inheritance. Repea ted inheritance lac ks the flexibility of  
sharing or replicating on a feat ure-by-feature basis, which fro m the discussion of  
these topics seemed quite import ant. Instead, you share or dupl icate an entire feature  
set from the repeated ancestor.
•Static binding by default, but d ynamic binding for functions sp ecified as virtual; the  
C++ approach to this issue was d iscussed in depth  in an earlier  chapter.
• A notion of “pure vir tual function”, which resembles deferred features.
• Stricter typing than in traditi onal C, but still with the poss ibility of casting.
• Usually no garbage collection (b ecause of the pr esence of cast s and the use of  
pointers for arrays and similar structures), alt hough some tool s are available for  
suitably restrained programs.
• Because of the absence of automatic memory management by defau lt, a notion of  
destructor  for taking care of object d isposal (complementing the constructors of a 
class, that is to say it s creation procedures).“The C++ approach 
to binding”, page 513.
SIMULA TO JA V A AND BEYOND:  MAJOR O-O LANGUAGES AND ENVIRONMENT S  §35.4 1134
• Exception handling, again not p art of the original definition but now supported by  
most compilers.
• A form of assignment attempt, “downcasting”.
•A form of genericity, “templates ” ,  w h i c h  s u f f e r s  f r o m  t w o  l i m i t ations: no  
constrained genericity; and, for  reasons unclear  to a non-imple menter, a considerable  
burden on compile-time performan ce (known in the  C++ literature  as the template  
instantiation problem ).
• Operator overloading.
•A n  assert  instruction for debugging, but no assertions in the sense of s upport for Design  
by Contract (preconditions, postc onditions, class invariants) t ied to O-O constructs.
• Libraries available from various  suppliers, such as the Micros oft Foundation Classes.
Complexity
The size of C++ has grown consid erably since the language’s fir st versions, and many  
people have complained about its  complexity. That they have a p oint is illustrated, among  
many possible examples, by this little excerpt from a pedagogic al article by a recognized  
C and C++ authority, chair of the C standards committee of the American National  
Standards Institute and author o f several respected C++ books a s well as the Dictionary of  
Standard C , from whom I was at some point hoping to learn the difference between the  
C++ notions of ref erence and pointer:
While a reference is somewhat like a pointer , a pointer is an object that  
occupies memory and has an address . Non- const  pointers can al so be made to  
point to different objects at run time . On the other hand , a reference is an alias  
to an object and does not , itself , occupy any memory . Its address and value are  
the address and value of the ob ject to which it is aliased . And while you can  
have a reference to a pointer , you cannot have a pointer to a reference or an  
array of references , nor can you have an object of some reference type .
References to the void type are also prohibited .
References and pointer are not interchangeable . A reference to an int cannot ,
for example , be assigned to a pointer to an int or vice versa . However , a 
reference to a pointer to an int can be assigned a pointer to an int.
I swear I tried to understand. I  was almost convinced I got the  hang of it, although  
perhaps not being quite ready for the midterm exam yet. (“Give convincing examples of  
cases in which it is appropriate to use: (1) A pointer only. (2 ) A reference only. (3) Either.  
(4) Neither. No notes or Web bro wsers allowed”.) Then I noticed  I had missed the start of  
the next paragraph:
From what we ha ve seen so far , it may not be obvious as to why references  
indeed exist .See “Efficiency con-
siderations”, page 327.
From Rex 
Jaeschke's C++ col-umn in DEC  Profes-
sional,  November 
1991.
§35.4   C EXTENSIONS 1135
Oh well. Proponents of C++ would undoubtedly stat e that most us ers can ignore such  
subtleties. Another school hol ds that a programming language, t h e  p r i n c i p a l  t o o l  o f  
software developers, should be based on a reasonable number of solid, powerful, perfectly  
understood concepts; in other wor ds, that every serious user sh ould know all of the  
language, and trus t all of it. But it may be impossible to reco ncile this view with the very  
notion of hybrid language — a not ion which in the case of C++ i rresistibly evokes Liszt’s  
transcription of Schubert’s admirable Wanderer Fantasy: add a f ull symphony orchestra,  
and keep the piano .
C++: an assessment
C++ leaves few people indifferen t. The eminent author Grady Boo ch lists it, in a “Geek  
Chic” interview, as his programmi ng language of choice. Then, a ccording to Donald  
Knuth, it would make Edsger Dijkstra “ physically ill to think of programming in C++ ”.
C++ here could use the answer o f Junia to Nero in Racine’s Britannicus :
I have neither deserved , in all humility , 
         Such excess of honor , nor such indignity .
Disappointment with C++ indeed fol lows from exaggerated hopes. Earlier  
discussions in this book have car efully analyzed some of the la nguage’s more  
controversial design choices — especially in the areas of typin g, memory management,  
inheritance conventi ons and dynamic binding — and shown that be tter solutions are  
available. But one cannot criticize C++ as if it were the be-al l and end-all of object-
oriented languages. What C++ ha s attempted, and achieved beyond  anyone’s dreams, was  
to catch a particular moment in the history of software: the ti me at which a large part of  
the profession and its managers were ready to try object techno logy, but not ready to shed  
their current practices. C++ was the almost magical answer: sti ll C enough not to scare  
the managers; already O-O enough to attract the forward-looking  members of the trade. In  
seizing the circumstance, C++ wa s only following the example of  C itself, which, fifteen  
years earlier, was another pro duct of coinciding opportunities — the need for a portable  
machine-oriented language, the de velopment of Unix, the emergen ce of personal  
computers, and the availability o f a few decommissioned machine s at Bell Labs. The  
merits of C++ lie in the histori c boost it gave to the developm ent of object technology,  
making it presentable to a whole  community that might not have accepted the ideas under  
a less conventional apparel.
That C++ is not the ideal object -oriented language, a comment r egularly made by  
authors and lecturers in the fie ld, and obvious enough to anyon e who has studied the  
concepts, should not obscure thi s contribution. We must not ind eed look at C++ as if it  
were destined to remain a major tool for the software engineeri ng community well into the  
twenty-first century, as it would then be overstaying its welco me. In the meantime C++  
has admirably played its role: t hat of a transit ion technology.Booch interview : 
http://www .geek-
chic.com/replique .
htm. Knuth inter-
view: Dr. Dobb’s 
Journal , no. 246, 
April 1996 , pages 
16-22 .
SIMULA TO JA V A AND BEYOND:  MAJOR O-O LANGUAGES AND ENVIRONMENT S  §35.5 1136
35.5  JA V A
Introduced by a Sun Microsystems  team, Java gain ed considerable  attention in the first  
few months of 1996, pre s e n t e d  a s  t h e  w a y  t o  h e l p  t a m e  t h e  I n t e r net. According to  
ComputerWorld , the number of press mentions of Java in the first six months of 1996 was  
4325 (which we may multiply by 2  or 3 since this was presumably  the US press only); as  
a point of comparison, Bill Gate s was mentioned only 5096 times .
The principal contribution of Jav a is in implementation technol ogy. Building on  
ideas already present in many ot her O-O environments but taken here to a new level, Java  
execution rests on a bytecode  (a low-level, portable in terpretable format) whose  
specification is in the public domain, and a wid ely available virtual machine  to interpret  
bytecode programs. The virtual m a c h i n e  i s  s i m p l y  a  p r o g r a m ,  f o r  which versions are  
available for many different platforms, and can be downloaded f reely through the Internet;  
this enables almost anyone to execute bytecode programs produce d by almost anyone else.  
Often you do not even have to dow nload anything e xplicitly: the  virtual machine is built  
in tools such as W eb browsers; and such tools will be able to r ecognize references to a  
bytecode program, for example a reference embedded in a link on  a Web page, so that they  
will then automatically download the program and execute it on the spot.
The explosion of the Internet ha s given this technology a great  momentum, and Sun  
has been able to convince many o ther major players to produce t ools based on this  
technology. As the byt ecode is largely separate from the langua ge, it stands a good chance  
o f  b e c o m i n g  a  m e d i u m  o f  c h o i c e  f o r compiler output, regardless of what the source  
language is. Compiler writers fo r such notations  as O-O extensi ons of Pascal and Ada, as  
well as the notation of this book , have not been slow to recogn ize the opportunity for  
developing software that will run  without any chan ge, and witho ut even the need to  
recompile, across all industry platforms.
Java is one of the most innovative developments in the software  field, and there are  
many reasons to be excited about it. Java’s language is not the  main one. As an O-O  
extension of C, it has missed so me of the lessons learned since  1985 by the C++  
community; as in the very first version of C++, there is no gen ericity and only single  
inheritance is suppo rted. Correcting these early oversights in C++ was a long and painful  
process, creating years of havoc  as compilers never quite suppo rted the same language,  
books never quite gave accurate in formation, trainers never qui te taught the right stuff, and  
programmers never quite  knew what to think.
Just as everyone in the C++ world has finally come up to speed,  Java is starting along  
the same road. The language does  have one significant benefit o ver C++: by removing the  
notion of arbitrary pointer, espe cially to describe arrays, it has finally made it possible to  
support garbage collection. For the rest, it seems to take no a ccount of mode rn software  
engineering ideas: no assertion  support (in fact, Java went so far as to remove the modest  
assert  instruction of C and C++); part ial reliance on run-time type c hecking; a confusing  
modular structure with three inte racting concepts (classes, nes ted packages, source files);  
and ever the cryptic syntax beque athed from C, with such lines as the following typical  
examples from the designers’ book on the language:ComputerWorld , vol. 
30, no. 29, 15 July 
1996 , page 122 .
See “Remote execu-
tion”, page 955 .
§35.6   OTHER O-O LANGUAGES 1137
String [] labels = (depth == 0 ? basic  : extended );
while ((name = getNextPlayer ()) != null) {
exhibiting side-effect -producing functions as a way of life, us e of = conflicting with the  
tradition of mathematics, semico lons sometimes r equired and som etimes illegal etc.
That the language is uninspiring  should not, however, detract f rom the contribution  
that Java technology has already made to portable software deve lopment. If it can  
eventually solve its c urrent efficiency problems, Java could, t hrough its bytecode, become  
the closest approximati on (built from software rather than hard ware, although “Java  
chips” have also been announced) to one of the oldest dreams of  the computer industry: a  
truly universal machine.
35.6  OTHER O-O LANGUAGES
The languages reviewed so far are some of the best known, but b y no means the only ones  
to have attracted significant atte ntion. Here are a few other i mportant contrib utions, which  
would each deserve a separate chapter in a book entirely devote d to object-oriented  
languages, and to which you can f ind references (books and Web pages) in the  
bibliographi cal section:
•Oberon is Niklaus Wirth’s O-O successor to Modula-2, part of a more ge neral project  
which also involves a programming environment and even hardware  support.
•Modula-3 , originally from Digital Equipment’s research laboratory, is a nother  
modular language with class-like  record types, also starting fr om Modula-2.
•Trellis , also from DEC Research, was among the first to offer both gen ericity and  
multiple inheritance.
•Sather , drawing in part from the conce pts and notation of the first e dition of this  
book, especially assertions, has the benefit of a public-domain  implementation; its  
pSather  version provides an  interesting concurrency mechanism.
•Beta is a direct descendant of Simul a, designed in Scandinavia with  the collaboration  
of Kristen Nygaard (one of Simul a’s original authors). It intro duces the pattern
construct to uni fy the concepts of class , procedure, function, type and coroutine.
•Self is based not on classes but on “prototypes”, s upporting inheri tance as a relation  
between objects rather than types.
•Ada 95 was discussed in t he Ada chapter.
•Borland Pascal  and other O-O extensions of Pascal were cited in the discussio n 
of Pascal.From [Arnold 1996].
See “Formats for 
reusable component distribution”, page 79.
“FROM ADA TO 
ADA 95”, 33.7, page 1092 ; “Object-ori-
ented extensions of 
Pascal”, page 1101 .
SIMULA TO JA V A AND BEYOND:  MAJOR O-O LANGUAGES AND ENVIRONMENT S  §35.7 1138
35.7  BIBLIOGRAPHICAL NOTES
Simula
[Dahl 1966]  describes an initial version of Simula subsequently known as S imula 1. The  
current Simula, long known as Simula 67, was initially describe d by [Dahl 1970] , which  
assumed Algol 60 as a basis and only described the Simula exten sions. A chapter in the  
famous Structured Programming book of Dahl, Dijkstra and Hoare [Dahl 1972]  brought  
the concepts to a wider audience. The language description was revised in 1984,  
incorporating the Algol 60 elements. The official reference is the Swedish national  
standard [SIS 1987] . For an account of Simula’s history by its designers, see [Nygaard  
1981] .
The best known book on Simula is [Birtwistle 1973] . It remains an excellent  
introduction. A more recent text is [Pooley 1986] .
Smalltalk
References on the earliest versi ons of Smalltalk  (-72 and -76) are [Goldberg 1976]  and 
[Ingalls 1978] .
A special issue that Byte devoted to Smalltalk [Goldberg 1981]  was the key event  
that brought Smalltalk to promine nce long before supporting env ironments became  
widely available. The basic re ference on the language is [Goldberg 1983] , serving both as  
pedagogical description and reference; complementing it is [Goldberg 1985] , which  
describes the progra mming environment.
For a good recent intr oduction to both the S malltalk language a nd the VisualWorks  
environment see [Hopkins 1995] ; for an in-depth treatment se e Lalonde’s a nd Pugh’s two-
volume set [Lalonde 1990-1991] .
The story of Simula’s original i nfluence on Smalltalk (the “Alg ol compiler from  
Norway”) comes from an interview of Alan Kay in TWA Ambassador  ( ye s,  an  a i rl i ne  
magazine), exact issue number forgotten — early or mid-eighties . I am indebted to Bob
Marcus for pointing out the connection between Lisp’s decline a nd Smalltalk’s resurgence.
C extensions: Objective-C, C++
Objective-C is described by its designer in an article [Cox 1984]  and a book [Cox 1990] 
(whose first edition dates back to 1986). Pinson and Wiener hav e written an introduction  
to O-O concepts bas ed on Objective-C [Pinson 1991] .
There are hundreds of books on C++. For a p ersonal account of t he language’s  
history by its designer, see [Stroustrup 1994] . The original article was [Stroustrup 1984] ; 
it was extended into a book [Stroustrup 1986] , later revised as [Stroustrup 1991] , which  
contains many tutorial examples and useful background. The refe rence manual is 
[Ellis  1990] .
§E35.1   EXERCISES 1139
Ian Joyner has published several editions of an in-depth “C++ c ritique”  
[Joyner  1996]  available on a number of Intern et sites and containing detaile d comparisons  
with other O-O languages.
Lisp extensions
Loops: [Bobrow 1982] ; Flavors: [Cannon 1980] , [Moon 1986] ; Ceyx: [Hullot 1984] ;
CLOS: [Paepcke 1993] .
Java
In the few months that followed the release of Java, many books  have appeared on the  
topic. Those by the designing team include: [Arnold 1996]  for a language tutorial,  
[Gosling 1996]  as the language reference, and [Gosling 1996a]  about the basic libraries.
A discussion about Java’s lack o f assertions in the style of th is book (that is to say,  
supporting the principles of Desi gn by Contract), conducted on Usenet in August 1995,  
appears at http://java.sun.com/archives /java-interest /0992 .html. 
Other languages
Oberon: [Wirth 1992] , [Oberon-Web] . Modula-3: [Harbison 1992] , [Modula-3-Web] . 
Sather: [Sather-Web] . Beta: [Madsen 1993] , [Beta-Web] . Self: [Chambers 1991] , [Ungar  
1992] . 
EXERCISES
E35.1  Stopping on short files
Adapt the Simula corou tine example (printer -controller-producer ) to make sure that it  
stops properly if the input does  n o t  h a v e  e n o u g h  e l e m e n t s  t o  p r oduce 1000 output  
elements. ( Hint : one possible technique is to a dd a fourth coroutine, the “rea der”.)
E35.2  Implicit resume     
(This is a exercise on Simula concepts, but you may use the not ation of the rest of this book  
extended with the simulation pri mitives described in this chapt er.) Rewrite the producer-
printer example in such a way th at each coroutine does not need  to resume one of its  
colleagues explicitly when it ha s finished its current job; dec lare instead the coroutine  
classes as descendants of PROCESS , and replace explicit resume  instructions by  hold (0)
instructions. ( Hints : recall that event notices with the same activation time appea r in the  
event list in the order in which  they are generated. Associate with each process a condition  
that needs to be satisfied for the process to be resumed.)The address shown 
is for the first mes-sage in the discus-sion; from there you 
can follow links to the rest of the thread .
“A coroutine exam-
ple”, page 1119 .
SIMULA TO JA V A AND BEYOND:  MAJ OR O-O LANGUAGES AND ENVIRONMENT S  §E35.3 1140
E35.3  Emulating coroutines   
Devise a mechanism for emulating  coroutines in an O-O language of your choice (such as  
the notation of the re st of this book) that does not provide co routine support. ( Hint : write  
a resume  procedure, implemented as a loo p containing a c onditional inst ruction with a  
branch for every resume . Obviously, you may not for thi s exercise use the concurrency  
mechanism of chapter 30, which among other applicatio ns supports coroutines.) Apply  
your solution to the p roducer-printer-controller example of thi s chapter.
E35.4  Simulation   
Using the notation of this book or another O-O language, write classes for discrete-event  
simulation, patterned aft er the Simula classes SIMULATION , EVENT_NOTICE , 
PROCESS . (Hint : you may use the tech niques developed for t he previous exercis e.)
E35.5  Referring to a parent’s version
Discuss the respective merits of Smalltalk’s super  technique against  the techniques  
introduced earlier in this book to enable a redefined routine t o use the original version:  
Precursor  construct and, when appropri ate, repeated inheritance.“Keeping the origi-
nal version of a redefined feature”, page 555 .
Part G: 
Doing it right
O Freunde! Nicht diese Töne!  
Sondern laßt uns an genehmere anstimmen  
Und freudenvollere.
Ludwig van Beethoven, finale of the Ninth  
Symphony: prelude inserted before the text of  
Schiller’s Ode to Joy . 
 
(Translation: see begi nning of next chapter.)
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
Part G will briefly present an environment th at seeks combines the most productive  
ideas developed in this book and makes them practically available.
36   
An object-oriented environment 
L ate into Beethoven’s Choral Symph ony, a baritone breaks the str eam of astounding but  
until then purely ins trumental sounds to awa ke us to something even grander:
O my friends! No more of these tunes!  
Let us strike up instead  
Some more pleasant and joyful ones.
After reviewing in the preceding chapters some of the common ap proaches to O-O  
development, we should similarly end with a perhaps more modern  and comprehensive  
approach (with no intended dispa ragement of the others; after a ll the Ninth’s first three  
movements, before it g oes vocal, already were pretty decent stu ff.)
This chapter presents an environ ment (ISE’s) that relies on the  principles developed  
in the rest of this book, and ma kes them availabl e concretely t o O-O software developers.  
A complete diagram of the enviro nment appears later in this cha pter; some of the principal  
components are i ncluded for trial purpo ses in the CD-ROM attach ed to this book.
The purpose of this presentation is to put the final touch to o u r  s t u d y  o f  o b j e c t  
technology by showing how enviro nment support can make the conc epts convenient to use  
in practice. A caveat: nothing i n this discussion suggests that  the environment discussed  
b e l o w  i s  p e r f e c t  ( i n  f a c t ,  i t  i s  still evolving). It is only on e example of a modern O-O  
environment; others — such as Borland’s Delphi to name just one  — have met wide and  
deserved success. But we need to  explore one environment in som e depth to understand the  
connection between the method’s p rinciples and their day-to-day  application by a developer  
sitting at a terminal. Many of the concepts will, I hope, be us eful to readers using other tools.
36.1  COMPONENTS
The environment combines  the following elements:
• An underlying method : the object-orient ed method, as desc ribed in this book.
•A  language , the notation presented in this  book, for analysis, design and  
implementation.
• A  s e t  o f  tools  for exploiting the method and th e language: compiling, browsin g, 
documenting, designing.
•Libraries of reusable software components.
The next sections sketch these va rious elements, except for the  first which, of course,  
has been the subject of  the rest of this book.The diagram is on 
page 1149.
AN OBJECT-ORIENTED ENVIRONMENT  §36.2 1144
36.2  THE LANGUAGE
The language is the notation that we have devised in part C and applied throughout the  
book. W e have essentially seen all of it; the only exceptions a re a few technical details  
such as how to represe nt special characters.
Evolution
The first implementation of the language dates back to late 198 6. Only one significant  
revision has occurred since then  (in 1990); it did not change a ny fundamental concepts but  
simplified the expression of some of them. Since then there has  been a continuous attempt  
at clarification, simplification and cleanup, aff ecting only de tails, and bringing two recent  
extensions: the co ncurrency mechan ism of chapter 30 (concretely, the addition of a single  
keyword, separate ) and the Precursor  construct to facili tate redefinition.  The stability of  
the language, a rare phenomenon in this field, has been a major  benefit to users.
Openness
Although a full-fledged programmi ng language, the notation is a lso designed to serve as  
a wrapping mechanism for componen ts that may be written in othe r languages. The  
mechanism for including external elements — the external  clause — was described in an  
earlier chapter. It is also possible, through the Cecil  library, for external software to use the  
O-O mechanisms: create instances of classes, and call features on these objects, through  
dynamic binding (but of course w ith only limited static type ch ecking).
Of particular interest are the C and C++ interfaces. For C++, a  tool called Legacy++  
i s  a v a i l a b l e  t o  p r o d u c e ,  o u t  o f  a n  e x i s t i n g  C + +  c l a s s ,  a  “ w r a p p er” class that will  
automatically include t he encapsulation of all the exported fea tures of the original. This is  
particularly useful to developers whose organizations may have used C++ as their first  
stop on the road to object orientation in the late eighties or early nineties, and now want  
to move on to a more complete an d systematic form of the techno logy — without  
sacrificing their inve stment. Legacy++ smoothes the transition.
36.3  THE COMPILATION TECHNOLOGY
The first task of the environmen t is, of course, to let us exec ute our software.
Compilation challenges
Developed over many years and bootstrapped through several iter ations, the compilation  
technology is an answer t o a set of challenges:
C1  • The efficiency of the generated code  must be excellent, comparable to what  
developers could obtain by using  a classical language such as C . There is no reason  
to pay a significant performan ce price for O -O techniques.
C2  •T h e  recompilation time  after a change must be short. More precisely, it should be  
proportional to the size of the c hange, not to the size of the entire system. The  
crucial compilation concern, for  developers working on a possib ly large system, is  
the need to perform changes a nd see the results immediately.
§36.3   THE COMPILATION TECHNOLOGY 1145
C3  • A third requirement, which appe ared more recently, is quickly becoming  
important: the need to support t he fast delivery  of application s through the Internet  
to users or potential user s, for immediate execution.
The first two requirements, in p articular, are hard to reconcil e. C1 is usually  
addressed throug h extensive compiler opt imizations that make th e recompilation and  
linking process prohibitively long. C 2 is well served by interpre tive environments, which  
execute software on-the-fly with  little or no processing, but t o obtain this result they must  
sacrifice execution- time performance (C 1) and static type checking.
The Melting Ice Technology
The compilation technology that deals with the preceding issues , known as the Melting Ice  
Technology , uses a mix of complementary te chniques. Once you have compile d a system,  
it is said to be frozen , like a block of ice stored in the freezer. As you take out th e system  
to start working on it (so the metaphor goes), you produce some  heat; the melted elements  
represent the changes. Those elements will not cause a compile-link cycle, which would  
defeat the goal of fast recompilation (C 2); the melted code is, ins tead, directly executable  
by the environment’s execution engine.
The tricky part (for the compile r implementers) is of course to  make sure that the  
various components can work toge ther, in particular that frozen  code can call melted  
elements — even though  it was not known, at freezing time, that  they would later be  
melted! But the result i s definitely worthwhile:
• Recompilation is fast . The waiting time is typically a few sec onds.
• T h i s  i s  s t i l l  a  c o m p i l a t i o n  a p p r o a c h :  a n y  r e c o m p i l a t i o n  w i l l  p erform full type  
checking (withou t undue penalty on recom pilation time because t he checking, like  
the recompilation in general, is incremental: only the changed parts are rechecked).The Frozen 
and the MeltedYOUR SYSTEM
Execution,
browsing,
symbolic debugging,
documentation …
MELTINGFREEZING
Machine code
(from C code)FROZEN
MELTEDBENCH
“Bytecode”THE ENVIRONMENT
AN OBJECT-ORIENTED ENVIRONMENT  §36.3 1146
• Run-time performance remains acceptable be cause for a non-triv ial system a typical  
modification will only affect a small percentage of the code; e verything else will be  
executed in its compiled form. (F or maximum efficiency, you wil l use the finalization
form of compilation, as explained below.)
As you perform more and more cha nges, the proportion of melted code will grow;  
after a while the effect on perf ormance, time and space, may be come perceptib le. So it is  
wise to re-freeze every few days . Because freezing implies a C- compilation and linking,  
the time it takes is typically m ore on the order of minutes (or  even an hour after several  
days of extensive changes). You can start this t ask in the back ground, or at night.
Dependency analysis
As should be the case in any mod ern development environment, th e recompilation process  
is automatic; you will simply cl ick on the Melt button of the P roject Tool, in the interface  
described below, and the compili ng mechanisms will silently det ermine the smallest set of  
elements that need to be recompi led; there is no need for “Make  files” and the notation has  
no notion of “include file”.
To compute what needs to be reco mpiled, the environment’s tools  first find out what  
you have changed, either from within the environment, using its  o w n  c l a s s  e d i t o r ,  o r  
through outside tools such as tex t editors (each class text bei ng stored in a file, the time  
stamps provide the basic information). Then they use the two de pendency relations, client  
and inheritance, to determine wh at else may have been affected and needs recompilation.  
In the client case, information hiding is an important help to minimize propagation: if a  
change to a class only affects s ecret features, it s clients do not need recompilation.
To reduce melting time further, the grain of recompilation is n ot the class but the  
individual routine.
Note that if you add an external element, for example a C funct ion, a freeze will be  
required. Again this will be determined automatically.
Precompilation
In accordance with the  method’s emphasis on  reusability, it is essential to allow software  
developers to put together carefully crafted sets of components  — libraries —, compile  
them once and for all, and distribute them to other developers who will simply include  
them in their systems without ha ving to know anything about the ir internal organization.
The precompilation mechanism achi eves this goal. A special comp ilation option  
generates a compiled form of a set of classes; then it is possi ble (through the Ace file) to  
include a precompiled li brary in a new system.
There is no limit to the number of precompiled libraries that y ou may include in a  
new system. The mechanism that c ombines precompiled libraries s upports sharing: if two  
precompiled libraries B and C bot h rely on a third one A (as wi th the Vision graphical  
l i b r a r y  a n d  t h e  N e t  c l i ent-server library, discussed later, whi ch both rely on the Base  
libraries for data structures and  fundamental algorithms), only  o n e  c o p y  o f  A  w i l l  b e  
included provided bo th B and C use the s ame version of A.On Ace files see 
“Assembling a sys-tem”, page 198.
§36.3   THE COMPILATION TECHNOLOGY 1147
The author of a precompiled libr ary may want to prevent his cus tomers from having  
access to the source code of the library (an early chapter disc ussed the pros and cons of  
this policy). It is indeed possible, when precompiling, to make  t h e  s o u r c e  c o d e  
inaccessible. In that case users of the environment will be abl e, through the visual tools  
described later in this chapter, to browse the short form  and the flat-short form of the  
library’s classes, that is to sa y their interface (public) prop erties; but they will not be able  
to see their full text, let  alone their flat form.
Remote execution
The interpretive code generated by melting — conventionally kno wn as bytecode  and 
identified as such on the preced ing figure — is platform-indepe ndent. To execute  
bytecode, it suffices to have a copy of the environment’s Execu tion Engine, known as 3E  
and freely downloadable through the Internet.
By adding 3E as a plug-in  to a Web browser, it will be possible to make code directly  
executable: if a browser’s user clicks on a hyperlink correspon ding to bytecode, 3E will  
automatically execute the corresp onding code. This is the remot e execution mechanism  
first popularized by Java.
3E actually comes in two flavors , distinguished by the accompan ying precompiled  
libraries. The first, secure, is  meant for Internet usage; to a void security risks it only allows  
i n p u t  a n d  o u t p u t  t o  t h e  t e r m i n a l .  T h e  s e c o n d ,  m e a n t  f o r  I n t r a n e t (corporate network)  
usage, supports gene ral I/O and other precompiled libraries.
An effort is also in progress to translate the bytecode into Ja va bytecode, to offer the  
supplementary possibility of executing the result of a developm ent using a Java  
virtual machine.
Optimization
To generate the best possible code — goal C 1 of the earlier discus sion — frozen mode is  
not sufficient. Some cr ucial optimizations require having a com plete, stable system:
•Dead code removal removes any routines that can never be called, directly or  
indirectly, from the system’s ro ot creation procedure. This is particularly important  
if you rely on many precompiled libraries, of which your system  may only need a  
subset; a space gain of  50% is not uncommon.
•Static binding  which, as we studied in detail in the discussion of inheritanc e, should be  
applied by the compiler for feat ures that are not redefined, or  non-polymorphic entities.
•Routine inlining , also subject to compiler algorithms.
When you are still changing your system, these optimizations ar e not applicable,  
since your next editing move cou ld invalidate the compiler’s wo rk. For example by adding  
just one call you may resuscitat e a supposedly dead routine; by  adding a routine  
redefinition, you cause a static ally bound routine to require d ynamic binding. Besides,  
such optimizations may require a  complete pass through a system , for example to  
determine that no class redefines  a certain routine; this makes  them incompatible with  
incremental development.“Formats for reus-
able component dis-tribution”, page 79.
At the time of writing 
the plug-in mecha-nism has not yet been released.
“Static binding as 
an optimization”, page 509 (also dis-cusses inlining).
AN OBJECT-ORIENTED ENVIRONMENT  §36.4 1148
As a result, these optimizations are part of a third form of co mpilation, finalization , 
complementing the other two (melting and freezing). For a large  system finalization can  
take a few hours; but it leaves no stone unturned in removing a nything that will not be  
needed and speeding up everythin g that is not optimal. The resu lt is the most efficient  
executable form o f the system.
The obvious opportunity for fina lization is the delivery of a s ystem, for a final or  
intermediate release. B ut many project leade rs like to finalize  once a week, at the time of  
the latest integration.
36.4  TOOLS
The figure on the facing page sho ws the general organization of  the environment. The  
environment is of course used to  bootstrap itself, and is writt en in the O-O notation (except  
for some elements of the runtime system, discussed next); this makes it an excellent  
testbed of the technology, and a living proof that it does scal e up to large, ambitious  
systems (which, of course, we wo uld not want to develop in any other way!).
Bench and the development process
The centerpiece is Bench , the graphical workbench for co mpilation, browsing (exploring  
classes and features), documenta tion, execution, debugging. Whe n developing a system  
you will constantly interact with Bench. For example you can me lt the latest version by  
clicking on the Melt button of th e Bench’s Project Tool, shown below.
As long as you are melting and fr eezing you can st ay within Ben ch. When you  
finalize a system — also by click ing on a button, although for this operation and many  
others non-graphical commands are also available — the outcome will be a C program,  
which the environment will compile to machine code for your pla tform by calling the  
appropriate C compiler. Freezing too relies on C as intermediat e code. The use of C has  
several benefits: C is available on just about every platform; the language is sufficiently  
low level to provide a good targ et format for a compiler; C com pilers perform their own  
extensive optimizations. Two furth er advantages deserve emphasi s:
• Thanks to C generation you ca n use the environment as a cross-development
platform, by compiling the gener ated C on anothe r platform. Thi s is particularly  
useful for the production of embe dded systems development, whic h typically uses a  
different platform for develop ment and for fin al execution.
• The use of C as compilation tech nology helps implement the ope nness mechanisms  
discussed earlier, in particular the interfaces to and from exi sting software written in  
C and C++.
Finalized C code, once compiled,  must be linked; at this stage it uses the runtime  
system , a set of routines providing the interface with the operating system: file access,  
signal handling, basic  memory allocation. 
In the case of cross development of embedded systems, it is pos sible to provide a  
minimum form of the runtime, whi ch, for example, does not inclu de any I/O.
§36.4   TOOLS 1149
APPLICATION RESULTSNumerical and statistical libraryEXTERNAL
CODE (C, C++, …)Base (incl. Kernel)
Vision, WEL, MEL … 
Net
Lex, Parse
Math
WebGUI libraries
Client-server library, object exchange
Lexical and parsing libraries
Web form processing libraryRun-time object editingObjEditBuild Build
Store STORABLEBench
C Compilation
LinkingRuntime systemPORTABLE
ANSI-C CODEDeveloper-defined
Classes
Persistent
ObjectsDatabasesExecutable
SystemGraphical  application builder
         Existing software,  
         libraries,  
         utility packages,  
         low-level  
         access routines … 
also Cecil  library (calls to O-O  
facilities from C and other languages)
Shelf
User-contributed reusable componentsCase
reverse engineeringAnalysis, design and
FA S T R E C O MP I L AT I ON  
(MELTING ICE),  
EXECUTION,  
BROWSING,  
AUTOMATIC  
DOCUMENTATION,  
DEBUGGING
PORTABLE,
BYTECODEINTERNET-
DOWNLOADABLEFinali zation
Downloadable
Execution Engine
(Relational,
O-O)(OPTIMIZED COMPILATION )General libraries
AN OBJECT-ORIENTED ENVIRONMENT  §36.5 1150
High-level tools
At the top of the figure on the  preceding page, two high-level generation tools appear.
Build  is an interactive application generator based on the Context-E vent-Command-
State model developed in an earlier chapter. You can use it to develop GUI (Graphical  
User Interface) applications g raphically and  interactively.
Case  is an analysis and design workb ench which provides the ability  to reason on  
systems at a high level of abstr action, and through graphical r epresentations. In  
accordance with the principles of seamlessness  a n d  reversibility introduced in the  
discussion of the software pro cess, Case allows you both to:
• Devise system structures through  graphical interaction — to pr oduce visual  
representations of classes (“yy-b ubbles”), specify their relati ons through client and  
inheritance arrows, and group them into clusters —, relying on Case to generate the  
corresponding software texts in the end ( forward engineering ).
• Process existing class texts to produce the corresponding grap hical representations,  
to facilitate exploring and restructuring ( reverse engineering ).
Particular attention has been dev oted to making sure that devel opers can freely  
alternate between forward and re verse engineering. In particula r, you can make changes  
on either the graphical or the textual form; Case provides a reconciliation mechanism  
which will merge the two sets of changes and, in case of confli cts, take you through a step-
by-step decision process in whic h you will see the conflicting versions of a feature and  
choose, in each case, the version to be retained. This part of the tool is key to ensuring true  
reversibility, letting developers dec ide at each stage the leve l of abstraction and the  
notation, graphical or textual, that they f ind most appropriate .
The conventions of Case are drawn from the Business Object Nota tion described in  
an earlier chapter. BON supports i n particular the tools’ facil ities for abstraction and  
zooming : it is essential, for large sys tems, to enable developers to w ork on an entire system,  
on a subsystem, on just a small c luster, choosing the exact lev el of abstraction they desire.
An example Case screen appears a t the top of the facing page, s howing a cluster from  
a chemical plant description, the  properties of one of its clas ses (VAT), and the properties  
of one of the featur es of that class ( fill).
36.5  LIBRARIES
A number of libraries appear on the general environment diagram  of the preceding page.  
They play a considerab le role in the softwar e development proce ss, providing developers  
with a rich set (sever al thousand classes)  of reusable componen ts. They include:
•T h e  Base  libraries, about 200 classes cov ering the fundamental data str uctures (lists,  
tables, trees, stacks,  queues, files and so on). The most funda mental classes make up  
the Kernel  library, governed by an inte rnational standard (ELKS).
• The graphical libraries: Vision  for platform-independent GUI development; WEL  for 
Windows, MEL  for Motif, PEL for OS/2-Presentation Manager.Chapter 32.
Chapter 28.
“THE BUSINESS 
OBJECT NOTA-TION”, 27.7, page 919.
§36.5   LIBRARIES 1151
•Net, for client-se rver development, allowing the t ransferral of arb itrarily compl ex 
object structures over a network ; the platforms may be the same  or different (under  
independent_store  the format is platform-independent).
•Lex, Parse  for language analysis. Parse, i n particular, provides an inter esting  
approach to parsing, based on a systematic application of objec t-oriented concepts  
to parsing (each production modeled by a class; see the bibliog raphical notes). A  
supporting public-doma in tool, YOOCC, serve s as front-end for P arse.
•Math  is a numerical library providing  an object-oriented view of th e fundamental  
techniques of numerical computat ion. It is based internally on the NAG library and  
covers a lar ge set of facilities. Some of its concepts were pre sented in an earlier  
chapter as an example of O-O re- architecturing of non-O-O mecha nisms.
“Storable format 
variants”, page 1038.A cluster, class 
and feature under Case
(Here on a Sparc-
station with Motif, 
but versions exist 
for Windows and other look-and-feel 
variants .)
“Object-oriented 
re-architecturing”, page 441 .
AN OBJECT-ORIENTED ENVIRONMENT  §36.6 1152
•ObjEdit  provides facilities f or editing objects interactively during e xecution.
•Web supports the pr ocessing of forms submitted by visitors to a We b site,  
advantageously replaci ng the Perl or C “CGI scripts” sometimes used for this purpose.
The bottom part of the environmen t diagram shows libraries used  for taking care of  
persistence needs du ring execu tion: the STORABLE  class and a few co mplementary tools,  
discussed in earlier chapters, s upport storage, retrieval and n etwork transmission of object  
structures, self-contained throu gh the application of the Persi stence Closure principle; and  
the Store  library is the databa se interface, providing mechanisms for ac cessing and storing  
data in relational databases (suc h as Oracle, Ingres, Sybase) a nd object-oriented databases.
This list is not exhaustive; oth er components are under develop ment, and users of the  
environment have provi ded their own librarie s, either free or c ommercial.
A particularly interesting combination is the use of Net, Vision  and Store  for building  
client-server systems: a server can take care of the database a spects through Store, and of  
the heaviest part the computatio n (possibly usin g Base, Math et c.); lean clients that only  
h a n d l e  t h e  u s e r  i n t e r f a c e  p a r t  c a n  r e l y  o n  V i s i o n  ( o r  j u s t  o n e  o f  t h e  p l a t f o r m - s p e c i f i c  
libraries), and include little else.
36.6  INTERFACE MECHANISMS
To support the precedi ng concepts, t he environment  provides a v isual interface, based on  
an analysis of the needs of deve lopers and of the requirements of various platforms.
This brief presentation will onl y mention some of the most orig inal aspects of the  
environment. Ample literature (s ee the bibliographic notes) is available on its other  
facilities; the reader familiar with other modern development e nvironments will have no  
difficulty guessing some of the tools and possibilities not des cribed here.
Platforms
The screenshots that follow were  drawn from a session on a Sun Sparcstation, for no other  
reason than convenience. Other p latforms supported at the time of writing include  
Windows 95 and Windows NT, Windows  3.1, OS/2, Digital’s VMS (Al pha and Vax) and  
all major brands of Un ix (SunOS, Solaris, Si licon Graphics, IBM  RS/6000, Unixware,  
Linux, Hewlett-Packard  9000 Series etc.).
Although the general concepts are  the same on every platform, a nd the environment  
supports source-code compatibili ty, the exact look-and-feel ada pts to the conventions of  
each platform, especially for Wind ows which has its own distinc tive culture.
The following screenshot shows a  set of environment windows dur ing a session.  
Although printed in black and wh i te  in  th is  boo k,  t he  di sp la y m akes extensive use of  
colors, especially to distinguish th e various parts of class te xts (the default conventions,  
user-changeable, are keywords in  blue, identifier s in black, co mments in red).
§36.6   INTERFACE MECHANISMS 1153
Tools
An environment consists of tools . In many cases those tools are  functional  tools, in the  
sense of being devoted to functi ons: a browser tool to browse, a debugger tool to debug,  
a pretty-printer tool to produce formated versions of software texts. A recent environment  
such as Sun’s Java Workshop (as demonstrated in September of 19 96) still conforms to  
this traditional pattern; to find the ancestors of a class (its  parent, grandparent etc.) you  
start a special “browser” tool.
The disadvantage of this approach is that it is modal : it forces you to select first what  
you want to do, then what you want to do it to. The practice of  software development is  
different. During the course of a debugging session, you may su ddenly need a browsing  
facility: for example you discover that a ro utine causing troub le is a redefined version, and  
you want to see the original. If you see that original you may next want to see the enclosing  
class, its short form, and so on. Modal environments do not let  you do this: you will have  
to go away from the “debugger to ol” to a “browser tool” and res tart from scratch to look  
for the item of interest (the rou tine) even though  you had it i n the other window.
Here too the object-oriented method provides a better approach.  In the same way that  
we learned to trust object types  rather than functions to defin e our software architectures,  
we can base our tools on the type of development objects  that developers manipulate. So  
we will have no debugg er or browser window, but instead a Class  Tool, a Feature Tool, a  
System Tool, a Project Tool, an Object Tool, corresponding to t he abstractions that O-O  
software developers deal with day in and day out: classes, feat ures, systems (assemblies  
of classes), projects, and, at r un-time, class instances (“obje cts” in the strict sense).
Tools
AN OBJECT-ORIENTED ENVIRONMENT  §36.6 1154
A Project Tool, for example, will keep track of your overall pr oject. You use it among  
other applications t o perform a Melt , a Freeze or a Finalize; here is  a Project Tool  
captured during a comp ilation, with a progr ess bar showing the percentage done:
A Class Tool will be targeted  to a particular class s uch as LIST :
Project Tool 
during a 
compilation
A Class Tool in 
default format

§36.6   INTERFACE MECHANISMS 1155
A Feature Tool, here attached to a Project Tool as part of a de bugging session, shows  
both a feature and the progress of  the execution, with mechanis ms for step-by-step execution,  
displaying the call stacks (see the local entities’ values in t he Project Tool). The Feature Tool  
is targeted to  feature call_this_routine of class TEST .
During an execution, you can als o see an individual object thro ugh an  Object Tool:Project and 
Feature Tool 
for debugging
An object and 
its fields 
captured during execution

AN OBJECT-ORIENTED ENVIRONMENT  §36.6 1156
This shows the various fields of the objects. One of them, guardian , denotes a non-
void reference; you can see the corresponding object by followi ng the link, as we will  
shortly see.
You can of course have as many Class Tools, Feature Tools and O bject Tools as you  
like, although there is only one System Tool and one Project To ol during a session.
Retargeting and browsing
Various techniques are available  to change the target of a tool , for example to retarget the  
preceding Class Tool from LIST  to ARRAY . One way is simply to type the new class name  
in the corresponding field (poss ibly with wild card characters as in ARR∗, to get a menu  
of matching names if you d o not exactly remember).
But you can also used the pick-and-throw mechanism briefly introduced in an  
earlier chapter. If you right-click on a class name, such as CHAIN  in the Class Tool  
targeted  to LIST
the cursor changes into a pebble  of elliptical form, indicating that what you have picked  
is a class. The ellipse corresponds to the form of the class hole ; find the Class Tool  
that you want to retarget (the same or another), and drop the p ebble into the hole, by right-
clicking into it, to retarget th e tool to the chosen class. For  convenience you can actually  
drop it more or less anywhere int o the tool, glob ally considere d as a big hole. Rather than  
pick, drag and throw, you can c ontrol-right-clic k on an object — class, feature … — to  
start a new tool of the appropria te type, targeted to the objec t.
The pick-and-throw mech anism is a generalization of common drag -and-drop.  
Instead of having to maintain th e button pressed, however, you work in three steps: the  
first right-click selects the obj ect; you release the button im mediately. Then you are in drag  
mode, where moving the mouse wil l cause the line attached to th e original element (as on  
the above figure) to f ollow the pebble. Finally, you right-clic k again in the destination  
hole. This has three advantage s over common drag-and-drop:See the figure enti-
tled “Pick-and-throw”, page 534
Typed pick-
and-throw
CHAIN[G]The pebble being dragged

§36.6   INTERFACE MECHANISMS 1157
• Having to keep the mo use button pressed during the whole proce ss, although  
acceptable for occasional drag-a nd-drop operatio ns such as movi ng an element in an  
interface builder, can cause cons iderable muscle fatigue at the  end of the day when  
you use it frequently.
• It is all too easy to slacken off the pressure for a split sec ond and drop on the wrong  
place, often with unpleasant or e ven catastrophic  consequences.  (This has happened  
to me on Windows 95 while drag-a nd-dropping an icon representin g a file; I  
involuntarily dropped it at a quite unintended place and had a hard time finding out  
what the operating system  had done with the file.)
• Common drag-and-drop does not le t you cancel the operation! On ce you have picked  
an object, you must  drop it somewhere; but there may not be such an acceptable  
somewhere if you have changed yo ur mind. With the pick-and-thro w mechanism, a  
left-click will cancel  the entire operation  at any time before throwing.
• Also note that the mechanism is typed : it will only let you drop a pebble into a  
matching hole. There is some tol erance: in the same way that po lymorphism lets  
you attach a RECTANGLE object to a POLYGON  entity, you can drop a feature  
pebble into a class hole (and see the enclosing class, with the  feature highlighted).  
Again the environment’s interac tion mechanisms directly apply, for convenience  
and consistency, the concepts of  the method. (Here the differen ce with common  
drag-and-drop mechanisms is not crucial, as some of them do hav e a limited form  
of typing.)
These, however, are just user in terface issues. More important is the role of pick-and-
throw, combined with o ther mechanisms of the  environment, to pr ovide an integrated set  
of mechanisms for all tasks of s oftware developm ent. If you loo k back at the Class Tool  
targeted to LIST , a deferred class from the Base  libraries, you will note a row  of format  
buttons (the second row  of buttons from the top). They include:
• Class text .
• Ancestors .
• Short form .
• Routines .
• Deferred routines .
and so on. Clicking on one of them will display the class text in the corresponding format.  
For example if you click on Ances tors the Class Tool will displ ay the inherita nce structure  
leading to LIST  in the Base libraries:

AN OBJECT-ORIENTED ENVIRONMENT  §36.6 1158
I n  s u c h  a  d i s p l a y ,  a s  i n  e v e r y  o t h e r  t o o l  d i s p l a y ,  everything of importance is  
clickable . This means that if for e xample you notice class CURSOR_STRUCTURE  and 
want to learn more about it, you can just right-click on it and  u s e  p i c k - a n d - t h r o w  t o  
retarget this tool, or  another, to the chosen class. Then you c an choose anothe r format, such  
as Short Form. If in that format  you see the name of an interes ting routine, you can again  
apply pick-and-throw to target a  Feature Tool to it. In the Fea ture Tool, the available  
format buttons include history  w h i c h  s h o w s  a l l  t h e  a d v e n t u r e s  o f  a  f e a t u r e  i n  t h e  
in heritance g ames: all th e version s it h as in  v arious classes, after renaming, effecting,  
redefinition; and whenever it lists a class or a feature in sho wing this info rmation, the  
environment will let you p ick-and-throw the element.
Similarly, the debugging sessio n shown earlier showed class and  feature names in  
various places; to find out info rmation on any of them, just us e pick-and-throw. To see an  
object, such as 0X142F18  on the previous example (an internal identifier, by itself  
meaningless but clickable), con trol-right-click on it to start an Object Tool similar to the  
one we saw, displaying an instance of PERSON . In that tool, all fields are identified by  
their class names — clickable — and references are also clickab le, so that you can easily  
explore the run-time data st ructures, however complex.
The ancestry of 
a class
§36.6   INTERFACE MECHANISMS 1159
For each of the available formats, you can produce output in va rious forms such as  
HTML, T EX, Microsoft’s Rich Text Format, Fr ameMaker MML, troff and so on ( a small  
descriptive language enables you to define your own output form s or adapt an existing  
one). The output can be displayed , stored with the class files,  or, if you want to produce  
on-line documentation for an enti re project or cluster, stored in a separate directory.
These browsing mechanisms do not  make any difference between bu ilt-in libraries  
and developer-defined classes. I f an element of your software u ses INTEGER , you can just  
control-right-click or use pick-and-throw to see that basic cla ss in a Class Tool, in any  
available format. (As noted, the  author of a precompiled librar y may elect to make the  
source unavailable, but you will still have access to the short  and flat-short forms, with  
usual clickability properties.) Th is is of course in line with this book’s general principle of  
uniformity and seamlessness, atte mpting as much as possible to use a single set of  
concepts throug hout software develo pment activities.
In contrast, I tried in the aforementioned demo of Java Worksho p to get some information  
about a redefined feature of a certain class, picked at random,  but was told that there was  
no way the “browser tool” could handle that feature, since it t urned out to come from a  
class of the predefined graphical library. The only way to get any information at all was  
to go to another tool and bring up the documentation — which ha d a one-line description  
of the feature. ( INTEGER  would probably also not be browsable since basic types are not  
classes in Java.)
The run-time mechanisms, in part icular the debugging facilities  (single-stepping,  
stop points and so on) all follow  from these basi c concepts. Fo r example to put a stop point  
on an instruction or a routine you just drag -and-drop the chose n stop point location to a  
Stop Point hole .
Some holes, known as “buttonhole s”, double up as buttons. For e xample clicking on  
a Stop Point hole, treated as a button, will display in the Pro ject Tool information about all  
the currently active stop points ; such information being again clickable, you can easily  
remove existing stop points or add new ones to the list.
T h e  s y s t e m a t i c  a p p l i c a t i o n  o f  t h e s e  t e c h n i q u e s  m a k e s  u p  a  m e c h a nism for  
proximity browsing where everythi ng of interest is hyperlinked — far preferable, in my  
experience, to modal environment s which force you to ask at eac h step “Am I browsing?  
Oh no, I am debugging, so I must start a browser tool. And what  tool should I start to  
get the class documentation?”.
You are neither debugging nor br owsing nor documenting nor edit ing; you are using  
and building software, and the t ools should let you do what you  want on all the objects you  
want, at any time you want.

AN OBJECT-ORIENTED ENVIRONMENT  §36.7 1160
36.7  BIBLIOGRAPHICAL NOTES
For an up-to-date summary of the benefits of the environment se e [M 1996b] , also 
available on line [M-Web]  along with many other technical documents and descriptions  
of actual projects.
A collective volume describing a set of industrial applications  produced with the  
environment over the years, whos e chapters are written by the p roject leaders in the  
companies involved , was published as [M 1993] .
Among the publications that have  described various aspects of t he environments at  
successive stages of its evolutions are: [M 1985c] , [M 1987b] , [M 1987c] , [M 1988] ,
[M 1988a] , [M 1988d] , [M 1988f] , [M 1989] , [M 1993d] , [M 1997] .
The reference on the language is [M 1992] . The book Reusable Software  [M 1994a]
contains, along with a discussi on of library design principles,  a detailed description of the  
Base libraries.
Another book [M 1994]  presents the environment as a whole. [M 1995c]  describes  
the Case analysis and design workbench, and [M 1995e]  the Build graphical application  
builder. The interface prin ciples were presented in [M 1993d] .
The YOOC compiler generator was d eveloped by Chris tine Mingins,  Jon Avotins,  
Heinz Schmidt and Glenn Maughan of Monash University [Avotins 1995]  and is available  
from Monash’s FTP site. The objec t-oriented parsing techniques of the underlying Parse  
library, initiall y presented in [M 1989d] , are covered in [M 1994a] .
The Math library was developed b y Paul Dubois and is described in [Dubois 1997] .
Many people have participated in the development of the environ ment. Some of the  
principal contributions are due to Éric Bezault (to whom I am a lso grateful for  
proofreading parts of this book), Reynald Bouy, Fred Deramat, F red Dernbach (who built  
the original architecture of the current compiler), Sylvain Duf our, Fabrice Franceschi,  
Dewi Jonker, Patrice Khawam, Vince Kraemer, Philippe Lahire, Fr édéric Lalanne, Guus  
Leeuw, Olivier Mallet, Raphaël Manfredi (who established the ba sis for the current  
runtime system), Mario Menger, Joost De Moel, David Morgan, Jea n-Marc Nerson  
(especially for the initial versions), Robin van Ommeren, Jean- Pierre Sarkis, Glen Smith,  
Philippe Stephan (who originated many of the interface principl es), Terry Tang, Dino  
Valente, Xavier Le V ourch, Deniz Yuksel. It is impossible to ci te even a small part of the  
environment users who also helpe d through their feedback and su ggestions
Epilogue, In Full Frankness 
Exposing the Language
E  nthusiastically setting out to so lve some of the most pressing problems of software  
engineering, this book has devel oped an ambitious method for de veloping quality  
systems. Since no method is possi ble without a supporting notat i o n ,  w e  h a v e  h a d  t o  
devise, as we learned the variou s components of object-oriented  software construction,  
what in the end turned out to be a complete lifecycle language for software analysis,  
specification, design , implementation, maint enance and document ation.
Instead of reading on page one, however, the name of the langua ge that you would  
be using, you have been invited to participate with the author in developing the notation,  
chapter after chapter, notion af ter notion, construct after con struct. And until now that  
language has remained nameless. Why? The reasons  were sketched in the preface but may  
deserve some final elaboration.
First, I hope that even though you were warned that the notatio n already exists and  
is extensively documented in tens of published textbooks, hundr eds of articles and  
thousands of Usenet messages, yo u earnestly accepted the pedago gical convention that  
you participated in its design a s you were reading this book. A lthough this has made life  
a little harder for the author — imagine: having to justify  every single construct, instead  
of bringing it to the people dow n from the top of Mount Sinai —  the effort will have been  
worthwhile if it has succeeded in giving you a better understan ding not only of what things  
are but of why they must be that  way. Second, the convention ha s enabled us to  
concentrate on the method, not o n notational details, making th is book useful not just to  
people who will indeed  have access to the language through one of the supporting  
commercial environments, but also to those readers who are requ ired to use less complete  
O-O languages such as Smalltalk, C++, Ada 95, Java or Object Pa scal, or even a non-
O-O one such as C, Fortran, Pasca l  o r  A d a ,  t o  w h i c h  o n e  c a n  a p p l y  t h e  e m u l a t i o n  
techniques dis cussed in earl ier chapters.
Fiction or not, the mystery is n ot very hard to penetrate. Even  if you have not looked  
a t t he  ba ck  co ve r o f t hi s b oo k or  re a d ot he r  w or ks  by t he  sa m e  author (including the  
complete language description [M 1992] ), just a cursory glance at some of the  
bibliographical references will have revealed all there is to r eveal. And books such as this  
one are meant to be not only read but re -read, so the surprise,  if any, will not last long.
EPILOGUE, IN FULL FRANKNESS EXPOSING THE LANGUAGE 1162
Even so, keeping the language nam e away from the discussion (ex cept for a few  
hints that the alert reader may have noted) has enabled us to c oncentrate on the method.  
This is a little parad oxical, since one of the language’s princ ipal claims is that, alone  
among O-O languages, it is also a method, avoiding the g ap between concept and  
expression, between analysis and design, between design and imp lementation, which  
plagues common O-O approaches and  threatens to defeat some of t he principal advantages  
of object technology. Not even the brightest-eyed Java or Small talk enthusiast will allege  
that his language of choice is a general-purpose tool for desig n, let alone analysis; and  
users of popular analysis notations such as OMT know that they must move to something  
else when it comes to producing the actual software. The ambiti on of the method-notation  
developed in this book is higher: to fulfill one of the main pr emises and promises of object  
technology, seamlessness , by serving as a faithful assi stant that will accompany you  
throughout the software  construction process .
Literary conventions have an end, so the time has now come, at the close of our  
extended tour of the beauties of  object-oriented software const ruction, after thanking the  
reader for patiently going along, through all these pages, with  the pedagogical pretense of  
an anonymous language, to lift the  very thin veil that covered the name of our notation:  
welcome to the world of Eiffel.
Part H: 
Appendices
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
Part H contains the appendices: an  overview of some librar y classes; a discussion of  
genericity versus inheritance; a list of principles and defini tions; a glossary; the  
bibliography; and the index.
A  
Extracts from the Base libraries
Throughout the discussi on, we have encounte red references to a set of libraries  
collectively known as the “Base libraries”, from which the most  fundamental classes are  
grouped into the “Kernel library”.
Reading such classes is a good way to learn more about the meth od by benefiting  
from the example of widely reused software components, which ha ve been around for a  
long time and continue to evolve.
This page and the next are only the introduction to the appendi x; the actual class  
texts, made available in electronic form so as to facilitate br owsing, appear on the CD-
ROM accompanying this book.
A detailed presentation of the libraries has been published sep arately [M 1994a] , which  
also describes the theoretical underpinnings — the general taxo nomy principles used to  
classify the major data structur es of computing science. A few of the basic ideas were  
summarized in the discussion of view inheritance.
Among the most important classes whose concepts were discussed in the previous  
chapters and whose text you w ill find on the CD-ROM are:
•ARRAY , describing one-dimensional arrays and relying on a flexible a nd general  
view of this notion (in particul ar, arrays can be freely resize d to any dimension  
during the executio n of a system).
•LINKABLE , describing cells of linked stru ctures, chained one way to sim ilar cells.
•BI_LINKABLE , the equivale nt for two-way linked cells.
•LIST , a deferred class representing the general notion of list as “ active data structure”  
w i t h  c u r s o r ,  w i t h o u t  c o m m i t m e n t  t o  a  p a r t i c u l a r  r e p r e s e n t a t i o n .  (The next three  
classes provide specific implementations, using multiple inheri tance through the  
“marriage of conveni ence” technique.)
•ARRAYED_LIST , giving an implementation by an  a r r a y  ( w h o s e  r e s i z a b i l i t y  i s  
particularly useful here).
•LINKED_LIST , a one-way linked list implement ation, relying internally on c lass 
LINKABLE .See “Criteria for 
view inheritance”, page 856 .
EXTRACTS FROM THE BASE LIBRARY  §A 1166
•TWO_WAY_LIST , a one-way linked list implement ation, relying internally on c lass 
BI_LINKABLE .
•TWO_WAY_TREE , a widely used implementation  of general trees, based on  
TWO_WAY_LIST for its representation and relying on the observation made in  
the chapter on multiple inheritanc e: if we merge the notion of tree and node, we  
can consider that a tree is both a list (as in TWO_WAY_LIST ) and a list element  
(as in BI_LINKABLE ).
All these classes, representing containers, are generic, with a  single generic  
parameter representing the type of elements.
B  
Genericity versus inheritance
The material that follows, and i ts appearance in an appendix, d eserve some background  
explanation. Part of the original impetus for the work that eve ntually led to this book was  
a study that I performed in 1984; in preparation for a graduate  course that I was to teach  
on “advanced concepts in  programming languages ”, I compared the “h orizontal” module  
extension mechanism of genericit y, illustrated by Ada, Z, LPG a nd other generic  
languages, with the “vertical” me chanism of inheritance introdu ced by Simula: how these  
techniques differ, to what extent they com pete, and to what ext ent they complement each  
other. This led to an article on  “Genericity versus Inheritance ” [M 1986] , presented at the  
first OOPSLA conference, and to a chapter in the first edition of the present book.
When preparing this new edition I felt that both genericity and  inheritance were now  
understood well enough, and thei r treatment detailed enough in the rest of the book, to  
make the chapter appear too spec ialized: useful mostly to reade rs interested in issues of  
language design or O-O theory. So I removed it. But then I foun d out that a regular flow  
of articles in the software pres s still showed m uch puzzlement over the issue, especially  
in the context of C++ for which many people seem to be searchin g for genera l guidelines  
on when to use “templates” and w hen to use inheritance. This me ans the discussion still  
has its place in a general prese ntation of object technology, a lthough it is perhaps best  
severed from the main part of the text. Hence this appendix.
The topics reviewed are, in orde r: genericity; inheritance; how  to emulate each of  
these mechanisms through the other; and, as a conclusion, how b est to reconcile them.
If you have read carefully the remainder of this book, you will  find the beginning of  
this discussion familiar since w e must restart with the basics to get a full picture of each  
mechanism, of its contribution, a nd of its limitations. As we p robe deeper and deeper,  
perhaps stepping briefly into a few dead ends along the way, th e ideal combination of  
genericity and inheritance will progressively unfold before our  eyes, imposing itself in the  
end as almost inevitable and let ting us understand, in full det ail, the fascinating  
r e la ti on sh ip  be tw ee n t he  tw o pr i nc ip al  m e th ods  f or  m ak in g s of tw are modules open to  
variation and adaptation.
GENERICITY VERSUS INHERITANCE  §B.1 1168
B.1  GENERICITY
W e begin our review by appraising the merits of genericity as i t exists in a number of  
languages, object-oriented or no t .  L e t  u s  r e l y  f o r  c o n v e n i e n c e  o n  t h e  n o t a t i o n s  —  
semicolons and all — of the best known non-O-O generic language , Ada (meaning by  
default, as elsewhere in this book, Ada 83) . So for the rest of  this section we  forget about  
O-O languages and techniques.
Only the most important form of Ada genericity will be consider ed: type 
parameterization , that is to say the ability to parameterize a software element  (in Ada, a  
package or routine) by one or mo re types. Generi c parameters ha ve other, less momentous  
uses in Ada, such as parameteriz ed dimensions for arrays. We ma y distinguish between  
unconstrained  genericity, imposing no specifi c requirement on generic parame ters, and  
constrained  genericity, whereby a certa in structure is required.
Unconstrained genericity
Unconstrained genericity removes some of the rigidity of static  typing. A trivial example  
is a routine (in a language with Ada-like syntax but without ex plicit type declarations) to  
swap the values of  two variables:
procedure  swap (x, y) is
local t;
begin
t := x; x := y; y := t;
end swap ;
This form does n ot specify t he types of the elements to be swap ped and of the local  
variable t. This is too much freedom, since a call swap (a, b), where a is an integer and b
a character string, will not be p rohibited even t hough it is pr obably an error.
T o  a d d r e s s  t h i s  i s s u e ,  s t a t i c a l l y typed languages such as Pasca l and Ada require  
developers to declare explicitly  the types of all variables and  formal arguments, and  
enforce a statically checkable t ype compatibility constraint be tween actual and formal  
a r g u m e n t s  i n  c a l l s  a n d  b e t w e e n  s ource and target in assignments .The procedure to  
exchange the values of t wo variables of type G becomes:
procedure G_swap (x, y: in out G) is
t: G;
begin
t := x; x := y; y := t;
end swap ;
Demanding that G be specified as a single type av erts type incompatibility erro rs, but  
in the constant haggli ng between safety and flexibility we have  now erred too far away  
f r o m  f l e x i b i l i t y :  t o  c o r r e c t  t h e  l a c k  o f  s a f e t y  o f  t h e  f i r s t  s o lution, we have made the  
solution inflexible. We will nee d a new procedure for every typ e of elements to be  
exchanged, for example INTEGER_swap , STRING_swap  and so on. Such multiple  
declarations lengthen and obscure programs. The example chosen is particularly bad since  
all the declarations will be iden tical except for  the two occur rences of G.This extract and the 
next few are in Ada or Ada-like syntax .
§B.1   GENERICITY 1169
Static typing may be considered too restrictive h ere: the only real requirement is that  
the two actual arguments passed to any call of swap  should be of the same type, and that  
their type should also be applied to the declaration of the loc al variable t. It does not matter  
what this type actually is as lo ng as it satisfie s these proper ties.
In addition the arguments must be passed in  in out mode, so that the procedure can  
change their values. This is permitted in Ada.
Genericity provides a tradeoff between too much freedom, as wit h untyped  
languages, and too much restrain t, as with Pascal. In a generic  language you may declare  
G as a generic parameter of swap or an enclosing unit. Ada indeed offers generic routines,  
along with the generic packa ges described in chapter 33. In quasi-Ada you can write:
generic
type G is private ;
procedure  swap (x, y: in out G) is
t: G;
begin
t := x; x := y; y := t;
end swap ;
The only difference with real Ada is that you would have to sep arate interface from  
implementation, as explained in the chapter on Ada. Since infor mation hiding is irrelevant  
for the discussion in this chapt er, interfaces a nd implementati ons will be mer ged for ease  
of presentation.
The generic … clause introduces type pa rameters. By specifying G as “private”, the  
writer of this procedure allows himself to apply to entities of  type G (x, y and t) operations  
available on all types, such as a ssignment or comparison, and t hese only.
The above declaration does not qu ite introduce a routine but ra ther a routine pattern;  
to get a directly usabl e routine you will provide actual type p arameters, as in
procedure int_swap  is new  swap (INTEGER );
procedure str_swap  is new swap (STRING );
etc. Now assuming that i and j are variables of type INTEGER , s and t of type STRING , 
then of the following calls
int_swap (i, j); str_swap (s, t); int_swap (i, s); str_swap (s, j); str_swap (i, j);
all but the first two a re invalid, and will be rejected by the compiler.
More interesting than parameteri zed routines are parameterized packages. As a  
m i n o r  v a r i a t i o n  o f  o u r  u s u a l  s t a c k  e x a m p l e ,  c o n s i d e r  a  q u e u e  p a ckage, where the  
operations on a queue (first-in, f irst out) are: add an element ; remove the oldest element  
added and not yet removed; get i ts value; test f or empty queue.  The interface is:
GENERICITY VERSUS INHERITANCE  §B.1 1170
generic
type G is private ;
package  QUEUES is
type QUEUE (capacity : POSITIVE ) is private ;
function  empty (s: in QUEUE ) return  BOOLEAN ;
procedure  add (t: in G; s: in out QUEUE );
procedure  remove (s: in out QUEUE );
function  oldest (s: in QUEUE ) return  G;
private
type QUEUE (capacity : POSITIVE ) is 
-- The package uses an array  representation for queues  
record
implementation : array (0 . . capacity ) of G;
count : NATURAL ;
end record ;
end QUEUES ;
Again this does not define a package but a package pattern; to get a directly usable  
package you will use gen eric derivation, as in
package INT_QUEUES  is new QUEUES (INTEGER );
package STR_QUEUES  is new QUEUES (STRING );
Note again the tradeoff that generic declarations achieve betwe en typed and untyped  
approaches. QUEUES  is a pattern for modules implemen ting queues of elements of al l 
possible types G, while retaining the possibility to enforce type checks for a specific G, so as  
to rule out such unholy combinations as the insertion of an int eger into a queue of strings.
The form of genericity illustrated by both of the examples seen  so far, swapping and  
queues, may be called unconstrained  since there is no specific requirement on the types  
that may be used as actual gener ic parameters: you may swap the  values of variables of  
any type and create queues of va lues of any type, as long as al l the values in a given queue  
are of the same type.
Other generic definitions, howeve r, only make sense if the actu al generic parameters  
satisfy some conditions. T his form may be called constrained  genericity.
Constrained genericity
As in the unconstrained case, the  examples of constrained gener icity will include both a  
routine and a package.
Assume first you need a generic function to compute the minimum  of two values.  
You can try the pattern of swap :
generic
type G is private ;
function  minimum (x, y: G) return  G is begin
if x <= y then  return  x; else return  y; end if;
end minimum ;From here on most 
routine declarations omit the in mode 
specification for 
arguments, which is optional.
§B.1   GENERICITY 1171
Such a function declaration, how ever, does not always make sens e; only for types G
on which a comparison operator <= is defined. In a language  that enhances security  
through static t yping, we want to enforc e this requirement at c ompile time, not wait until  
run time. We need a way to specify that type G must be equipped with  the right operation.
In Ada this will be writte n by treating the operator <= as a generic parameter of its  
own. Syntactically it is a funct ion; as a syntactic facility, i t is possible to invoke such a  
function using the usual infix form if it is declared with a na me in double quotes, here  
"<=" . Again the following declaratio n becomes legal Ada if the inte rface and  
implementation are taken apart.
generic
type G is private ;
with  function  "<="  (a, b: G) return  BOOLEAN is < >;
function  0(x, y: G) return  G is begin
if x <= y then  return  x; else return  y end if;
end minimum ;
The keyword with  introduces generic parameters r epresenting rou tines, such as "<=" .
You may perform a generic derivation minimum  for any type, say T1, such that there  
exists a function, say T1_le , of signature function  (a, b: T1) return  BOOLEAN :
function  T1_minimum is new minimum (T1, T1_le );
If function T1_le  is in fact called  "<=" , more precisely if its name and type signature  
match those of the corresponding  formal routine, then you do no t need to include it in the  
list of actual parameters to the  generic derivation. So because  type INTEGER  h a s  a  
predefined "<="  function with the right signa ture, you can simply declare
function  int_minimum is new minimum (INTEGER );
This use of default routines wit h matching names and types is m ade possible by the  
clause is < > in the declaration of th e formal routine, here "<=" . Operator overloading, as  
permitted (and in fact encouraged ) by Ada, plays an essential r ole: many diff erent types  
will have a "<="  function.
This discussion of constrained genericity for routines readily transposes to packages.  
Assume you need a generic package for handling matrices of obje cts of any type G, with 
matrix sum and product as basic operations. Such a definition o nly makes sense if type G
has a sum and a produc t of its own, and each of these operation s has a zero element; these  
features of G will be needed in the implementation of matrix sum and product . The public  
part of the package may be written as follows:
generic
type G is private ;
zero: G;
unity : G;
with  function  "+" (a, b: G) return  G is < >;
with  function  "" (a, b: G) return  G is < >;
GENERICITY VERSUS INHERITANCE  §B.1 1172
package  MATRICES is
type MATRIX (lines , columns : POSITIVE ) is private ;
function  "+" (m1, m2: MATRIX ) return  MATRIX ;
function  "" (m1, m2: MATRIX ) return  MATRIX ;
private
type MATRIX (lines , columns : POSITIVE ) is
array (1 . . lines , 1 . . columns ) of G;
end MATRICES ;
Typical generic derivations are:
package  INTEGER_MATRICES is new MATRICES (INTEGER , 0, 1);
package BOOLEAN_MATRICES  is
new MATRICES (BOOLEAN , false , true, "or", "and");
Again, you may omit actual parameters corresponding to formal g eneric routines  
(here "+" and "") for type INTEGER , which has matching operations; but you will need  
them for BOOLEAN . (It is convenient to declare s uch parameters last in the form al list;  
otherwise keyword notation is required in derivations that omit  the corresponding actuals.)
It is interesting here to take a  look at the body (implementati on) of such a package:
package body MATRICES  is
… Other declarations …
function  "" (m1, m2: G) is
result : MATRIX (m1' lines , m2' columns );
begin
if m1' columns /= m2' lines then
raise  incompatible_sizes ;
end if;
for i in m1' RANGE (1) loop
for j in m2' RANGE (2) loop
result (i, j) := zero ;
for k in m1' RANGE (2) loop
result (i, j) := result (i, j) + m1 (i, k)  m2 (k, j)
end loop;
end loop;
end loop;
return  result
end "";
end MATRICES ;
This extract relies on some specific features of Ada:
• For a parameterized type such as MATRIX (lines , columns : POSITIVE ), a variable  
declaration must provide a ctual parameters, e.g. mm: MATRIX (100, 75); you may  
then retrieve their values usi ng apostrophe notation, as in mm' lines  which in this case  
has value 100.
§B.2   INHERITANCE 1173
•I f  a is an array , a' RANGE (i) denotes the range of values in its i-th dimension; for  
example m1' RANGE (1) above is the same as 1 . . m1' lines .
• If requested to multiply two dimension-wise incompatible matri ces, the extract  
raises an exception, c orresponding to the v iolation of an impli cit precondition.
The minimum and matrix examples are representative of Ada techn iques for  
constrained genericity. They als o show a serious limitation of these techniques: only  
syntactic constraints can be expr essed. All that a programmer m ay require is the presence of  
certain routines ( "<=" , "+", "" in the examples) with given t ypes; but the declarations are  
meaningless unless the routines a lso satisfy some semantic cons traints. Function minimum
only makes sense if  "<="  is a total order relation on G; and to produce a generic derivation  
of MATRICES  for a type G, you should make sure that operations "+" and "" have not just  
the right signature, G × G → G, but also the appropriate p roperties: associativity,  
distributivity, zero a zero element for "+" and unity  for "" etc. We may use the mathematical  
term ring for a structure equipped with operations enjoying these proper ties.
B.2  INHERITANCE
So much for pure genericity. The other term of the comparison i s inheritance. To contrast  
it with genericity, co nsider the example of a general-purpose m odule library for files. First  
here is the outline of an implementation of “special files” in the Unix sense, that is to say,  
files associated  with devices:
class DEVICE  feature
open (file_descriptor : INTEGER ) do … end
close do … end
opened : BOOLEAN
end
An example use of this class is:
d1: DEVICE ; f1: INTEGER ; …
create  d1  make ; d1  open (f1);
if d1  opened  then …
Consider next the notion of a ta pe device. For the purposes of this discussion, a tape  
unit has all the properties of de vices, as represented by the t hree features of class DEVICE , 
plus the ability to rewind its t ape. Rather than building a cla ss from scratch, we may use  
inheritance to declare class TAPE  as an extension-cum -modification of DEVICE . The new  
class extends DEVICE  by adding a new procedure rewind , describing a mechanism  
applicable to tapes but not nece ssarily to other devices; and i t modifies some of DEVICE ’s 
p r o p e r t i e s  b y  p r o v i d i n g  a  n e w  v e r s i o n  o f  open , describing the specifics of opening a  
device that happens to be a tape drive.
Objects of type TAPE  automatically possess all the features of DEVICE  objects, plus  
their own (here rewind ). Class DEVICE  could have more heirs, for example DISK  with its  
own specific features such  as direct a ccess read.This extract and the 
next few are in the  
O-O notation of the 
rest of this book .
GENERICITY VERSUS INHERITANCE  §B.2 1174
Objects of type TAPE  will possess all the features of type DEVICE , possibly adapted  
(in the case of open ), and complemented b y the new feature rewind .
With inheritance comes polymorph ism, permitting assignments of the form x := y, 
but only if the type of x is an ancestor of the type of y. The next associated property is  
dynamic binding: if x is a device, the call x  open (f1) will be executed differently  
depending on the assignments performed on x before the call: after x := y, where y is a tape,  
the call will execut e the tape version.
We have seen the remarkable bene fits of these inheritance techn iques for reusability  
and extendibility. A key aspect w as the Open-Closed principle: a software element such  
as DEVICE  is both usable as it stands (it  may be compiled as part of an executable system)  
and still amenable to extensions  (if used as an ancestor of new  classes).
Next come deferred features and classes. Here we note that Unix  devices are a special  
kind of file; so you may make DEVICE  an heir to class FILE , whose other heirs might  
include TEXT_FILE  (itself with heirs NORMAL  and DIRECTORY ) and BINARY_FILE . 
The figure shows the inher itance graph, a tree in this case.
Although it is possible to open o r close any file, how these op erations are performed  
depends on whether the file is a device, a directory etc. So FILE  is a deferred class with  
deferred routines open  or close , making descendant s responsible for implementing them:
deferred class FILE  feature
open (file_descriptor : INTEGER ) deferred  end
close deferred  end;
end
Effective descendants of FILE  will provide effective implementations of open
and close .This is approximate 
terminology; “is an 
ancestor of  ” stands for “conforms to”. 
Precise rules appear 
in earlier chapters.
A simple 
inheritance hierarchy , with 
deferred and 
effective classes∗
FILE
DEVICE
Inherits fromTEXT_FILE BINARY_
FILE
∗DeferredDEVICE BINARY_
FILEopen *
close *
§B.3   EMULATING INHERITANCE WITH GENERICITY 1175
B.3  EMULATING INHERITANCE WITH GENERICITY
To compare genericity with inher itance, we will study how, if i n any way, the effect of each  
feature may be emulated in a l anguage offering the other.
First consider a language such a s Ada (again meaning Ada 83), o ffering genericity  
but not inheritance. Can  it be made to achieve the effects of i nheritance?
The easy part is name overloading. Ada, as we know, allows reus ing the same routine  
name as many times as needed for  operands of dif ferent types; s o you can define types  
such as TAPE , DISK  and others, each wi th its own version  of the routines:
procedure  open (p: in out TAPE ; descriptor : in INTEGER );
procedure  close (p: in out DISK );
No ambiguity will arise if the r outines are distinguished by th e type of at least one  
operand. But this solution does not provide polymorphism and dy namic binding, whereby  
d  close , for example, would have a diffe rent effect after assignments d := di and d := ta, 
where di is a DISK  and ta a TAPE .
To obtain the same effect, you h ave to use records with variant  fields: define
type DEVICE (unit: DEVICE_TYPE ) is
record
… Fields common to all device types …
case unit is
when  tape => … fields for tape devices …;
when  disk => … fields for disk devices …;
… Other cases …;
end case
end record
where DEVICE_TYPE  is an enumerated type with elements tape, disk etc. Then there  
would be a single version of each the procedures on devices ( open , close  etc.), each  
containing a case disc rimination of the form
case d'unit  is
when  tape => … action for tape devices …;
when  disk => … action for disk devices …;
… other cases …;
end case
This uses explicit discriminatio n in each case, and closes off the list of choices,  
forcing every routine to know of all the possible variants; add ition of new cases will cause  
changes to all such routines. Th e Single Choice principle expre ssly warned against such  
software architectures.
So the answer to the question of  this section is essentially no :
Emulating inheritance
It appears impossibl e to emulate inherit ance through genericity .This extract and the 
next few are in Ada 
syntax .
See “Single Choice”, 
page 61 .
GENERICITY VERSUS INHERITANCE  §B.4 1176
B.4  EMULATING GENERIC ITY WITH INHERITANCE
Let us see if we will have more luck with the reverse problem: can we achieve the effect  
of Ada-style genericity  in an object-orient ed language with inh eritance?
The O-O notation introduced in ea rlier chapters does provide a generic parameter  
mechanism. But since we  are comparing pure genericity versus pu re inheritance, the rule  
of the game for some time, frustrating as it may be, is to pret end we have all but forgotten  
about that genericity mechanism. As a result the solutions pres ented in this section will be  
substantially more complex than those obtainable with the full notation, described in the  
rest of this book and in later s ections. As you read this secti on, remember that the software  
extracts are not final  forms, but for purpo ses of discussion on ly.
Surprisingly perhaps, the simulat ion turns out to be easier, or  at least less artificial,  
for the more sophisticated form of genericity: constrained. So we begin with this case.
Emulating constrained genericity: overview
The idea is to associate a class  with a constrained formal gene ric type parameter. This is a  
natural thing to do since a cons trained generic t y p e  m a y  b e  v i e wed, together with its  
constraining operations, as an a bstract data type. Consider for  example the Ada generic  
clauses in our two constrained examples, minimum and matrices:
generic
type G is private ;
with function "<="  (a, b: G) return BOOLEAN  is < >
generic
type G is private ;
zero: G; unity : G;
with  function  "+" (a, b: G) return G is < >;
with  function  "" (a, b: G) return G is < >;
We may view these clauses as the definitions of two abstract da ta types,  
COMP ARABLE  a n d  RING_ELEMENT ; the first is characterized by a comparison  
operation "<=" , and the second by features zero, unity , "+" and "".
In an object-oriented language, such types may be directly repr esented as classes. We  
cannot define these classes entir ely, for there is no universal  implementation of "<=" , "+"
etc.; rather, they are to be use d as ancestors of other classes , corresponding to actual  
generic parameters. Deferred clas ses provide exactly what we ne ed:
deferred class COMP ARABLE  feature
infix “<=” (other : COMP ARABLE ): BOOLEAN deferred  end
endThis extract is in Ada 
syntax .
This extract and all 
remaining ones are 
in the O-O notation 
of this book .
§B.4   EMULATING GENERICITY WITH INHERITANCE 1177
deferred class RING_ELEMENT  feature
 infix "+" (other : like Current ): like Current is
deferred
ensure
equal (other , zero ) implies equal (Result , Current )
end;
 infix "" (other : like Current ): like Current deferred  end
zero: like Current  deferred end
unity : like Current  deferred end
end
Unlike Ada, the O-O notation allo ws us here to express abstract  semantic properties,  
although only one of them has been included as an example (the property that x + 0 = x 
for any x, appearing as a postcondition of infix "+").
The use of anchored types ( like Current ) makes it possible to avoid some improper  
combinations, as explained for the COMP ARABLE example next. At this stage replacing  
all such types by RING_ELEMENT  would not affect the discussion.
Constrained genericity: routines
W e  c a n  w r i t e  a  r o u t i n e  s u c h  a s  minimum  b y  s p e c i f y i n g  i t s  a r g u m e n t s  t o  b e  o f  t y p e  
COMP ARABLE . Based on the Ada pattern, the  function would be declared as
minimum  (one: COMP ARABLE ; other : like one): like one is
-- Minimum of one and other
do … end
In O-O development, however, every routine appears in a class a nd is relative to the  
current instance of that class; we may include minimum  in class COMP ARABLE , argument  
one becoming the implicit current  instance. The class becomes:
deferred class COMP ARABLE  feature
infix "<=" ( other : like Current ): BOOLEAN  is
-- Is current object less than or equal to other ?
deferred
end
minimum (other : like Current ): like Current  is
-- Minimum of current object and other
do
if Current <= other then  Result  := Current else Result  := other end
end
end
To compute the minimum of two el ements, you must declare them o f some effective  
descendant  type of COMP ARABLE , for which infix  “<=” has been effected, such as“ANCHORED 
DECLARATION”, 16.7, page 598 .
COMP ARABLE  
becomes a “behavior class”, with an effec-tive feature relying on a deferred one. See “Don’t call us, we’ll call you”, page 504.
GENERICITY VERSUS INHERITANCE  §B.4 1178
class INTEGER_COMP ARABLE  inherit
COMP ARABLE
creation
put
feature -- Initialization
put (v: INTEGER )
-- Initialize from v.
do item  := new end
feature  -- Access
item: INTEGER ;
-- Value associated wi th current object
feature  -- Basic operations
infix "<=" ( other : like Current ): BOOLEAN
-- Is current object le ss than or equal to other ?
do Result  := (item <= other   item) end;
end
T o f i nd  th e m i n im u m  of  t w o i nt e ge rs ,  y ou m ay  now  ap pl y f un ct i on  minimum  t o 
entities ic1 and ic2, whose type is not INTEGER but INTEGER_COMP ARABLE :
ic3 := ic1  minimum (ic2)
T o use the generic infix "<=" and minimum  functions, you must renounce direct  
references to integers, using INTEGER_COMP ARABLE  entities instead; hence the need  
for attribute item and routine put to access and modify the ass ociated integer values. You  
will introduce a similar heirs of COMP ARABLE , such as STRING_COMP ARABLE , and 
REAL_COMP ARABLE , for each type requ iring a version of minimum .
Note that the mechanism of anchored declaration is essential to  ensure type  
correctness. If the argument to minimum  i n  COMP ARABLE  had been declared as a  
COMP ARABLE , rather than like Current , then the following call would be valid:
ic1  minimum (c)
even if c is a COMP ARABLE  but not an INTEGER_COMP ARABLE . Clearly, such a call  
should be disallowed. This also applies to the previous example , RING_ELEMENT .
Having to declare features item and put for all descendants of COMP ARABLE , and 
hence sacrificing the direct use of simple types, is unpleasant . There is also a performance  
cost: rather than manipulating in tegers or strings we must crea te and use wrapper objects
of types such as INTEGER_COMP ARABLE . But by paying this fixed price in both ease of  
use and efficiency we do achieve the full emulation of constrai ned genericity by inheritance.  
(In the final notation, of course , there will be no price at al l to pay.)
Emulating constrained genericity (1)
It is possible to emulate constr ained genericity through inheri tance, by using  
wrapper classes and the corr esponding wrapper objects.
§B.4   EMULATING GENERICITY WITH INHERITANCE 1179
Constrained genericity: packages
The previous discussion transpos es to packages. To emulate the matrix abstraction which  
Ada implemented through the MATRICES  package, we can use a class:
class MATRIX  feature
anchor : RING_ELEMENT do end
implementation : ARRAY2 [like anchor ]
item (i, j: INTEGER ): like anchor
-- Value of ( i, j) entry
do Result  := implementation   item (i, j) end
put (i, j: INTEGER ; v: like anchor )
-- Assign value v to entry ( i, j).
do implementation   put (i, j, v) end
infix "+" ( other : like Current ): like Current
-- Matrix sum of current matrix and other
local
i, j: INTEGER
do
create  Result   make (…)
from i := … until … loop
from  j := … until … loop
Result     put ((item (i, j) + other   item (i, j)), i, j)
j := j + 1
end
i := i + 1
end
end
infix "∗" (other : like Current ): like Current
-- Matrix product of current matrix by other
local  … do … end
end
The type of the argument to put and of the result of item raises an interesting  
problem: it should be RING_ELEMENT , but redefined properly in descendant classes.  
Anchored declaration is the solu tion; but here for the first ti me no attribute of the class  
seems to be available to serve as anchor. This should not stop us, however: we declare an  
artificial anchor , called anchor . Its only purpose is to be redefined to the proper  
descendant types of RING_ELEMENT  in future descendants of MATRIX  (that is to say, to  
BOOLEAN_RING  in BOOLEAN_MATRIX  etc.), so that all associated entities will follow.  
To avoid any space penalty in instances, anchor  is declared as a function rather than an  
attribute. This technique of art ificial anchors is useful to pr eserve type consistency when,  
as here, there is no “natural” a nchor among the attributes of t he class.
GENERICITY VERSUS INHERITANCE  §B.4 1180
A few loop details have been left out, as well as the body of infix "∗", but they are  
easy to fill in. Features put and item as applied to implementation  will come from the  
library class ARRAY2  describing two-di mensional arrays.
To define the equivalent of the Ada generic package derivation shown earlier
package BOOLEAN_MATRICES  is
new MATRICES (BOOLEAN , false , true, "or", "and");
we must first declare the “ring element” corresp onding to boole ans:
class BOOLEAN_RING_ELEMENT  inherit
RING_ELEMENT
redefine  zero , unity end
creation
put
feature -- Initialization
put (v: BOOLEAN )
-- Initialize from v.
do item := v end
feature -- Access
item: BOOLEAN
feature  -- Basic operations
infix "+" ( other : like Current ): like Current
-- Boolean addition: or
do create  Result   put (item or other   item) end
infix "∗" (other : like Current ): like Current
-- Boolean multip lication: and
do create  Result   put (item and other   item) end
zero: like Current
-- Zero element for boolean addition
once create  Result   put (False ) end
unity : like Current
-- Zero element for boolean multiplication
once create  Result   put (True) end
end
Note how zero and unity  are effected as once functions.
Then to obtain an equivalent to the Ada package derivation, jus t define an heir  
BOOLEAN_MATRIX  of MATRIX , where you only need to redefine anchor , the artificial  
anchor; all the other affected t ypes will follow automatically:
§B.4   EMULATING GENERICITY WITH INHERITANCE 1181
class BOOLEAN_MATRIX  inherit
MATRIX
redefine  anchor end
feature
anchor : BOOLEAN_RING_ELEMENT
end
This construction achieves the e ffect of constrained genericity  u s i n g  i n h e r i t a n c e ,  
confirming for packages  the emulation result initially illustra ted for routines.
Unconstrained genericity
The mechanism for simulating unc onstrained genericity is the sa me; we can simply treat  
this case as a special form of constrained genericity, with an empty set of constraints. As  
above, formal type parameters will  be interpreted as abstract d ata types, but here with no  
relevant operations. Th e technique works, but becomes rather he avy to apply since the  
dummy types do not corr espond to any obviou sly relevant data ab straction.
Let us apply the previous techniq ue to both our unconstrained e xamples, swap and  
queue, beginning wi th the latter. We need a class, say QUEUABLE , describing objects that  
may be added to and retrieved from a queue. Since this is true of any object, the class has  
no other property than its name:
class  QUEUABLE end
We may now declare a class QUEUE , whose operations apply to QUEUABLE
objects. (Remember that this class is not offered as a paragon of good O-O design: we are  
still voluntarily playing with a n impoverished version of the O -O notation, devoid of  
genericity.) Routine postconditio ns have been left out for brev ity. Although in principle  
function item could serve as an anchor, its bod y will not change in descendan ts, so it is  
better to use an artificial anchor item_anchor  to avoid having to redefine item.
note
description : "First-in-first out queues , implemented through arrays "
class  QUEUE creation
make
feature  -- Initialization
make (m: INTEGER )
-- Create queue with space for m items.
require
m >= 0
do
create  implementation   make (1, m); capacity  := m
first := 1; next  := 1
endSee the box on page 
1178 .
GENERICITY VERSUS INHERITANCE  §B.4 1182
feature  -- Access
capacity , first, next , count : INTEGER
item: like item_anchor
-- Oldest element in queue
require
not empty
do
Result  := implementation   item (first)
end
feature -- Status report
empty : BOOLEAN
-- Is queue empty?
do Result  := (count = 0) end
full: BOOLEAN
-- Is representation full?
do Result  := (count = capacity ) end
feature -- Element change
put (x: like item_anchor )
-- Add x at end of queue
require
not full
do
implementation   put (x, next); count  := count + 1 ; next := successor (next)
end
remove
-- Remove oldest element
require
not empty
do
first := successor (first); count  := count – 1
end
§B.4   EMULATING GENERICITY WITH INHERITANCE 1183
feature  {NONE } -- Implementation
item_anchor : QUEUABLE do end
implementation : ARRAY [like item_anchor ]
successor (n: INTEGER ): INTEGER
-- Next value after n, cyclically in the interval 1 . . capacity
require
n >= 1; n <= capacity
do
Result  := (n \\ capacity ) + 1
end
invariant
0 <= count ; count <= capacity ; first >= 1; next >= 1
(not full) implies ((first <= capacity ) and (next <= capacity ))
(capacity = 0) implies full
-- Items, if any, appear in array positions first, … next – 1 (cyclically)
end
Bounded queue implementations elsewhere in this book rely on th e technique of keeping  
one position open. Here, we allocate capacity  elements and keep track of count . There is  
no particular reason, other than to illustrate alternative impl ementation techniques.
To get the equivalent of generic  derivation (so as to obtain qu eues of a specific type)  
you must, as with the COMP ARABLE example, define descendants of QUEUABLE :
class INTEGER_QUEUABLE  inherit
QUEUABLE
creation
put
feature -- Initialization
put (n: INTEGER )
-- Initialize from n.
do item  := n end
feature -- Access
item: INTEGER
feature {NONE } -- Implementation
item_anchor : INTEGER do end
end
and similarly STRING_QUEUABLE  etc.; then declare the co rresponding descendants of  
QUEUE , redefining item_anchor appropriately in each.
Emulating unconstrained genericity
It is possible to emulate unconstrained genericity through inhe ritance, by  
using wrapper classe s and the correspond ing wrapper objects.For an alternative 
technique see e .g. “A 
buffer is a separate queue”, page 990 .
GENERICITY VERSUS INHERITANCE  §B.5 1184
B.5  COMBINING GENERIC ITY AND INHERITANCE
It appears from the previous dis cussion that inheritance is the  more powerf ul mechanism  
since we have not found a reasona ble way to simulate it with ge nericity. In addition:
• You can express the equivalent o f generic routines or packages  in a language with  
inheritance, but this requires some duplication and complicatio n. The verbosity is  
particularly hard to justify for  unconstrained genericity, whic h requires just as much  
emulation effort even though it is theoretically simpler.
• Type checking introduces difficulties in the use of inheritanc e to emulate genericity.
Anchored declaration solves the second problem. (The reader fam iliar with the  
detailed discussion of typing in  an earlier chapter will, howev er, have noted the potential  
for system validity problems, wh ich we do not need to explore f urther since they will  
disappear in the solutions finally retained below.)
Let us see how we can solve the first problem by introducing (r eintroducing, that is)  
the appropriate form of genericity.
Unconstrained genericity
Since the major complication aris es for unconstrained genericit y even though it should be  
the simpler case, it seems adequ ate to provide a specific gener icity mechanism for this  
case, avoiding the need to rely o n inheritance. Consequently, w e allow our classes to have  
unconstrained generic parameters: as we are now (at last) allow ed to remember from  
earlier chapters, a cla ss may be defined as
class  C [G, H, …] …
where the parameters represent a rbitrary types. To obtain a dir ectly usable type you use a  
generic derivation, u sing types as actual generic parameters:
x: C [DEVICE , RING_ELEMENT , …]
This immediately applies to the queue class, which we can simpl y declare as
note
description : "First-in-first out queues , implemented through arrays "
class  QUEUE [G] creation
… The rest as before , but removing the declaration of item_anchor
      and replacing all o ccurrences of type like item_anchor by G …
end
We get rid of class QUEUABLE as well as INTEGER_QUEUABLE  and other such  
descendants; to have a queue of integers, we simply use type QUEUE [INTEGER ], 
manipulating integers directly rather than through intermediate  wrapper objects.
This is a remarkable simplificat ion, suggesting that in spite o f the theoretical  
possibility of emulating unconstrained genericity through inher itance, it is desirable in  
practice to introduce a generic mechanism into the object-orien ted framework.Chapter 17.
§B.5   COMBINING GENERICITY AND INHERITANCE 1185
Constrained genericity
For constrained genericity we can explore the same general sche me. In the matrix example:
class MATRIX [G] feature
anchor : RING_ELEMENT [G]
…Other features as before …
end
with ring elements now declared as
deferred class RING_ELEMENT [G] feature
item: G
put (new: G) do item  := new end
…Other features as before …
end
Using the same a generic parameter in two related classes, RING_ELEMENT  and 
MATRIX , ensures type consistency: all the elements of a given matrix will be of type  
RING_ELEMENT [G] for the same  G.
We can similarly make class COMP ARABLE  generic:
deferred class COMP ARABLE [G] feature
item: G
put (new: G) do item  := new end
 
…Other features ( infix "<=", minimum ) as before … 
end
The features of the class ( infix "<=", minimum ) represent the constraints (the with 
routines of the Ada form). The e arlier descendants become extre mely simple:
class INTEGER_COMP ARABLE inherit
COMP ARABLE [INTEGER ]
creation
put
end
(Note that this is the whole class, not a sketch with features to be added!) The same scheme  
immediately applies to all  other variants such as STRING_COMP ARABLE .
The technique is indeed fairly s imple to apply, leading to one more emulation principle:Providing unconstrained genericity
Along with inheritance, it is des irable to provide a specific n otation for  
declaring classes as gen eric (unconstrained).
GENERICITY VERSUS INHERITANCE  §B.5 1186
But we are again paying a price:  we need to reintroduce wrapper  classes such as  
INTEGER_COMP ARABLE . This is less shockin g than in the earlier solution, because t hen 
we had to pay that price for the  unconstrained case as well, ev en though it is conceptually  
very simple. Here it seems easier  to justify the need for wrapp er classes and objects since  
constrained genericity is a re latively sophisticated idea.
Based on these observations, the  notation of this book and comp ilers for it did not  
initially — for a little over tw o years, late 19 85 to early 198 8 — have speci al support for  
constrained genericity. The first edition of this book mentione d the possibility of such  
support, proposing as an exercis e the exact design of an approp riate language  construct.  
But it did not take very long aft erwards to realize that most a pplications were not ready to  
pay the price of wrapper classes and objects, and to integrate the exercise’s solution into  
the notation; the compilers soon followed.
The notation in question is, of c ourse, the one earlier chapter s have used to specify  
constrained genericity, as in
class MATRIX [G –> RING_ELEMENT ] …
and
class SORTABLE_LIST [G –> COMP ARABLE ] …
where RING_ELEMENT and COMP ARABLE are the original versions, deferred and non-
generic. As noted in the first pr esentation of this notation in  an earlier chapter, it is a  
remarkable combination of generic ity and inheritance, avoiding all the extra baggage of  
earlier solutions:
• We do not need, like Ada, to us e routines as generic parameter s (with  clauses). Only  
types can be generic parameters; this is simple, consistent and  easy to learn.
• We do not need any special wrapp er classes and objects. If you  want a matrix of  
integers, you declare it as MATRIX [INTEGER ] and use plain integers to set and  
retrieve its elements; if you wa nt a sortable list of strings, you declare it as  
SORTABLE_LIST [STRING ] and use plain strings.
The semantics, as you will remember, is that G represents not an arbitrary type any  
more, but a type that must confo rm to the constraint (be based on a descendant class). A  
generic derivation such as MATRIX [T] is valid if and only if T is such a type; this is true  
of INTEGER  but not, for example, of STRING . Similarly, STRING  will inherit from  
COMP ARABLE and hence will be acceptable as an actual generic parameter for  the class  
SORTABLE_LIST ; but this is not true of a class COMPLEX (for complex numbers) which  
has no associated order relation. The symbol –> was chosen, as you will also remember,  
to evoke the arrow of inheritance  diagrams.Emulating constrained genericity (2)
It is possible to emulate constrained genericity through inheri tance and  
unconstrained generici ty, by using wrapper classes and the corr esponding  
wrapper objects.
Exercise 19 .5, page 
422 of [M 1988].  
Later printings men-tioned that the exten-sion had been integrated into the language.
§B.6   KEY CONCEPTS INTRODUCED IN THIS APPENDIX 1187
A s  a  l a s t  d e t a i l ,  y o u  w i l l  r e m e m ber that in this scheme constra ined genericity  
becomes the more basic facility:  the unconstrained case, as in QUEUE [G], is understood  
as an abbreviation for QUEUE [G –> ANY ] where ANY denotes the class that serves as  
ancestor to all developer-defined classes. This has the consequ ence of defining precisely  
the operations applicable to G: those, coming from ANY, which are applicable to all  
classes, including general-purpose features such as clone , print  and equal .
The introduction of constrained g enericity provid es the final t ouch to the delicate  
combination of inheritance and ge nericity detailed in this chap ter. I hope that you will find  
the result consistent, elegant, and minimal  in the sense that although no component of the  
edifice is redundant (as it shou ld indeed always be immediately  clear, for any particular  
circumstance, which of the vari ous possibilities is the appropr iate one), removing any one  
of them would lead us to one of the situations that we found un acceptable or unpleasant  
in the earlier sections of this a ppendix: unaccep table because we cannot do what we want,  
as when we were trying to emulat e inheritance wi th genericity; unpleasant when we could  
do what we want but at the price of such complications as the u se of artificial wrapper  
classes and inefficient wrapper objects. The proper combination  of inheritance and  
genericity should help make our choices not only acceptable but  pleasant too.
B.6  KEY CONCEPTS INTRODUCED IN THIS APPENDIX
• Both genericity and i nheritance aim to increase the flexibilit y of software modules.
• Genericity is a static techniqu e, applicable in O-O and non-O- O contexts, permitting  
the definition of modules parameterized by types.
• There are two forms of generic ity: unconstrained, imposing no requirements on the  
parameters; constrained, requiri ng parameters to be equipped wi th specific operations.
• Inheritance permits incremental module construction, by extens ion and  
specialization. It ope ns the way to polymor phism and dynamic bi nding.
• It does not seem possible to ob tain the power o f inheritance t hrough genericity.
• Pure inheritance can be used to emulate genericity, but at the  expense of heaviness  
in expression, performa nce penalties (mostly space) and type di fficulties.
• A good compromise is to combine the full power of inheritance and redefinition with  
genericity, at least in its unconstrained form. This is achieve d by permitting classes  
to have generic parameters.
• It is also desirable to provide constrained genericity , which relies on the notion of  
type conformance, itse lf following from inhe ritance. Unconstrai ned genericity can  
then be viewed as a special ca se, using the universal class ANY as the constraint.
• The resulting construction seems elegant and minimal.Providing constrained genericity
Along with unconstrained generici ty, it is desira ble to provide  constrained  
genericity by relying on inherit ance rules (through the notion of type  
conformance) to define constraints  on permissible actual generi c parameters.
GENERICITY VERSUS INHERITANCE  §B.7 1188
B.7  BIBLIOGRAPHICAL NOTES
The material for this chapter or iginated with an article at the  first OOPSLA conference  
[M 1986] . The Trellis language [Schaffert 1986]  also offered the comb ination of multiple  
inheritance with constrained  and unconstrained genericity.
EXERCISES
E-B.1  Artificial anchors
The artificial anchor  anchor  is declared as an attribute of class MATRIX  and thus entails a  
s m a l l  r u n - t i m e  s p a c e  o v e r h e a d  i n  i n s t a n c e s  o f  t h e  c l a s s .  I s  i t  possible to avoid this  
overhead by declaring anchor  as a “once function”, whose bo dy may be empty since it will  
never need to be evaluated? ( Hint : consider type rules.)
E-B.2  Binary trees and binary search trees
Write a generic “binary tree” class BINARY_TREE ; a binary tree (or binary node) has  
some root information and two op tional subtrees, left and right . Then consider the notion  
of “binary search tree” where a new element is inserted on the left of a given node if its  
information field is less than or equal to the information of t hat node, and to the right  
otherwise; this assumes that the re is a total order relation on  “informations”. Write a class  
BINARY_SEARCH_TREE  implementing this notion, as a descendant of BINARY_TREE . 
Make the class as general as possible, and its use by a client,  for an arbitrary type of  
“informations” with th eir specific order re lation, as easy as p ossible.
E-B.3  More usable matrices
Add to the last version obtained for class MATRIX  two functions, one for access and one  
for modification, which in contrast to item and put will allow clients to manipulate a matrix  
of type MATRIX [G] in terms of elements of type G rather than RING_ELEMENT  [G].
E-B.4  Full queue implementations
Expand the queue example by defining a deferred class QUEUE , completing the class of  
this chapter (now called ARRAYED_QUEUE , inheriting from QUEUE  and ARRAY , and 
with proper postconditio ns), and adding a class LINKED_QUEUE  for the linked list  
implementation (based on inheritance from LINKED_LIST  and QUEUE ).
C  
Principles, rules, precepts and 
definitions
Absolute Negatives methodology principle  667
Absolute Positives methodology principle  667Ada Exception rule  416ADT specification of stacks  139Advanced Curriculum principle  936Advisory Rules methodology principle  668
Assertion Argument rule  997
Assertion Evaluation rule  403Assertion Redeclaration rule (1)  573Assertion Redeclaration rule (2)  578Assertion Violation rule (1)  346Assertion violation rule (2)  347Business Card principle  990Canonical Reduction rule  158Catcall type rule  637Choosing between client and inheritance  817Class Consistency principle  730Class Elicitation principle  725Class Name rule  727Class-ADT Consis tency property  375
Classification  of methodological rules  666
Command-Query Separation principle  751Composite Feature Name rule  879Consumer-to-producer strategy  943Correctness rule for failu re-inducing rescue clauses  429
Correctness rule for retry -inducing rescue clauses  429
Creation Inheritance rule  466Default initialization values  233Deferred class declaration rule  486Deferred Class No-Instantiation rule  487Definition: abstract side effect  757Definition: ADT consistency  155Definition: attachment  262Definition: CAT (Changing Availability or Type)  638Definition: Catcall  638
Definition: class correctness  370
Definition: class  142Definition: class  165Definition: client, supplier  182
PRINCIPLES, RULES, PRECEP TS AND DEFINTIONS  §C 1190
Definition: compatibility  8
Definition: concrete side effect  749Definition: conformance  474Definition: correct ADT expression  154
Definition: correctness  4
Definition: deferred, effective class  142Definition: deferred, effective class  486Definition: direct dependents, dependents  250Definition: direct instance, instance  475
Definition: ease of use  11
Definition: efficiency  9Definition: entity  213Definition: exception cases  413Definition: exception  412
Definition: expanded type  255
Definition: extendibility  6Definition: extension inheritance  826Definition: facility inheritance  832Definition: failure cases  414
Definition: final name  549
Definition: functional and type variation inheritance  829Definition: functionality  12Definition: implementation inheritance  832Definition: object  218
Definition: operand and option arguments  766
Definition: origins, reacha ble and unreachable objects  290
Definition: Polymorphic call  638Definition: Polymorphic entity  637Definition: portability  11
Definition: processor  964
Definition: redeclaration  485Definition: reference  224Definition: referential transparency  750Definition: reification inheritance  831
Definition: restriction inheritance  826
Definition: reusability  7Definition: robustness  5Definition: satisfiable call  1026Definition: statically typed language  612
Definition: structure inheritance  831
Definition: subtype inheritance  825Definition: sufficient completeness  155Definition: system closure  196Definition: system execution  195
Definition: timeliness  14
Definition: transition from analys is (specification) to design  150
Definition: tree  526Definition: type violation  612Definition: uneffecting inheritance  830
Definition: weight  157
Definitions: success, failure  412Disciplined Exception Handling principle  417
§C   PRINCIPLES, RULES, PRECEPTS AND DEFINTIONS 1191
Discrimination principle  655
Documentation principle  804Dynamic Binding principle  511Effect of a basic creation instruction  233
Effect of a creation call  237
Effect of calling a feature f on a target x  184Emulating constrained genericity (1)  1178Emulating constrained genericity (2)  1186Emulating inheritance  1175
Emulating unconstrained genericity  1183
Exception Simplicity principle  434Exceptions Included methodology principle  669Expanded Client rule  259
Failure principle  420
Failures and exceptions  413Feature Call principle  186Feature Call rule  473Fixing What Is Broken methodology principle  671
Garbage collector properties  305
Genericity in Repeated Inheritance rule  562Goals of performing analysis  904How the module-type merge works  185
How to distinguish options from operands  767
Inheritance rule  822Inheritance Simplicity rule  823Inheritance terminology  464Initial training: the “hit them twice” strategy  935
Invariant inheritance rule  465
Invariant rule  366“Is-a” rule of inheritance  811Law of inversion  684Linguistic Modular Units principle  53
Manager Training principle  937
Meaning of a correctness  formula {P} A {Q}  335
Name clashes: definition and rule  562Non-Redundancy principle  343
Non-strict boolean operators  454
OBJECT MOTTO  116Object rule  171Object-oriented software construction (definition 1)  116Object-oriented software construction (definition 2)  147
Object-oriented typing problem  612
Once Function rule  653Open-Closed principle  57Operand principle  767
Parents’ Invariant rule  570
Persistence Closure principle  252Polymorphism rule  817Practical Basis methodology principle  665Precondition Availability rule  358
Providing constrained genericity  1187
PRINCIPLES, RULES, PRECEP TS AND DEFINTIONS  §C 1192
Providing unconstrained genericity  1185
Qualified Call rule  447Real systems have no top.  108Reasonable Precondition principle  356Repeated Inheritance rule  546Reuse Experience methodology principle  666Reuse Path principle  70Role of genericity  97Role of overloading  94Rule of change  816Select rule  555Selective Export Inheritance rule  609Self-Documentation principle  54Semicolon Style principle  899Semicolon Syntax rule  898Separate Call rule  985Separate call semantics  996Separateness consistency rule (1)  973Separateness consistency rule (2)  974Separateness consistency rule (3)  975Separateness consistency rule (4)  975
Shopping List advice  772
Sinecure 1  336Sinecure 2  336Single Choice principle  63Single Name rule  549Single Target principle  184Software Correctness property  333STACK AXIOMS  157Static-dynamic type consistency  475Symbolic Constant principle  884System Validity rule  634Taxomania rule  820Terms to denote software woes  347The reusability culture  929Theoretical Basis methodology principle  665Training Topics principle  936Type Conformance rule  474Type Redeclaration rule  598Typing and binding  619Uniform Access principle  57Universal Class rule  580Use Case principle  739User Interface Design principle  12Uses of entities of a formal generic type  324Wait by necessity  989Weight Consistency rule  156Zero Weight rule  157
D  
A glossary of object technology
This glossary provides brief definitions of the principal terms  of object technology,  
discussed in detail in the rest of this book. Italics font in a definition marks a term or phrase,  
other than the ubiquitous “class” and “object”, that  is itself the subject of another definition.
Abstract class
See deferred class .
Abstract data type (ADT)
A set of mathematical elements s pecified by listing the functio ns applicable to all  
these elements and the formal properties of these functions.
Abstract object
An element of an ADT .
Ancestor (of a class)
The class itself, or one of its  direct or indirect parents.
Assertion
A formal condition describing th e semantic properties of softwa re elements,  
especially routines and lo ops. Used in expressing contracts . Assertions include in  
particular preconditions , postconditions , class  invariants  and loop invariants .
Assignment attempt
An operation that conditionally attaches an object to a referen ce, only if the object’s  
type conforms  to the type declared for the corresponding entity .
Asynchronous call
A call which lets its caller proceed before it completes. Anton ym: synchronous call .
Attribute
The description of a field p r e s e n t  i n  a l l  t h e  i n s t a n c e s  o f  a  c l a s s .  A l o n g  w i t h  t h e  
routine , one of the two forms of feature .
Behavior class
A class, usually deferred , describing a set of adap table behaviors through effective
routines  relying on some com ponents (usually deferred features ) that may be  
redeclared to capture specific variants  of the general behaviors.
A GLOSSARY OF OBJECT TECHNOLOGY  §D 1194
Class
A partially or totally implemented abstract data type. Serves b oth as a module  and as  
a type (or type pattern i f the class is generic .)
Class invariant
An assertion  which must be satisfied on crea tion of every instance of a cla ss, and  
preserved by every exported rout ine of the class, so that it wi ll be satisfied by all  
instances of the class  whenever they are ext ernally observable.
Client
A class that uses the features of another, its supplier , on the basis of the supplier’s  
interface specification ( contract ).
Cluster
A group of related cla sses or, recursively , of related clusters .
Component
See reusable software component .
Concurrent
Able to use two or more processors . Antonym: sequential .
Conformance
A relation between types. A type c onforms to another if it is d erived from it by  
inheritance.
Constrained genericity
A form of genericity  where a formal generic parameter represents not an arbitrary  
type, but one that is required to conform  to a certain type, known as the constraint.  
See constrained genericity .
Container data structure
An object  w h o s e  p r i m a r y  u s e  i s  t o  p r o v i d e  a c c e s s  t o  a  n u m b e r  o f  o t h e r  o b jects. 
Examples include lists, queues, stacks, arrays.
Contract
The set of precise conditions th at govern the relations between  a supplier  class and  
its clients . The contract for a class inclu des individual contracts for th e exported  
routines of the class, represent ed by preconditi ons and postcon ditions, and the global  
class properties, represented by  the class invari ant. See also Design by Contract .
Contravariance
The policy allowing a feature redeclaration  to change the signature  so that a new  
result type will conform  to the original but the original argument types conform to  
the new. See also: covariance , novariance .
Covariance
The policy allowing a feature redeclaration  to change the signature  so that the new  
types of both arguments and result conform  to the originals. See also: contravariance , 
novariance .
Current object (or: current instance)
During the execution of an object -oriented software system, the  target of the most  
recently started  routine call.
§D   A GLOSSARY OF OBJECT TECHNOLOGY 1195
Defensive programming
A technique of fighting potential  errors by making every module  check for many  
possible consistency co nditions, even if th is causes redundancy  of checks performed  
by clients  and suppliers . Contradicts Design by Contract .
Deferred class
A class which has at least one deferred  feature . Antonym: effective  class .
Deferred feature
A feature which, in a certain class, has a specification but no  implementation. May  
be declared as deferred in the class itself, or inherited as de ferred and not effected  in 
the class. Antonym: effective  feature .
Descendant (of a class)
The class itself, or one of i ts direct or indirect heirs.
Design by Contract
A method of software c onstruction that desig ns the components o f a system  so that  
they will cooperate on the basis of precisely defined contracts . See also: defensive  
programming.
Direct instance (of a class)
An object built acco rding to the mold defined by the class.
Dynamic
Occurring during th e execution of a system . See also run time . Antonym: static .
Dynamic binding
The guarantee that eve ry execution of an operation will select the correct version of  
the operation, based on the type  of the operation’s target.
Dynamic typing
The policy whereby applicability of operations to their target objects is only checked  
at run time, pri or to executing each operation.
Effect
A class effects a feature if it inherits it in deferred  form and provides an effecting
for that feature.
Effecting
A redeclaration  w h i c h  p r o v i d e s  a n  i m p l e m e n t a t i o n  ( a s  attribute  o r  routine ) of a  
feature inherited in deferred  form.
Effective class
A class which only has effective  features  (that is to say, does not introduce any  
deferred  feature , and, if it inherits any deferred feature, effects it). Antony m: 
deferred  class .
Effective feature
A feature declared with an implementation — either as a routine  w h i c h  i s  n o t  
deferred , or as an attribute . Antonym: deferred  feature .
Encapsulation
See information hiding .
A GLOSSARY OF OBJECT TECHNOLOGY  §D 1196
Entity
A name in the softwa re text that denotes  a run-time value ( object  or reference ).
Event-driven computation
A style of software c onstruction where developers define the co ntrol structure by  
listing possible exter nal events and the system’s response to e ach of them, rather than  
by specifying a pre-orda ined sequence of steps.
Exception
The inability of a routine to achieve its contract  through one of its possible strategies.  
May result in particular from a failure  of a routine called by th e original routine. Will  
be treated as resumption , organized  panic  or false  alarm .
Exporting a feature
Making the feature available to clients . Exports may be selectiv e (to specified classes  
only) or general.
Extendibility
The ability of a softwa re system to be changed easily in respon se to different choices  
of requirements, archi tecture, algorithms or data structures.
Failure
The inability of a routine’s execution to fulfill the routine’s  contract . Must trigger  
an exception .
False alarm
Along with resumption  and organized  panic , one of the three possible responses to  
an exception ; resumes the execution  of the current strategy, possibly after  taking  
some corrective action.
Feature renaming
The attribution, by a class, of a new name to an inherited feat ure, not changing any  
other proper ty. See also redeclaration.
Field
One of the values making up an object .
Function
A routine which return s a result. (The othe r form of routine is  the procedure .)
Garbage collection
A facility provided by the runtime  to recycle the memory s pace used by objects that  
have become useless. Garbage col lection is automatic, that is t o say does not require  
any change to the text of the systems  whose objects are  being recycled.
Generalization
The process of turning specializ ed program elements into genera l-purpose, reusable  
software components.
Generating class
Same as generator .
Generator (of an object)
The class of which the object is a direct  instance .
§D   A GLOSSARY OF OBJECT TECHNOLOGY 1197
Generic class
A class having formal parameters representing types. Such a cla ss will yield a type  
only through generic  derivation .
Generic derivation
The process of providing a type for each formal generic paramet er of a generic  class , 
yielding a type as a result.
Genericity
The support, by a software notati on, for type-parameterized mod ules; specifically, in  
an O-O notation, for generic  classes . Can be unconstrained  or constrained .
Heir (of a class)
A class that inherits from the given class. Antonym: parent .
Identity
See object identity .
Information hiding
The ability to prevent certain aspects of a class from being ac cessible to its clients,  
through an explicit exporting  policy and through reliance on the short  form  as the  
primary vehicle for class documentation.
Inheritance
A mechanism whereby a class is defined in reference to others, adding all their  
features to its own.
Instance (of a class)
An object built according to the mold defined by the class or a ny one of its proper  
descendants. See also direct instance , proper descendant , generator .
Instance variable
Smalltalk term for attribute.
Interface (of a class)
See contract , abstract data type .
Invariant
See class invariant , loop invariant .
Iterator
A control structure de scribing preordained sequencing of some a ctions but not  
defining the actions themselves.  Iterators often apply to data structures, such as an  
iterator describing the trav ersal of a list or a tree.
Loop invariant
An assertion  w h i c h  m u s t  b e  s a t i s f i e d  p r i o r  t o the first execution of a loop , and 
preserved by every iteration, so that it will hold on loop term ination.
Loop variant
An integer expression which must  be non-negative prior to the f irst execution of a  
loop, and decreased by every ite ration, so that it will garante e loop termination.
Message
Routine call.
A GLOSSARY OF OBJECT TECHNOLOGY  §D 1198
Metaclass
A class whose instances are classes themselves.
Method
Smalltalk term for routine.
Module
A unit of software decomposition . In the object-oriented approa ch, classes provide  
the basic form of module.
Multiple inheritance
The unrestricted form of inherit ance, whereby a class may have any number of  
parents. Antonym: single inheritance .
Non-separate
Antonym of separate .
Novariance
The policy allowing pro hibiting any feature redeclaration  from changing the  
signature . See also: contravariance , covariance .
Object
A run-time data structure made o f zero or more values, called fields , and serving as  
the computer representation of an abstract  object . Every object is an instance of  
some class.
Object identity
A property that uniquely identif ies an object independently of its current contents  
(fields ).
Object-oriented
Built from classes , assertions , genericity , inheritance , polymorphism  and dynamic
binding .
Object-oriented analysis
The application of object-oriented  concepts to the modeling of problems and  
systems from both software and non-software domains.
Object-oriented database
A repository of persistent objects , permitting their storage  and retrieval on the basis  
of object-oriented  concepts, and supporting databas e properties such as concurren t 
access, locking and transactions.
Object-oriented design
The process of building the architecture of systems  through object-oriented  concepts.
Object-oriented implementation
The process of building executa ble software systems through object-oriented
concepts. Differs from object-oriented design  primarily by the level of abstraction.
Organized panic
Along with resumption  and false  alarm , one of the three pos sible responses to an  
exception ; abandons the execution of the current strategy, triggering an  exception in  
the caller, after restoring the  class invariant  for the current  object .
§D   A GLOSSARY OF OBJECT TECHNOLOGY 1199
Overloading
The ability to let a feature name  denote two or more operations .
Package
A module of non-object-oriented languages such as Ada, providin g encapsulation of  
a set of variabl es and routines.
Parallel
See concurrent .
Parameterized class
See generic class .
Parent (of a class)
A class from which the given class inherits. Antonym: heir.
Persistence
The ability of a software development environment or language t o make objects  
persistent  and support the retrieval of persistent objects for use by sys tems.
Persistent object
An object that (through storage in a file or database or transm ission across a network)  
survives executi ons of systems that creat e or manipulate it. An tonym: transient
object .
Polymorphic data structure
A container data structure  hosting objects of two or more possible types.
Polymorphism
The ability for an element of th e software text to denote, at r un time, objects of two  
or more possible types.
Postcondition
An assertion  attached to a routine, which mus t be guaranteed by the routine ’s body  
on return from any call to the routine if the precondition  was satisfied on entry. Part  
of the contract  governing the routine.
Precondition
An assertion  attached to a routine, which mu st be guaranteed by every clien t prior to  
any call to the rou tine. Part of the contract  governing the routine.
Predicate
See assertion .
Procedure
A routine which does not return a result. (The o ther form of ro utine is the function .)
Processor
A mechanism providing a single t hread of computation. May be a physical  
device, such as the CPU of a computer, or a software device, su ch as a task or  
thread of an ope rating system.
Program
See system .
A GLOSSARY OF OBJECT TECHNOLOGY  §D 1200
Proper ancestor (of a class)
A direct or indirect p arent of the class.
Proper descendant (of a class)
A direct or indirect  heir of the class.
Redeclaration
A feature declaration which, ins tead of introducing a new featu re, adapts some  
properties (such as the signature , precondition , postcondition , implementation,  
deferred/effective status, but not the name) of  a feature inherited from a parent . A 
redeclaration may be a redefinition  or an effecting . See also feature renaming .
Redefinition
A redeclaration  which is not an effecting , that is to say, changes some properties of  
a feature inherited as effective , or changes the  specification of a feature inherited as  
deferred  while leaving  it deferred.
Reference
A run-time value that uniquely identifies an object.
Renaming
See feature renaming .
Retrying
Along with organized  panic  and false  alarm , one of the three possible responses to  
an exception ; tries a new strategy for  achieving the routine’s contract .
Reusability
The ability of a software develo pment method to yield software elements that can be  
used in many different  applications, and to support a software development process  
relying on pre-existing reusable  software  components .
Reusable software component
An element of software  that can be used by many different appli cations.
Reversible d evelopment
A software development process t hat lets insights gained in lat er phases affect the  
results obtained in earlier phases. Normally part of a seamless development  process.
Root class
The generator  of a system’s root object . Executing the system means creating an  
instance of the root class (the root object), and calling a cre ation procedure on that  
instance.
Root object
The first object created in t he execution of a system.
Routine
A computation defined in a class,  and applicable to the instanc es of that class. Along  
with the attribute , one of the two forms of feature .
Runtime (noun, one word)
Any set of facilities supporting the execution of systems. See also next entry.
§D   A GLOSSARY OF OBJECT TECHNOLOGY 1201
Run time  (noun, two words)
The time when a system  is being executed. Also used as an adjective, with a hyphen,  
as in “the run-time value of an entity ”. See also dynamic  and previous entry.
Schema evolution
Change to one or more classes of which some persistent  instances exist.
Seamless development
A software development process which uses a uniform method and notation  
throughout all activiti es, such as problem modeling and analysi s, design,  
implementation and maintenance. See also reversible development .
Selective export
See exporting a feature .
Separate
Handled by a different processor . Antonym: non-separate.
Sequential
Running on only one processor . Antonym: concurrent .
Short form (of a class)
A form of class documentation generated from the class text, sh owing only interface  
properties of the class. The  short form documents the contract  attached to the class  
and the underlying abstract  data type.
Signature (of a feature)
The type part of the feature’s s pecification. For an attribute or a function, includes  
the result type; for a routine, includes the number of argument s and the type of each.
Single inheritance
A restricted form of in heritance whereby each class may have at  most one parent.  
Antonym: multiple inheritance .
Software component
See reusable software component .
Specification (of a class)
The short  form  of the class.
Specification (of a feature)
The properties of a feature that are relevant to a client. Incl udes the name, signature , 
header comment and contract  of the feature.
Subcontract
The ability of a class to let some proper descendant  handle some of its feature calls,  
thanks to redeclaration  and dynamic  binding .
Supplier
A class that provides another, its client , with features to be use d through an interface  
specification ( contract ).
Static
Applying to the text of a system , not to a particular execution. Antonym: dynamic .
A GLOSSARY OF OBJECT TECHNOLOGY  §D 1202
Static binding
The premature choice of operatio n variant, resulting in possibl y wrong results and  
(in favorable cases) run-time system crash.
Static typing
The ability to check, on the bas is of the software text alone, that no execution of a  
system will ever try to apply to an object an operation that is  not applicable to that  
object.
Synchronous call
A call which forces the caller t o wait until it completes. Anto nym: asynchronous  
call.
System
A set of classes that can be assembled to produce an executable  result.
Template
C++ term for generic class  (for unconstrained genericity  only).
Traitor
A reference to a separate  object, associated in the software text with an entity  that is  
declared as no n-separate.
Transient object
An object that exists only during the execution of the system t hat creates it.  
Antonym: persistent  object .
Type
The description of a set of objects equipped with certain opera tions. In the object-
oriented approach every type is based on a class.
Type checking, typing
See static typing , dynamic typing .
Unconstrained genericity
A form of genericity  where a formal generi c parameter represents  an arbitrary type.  
See constrained  genericity .
Variant
See loop variant .
E  
Bibliography
This bibliography has two parts: works by other authors; works by the author of the present book. See also, in the  
chapter on inheritance methodol ogy (page 868), a list of refere nces on classification in the  biological sciences.
E.1  WORKS BY OTHER AUTHORS
[Abrial 1980] 
Jean-Raymond Abrial: The Specification Language Z : Syntax and "Semantics ", Oxford University Computing  
Laboratory, Programming Research G roup Technical Report, Oxford , April 1980. 
[Abrial 1980a]
Jean-Raymond Abrial, Stephen A.Schuman and Bertrand Meyer: A Specification Language , in On the  
Construction of Programs , eds. R. McNaughten and R.C. McKea g, Cambridge University Pres s, 1980.
[Ada 95-Web]
Ada 95 Reference Manual : Language and Standard Library , on-line at http://lglwww .epfl.ch/Ada/LRM /9X/
rm9x /rm9x-toc .html.
[ADB 1995]
Matisse 2 .3 Tutorial , Report DE/95/03/0022-M2DOC-TUA, ADB S.A., Paris, January 1995 .
[Agha 1986]
Gul Agha: ACTORS : A Model of Concurrent Computation in Distributed Systems ; MIT Press, Cambridge  
(Mass.), 1986.
[Agha 1988]
Gul Agha, Peter Wegner and Akinori Yonezawa (eds.): Proceeding of the ACM SIGPLAN Workshop on Object-
Based Concurrent Programming , San Diego, 26-27 September, 1988; in ACM SIGPLAN Notices , vol. 24, no.  
4, 1988.
[Agha 1990]
Gul Agha: Concurrent Object-Oriented Programming , in Communications of the ACM , vol. 33, no. 9,  
September 1990, pages 125-141.
[Agha 1991]
Gul Agha, Carl Hewitt, Peter We gner and Akinori Yonezawa (eds.) : Proceedings of the ECOOP-OOPSLA  
Workshop on Object-Based Concurrent Programming , Ottawa, 21-22 October 1990; in OOPS Messenger  
(ACM ), vol. 2, no. 2, April 1991.
[Agha 1993]
Gul Agha, Peter Wegner and Akinori Yonezawa (eds.): Research Directions in Concurrent Object-Oriented  
Programming , MIT Press, Cambridge (Mass.), 1993.
[Aho 1974] 
Alfred V . Aho , John E. Hopcroft and Jeffrey D. Ullman: The Design and Analysis of Computer Algorithms , 
Addison-Wesley, Reading (Mass.), 1974. 
BIBLIOGRAPHY 1204
[Aho 1983] 
Alfred V . Aho , John E. Hopcroft and Jeffrey D. Ullman: Data Structures and Algorithms , Addison-Wesley,  
Reading (Mass.), 1983. 
[Alagar 1995]
Vangalur S. Alagar and Rokia Missaoui (eds.): Object-Oriented Technology for Database and Software Systems , 
World Scientific Publishers, Singapore, 1995.
[America 1989]
Pierre America and Marcel Beemster: A portable implementation of the language POOL ; in TOOLS 1  
(Proceedings of TOOLS EUROPE 1989 ), ed. Jean Bézivin, SOL , Paris, 1989, pages 347-353.
[America 1989a]
Pierre America: Book Review : “Object-Oriented Software Construction”  (a review of the first edition of the  
present book, [M 1988]), Science of Computer Programming , vol. 12, 1989, pages 83-92.
[ANSI 1983] 
ANSI (American National Standards Institute) and US Government Department of Defense, Ada Joint Program  
Office: Military Standard : Ada Programming Language , ANSI/MIL-STD-1815A-1983, February 17, 1983.
[Arnold 1996]
Ken Arnold and James Gosling: The Java Programming Language , Addison-Wesley, Reading (Mass.), 1996.
[Atkinson 1989]
M. Atkinson, F. Bancilhon, D. DeWitt, K. Dittrich, D. Maier, an d S. Zdonik: The Object-Oriented Database  
System Manifesto , in Proc . First Intl . Conf . on Deductive and Object-Oriented Databases , Kyoto, Japan,  
December 1989, pages 223-40. On-line: http://www .cs.cmu.edu/Web/People /clamen /OODBMS /Manifesto .html. 
Also in [Bancilhon 1992].
[Atkinson 1991]
Colin Atkinson: Object-Oriented Reuse , Concurrency and Distribution , ACM Press (Addison Wesley), New  
York, 1991.
[Avotins 1995]
Jon Avotins, Christine Mingins and Heinz Schmidt: Yes! An Object-Oriented Compiler Compiler , in TOOLS 17  
(Technology of Object-Oriented Languages and Systems ), eds. Raimund Ege, Madhu Singh, and Bertrand Meyer,  
Prentice Hall, Englewood Cli ffs (N.J.) 1995, pages 191-205.
[Bachelard 1960]
Gaston Bachelard: La Formation de l'Esprit scientifique : Contribution à une Psychanalyse de la Connaissance  
objective , Lib. Phil. J. Vrin, Paris, 1960.
[Baker 1972] 
F. Terry Baker: Chief Programmer Team Management of Production Programming , in IBM Systems Journal , vol.  
11, no. 1, 1972, pages 56-73. 
[Balter 1991]
R. Balter et al.: Architecture and Implementation of Guide , an Object-Oriented Distributed System , in Computing  
Systems , vol. 4, 1991.
[Bancilhon 1992]
François Bancilhon, Claude Delobe l and P. Kanellakis (eds.): Building an Object-Oriented Database System : The 
Story of O2 , Morgan Kaufmann Publishe rs, Menlo Park (Calif.), 1992.
[Baudoin 1996]
Claude Baudoin and Glenn Hollowell: Realizing the Object-Oriented Lifecycle , Prentice Hall Object-Oriented  
Series, Upper Saddle River (N.J.), 1996.
[Ben Ari 1990]
Mordechai Ben Ari: Principles of Concurrent and Distributed Programming , Prentice Hall, Hemel Hempstead  
(U.K.), 1990.
BIBLIOGRAPHY 1205
[Bert 1983]
Didier Bert: Manuel de Référence du Langage LPG , Version 1 .2, Rapport R-408, IFIAG, IMAG Institute,  
Grenoble University, December 1983.
[Bertino 1993]
Elisa Bertino and Lorenzo Martino: Object-Oriented Database Systems , Concepts and Architecture , Addison-
Wesley, Reading (Mass.), 1993.
[Beta-Web]
Mjølner BETA System Home page at http://www .mjolner .dk/.
[Bielak 1993]
Richard Bielak and James McKim: The Many Faces of a Class , in TOOLS 11 (Technology of Object-Oriented  
Languages and Systems ), eds. Raimund Ege, Madhu Singh and Bertrand Meyer, Prentice H all, Englewood Cliffs  
(N.J.), 1993, pages 153-161.
[Bielak 1994]
Richard Bielak and James McKim: Let There be … Objects , in Journal of Object-Oriented Programming , vol. 7,  
no. 6, October 1994, pages 71-74.
[Biggerstaff 1984] 
Ted J. Biggerstaff and Alan J. Perlis (Eds): Special Issue on Software Reusability , in IEEE Transactions on  
Software Engineering , vol. SE-10, no. 5, September 1984, pages 474-609.
[Biggerstaff 1989] 
Ted J. Biggerstaff and Alan J. Perlis (eds): Software Reusability , ACM Press (Addison-Wesley), New York, 1989. (Two  
volumes.)
[Birtwistle 1973] 
Graham M. Birtwistle, Ole-Johan Dahl, Bjorn Myhrhaug and Kriste n Nygaard: Simula Begin , Studentliteratur  
(Lund, Sweden) and Petrocelli/Charter (New York) 1973. (This is  the imprint on my copy, although every  
bibliography I have seen lists t he publisher as “Auerbach publi shers”.)
[Bobrow 1982] 
Daniel G. Bobrow and Mark J. Stefik: LOOPS : an Object-Oriented Program ming System for Interlisp , Xerox  
PARC, 1982. 
[Boehm 1978] 
Barry W. Boehm, J.R. Brown, G. McLeod, Myron Lipow and M. Merri t: Characteristics of Software Quality , 
TRW Series of Software Technol ogy, North-Holland Publishing Co. , Amsterdam, 1978. 
[Boehm 1979] 
Barry W. Boehm: Software Engineering — As It Is , in Proceedings of the 4th International Conference on  
Software Engineering , Munich, IEEE, September 1979, pages 11-21. 
[Boehm 1981] 
Barry W. Boehm: Software Engineering Economics , Prentice Hall, Engl ewood Cliffs (N.J.), 1981. 
[Boehm 1988] 
Barry W. Boehm: A Spiral Model of Software Development and Enhancement , in IEEE Computer , no. 5, vol. 21,  
May 1988, pages 61-72. 
[Booch 1986] 
Grady Booch: Object-Oriented Development , in IEEE Transactions on Software Engineering , vol. SE-12, no. 2,  
pages 211-221, February 1986. 
[Booch 1986a] 
Grady Booch: Software Engineering with Ada , Benjamin/Cummings Publishing Co., Menlo Park (Calif.), 1983  
(new edition, 1986).
[Booch 1994]
Grady Booch: Object-Oriented A nalysis and Design With Applications , Second Edition , Benjamin/Cummings,  
Menlo Park (Calif.), 1994.
BIBLIOGRAPHY 1206
[Brachman 1983] 
Ronald J. Brachman: What IS-A and isn’t : An Analysis of Taxonomic Links in Semantic Networks , in Computer  
(IEEE ), vol. 16, no. 10, pages 67-73, October 1983. 
[Breu 1995]
Ruth Breu and Michael Breu: A Methodology of Inheritance , in Software — Concepts and Tools  (Springer-
Verlag), vol. 16, no. 3, 1995, pages 113-123.
[Bright 1995]
Walter Bright: Optimizing C++ Code , in Dr. Dobb’s Journal , no. 233, August 1995, pages 88-89.
[Brooks 1974] 
Fred P. Brooks: The Mythical Man-Month , Addison-Wesley, Reading (Mass.), 1974. 
[Bruce 1997]
Kim B. Bruce: Typing in Object-Oriented languages : Achieving Expressiveness and Safety , in ACM Computing  
Surveys , to appear.
[Burstall 1977] 
Rod M. Burstall and Joseph A. Goguen: Putting Theories Together to Make Specifications , in Proceedings of 5th  
International Joint Conference on Artificial Intelligence , Cambridge (Mass.), 1977, pages 1045-1058. 
[Burstall 1981] 
Rod M. Burstall and Joseph A. Goguen: An Informal Introduction to Specifications using Clear , in The 
Correctness Problem in Computer Science , eds. R. S. Boyer and J. S. Moore, Academic Press, London, 198 1, 
pages 185-213. 
[Buxton 1976]
John M. Buxton, Peter Naur a nd Brian Randell (eds.) Software Engineering Concepts and Techniques  
(Proceedings of 1968 NATO Conference on Software Engineering), Van Nostrand Reinhold, New York, 1976.
[Campbell 1974]
Roy H. Campbell and A. Nico Habermann: The Specification of Process Synchronization by Path Expressions , 
Lecture Notes in Computer Sci ence 16, Springer-Verlag, Berlin-N ew York, 1974, pp. 89-102.
[Cannon 1980] 
H. I. Cannon: Flavors , Technical Report, MIT Artific ial Intelligence Laboratory, Cam bridge (Mass.), 1980. 
[Cardelli 1984] 
Luca Cardelli: A Semantics of Multiple Inheritance , in Semantics of Data Types , eds. Gilles Kahn, David B.  
McQueen and Gordon Plotkin, Lecture Notes in Computer Science 1 73, Springer-Verlag, Berlin-New York, 1984,  
pages 51-67. Revised version in Information and Computation , no. 76, 1988, pages 138-164. Also in [Zdonik  
1990], pages 59-83. 
[Cardelli 1984a] 
Luca Cardelli: Basic Polymorphic Typechecking , AT&T Bell Laboratories Computing Science Technical Report,  
1984. Revised version in Science of Computer Programming , vol. 8, no. 2, 1987.
[Cardelli 1985] 
Luca Cardelli and Peter Wegner: On understanding Types , Data Abstraction and Polymorphism , in ACM 
Computing Surveys , vol. 17, no. 4, 1985, pages 471-522. 
[Caromel 1989]
Denis Caromel: Service , Asynchrony , and Wait-by-Necessity , in Journal of  Object-Oriented  Programming ,  vol.  
2, no. 4, Nov.-Dec. 1989, pp. 12-18.
[Caromel 1993]
Denis  Caromel:  Toward  a Method  of  Object-Oriented  Concurrent Programming , in [M 1993a], pages 90-102.
[Carriero 1990]
Nicholas Carriero and David Gelernter: How to Write Parallel Programs : A First Course , MIT Press, Cambridge  
(Mass.), 1990.
BIBLIOGRAPHY 1207
[Castagna 1995]
Giuseppe Castagna: Covariance and Contravariance : Conflict without a Cause , in ACM Transactions on  
Programming Languages and Systems , vol. 17, no. 3, 1995, pages 431-447.
[Castagna 1996]
Giuseppe Castagna: Le Modèle fondé sur la Surcharge : Une Visite Guidée (The Overloading-Based Model: A  
Guided Tour), in TSI (Technique et Sciences Informatiques ), vol. 15, no. 6, 1996.
[Cattell 1993]
R. G. G. Cattell (ed.): The Object Database Standard : ODMG-93 , Morgan Kaufmann, Menlo Park (Calif.), 1993.
[Chambers 1991]
Craig Chambers, David Ungar, Bay-Wei Change and Urs Hölzle: Parents are Shared Parts of Objects : Inheritance  
and Encapsulation in SELF , in Lisp and Symbolic Computation : An International Journal , vol. 4, no. 3, 1991.
[Chen 1976] 
Peter P.S. Chen: The Entity-Relationship model — Towards a Unified View of Data , in ACM Transactions on  
Database Systems , vol. 1, no. 1, March 1976, pages 9-36.
[Coad 1990] 
Peter Coad and Edward Nash Yourdon: Object-Oriented Analysis , Prentice Hall, Englewood Cliffs (N.J.), 1990. 
[Codd 1970]
E.F. Codd: A Relational Model of Data for Large Shared Data Banks , in Communications of the ACM , vol. 13,  
no. 6, June 1970, pages 377- 387.
[Cohen 1984] 
Jacques Cohen and Tim Hickey: Performance Analysis of On-the-Fly Garbage Collection , in Communications of  
the ACM , vol. 27, no. 11, November 198, pages 1143-1154.
[Cohen 1991] 
Bernard Cohen: The Inverted Curriculum , Report, National Economic Development Council, London, 1991.
[Coleman 1994]
Derek Coleman et al.: Object-Oriented Development : The Fusion Method , Prentice Hall Object-Oriented Series,  
Englewood Cliffs (N.J.), 1994.
[Computer 1996]
Gurus Share Insights on Objects  (interview with Grady Booch, Ivar Jacobson and James Rumbaugh) , in 
Computer  (IEEE), Object Technology department, vol. 29, no. 6, June 199 6, pages 95-98.
[Cook 1989]
William R. Cook: A Proposal for Maki ng Eiffel Type-Safe , in ECOOP 89 (Proceedings of 1989 European  
Conference on Object-Oriented Programming, Nottingham, U.K., 10 -14 July 1989), ed. Stephen Cook,  
Cambridge University Press, 1989, pages 57-70.
[Cook 1994]
Steve Cook and John Daniels: Designing Object Systems , Prentice Hall Object-Oriented Series, Hemel  
Hempstead (U.K.), 1994.
[Cox 1984] 
Brad J. Cox: Message /Object Programming : An Evolutionary Change in Programming Technology , in IEEE 
Software , vol. 1, no. 1, January 1984, pages 50-69.
[Cox 1986]
Brad Cox et al.: User Interface Frameworks  (position papers for a panel), in OOPSLA ’86 Conference  
Proceedings , Portland (Oreg.), Sept. 29-Oct. 2, 1986, published as SIGPLAN Notices , vol. 21, no. 11, Nov. 1986,  
pages 497-501.
[Cox 1990] 
Brad J. Cox and Andrew J. Novobilski: Object-Oriented Programming : An Evolutionary Approach , 2nd edition .,  
Addison-Wesley, Reading (Mass.), 1990. (Original edition, first  author only: 1986.)
[Cox 1992] 
Brad J. Cox: Superdistribution and Electronic Objects , in Dr. Dobb’s Journal , no. 193, October 1992, pages 44-48.
BIBLIOGRAPHY 1208
[Cristian 1985] 
Flaviu Cristian: On Exceptions , Failures and Errors , in Technology and Science of Informatics , vol. 4, no. 4, July-
August 1985. 
[Curry 1984] 
Gael A. Curry and Robert M. Ayers: Experience with Traits in the Xerox Star Workstation , in IEEE Transactions  
on Software Engineering , vol. SE-10, no. 5, September 1984, pages 519-527.
[Dahl 1966] 
Ole-Johan Dahl and Kristen Nygaard: SIMULA — An Algol-based Simulation Language , in Communications of  
the ACM , vol. 9, no. 9, September 1966, pages 671-678
[Dahl 1970] 
Ole-Johan Dahl, Bjorn Myrhaug and Kristen Nygaard: (Simula 67)  Common Base Language , Norsk Regnesentral  
(Norwegian Computing Center) , Publication N. S-22, Oslo, Octobe r 1970. (Revised version, February 1984.)
[Dahl 1972]
Ole-Johan Dahl and C.A.R. Hoare: Hierarchical Program Structures , in Dahl, Dijkstra, Hoare, Structured  
Programming , Academic Press, 1972, pages 175-220
[Dami-Web]
Web page at http://cuiwww .unige .ch/OSG /Hop/types .html, from 1996 on (list of links to articles and researchers  
on O-O type theory.)
[Date 1995]
Chris J. Date: An Introduction to Database Systems , sixth edition, Addison-Wesley, Reading (Mass.), 1995.
[Dekleva 1992] 
Sasa M. Dekleva: Software Maintenance : 1990 Status , in Software Maintenance : Research and Practice , John  
Wiley and Sons, New York, vol. 4, 1992. 
[DeMarco 1978] 
Tom DeMarco: Structured Analysis and System Specification , Yourdon Press, New York, 1978.
[DeMarco 1988] 
Tom DeMarco and Tim Lister: Peopleware , Dorset Publishing, New York, 1988.
[DeRemer 1976] 
Frank DeRemer and Hans H. Kron: Programming-in-the-Large Versus Programming-in-the-Small , in IEEE 
Transactions on Software Engineering , vol. SE-2, no. 2, June 1976, pages 80-86.
[Dijkstra 1968]
Edsger W. Dijkstra: Go To Statement Considered Harmful , in Communications of the ACM , vol. 15, no. 10,  
October 1972, pages 859-866.
[Dijkstra 1968a]
Edsger W. Dijkstra: Co-operating Sequential Processes , in Programming Languages , ed. F. Genuys, Academic  
Press, New York, 1968. pp. 43-112.
[Dijkstra 1976] 
Edsger W. Dijkstra: A Discipline of Programming , Prentice Hall, Englewood Cliffs (N.J.), 1976. 
[Dijkstra 1978] 
E. W. Dijkstra, L. Lamport, A.J. Martin, C.S. Scholten and E.F. M. Steffens: On-the-Fly Garbage Collection : An 
Exercise in Cooperation , in Communications of the ACM , vol. 21, no. 11, November 1978 , pages 966-975.
[Dubois 1997]
Paul Dubois: Object Technology for Scientific Computing , Prentice Hall, Englewood Cliffs (N.J.) 1997.
[Duke 1991] 
Roger Duke, Paul King, Gor don Rose and Graeme Smith: The Object-Z Specification Language , in TOOLS 5  
(Technology of Object-Oriented Languages and Systems ), Santa Barbara, (Calif.), 1991, eds. Tim Korson, Vijay  
Vaishnavi and Bertrand Meyer, Prentice Hall, Englewood Cliffs ( N.J.), 1991, pages 465-483.
[Eliëns 1995]
Anton Eliëns: Principles of Object-Oriented Software Development , Addison-Wesley , Reading (Mass.), 1995.
BIBLIOGRAPHY 1209
[Ellis 1990] 
Margaret Ellis and Bjarne Stroustrup: The Annotated C++ Reference Manual , Addison-Wesley, Reading (Mass.),  
1990. 
[Elmasri 1989]
Ramez Elmasri and Shamkant B. Navathe: Fundamentals of Database Systems , Benjamin Cummings, Redwood  
City (Calif.), 1989.
[Embley 1992]
D.W. Embley, B.D. Kurtz, and S.N. Woodfield: Object-oriented Systems Analysis : A Model-driven Approach , 
Prentice-Hall, Englewood Cliffs (N.J.), 1992.
[Feldman 1979] 
Stuart I. Feldman: Make — A Program for Maintaining Computer Programs , in Software , Practice and  
Experience , vol. 9, 1979, pages 255-265.
[Feldman 1993]
Jerome A. Feldman, Chu-Cheo w Lim and Thomas Rauber: The Shared-Memory Language pSather on a  
Distributed-Memory Multiprocessor ; in Proc . Workshop on Languages , Compilers and Run-Time Environments  
for Distributed Memory Multiprocessors , SIGPLAN Notices , vol. 28, no. 1, January 1993, pages 17-20.
[Feldman-Web]
Michael B. Feldman and Magnus Kempe (eds.): Ada 95 Textbooks : Brief Reviews , on-line at http://
www.adahome.com/Resources/Books/ada95reviews.html , 1996 on.
[Firesmith 1995]
Donald G. Firesmith and Edward M. Eyckholt: Dictionary of Object Technology, the Definitive Desk Reference , 
SIGS Books, New York, 1995.
[Floyd 1967] 
Robert W. Floyd: Assigning Meanings to Programs , in Proc . American Mathemat ical Society Symp . in Applied  
Mathematics , vol. 19, 1967, pages 19-31.
[Futatsugi 1985] 
Kokichi Futatsugi, Joseph A. G oguen, Jean-Pierre Jouannaud and José Meseguer: Principles of OBJ2 , in 
Proceedings of the 1985 ACM Symposium on Principles of Programming Languages , vol. 12, 1985, pages 52-66.
[Gamma 1995]
Erich Gamma, Richard Helm, Ral ph Johnson, and John Vlissides: Design Patterns : Elements of Reusable Object-
Oriented Software , Addison-Wesley, Reading (Mass.), 1995.
[Gannon 1975]
John D. Gannon and Jim J. Horning: Language Design for Programming Reliability , in IEEE Transactions on  
Software Engineering , vol. SE-1, no. 2, June 1975.
[Geschke 1975] 
C.M. Geschke and J.G. Mitchell: On the Problem of Uniform References to Data Structures , in SIGPLAN Notices , 
vol. 10, no. 6, June 1975, pages 31-42.
[Ghezzi 1991] 
Carlo Ghezzi, Mehdi Jazayeri, and Dino Mandrioli: Fundamentals of Software Engineering , Prentice Hall,  
Englewood Cliffs (N.J.), 1991. 
[Ghezzi 1997]
Carlo Ghezzi and Mehdi Jazayeri: Programming Language Structures , second edition , John Wiley and Sons,  
New York, 1987; third edition announced for 1997.
[Gil 1994]
Joseph Gil and Ricardo Szmit: Software Boards via Configurable Objects , in TOOLS 14 (Technology of Object-
Oriented Languages and Systems ), Santa Barbara (California), 1994, eds Raimund Ege, Madhu Singh and 
Bertrand Meyer, Prentice Ha ll, Englewood Cliffs (N.J.), 1994, p ages 303-317.
BIBLIOGRAPHY 1210
[Gindre 1989] 
Cyrille Gindre and Frédérique Sada: A Development in Eiffel : Design and Implementation of a Network  
Simulator , in Journal of Object-Oriented Programming , vol. 2, no. 2, May 1989, pages 27-33, Revised version in  
[M 1992a], pages 199-214.
[Girod 1991]
Xavier Girod: Conception par Objets — MECANO : Une Méthode et un Environnement de Construction  
d’Appplications par Objets , PhD Thesis, Université Jos eph Fourier (Grenoble), 21 June 199 1.
[Goguen 1978] 
Joseph A. Goguen, J. W. Thatcher and E. G. Wagner: An Initial Algebra Approach to the Specification ,
Correctness and  Implementation of Abstract Data Types , in Raymond T. Yeh (ed.), Current Trends in  
Programming Methodology , vol. 4, Prentice Hall, Englew ood Cliffs (N.J.), 1978, pages 80- 149.
[Goguen 1984] 
Joseph A. Goguen: Parameterized Programming , in IEEE Transactions on Software Engineering , vol. SE-10, no.  
5, September 1984, pages 528-543.
[Goldberg 1976] 
Adele Goldberg and Alan Kay (Eds): Smalltalk-72 Instruction Manual , Technical Report SS L-76-6, Xerox Palo  
Alto Research Center, March 1976. 
[Goldberg 1981] 
Adele Goldberg and others: Special issue on Smalltalk-80 , in Byte Magazine , August 1981. 
[Goldberg 1983] 
Adele Goldberg and David Robson: Smalltalk-80 : The Language and its Implementation , Addison-Wesley,  
Reading (Mass.), 1983. 
[Goldberg 1985] 
Adele Goldberg: Smalltalk-80 : The Interactive Programming Environment , Addison-Wesley, Reading (Mass.), 1985. 
[Goldberg 1995] 
Adele Goldberg and Kenneth S. Rubin: Succeeding with Objects : Decision Frameworks for Project Management , 
Addison-Wesley, Reading (Mass.), 1995. 
[Gore 1996]
Jacob Gore: Object Structures : Building Object-Oriented Software Components with Eiffel , Addison-Wesley,  
Reading (Mass.), 1996.
[Gosling 1996]
James Gosling, Bill Joy and Guy Steel, The Java Language Specification , Addison-Wesley, Reading (Mass.), 1996.
[Gosling 1996a]
James Gosling, Frank Yellin and the Java Team: The Java Application Programming Interface , vol.1 ( Core 
Packages ) and vol. 2 ( Window Toolkit and Applets ), Addison-Wesley, Reading (Mass.), 1996.
[Graham 1995]
Ian Graham: Migrating to Object Technology , Addison-Wesley, Wokingham (U.K.), 1995.
[Gries 1981]
David Gries: The Science of Programming , Springer-Verlag, Berlin-New York, 1981.
[Guidec 1996]
Frédéric Guidec, Jean-Marc Jézéquel and Jean-Louis Pacherie: An Object-Oriented Framework for  
Supercomputing , in special issue on Software Engineering for Distributed Comp uting of the Journal of Systems  
and Software , June 1996.
[Guttag 1977] 
John V . Guttag: Abstract Data Types and the Development of Data Structures , in Communications of the ACM , 
vol. 20, no. 6, June 1977, pages 396-404.
[Guttag 1978] 
John V . Guttag and Jim J. Horning: The Algebraic Specification of Abstract Data Types , in Acta Informatica , vol.  
10, 1978, pages 27-52.
BIBLIOGRAPHY 1211
[Guttag 1985]
John V . Guttag, Jim J. Horning and Jeannette M. Wing: Larch in Five Easy Pieces , Report 5, Digital Systems  
Research Center, Palo Alto (Calif.), 24 July 1985.
[Hadamard 1945]
Jacques Hadamard: La Psychologie de l’Invention dans le Domaine mathématique , Albert Blanchard, Paris, 1948.  
Extension of earlier English edition: The Psychology of Invention in the Mathematical Field , Princeton University  
Press, Princeton (N.J.), 1945; mor e recent reprint available fr om Dover Publications, New York.
[Halbert 1987] 
Daniel C. Halbert and Patrick D. O’Brien: Using Types and Inheritance in Object-Oriented Languages , in 
ECOOP 87 : European Conference on Object-Oriented Programming , Paris, June 1987, pages 23-34. Revised  
version in IEEE Software , vol. 4, no. 5, September 1987, pages 71-79.
[Harbison 1992]
Samuel P. Harbison: Modula-3 , Prentice Hall, Engl ewood Cliffs (N.J.), 1992.
[Hayes 1988] 
Ian J. Hayes (Ed.): Specification Case Studies , Prentice Hall International , Hemel Hempstead (U.K.), 1988. 
[Heliotis 1996]
James Heliotis: Eiffel in Computer Science Education , in Journal of Object-Oriented Programming , vol. 9, no. 2,  
May 1996, pages 64-66, 82.
[Henderson-Sellers 1990] 
Brian Henderson-Sellers and Julian M. Edwards: The Object-Oriented Systems Life Cycle , in Communications of  
the ACM , vol. 33, no. 9, September 1990, pages 142-159.
[Henderson-Sellers 1991] 
Brian Henderson-Sellers: A BOOK of Object-Oriented Knowledge , Prentice Hall Object-Oriented Series, Sydney  
(Australia), 1991. 
[Henderson-Sellers 1994] 
Brian Henderson-Sellers a nd Julian M. Edwards: BOOKTWO of Object-Oriented Knowledge : The Working  
Object , Prentice Hall Object-Oriente d Series, Sydney (Australia), 199 1. 
[Henderson-Sellers 1994a]
Brian Henderson-Sellers and James McKim: Contracting : What's in it for the Supplier ?, in TOOLS 14  
(Technology of Object-Oriented Languages and Systems ), Santa Barbara (California), 1994, eds Raimund Ege,  
Madhu Singh and Bertrand Meyer, P rentice Hall, Englewood Cliffs  (N.J.), 1994, pages 179-186.
[Henderson-Sellers 1996]
Brian Henderson-Sellers and Ian Graham: OPEN : Towards Method Convergence ?, in Computer  (IEEE), Object  
Technology department, vol. 29, no. 4, April 1996, pages 86-89.
[Henderson-Sellers 1996a]
Brian Henderson-Sellers: Object-Oriented Metrics : Measures of Complexity , Prentice Hall Object-Oriented  
Series, Upper Saddle River (N.J.), 1996.
[Hoare 1966] 
C.A.R. Hoare and Niklaus Wirth: A Contribution to the Development of ALGOL , in Communications of the ACM , 
vol. 9, no. 6, June 1966, pages 413-431. Reprinted in C.A.R. Ho are and C. B. Jones (ed.), Essays in Computing  
Science , Prentice Hall International, Hemel Hempstead (U.K.), 1989, pa ges 31-43.
[Hoare 1969] 
C.A.R. Hoare: An Axiomatic Basis for Computer Programming , in Communications of the ACM , vol. 12, no. 10,  
October 1969, pages 576-580, 583. Reprinted in [Hoare 1989], pa ges 45-58.
[Hoare 1972] 
C.A.R. Hoare: Editorial : The Quality of Software , in Software , Practice and Experience , vol. 2, no. 2, 1972, pages  
103-105. 
BIBLIOGRAPHY 1212
[Hoare 1972a] 
C.A.R. Hoare: Proof of Correctness of Data Representations , in Acta Informatica , vol. 1, 1972, pages 271-281.  
Reprinted in [Hoare 1989], pages 103-115.
[Hoare 1973] 
C.A.R. Hoare: Hints on Programming Language Design , Stanford University Artificial Intelligence memo AIM-
224/STAN-CS-73-403. Reprinted in [Hoare 1989], pages 193-216.
[Hoare 1974] 
C.A.R. Hoare: Monitors : An Operating System Structuring Concept , in Communications of the ACM , vol. 17, no.  
10, October 1974, pages 549-557. Reprinted in [Hoare 1989], pag es 171-191.
[Hoare 1978] 
C.A.R. Hoare: Communication Sequential Processes , in Communications of the ACM , vol. 21, no. 8, August  
1978, pages 666-677. Reprinted in [Hoare 1989], pages 259-288.
[Hoare 1981]
C.A.R. Hoare: The Emperor’s Old Clothes  (1980 Turing Award lecture), in Communications of the ACM , vol. 24,  
no. 2, February 1981, pages 75-83. Reprinted in [Hoare 1989], p ages 1-18.
[Hoare 1985]
C.A.R. Hoare: Communicating Sequential Processes ; Prentice Hall International, Hemel Hempstead (U.K.), 1985.
[Hoare 1989] 
C.A.R. Hoare and C. B. Jones (ed.): Essays in Computing Science (reprints of Hoare’s papers), Prentice Hall  
International, Hemel  Hempstead (U.K.), 1989.
[Hopkins 1995]
Trevor Hopkins and Bernard Horan: Smalltalk — An Introduction to Application Development Using VisualWorks ,
Prentice Hall Object-Oriented Series, Hemel Hempstead (U.K.), 1 995.
[Horowitz 1984] 
Ellis Horowitz and John B. Munson: An Expansive View of Reusable Software , in IEEE Transactions on Software  
Engineering , vol. SE-10, no. 5, September 1984, pages 477-487. 
[Hullot 1984] 
Jean-Marie Hullot: Ceyx , Version 15 : I — une Initiation , Rapport Technique no. 44, INRIA, Rocquencourt, 1984. 
[IEEE 1990]
IEEE Computer Society: Glossary of Software Engineering Terminology , ed. Jane Radatz, standard 1990-610.12  
(revision of 1983-729). Also ANSI standard, 2/91.
[IEEE 1993]
IEEE Computer Society: Classification of Software Errors /Faults /Failures , ed. Richard Evans, standard 1993-1044.
[Ingalls 1978] 
Daniel H. H. Ingalls: The Smalltalk-76 Programming System : Design and Implementation , in Proceedings of the  
ACM Principles of Programming Languages Symposium , January 1978. 
[Inmos 1988]
Inmos Ltd.: Occam 2 Programming Manual , Prentice Hall International , Hemel Hempstead (U.K.), 1988.
[ISE 1996]
Interactive Software Engineering Inc.: ArchiText User’s Manual , Technical Report TR-EI-33.AT, 1996.
[Jackson 1975] 
Michael A. Jackson: Principles of Program Design , Academic Press, London, 1975. 
[Jackson 1983] 
Michael A. Jackson: System Development , Prentice Hall International , Hemel Hempstead (U.K.), 1983. 
[Jacobson 1992]
Ivar Jacobson, Magnus Christerson, Patrik Jonsson and Gunnar Öv ergaard: Object-Oriented Software  
Engineering : A Use Case Driven Approach , Addison-Wesley, Wokingham (England), 1992.
BIBLIOGRAPHY 1213
[Jalloul 1991]
Ghinwa Jalloul and John Potter: Models for Concurrent  Eiffel , in TOOLS 6 (Technology of Object-Oriented Languages  
and Systems ), eds. J. Potter, M. Tokoro an d B. Meyer, Prentice Hall, Sydne y (Australia), 1991, pp. 183-191.
[Jalloul 1994]
Ghinwa Jalloul: Concurrent  Object-Oriented Systems :  A Disciplined Approach ., PhD  Dissertation,  University  
of  Technology,   Sydney (Australia), June 1994.
[Jézéquel 1992]
Jean-Marc Jézéquel: ÉPÉE : an Eiffel Environment to Program Distributed Parallel Computers ; in ECOOP’92  
proceedings, Lecture Notes in Computer Science 611 , Springer-Verlag, Berlin, July 1992. Revised version in  
Journal of Object-Oriented Programming , vol. 6, no. 2, May 1993, pp. 48-54.
[Jézéquel 1996]
Jean-Marc Jézéquel: Object-Oriented Software Engineering with Eiffel , Addison-Wesley, Reading (Mass.), 1996.
[Johnson 1995]
Paul Johnson: “Marconi” Proposal for the Eiffel Library Kernel Standard , archives of the NICE library  
committee discussions, Nonprofit International Consortium for E iffel, 1995.
[Johnston 1971] 
J.B. Johnston: The Contour Model of Block Structured Processes , in SIGPLAN Notices , vol. 6, no. 2, February  
1971, pages 55-82.
[Jones 1980] 
Cliff B. Jones: Software Development : A Rigorous Approach , Prentice Hall International, H emel Hempstead (U.K.), 1980.
[Jones 1984] 
T. Capers Jones: Reusability in Programming : A Survey of the State of the Art , in IEEE Transactions on Software  
Engineering , vol. SE-10, no. 5, September 1984, pages 488-494. 
[Jones 1986] 
Cliff B. Jones: Systematic Software Development Using VDM , Prentice Hall International, Hemel Hempstead (U.K.), 1986. 
[Joyner 1996]
Ian Joyner: C++ Critique , third edition , available on several Internet sites including http://
www.progsoc.uts.edu.au/~geldridg/cpp/cppcv3.html  and ftp://ftp.inria.fr/doc/lang/cpp.crit.ps.gz . (For others,  
perform a search on the keywords  "Joyner" and "C++ critique".)
[Kemper 1994]
Alfons Kemper and Guido Moerkotte:  Object-Oriented Database Management : Applications in Engineering and  
Computer Science , Prentice Hall, Engl ewood Cliffs (N.J.), 1994.
[Kernighan 1978]
Brian W. Kernighan and Dennis M. Ritchie: The C Programming Language , Prentice Hall, Englewood Cliffs  
(N.J.), 1978.
[Kernighan 1988]
Brian W. Kernighan and Dennis M. Ritchie: The C Programming Language , second edition , Prentice Hall,  
Englewood Cliffs (N.J.), 1988 (covers  the ANSI standard version  of the languages).
[Kilov 1994]
Haim Kilov and James Ross:  Information Modeling : An Object-Oriented Approach , Prentice Hall Object-
Oriented Series, Engl ewood Cliffs (N.J.), 1994.
[Khoshafian 1986]
Setrag Khoshafian and George P. Copeland: Object Identity , in OOPSLA ’86 Conference Proceedings , Portland  
(Oreg.), Sept. 29-Oct. 2, 1986, published as SIGPLAN Notices , vol. 21, no. 11, Nov. 1986, pages 406-416. Also  
in [Zdonik 1990], pages 37-46.
[Khoshafian 1993]
Setrag Khoshafian: Object-Oriented Databases , John Wiley and Sons, New York, 1993.
[Kim 1990]
Won Kim: Introduction to Object-Oriented Databases , MIT Press, Cambridge (Mass.), 1990.
BIBLIOGRAPHY 1214
[Knudsen 1993]
Jørge Lindskov Knudsen, Mats Löfgr en, Ole Lehrmann Madsen, Bori s Magnusson: Object-Oriented  
Environments : The Mj ølner Approach , Prentice Hall Object-Oriented S eries, Hemel Hempstead (U.K.),  1993.
[Knuth 1968]
Donald E. Knuth: The Art of Computer Programming , Vol. 1: Fundamental Algorithms , Addison-Wesley, Menlo  
Park (Calif.), 1968.
[Knuth 1973] 
Donald E. Knuth: The Art of Computer Programming , Vol. 3: Sorting and Searching , Addison-Wesley, Menlo  
Park (Calif.), 1973. 
[Knuth 1980]
Donald E. Knuth and Luis Trabb Pardo: The early development of Programming Languages , in A History of  
Computing in the Twentieth Century , N. Metropolis, J. Howlett and Gi an-Carlo Cota (eds.), Academi c Press, New  
York, 1980, pages 197-273. 
[Knuth 1981]
Donald E. Knuth: The Art of Computer Programming , Vol. 2: Seminumerical Algorithms , Addison-Wesley, Menlo  
Park (Calif.), 1969. Second edition, 1981.
[Knuth 1984] 
Donald E. Knuth: Literate Programming , in The Computer Journal , vol. 27, no. 2, May 1984, pages 97-111.
[Krief 1996]
Philippe Krief: Prototyping with Objects , Prentice Hall Object-Oriented Series, Hemel Hempstead (U.K.),  1996.
[Lalonde 1990-1991]
Wilf R. Lalonde and John R. Pugh: Inside Smalltalk , Prentice Hall, Englewood Cliffs (N.J.), 1990 (volume 1) and  
1991 (volume 2).
[Lampson 1977] 
Butler W. Lampson, Jim J. Horning, Ralph L. London, J. G. Mitch ell and Gerard L. Popek: Report on the  
Programming Language Euclid , in SIGPLAN Notices , vol. 12, no. 2, February 1977, pages 1-79.
[Language-Web]
Eiffel Home Page , at http://www .eiffel .com.
[Lano 1994] 
Kevin Lano and Howard Haughton (eds.): Object-Oriented Specification Case Studies , Prentice Hall Object-
Oriented Series, Hemel Hempstead (U.K.), 1994.
[Lea 1993]
Rodger Lea, Christian Jacquemot and Eric Pillevesse: COOL : System Support for Distributed Programming , in 
[M 1993a], pp. 37-46.
[Ley-Web]
Michael Ley: Bibliography WWW Server on Dat abase Systems and Logic Programming , on-line Web archive at  
http://www .informatik .uni-trier .de/~ley/db/index .html.
[Lieberherr 1989]
Karl J. Lieberherr and Ian M. Holland: Assuring Good Style for Object-Oriented Programs , in IEEE Software , 
vol. 6, no. 5, September 1989, pages 38-48.
[Lieberman 1987]
Henry Lieberman: Concurrent Object-Oriented Programming in Act 1 ; in [Yonezawa 1987], pages 9-36.
[Lientz 1980] 
Bennet P. Lientz and E. Burton Swanson: Software Maintenance Management : a Study of the Maintenance of  
Computer Application Software in 487 Data Processing Organizations , Addison-Wesley, Reading (Mass.), 1980. 
[Liskov 1974] 
Barbara H. Liskov and Stephen N. Zilles: Programming with Abstract Data Types , Computation Structures  
Group, Memo no. 99, MIT, Project MAC, Cambridge (Mass.) 1974. ( See also SIGPLAN Notices , 9, 4, April 1974,  
pages 50-59.)
BIBLIOGRAPHY 1215
[Liskov 1979] 
Barbara H. Liskov and Alan Snyder: Exception Handling in CLU , in IEEE Transactions on Software Engineering , 
vol. SE-5, no. 6, November 1979, pages 546-558.
[Liskov 1981] 
Barbara H. Liskov, Russel Atkinson, T. Bloom, E. Moss, J. Craig  Schaffert, R. Scheifler and Alan Snyder: CLU 
Reference Manual , Springer-Verlag, Berlin-New York, 1981. 
[Liskov 1986] 
Barbara H. Liskov and John Guttag: Abstraction and Specification in Program Development , MIT Press,  
Cambridge (Mass.), 1986. 
[Loomis 1995]
Mary E. S. Loomis: Object Databases : The Essentials , Addison-Wesley, Reading (Mass.), 1995.
[M 19 XX] 
Bibliographic references of this  form indicate works by the aut hor of the present book, listed separately in the  
second part of this bibliography (E.2, page 1221).
[Madsen 1993]
Ole Lehrmann Madsen, Birger Mølle r-Pedersen, Kristen Nygaard: Object-Oriented Programming in the BETA  
Programming Language , Addison-Wesley, Wokingham (U.K.), 1993.
[Martin 1992]
James Martin and James J. Odell: Object-Oriented Analysis and Design , Prentice Hall, Englewood Cliffs (N.J.), 1992.
[Matsuoka 1993]
Satoshi Matsuoka and Akinori Yonezawa: Analysis of Inheritance Anomal y in Object-Oriented Concurrent  
Programming Languages , in [Agha 1993], pp 107-150.
[McCall 1977] 
James McCall (ed.):  Factors in Software Quality , Technical Report, G eneral Electric, 1977. 
[McGregor 1992]
John D. McGregor and David A. Sykes: Object-Oriented Software Development : Engineering Software for  
Reuse , Van Nostrand Reinhold, New York, 1992.
[McIlroy 1976] 
M.D. McIlroy: Mass-produced Software Components , in [Buxton 1976], pages 88-98.
[McKim 1992] 
James McKim: Teaching Object-Oriented Programming and Design , in Eiffel Outlook , vol. 2, no. 3, September-
October 1992, pages 8-19.
[McKim 1992a]
James McKim and David Mondou: Class Interface Design , in TOOLS 8 (Technology of Object-Oriented  
Languages and Systems ), eds. Raimund Ege, Madhu Singh, and Bertrand Meyer, Prentice Hall, Englewood Cliffs  
(N.J.) 1992, pages 151-161.
[McKim 1995]
James McKim: Class Interface Design and Programming by Contract , tutorial summary in  TOOLS 18  
(Technology of Object-Oriented Languages and Systems ), eds. Christine Mingins, Roger Duke and Bertrand  
Meyer, Prentice Hall, Englewood Cliffs (N.J.), 1995, pages 433- 470.
[McKim 1996]
James McKim: Programming by Contract , in Computer (IEEE), Object Technology department, vol. 29, no. 3,  
March 1996, pages 109-111.
[McKim 1996a]
James McKim: Programming by Contract : Designing for Correctness , in Journal of Object-Oriented  
Programming , vol. 9, no. 2, May 1996, pages 70-74.
[McMenamin 1984] 
Stephen M. McMenamin and John F. Palmer: Essential Systems Analysis , Yourdon Press, New York, 1984.
BIBLIOGRAPHY 1216
[Mills 1973] 
Harlan D. Mills and F. Terry Baker: Chief Programmer Teams , in Datamation , vol. 19, no. 2, December 1973,  
pages 58-61.
[Mills 1975]
Harlan D. Mills: How to Write Correct Programs and Know It , in Proceedings International Conference on  
Reliable Software , Los Angeles (Calif.), April 1975, published as ACM SIGPLAN Notices , 10, June 1975, pages  
363-370. Also in Mills’s book Software Productivity , Little, Brown and Company, Boston, 1983, pages 193-214.
[Milner 1978] 
Robin Milner: A Theory of Type Polymorphism in Programming , in Journal of Computer  and System Sciences , 
vol. 17, 1978, pages 348-375. 
[Milner 1989]
Robin Milner: Communication and Concurrency ; Prentice Hall International , Hemel Hempstead (U.K.), 1989.
[Mingins 1993]
Christine Mingins, Bogdan Durnota and Glen Smith: Collecting Software Metrics Data for the Eiffel Class  
Hierarchy , in TOOLS 15 (Technology of Object-Oriented Languages and Systems ), eds. Christine Mingins and  
Bertrand Meyer, Prentice Hall , Englewood Cliffs (N.J.), 1993, p ages 427-435.
[Mingins 1995]
Christine Mingins: Designing Software Metrics  (Tutorial notes), TOOLS Pacific (Technology of Object-Oriented  
Languages and Systems), Melbourne, 1995.
[Mitchell 1979] 
John G. Mitchell, W. Maybury and R. Sweet: Mesa Language Manual (Version 5 .0), Xerox Research Center, Palo  
Alto (Calif.), Report CSL-79-3, April 1979. 
[Modula-3-Web]
Modula-3 Home Page at http://www .research .digital .com/SRC/modula-3 /html/.
[Moffat 1981] 
David V . Moffat: Enumerations in Pascal , Ada and Beyond , in SIGPLAN Notices , vol. 16, no. 2, February 1981,  
pages 77-82.
[Moon 1986] 
David A. Moon: Object-Oriented Programming with Flavors , in OOPSLA ’86 Conference Proceedings , Portland  
(Oreg.), Sept. 29-Oct. 2, 1986, published as SIGPLAN Notices , vol. 21, no. 11, Nov. 1986, pages 1-8.
[Mössenböck 1993]
Hans Mössenböck: Object-Oriented Programming in Oberon-2 , Springer-Verlag, Berlin, 1992.
[Nerson 1992] 
Jean-Marc Nerson: Applying Object-Oriented Analysis and Design , in Communications of the ACM , vol. 35, no.  
9, September 1992, pages 63-74.
[Nierstrasz 1992]
Oscar Nierstrasz: A Tour of Hybrid : A Language for Programming with Active Objects ; in [M 1992a], pages 167-182.
[NSIA 1985] 
NSIA: (National Security Industry Association):  Proceedings of the first Join t DoD-Industry Symposium on the  
STARS program , San Diego (Calif.), 30 April – 2 May 1985. 
[Nygaard 1981] 
Kristen Nygaard and Ole-Johan Dahl: The Development of the SIMULA languages , in History of Programming  
Languages , ed. Richard L. Wexelblat, A cademic Press, New York, 1981, pag es 439-493.
[Oberon-Web]
Oberon Home Page , at http://ics.inf.ethz.ch/Oberon .html.
[Ong 1993]
C.L. Ong and W.T. Tsai: Class and Object Extraction from Imperative Code , in Journal of Object-Oriented  
Programming , vol. 6, no. 1, March-April 1993, pages 58-68.
BIBLIOGRAPHY 1217
[Orr 1977] 
Ken T. Orr: Structured Systems Development , Yourdon Press, New York, 1977. 
[Osmond 1995]
Roger F. Osmond: Essential of Successful O-O Project Management : Designing High Performance Projects , tutorial  
notes, TOOLS USA 95 (Technology of Object-Oriented Languages an d Systems), Santa Barbara (Calif.), July 1995.
[Paepcke 1993]
Andreas Paepcke (ed.): Object-Oriented Programming : The CLOS Perspective , MIT Press, Cambridge (Mass.), 1993.
[Page-Jones 1980] 
Meilir Page-Jones: The Practical Guide to Structured Systems Design , Yourdon Press, New York, 1980.
[Page-Jones 1995] 
Meilir Page-Jones: What Every Programmer Should Know  about Object-Oriented Design , Dorset House, New  
York, 1995.
[Papathomas 1992]
Michael Papathomas: Language Design Rationale and Semantic Fram ework for Concurrent Object-Oriented  
Programming ; PhD Thesis, Université de Genève, 1992.
[Parnas 1972] 
David Lorge Parnas: A Technique for Software Module Specification with Examples , in Communications of the  
ACM , vol. 15, no. 5, May 1972, pages 330-336.
[Parnas 1972a] 
David Lorge Parnas: On the Criteria to Be Used in Decomposing Systems into Modules , in Communications of  
the ACM , vol. 15, no. 12, December 1972, pages 1053-1058.
[Parnas 1986]
David Lorge Parnas and Paul C. Clemens: A Rational Design Process : How and Why to Fake It , in IEEE 
Transatctions on Software Engineering , vol. SE-12, no. 2, February 1986, pages 251-257.
[Petroski 1994]
Henry Petroski: The Evolution of Useful Things , Vintage Books, New York, 1994. (Original hardcover: Alfred A.  
Knopf, New York, 1992.)
[Pinson 1991]
Lewis J. Pinson and Richard S. Wiener: Objective C : Object-Oriented Programming Techniques , Addison-
Wesley, Reading (Mass.), 1991.
[Pooley 1986] 
Robert J. Pooley: An Introduction to Programming in SIMULA , Blackwell Scien tific, Oxford, 1986. 
[Pree 1994]
Wolfgang Pree: Design Patterns for Object-Oriented Software Development , ACM Press (Addison-Wesley), New  
York, 1994.
[Randell 1975] 
Brian Randell: System Structure for Software Fault Tolerance , in IEEE Transactions on Software Engineering , 
vol. SE-1, no. 2, June 1975, pages 220-232.
[Rich 1989] 
Charles Rich and Richard C. Waters: Formalizing Reusable Software Components in the Programmer’s  
Apprentice , in [Biggerstaff 1989]. 
[Rist 1995]
Robert Rist and Robert Terwilliger: Object-Oriented Programming in Eiffel , Prentice Hall Object-Oriented  
Series, Sydney (Australia), 1995.
[Rumbaugh 1991]
James Rumbaugh, Michael Blaha, William Premerlani, Frederick Ed dy and William Lorensen: Object-Oriented  
Modeling and Design , Prentice Hall, Englewood Cliffs (N.J), 1991.
[Sather-Web]
Sather Home Page  at http://http.icsi.berkeley .edu/Sather /sather .html.
BIBLIOGRAPHY 1218
[Schaffert 1986] 
Craig Schaffert, Topher Cooper, Bruce Bullis, Mike Kilian and C arrie Wilpolt: An Introduction to Trellis-Owl , in 
OOPSLA ’86 Conference Proceedings , Portland (Oreg.), Sept. 29-Oct. 2, 1986, published as SIGPLAN Notices , 
vol. 21, no. 11, Nov. 1986, pages 9-16.
[Schweitzer 1991]
Michael Schweitzer and Lambert Strether: Eiffel /S Compiler and Runtime , User’s manual, SiG Computer GmbH,  
Braunfels-Altenkirchen (Germany), 1991.
[Shang 1996]
David Shang: Is a Cow an Animal ? and Subtypes and Convertible Types , in Object Currents  (on-line publication),  
SIGS, New York, January and June 1996, at http://www .sigs.com/publications /docs/oc/9601 /oc9601 .c.shang .html 
(second article: 9606/oc9606 .c.shang .html).
[Shapiro 1989]
Marc Shapiro, Philippe Gautr on and Laurence Mosseri: Persistence and Migration for C++ Objects ; in ECOOP  
1989 (European Conference on Object-Oriented Programming ), ed. Steve Cook, Cambridge University Press,  
Cambridge (England), pages 191-204.
[Shaw 1981] 
Mary Shaw et al.: Alphard : Form and Content , Springer-Verlag, Berlin-New York, 1981. 
[Shlaer 1992]
Sally Shlaer and Steve Mellor: Object Lifecycles : Modeling the World in States , Prentice Hall, Englewood Cliffs  
(N.J.), 1992.
[Shneiderman 1980] 
Ben Shneiderman: Software Psychology , Little, Brown and Compa ny, Boston (Mass.), 1980. 
[Shneiderman 1987] 
Ben Shneiderman: Designing the User Interface : Strategies for Effective Human-Computer Interaction , Second  
Edition , Addison-Wesley, Reading ( Mass.), 1992. (First edition: 1987.)  
[Simons 1995]
Anthony J.H. Simons: Rationalising Eiffel’s Type System , in TOOLS 18 (Technology of Object-Oriented  
Languages and Systems ), eds. Christine Mingins, Roger Duke and Bertrand Meyer, Prent ice Hall, Englewood  
Cliffs (N.J.) 1995, pages 365-377.
[SIS 1987] 
SIS: Data Processing- Programming Languages — SIMULA , Standardiseringskommissionen i Sverige (Swedish  
Standards Institute), Svensk Standard SS 63 61 14, 20 May 1987.  
[Snyder 1986] 
Alan Snyder: Encapsulation and Inheritance in Object-Oriented Programming Languages , in OOPSLA ’86  
Conference Proceedings , Portland (Oreg.), Sept. 29-Oct. 2, 1986, published as SIGPLAN Notices , 21, 11,  
November 1986, pages 38-45. 
[Sombrero-Web]
Sombrero Project at the Arizona State University: http://www .eas.asu.edu/~sasos .
[Spivey 1988] 
J. Michael. Spivey: Understanding Z : A Specification Language and its Formal Semantics , Cambridge University  
Press, Cambridge, 1988. 
[Spivey 1992] 
J. Michael Spivey: The Z Notation : A Reference Manual , second edition, Prentice Hall International, Hemel  
Hempstead (U.K.), 1992. 
[Stallman 1992] 
Richard Stallman: Why Software Should be Free , Free Software Fundation, Boston (Mass.), 24 April 1992. 
[Standish 1984] 
Thomas A. Standish: An Essay on Software Reuse , in IEEE Transactions on Software Engineering , vol. SE-10,  
no. 5, September 1984, pages 494-497
BIBLIOGRAPHY 1219
[Stein 1995]
Jacob Stein: Les SGBD Objets n’ont pas tenu leurs Promesses  (Object-Oriented Databases Have Not Fulfilled  
their Promises), int erview by B. Meyer, in L’OBJET , vol. 1, no. 3, September 1995, pages 25-27.
[Stroustrup 1984] 
Bjarne Stroustrup: Data Abstraction in C , in AT&T Bell Laboratories Technical Journal , vol. 63, no. 8, Part 2,  
October 1984, pages 1701-1732.
[Stroustrup 1986] 
Bjarne Stroustrup: The C++ Programming Language , Addison-Wesley, Menlo Park (Calif.), 1986. (Superseded  
by [Stroustrup 1991].)
[Stroustrup 1991] 
Bjarne Stroustrup: The C++ Programming Language , Second Edition , Addison-Wesley, Menlo Park (Calif.),  
1991. (Revised edition of [Stroustrup 1986].)
[Stroustrup 1994]
Bjarne Stroustrup: The Design and Evolution of C++ , Addison-Wesley, Reading (Mass.), 1994.
[Suzuki 1982]
Norihisa Suzuki: Analysis of Pointer “Rotation ”, in Communications of the ACM , vol. 25, no. 5, May 1982, pages  
330-335.
[Szypersky 1993]
Clemens Szypersky, Stephen Omohundro and Stephan Murer: Engineering a Programming Language : The Type  
and Class System of Sather , International Computer Science Institute TechReport Tr-93-064 , Berkeley (Calif.),  
1993. Available on-line from http://www .icsi.berkeley .edu/~sather /Publications /tr-93-064 .html.
[Tabourier 1986] 
Yves Tabourier: De l’autre côté de Merise – Systèmes  d’Information et Modèles d’Entreprise , Les Editions  
d’Organisation, Paris, 1986. 
[Tardieu 1984] 
Hubert Tardieu, Arnold Rochfeld and René Colletti: La Méthode Merise , Principes et Outils (2nd Edition), Les  
Editions d’Organisation, Paris, 1984. 
[Tokoro 1992]
Mario Tokoro, Oscar Nierstras z and Peter Wegner (eds.): Proceedings of ECOOP 1991 Workshop on Object-Based  
Concurrent Computing ; Lecture Notes in Computer Science 612, Springer-Verlag, Berli n-New York, 1992.
[Tracz 1988] 
Will Tracz: Software Reuse : Emerging Technology (Tutorial ), IEEE, Catalog number EH0278-2, 1988. 
[Tracz 1995] 
Will Tracz: Confessions of a Used Program Salesman : Institutionalizing Software Reuse , Addison-Wesley,  
Reading (Mass.), 1995. 
[Ungar 1984] 
David Ungar: Generation Scavenging : A Non-disruptive High Performan ce Storage Reclamation Algorithm , in 
Proceedings of ACM SIGSOFT /SIGPLAN Software Engineering Symposiu m on Practical Software Development  
Environments , Pittsburgh, Penn., April 23-25, 1984, ACM Software Engineering Notes , 9, 3, and SIGPLAN  
Notices , 19, 5, May 1984, pages 157-167. (See also The Design and Evaluation of a High Performance Smalltalk  
System , PhD Thesis, Report UCB/CSD 86/287, EECS, Computer Science Div ision, University of California,  
Berkeley, February 1986.)
[Ungar 1992]
David Ungar, Randall B. Smith, Craig Chambers and Urs Hölzle: Object , Message and Performance : How they  
Coexist in Self , in Computer (IEEE ), vol. 25, no. 10, October 1992, pages 53-64.
[van Wijngaarden 1975] 
Aad van Wijngaarden, B. J. Mailloux, J.E.L Peck, C.H.A. Koster,  Michel Sintzoff, Charles H. Lindsey, Lambert  
G.L.T. Meertens and R.G. Fisker: Revised Report on the Algorithmic Language Algol 68 , in Acta Informatica , vol. 
5, 1975, pages 1-236.
BIBLIOGRAPHY 1220
[Versant 1994]
C++ /Versant Usage Guide , VERSANT Release 3 .0, Versant Object Technology, Menlo Park (Calif.), 1994.
[Waldén 1995] 
Kim Waldén and Jean-Marc Nerson: Seamless Object-Oriented Software Architecture : Analysis and Design of  
Reliable Systems , Prentice Hall, Hemel Hempstead (U.K.), 1995.
[Waters 1984] 
Richard C. Waters: The Programmer’s Apprentice : Knowledge Based Program Editing , in Interactive  
Programming Environments , eds. David R. Barstow, Howard E. Shrobe and Erik Sandewall, M cGraw-Hill, New  
York, 1984, pages 464-486.
[Weber 1992]
Franz Weber: Getting Class Correctness and System Correctn ess Equivalent — How to Get Covariance Right , in 
TOOLS 8 (Technology of Object-Oriented Languages and Systems ), eds. Raimund Ege, Madhu Singh, and  
Bertrand Meyer, Prentice Hall , Englewood Cliffs (N.J.) 1992, pa ges 199-213.
[Wegner 1987]
Peter Wegner: Dimensions of Object-Based Language Design , in OOPSLA ’87 Conference Proceedings , Orlando  
(Fla.), 4-8 October 1987, published as SIGPLAN Notices , vol. 22, no. 12, Dec. 1987, pages 168-182.
[Weiser 1987] 
Mark Weiser: Source Code , in Computer  (IEEE), vol. 20, no. 11, November 1987, pages 66-73.
[Wexelblat 1981]
Richard L. Wexelblat (ed.): History of Programming Languages  (Proceedings of a 1978 ACM SIGPLAN  
conference), Academic Press, New York, 1981.
[Welsh 1977] 
Jim Welsh, W. Sneeringer and C.A.R. Hoare: Ambiguities and Insecu rities in Pascal , in Software , Practice and  
Experience , vol. 7, 1977, pages 685-696.
[Wheeler-Web]
Scott Wheeler, Lovelace , on-line Ada 95 tutorial at http://lglsun .epfl.ch/Ada/Tutorials /Lovelace /lovelace .html.
[Wiener 1988]
Richard Wiener and Lewis Pinson: Introduction to Object-Oriented Programming and C++ , Addison-Wesley, 1988.
[Wiener 1995]
Richard Wiener: Software Development Using Eiffel : There can be Life Other than C++ , Prentice Hall Object-
Oriented Series, Engl ewood Cliffs (N.J.), 1995.
[Wiener 1996]
Richard Wiener, An Object-Oriented Introduction to Computer Science Using Eiffel , Prentice Hall Object-
Oriented Series, Engl ewood Cliffs (N.J.), 1996.
[Wiener 1997]
Richard Wiener, An Object-Oriented Introduction to Data Structures Using Eiffel , Prentice Hall Object-Oriented  
Series, Englewood Cliffs (N.J.), 1997.
[Wilson 1996]
Gregory V . Wilson and Paul Liu (eds.): Parallel Programming Using C++ , MIT Press, Cambridge (Mass.), 1996.
[Wirfs-Brock 1990]
Rebecca Wirfs-Brock, Brian Wilkerson and Laura Wiener: Designing Object-Oriented Software , Prentice Hall,  
Englewood Cliffs (N.J), 1990.
[Wirth 1971] 
Niklaus Wirth: Program Development by Stepwise Refinement , in Communications of the ACM , vol. 14, no. 4,  
1971, pages 221-227.
[Wirth 1982] 
Niklaus Wirth: Programming in Modula-2 , Springer-Verlag, Berlin-New York, 1982.
BIBLIOGRAPHY 1221
[Wirth 1992]
Niklaus Wirth and Martin Reiser: Programming in Oberon — Steps Beyond Pascal and Modula , Addison-Wesley,  
Reading (Mass.), 1992
[Wyatt 1992]
Barbara B. Wyatt, Krishna Kavi and Steve Hufnagel: Parallelism in Object-Oriented Languages : A Survey , in 
IEEE Software  November 1992. vol. 9, no. 6, pp. 56-66.
[Yokote 1989]
Yasuhiko Yokote, Fumio Teraoka, Masaki Yamada, Hiroshi Tezuka a nd Mario Tokoro: The Design and  
Implementation of the MUSE Object-O riented Distributed Operating System , in TOOLS 1 (Technology of Object-
Oriented Languages and Systems ), ed. Jean Bézivin, SOL, Paris, 1989, pages 363-370.
[Yonezawa 1987]
Akinori Yonezawa and Mario Tokoro (eds): Object-Oriented Concurrent Programming ; MIT Press, Cambridge  
(Mass.), 1987.
[Yonezawa 1987a]
Akinori Yonezawa et al.: Modelling and Programming in an Object-Oriented Concurrent Language ABCL /1; in 
[Yonezawa 1987], pages 55-89. 
[Yourdon 1979] 
Edward Nash Yourdon and Larry L. Constantine: Structured Design : Fundamentals of a Discipline of Computer  
Program and Systems Design , Prentice Hall, Englewood Cliffs (N.J.), 1979.
[Yourdon 1989] 
Edward Nash Yourdon: Modern Structured Analysis , Yourdon Press (Prentice Hall), Englewood Cliffs (N.J.), 1989.  
[Zdonik 1990]
Stanley B. Zdonik and David Maier: Readings in Object-Oriented Database Systems , Morgan Kaufmann, Menlo  
Park (Calif.), 1990.
E.2  WORKS BY THE AUTHOR OF THE PRESENT BOOK
[M 1976] 
La Description des Structures de Données (The Description of Data Structures) in Bulletin de la Direction des  
Etudes et Recherches d’Electricité de  France , Série C (Informatique) Clamart, no. 2, 1976. 
[M 1978] 
(with Claude Baudoin) Méthodes de Programmation (Methods for Programming), Eyrolles, Paris, 1978. Revised  
third edition, 1984. 
[M 1979] 
Quelques Concepts importants des Langages de Programma tion modernes et leur Expression en Simula 67
(Some Important Concepts of Mode rn Programming Languages and th eir Expression in Simula 67), in Bulletin  
de la Direction des Etudes et R echerches d’Electricité de France , Série C (Informatique), Clamart, no. 1, 1979,  
pages 89-150. Also in GROPLAN 9, AF CET (French Computer Society ), 1979.
[M 1982] 
A Three-Level Approach to Data Structure Description , and Notational , Framework  in ACM-NBS Workshop on  
Data Abstraction , Databases and Conceptual Modelling , Pingree Park, Colorado, 25-26 June 1981 (published as  
January 1982 issues of ACM SIGPLAN , SIGMOD , SIGART  newsletters), eds. Michael Brodie and Steven Zilles,  
pages 164-166.
[M 1982a] 
Principles of Package Design , in Communications of the ACM , vol. 25, no. 7, pages 419-428, July 1982. 
[M 1983] 
Towards a Two-Dimensional Programming Environment , in Proceedings of the European Conference on  
Integrated Computing Systems  (ECICS 82), Stresa (Italy), 1- 3 September 1982, eds. Pierpaolo  Degano and Erik  
BIBLIOGRAPHY 1222
Sandewall, North-Holland, Amsterdam, 1983, pages 167-179. Repri nted in Readings in Artificial Intelligence , 
Tioga Press, Palo Alto (Calif.), 1983.
[M 1984]
(with Jean-Marc Nerson) CEP AGE , a Full-Screen Structured Editor , in Software Engineering : Practice and  
Experience , ed. Emmanuel Girard, North O xford Academic, Oxford, 1984, pp.  60-65.
[M 1985a] 
On Formalism in Specifications , in IEEE Software , vol. 3, no. 1, January 1985, pages 6-25, Reprinted in T.  
Colburn, J. Fetzer, and T. Rankin (eds.), Program Verification :  Fundamental Problems in Computer Science , 
Kluwer Academic Publishers, Dor drecht (The Netherlands), 1993, and in Dutch, French and ot her translations.
[M 1985b] 
M: A System Description Method , Technical Report TRCS85-15, University of California, Santa B arbara,  
Computer Science Department, 1985. 
[M 1985c]
Eiffel : A Language for Software Engineering , Technical Report TRCS85-19, University of California, Santa  
Barbara, Computer Science  Department, December 1985.
[M 1986]
Genericity versus inheritance, in  OOPSLA ’86 Conference Proceedings , Portland (Oreg.), Sept. 29-Oct. 2, 1986,  
published as SIGPLAN Notices , vol. 21, no. 11, Nov. 1986, pages 391-405. Revised version in  The Journal of  
Pascal, Ada and Modula-2 , 1988.
[M 1987] 
Reusability : the Case for Object-Oriented Design , in IEEE Software , March 1987 vol. 4, no. 2 , March 1987,  
pages 50-64.
[M 1987a]
Design by Contract , Technical Report TR-EI-12/CO, ISE Inc., 1987.
[M 1987b]
Eiffel : Programming for Reusability and Extendibility , in SIGPLAN Notices , vol. 22, no. 2, February 1987, pages 85-94.
[M 1987c]
(with Jean-Marc Nerson and Masanobu Matsuo) Eiffel : Object-Oriented Design for Software Engineering , in 
Proceedings of ESEC 87 (First European Software Engineering Conference ), Strasbourg, 8-11 September 1987,  
eds. H.K. Nichols and D. Simpson, Springer-Verlag, Berlin, 1987 , pages 221-229.
[M 1988] 
Object-Oriented Software Construction , Prentice Hall, Hemel Hempstead (U.K.), 1988 (the first editio n of the  
present book).
[M 1988a] 
Eiffel : Basic Reference , Technical Report TR-EI-2/BR , ISE Inc., 1988. (Obsolete; see [ M 1992].)
[M 1988b]
Bidding Farewell to Globals , in Journal of Object-Oriented Programming , vol. 1, no. 3, September 1988, pages 73-76.
[M 1988c]
Harnessing Multiple Inheritance , in Journal of Object-Oriented Programming , vol. 1, no. 4, November 1988,  
pages 48-51.
[M 1988d]
The Eiffel Environment , in Unix Review , vol. 6, no. 8, August 1988, pages 44-55.
[M 1988e]
Disciplined Exceptions , Technical Report TR -EI-13/EX, ISE Inc., 1988.
[M 1988f]
Eiffel : A Language and Environment for Software Engineering , in Journal of Systems and Software , 1988.
[M 1989] 
From Structured Programming to Object-Oriented Design : The Road to Eiffel , in Structured Programming , vol.  
10, no. 1, 1989, pages 19-39.
BIBLIOGRAPHY 1223
[M 1989a] 
The New Culture of Software Development : Reflections on the Practice of Object-Oriented Design , in TOOLS 89  
(Technology of Object-Oriented Languages and Systems ), Angkor/SOL, Paris, November 1989, pages 13-23,  
Revised version in Journal of Object-Oriented Programming , vol. 3, no. 4, November-December 1990, pages 76-
81; reprinted in [M 1992a], pp. 51-81.
[M 1989b]
Static Typing for Eiffel , Technical Report TR-EI-18/ST, ISE Inc., 1989.
[M 1989c]
Writing Correct Software , in Dr. Dobbs’ Journal , December 1989, pages 48-63.
[M 1989d]
(with Philip Hucklesby) The Eiffel Object-Oriented Parsing Library , in TOOLS 89 (Technology of Object-
Oriented Languages and Syste ms), Paris, November 1989, publishe d by SOL, Paris, 1989, pp. 501-507.
[M 1989e]
You Can Write, But Can You Type? , in Journal of Object-Oriented Programming , vol. 1, no. 6, March-April 1989,  
pages 58-67.
[M 1990] 
Introduction to the Theory of Programming Languages , Prentice Hall, Hemel Hempstead (U.K.), 1990. Second  
printing, 1991.
[M 1990a]
Sequential and Concurrent Ob ject-Oriented Programming , in TOOLS ‘90  (Technology of Object-Oriented  
Languages and Systems ), Paris, June 1990, published by Angkor/SOL, Paris, 1990, pp. 17-28.
[M 1990b]
Tools for the New Culture : Lessons from the Design of the Eiffel Libraries , in Communications of the ACM , vol.  
33, no. 9, September 1990, pages 40-60.
[M 1992] 
Eiffel : The Language , Prentice Hall Obj ect-Oriented Series, 1991; second revised pr inting, 1992. 
[M 1992a] 
(editor, with Dino Mandrioli) Advances in Object-Oriented Software Engineering , Prentice-Hall, 1992. 
[M 1992b]
Design by Contract , in [M 1992a], pages 1-50.
[M 1992c]
Applying “Design by Contract” , in Computer  (IEEE), vol. 25, no. 10, October 1992, pages 40-51 (slightly r evised  
version of [M 1987a]).
[M 1993] 
(editor, with Jean-Marc Nerson) Object-Oriented Applications , Prentice Hall Object-Oriented Series, 1993. 
[M 1993a] 
(editor): Special issue on  Concurrent Object-Oriented Programming , in Communications of the ACM , vol. 36, no.  
9, September 1993.
[M 1993b] 
Systematic Concurrent Ob ject-Oriented Programming , in [M 1993a], pp. 56-80.
[M 1993c]
Towards an Object-Oriented Curriculum , in Journal of Object-Oriented Programming , vol. 6, no. 2, May 1993,  
pages 76-81. Revised version in TOOLS 11 (Technology of Object-Oriented Languages and Systems ), eds.  
Raimund Ege, Madhu Singh and Bertra nd Meyer, Prentice Hall, Eng lewood Cliffs (N.J.), 1993, pages 585-594.
[M 1993d]
What is an Object-Oriented Environment ? Five Principles and their Application , in Journal of Object-Oriented  
Programming , vol. 6, no. 4, July 1993, pages 75-81.
[M 1993e]
Eiffel vs . C++ , Technical Report TR-EI-59/CE , ISE Inc., 1993 (also available at  http://www .eiffel .com).
BIBLIOGRAPHY 1224
[M 1994] 
An Object-Oriented Environment : Principles and Applications , Prentice Hall Object -Oriented Series, 1994. 
[M 1994a] 
Reusable Software : The Base Object-Oriented Libraries , Prentice Hall Object-Oriented Series, 1994. 
[M 1995] 
Object Success : A Manager’s Guide to Object Technology , its Impact on the Corporation , and its Use for  
Reengineering the Software Process , Prentice Hall Object-Oriented Series, 1995. 
[M 1995a] 
Beyond Design by Contract : Putting More Formality into Object-Oriented Development , keynote presentation at  
TOOLS EUROPE conference, Versailles (France), 1995. (Transparen cies only.)
[M 1995b]
On the Role of Methodology : Advice to the Advisors , in [Alagar 1995], pages 1-5.
[M 1995c]
EiffelCase : Engineering Object-Oriented Software , Forward and Backward  (manual), TR-EI-53/EA, ISE Inc.,  
January 1995.
[M 1995d]
An Alternative to Object-Oriented Databases ?, keynote presentations at TOOLS USA, Santa Barbara (Calif.) a nd 
ESEC (European Conference on Softw are Engineering), Sitges (Spa in), 1995. (Transparencies only.)
[M 1995e]
Building Graphical Applications with EiffelBuild (manual), TR-EI-43/UI, ISE Inc., April 1995.
[M 1996]
The Reusability Challenge , in Computer (IEEE ), Object Technology department, vol. 29, no. 2, February 1996,  
pages 76-78.
[M 1996a]
Static Typing , in Object Technologies for Advanced Software , eds. Kokichi Futatsugi and Satoshi Matsuoka,  
Springer Lecture Notes in Computer Science 1049, Springer Verla g, Berlin, 1996, pages 57-75.
[M 1996b]
Why Your Next Project Should Use Eiffel , in Journal of Object-Oriented Programming , vol. 9, no. 2, May 1996,  
pages 59-63, 82.
[M 1996c]
Schema Evolution : Concepts , Terminology and Solutions , in Computer (IEEE ), Object Technology department,  
vol. 29, no. 10, October 1996, pages 119-121.
[M 1997]
ISE Eiffel : The Environment (manual), TR-EI-39/IE, ISE I nc., 1997, regularly updated (first  edition 1993).
[M 1997a]
(with Jean-Marc  Jézéquel) Design by Contract : The Lessons of Ariane , in Computer (IEEE ), Object Technology  
Department, vol. 30, no. 1, January 1997.
[M 199?]
(with Christine Mingins) Touch of Class : Learning to Program Well — A Modern Introduction to Software Using  
Object Technology , in preparation.
[M-video]
Object Technology Course , set of five video lectures , originally for Europace (1992), a vailable from ISE.
[M-Web]
On-line technology papers at  http://www.eiffel.com/doc/manuals/technology , from 1995 on.
Index
–  189
–>  589, 1186
:=  448
?=  593
"Class  (Ada 95)   1094
@  327, 328, 882
*  1180
+  189, 1180
<  189
<=  1177 , 1178
A
a posteriori scheme for handling 
abnormal cases   800–801
a priori scheme for handling 
abnormal cases   798–800
obstacles   799–800
Abbott, Russell J.   744
ABCL/1   999, 1034
abnormal case   411–438, 797–801, 
1089 –1091
a posteriori scheme   800–801
a priori scheme   798–800
abnormal case style for exceptions  
 1091
Abrial, Jean-Raymond   xi, 100, 
160, 330
absolute negative rule   667
absolute positive rule   666–667
abstract
machine   792
side effect   757
state   756–758
syntax tree   115, 1038
abstract  (Ada 95)   1093
abstract data type   18, 121–162, 
166, 171, 172, 173, 174, 216, 229, 
231, 318, 338, 352, 373–377, 399, 500, 722, 733, 734, 792, 862, 907, 
1100 , 1101 , 1176 , 1193
advanced topics   148–159
and abstract machines   792
and analysis   907
and assertions   373–377
and classes   142–147, 373–377
and information hiding   144–145
applications beyond software  
 147–148
complete example specification  
 139
consistency   155
formal description   129–141
genericity   131–132, 318
goals   122–129
specifying axioms   135–137
specifying the functions   132–
135
specifying types   130–131
abstracting   860, 930
abstraction
elevating the level   861
for GUI (Graphical User 
Interface)   1068 –1071
how to find abstractions   699–
704, 754
in methodology rules   669
varieties of class abstraction  
 860
versus precision   905–906
versus specialization   858–859
abstraction function   230, 375, 756
access control   1047
accessor function   135
accommodate   625, 629
accommodation   625, 629
ACCOUNT   329, 1046
Ada 95   1093
Accounts  (Ada 95)   1093
ACCOUNT1   491, 513
ACCOUNT2   491, 492, 513ACE Consortium   79
Ace file   198, 200, 201, 393, 1146
action   848
ACTIONABLE   1040
activate  (Simula)   1124
active data structure   774–796
internal view   786–792
active object   957–960
incompatible with inheritance  
 959–960
active process   1123
ActiveX   8, 67, 955
actors model   1033
actual reclamation   302
Ada  46, 53, 56, 61, 84, 89, 90, 99, 
100, 176, 209, 211, 225, 265, 269, 
270, 285, 315, 392, 410, 415–416, 
443, 447, 507, 510, 564, 587, 588, 
616, 716, 876, 892, 898, 980, 1104 , 
1106 , 1108 , 1130 , 1137 , 1161 , 
1167 –1188
adding classes   1098
concurrency mechanism   980
context and history   1079 –1080
exception handling   410, 415–
416, 438, 1088 –1091
exception rule   1090
genericity   587–588
towards an object-oriented 
version   1096
Ada 95   443, 564, 566, 1080 , 1092 –
1096 , 1097 , 1131 , 1137 , 1161
assessment   1094 –1095
example   1092 –1094
object-oriented mechanisms  
 1092 –1094
add  762
add_vertex   627, 633
address   1039
ADJ group   160
Adobe   xiv
INDEX 1226
Acrobat   108
Acrobat Reader   xiv
adopt   311
adopting an object   311
Advanced Curriculum principle  
 936
advertizer   912
advisory rule   667–668, 823
after   755, 782
Agammemnon   269
aggregation   258, 907
Agha, Gul   1033 , 1034
Aho, Alfred V.   20, 100, 745
airline reservation system   676
airplane   521–522
AIRPLANE   521, 831
Algol   49, 64, 211, 396, 447, 876, 
897, 1080 , 1102 , 1107 , 1114 , 
1126 , 1138
Algol W   64, 353, 455
Algol 68   61, 211
alias   440
aliasing   265–270, 277
in software and elsewhere   268–
269
semantics   266–267
all-or-nothing garbage collection  
 306–307
Alpha   1152
Alphard   99, 1079
AltaVista   78, 1060
Amako, Katsuya   922
America, Pierre   642, 1034
AMPHIBIOUS_VEHICLE   522
analysis   217, 271, 506, 725, 732–
733, 903–922, 936, 941, 1162 , 
1198
and the software process   906
as negotiation   906
class   732–733
contribution of object 
technology   907
describing business rules   913
domain analysis   947
goals   903–906
methods   917–919
requirements on an analysis 
method and process   904–905
role in education   936, 941
tasks   903–904traditional analysis methods   906
TV station programming 
example   907–913
analytical modeling   1122
ancestor   464, 500, 1193
anchor   601–602
artificial   1179 –1187
anchor   1179 , 1181
anchor  (construct not retained)   631
anchor-equivalent   603, 631
anchored declaration   598–604, 
618, 629, 630–633, 1177 , 1178
a static mechanism   604
and covariance   630–633
and once functions   652–653
rules   603
when not to use   603–604
Anchoring approach to the 
covariance issue   630–633, 639, 
642
and  454
and between assertion clauses   337
and then   454, 570, 578
Andromaque   671
animals, distinguishing from plants  
 841
anorexia   314
ANSI (American National 
Standards Institute)   1079 , 1097 , 
1102 , 1107 , 1131
ANSWER   688, 694
antonomasia   269
ANY   580–582, 590, 592, 976, 1044 , 
1187
APL   754, 876
applet   956
application   1064
as a class   690–693, 1076
APPLICATION   688, 689, 690, 690–
692, 694, 734
application builder   1065 , 1066 , 
1072 , 1073 , 1075 , 1076
application developer   1064 , 1066 , 
1067 , 1068 , 1070 , 1071 , 1072 , 
1073 , 1076
applicative   145, 159, 351–353
ArchiText   715
argument   444–446, 651, 764–770
actual   89, 184, 261, 444–446
definition   444formal   261, 444–446, 637
definition   444
polymorphic   637
ideal number of arguments for a 
feature   764–770
in out  (in non-O-O approaches)  
 765
passing   444–446
polymorphic   637
term used for routines (see also 
parameter)   322
to a once routine   651
type redefinition   621–641
Ariane 4   410
Ariane 5   389, 410
Aristotle   843, 864, 866
ARITHMETIC   180
Arnold, Ken   222, 939, 1137 , 1139
array   87, 325–328, 372–373, 470–
472
as object   325–326
properties   326
slice   383
static (Fortran, Pascal)   45
two-dimensional   330
ARRAY   325, 330, 348, 372, 441, 
470, 530, 540, 583, 584, 844, 882, 
1165 , 1188
array_down   123
ARRAY_TABLE   504
array_up   123
ARRAYED   846
ARRAYED_LIST   1165
ARRAYED_QUEUE   1188
ARRAYED_STACK   530, 539, 540, 
837, 844, 845, 846
ARRAYED_TABLE   831
ARRAY2   330
arsonist   201–202
ASCII   847, 850, 851
assembly   197, 198
automatic process   200, 1146
assembly language   1099
assertion   23, 334, 337–410, 569–
580, 617, 779–780, 900, 907, 917, 
930, 1193
and abstract data types   373–377
and analysis   907, 917
and encapsulation   779–780
and generalization   930
INDEX 1227
and inheritance   569–580
and redeclaration   481–482, 
570–580
expressive power   399–403
for documentation   389–392
for writing correct software   389
in C, C++ etc.   334
instruction   378–380
monitoring at run time   392–399
not a control structure   346–347
not for input checking   345–346
style rules   900
using a comment   399
using in practice   389–398
Assertion Argument rule   997
Assertion Evaluation rule   403
Assertion Redeclaration rule   573, 
578, 580
Assertion Violation rule   346
asset   521–522
ASSET   521
assignment   448
assignment attempt   29, 478, 591–
595, 617, 1068 , 1134 , 1193
rationale   591–592
semantic specification   593–594
using properly   594–595
associated_state   692, 693
association   907
Association Dijonnaise des 
Tapeventres   161
Association of Simula Users   732
asynchronous call   966, 1193
AT&T Bell Laboratories   12, 328, 
802, 1106 , 1132 , 1135
Atkinson, Colin   1034
Atkinson, M.   1061
attachment   242–244, 261–265, 
280, 444
and equality   264–265
copy attachment   262–263
definition   262
hybrid   263–264, 412, 445
polymorphic   467–470
reference attachment   262–263
source   262
target   262
attribute   173–176, 1193
adding or removing attributes to 
classes of persistent objects  
 1045 –1046and postconditions   579
client privileges   206–208
constant   203, 644–645, 884–885
exporting   205–208
in relational databases   1048
no precondition   579
once?   660
redefined from function   491–
492, 579
versus function   204
Austin Mini   811
AUTHORS   1048 , 1049
automatic update   31
available   184, 191, 447
available   299, 316
AVL trees   72
Avotins, Jon   1160
axioms of an abstract data type  
 135–137
B
B-tree   82
Bachelard, Gaston   672–673
back   782, 790
Backslash   645, 653
Backus, John   1102
BAG   857
Baillon, Henri   843
balance   369, 1046
balance_enquiry   980
Balter, R.   1034
Bancilhon, François   1061
bandwidth   48
bank account   56, 364, 368, 369, 
472, 491, 492, 513, 1046 , 1047
BANK_ACCOUNT   364, 368, 370
baritone   1143
Base libraries   351, 357, 456, 543, 
555, 710, 796, 802, 1146 , 1149 , 
1150 , 1152 , 1157 , 1165 –1166
Basic   1099 , 1106
Basic Construct of object-oriented 
computation   183, 611–612
basic triangle of computation   101–
103, 964
basic_store   1038
batch version of a system   108–109
Baudoin, Claude   35, 934, 937Bauhin, Caspar   864
BBC (British Broadcasting 
Corporation)   315
BCPL   1106 , 1111
be versus have   812–814
Beck, Kent   740
Beethoven, Ludwig van   1141 , 
1143
before   782
behavior class   72, 503–504, 688, 
772, 850, 961, 1002 , 1004 , 1010 , 
1021 , 1029 , 1030 , 1031 , 1193
bells and whistles   12
Ben-Ari, Mordechai   1033 , 1034
Bench   1148 –1149
Bert, Didier   xi, 100, 330
Bertino, Elisa   1061
Beta   1137 , 1139
Bezault, Éric   674, 1160
BI_LINKABLE   597, 624, 625, 797, 
1165 , 1166
bibliography   1203 –1224
Bielak, Richard   277, 807, 1034 , 
1061
Big Bang   194–196
Big Green Button   695
Biggerstaff, Ted J.   99
binary distribution   79
binary search   380–381
binary search tree   85, 92, 1188
binary tree   1188
BINARY_FILE   1174
BINARY_SEARCH_TREE   1188
BINARY_TREE   97, 604, 1007 , 1188
BINARY_TREE1   1008
binding
dynamic   29, 63, 85, 480–482, 
570–577, 1071 , 1174 , 1175 , 
1195
and assertions   570–580
and efficiency   507–515
and interactive applications  
 1071
implementation   482
overhead   509
in C++   1133
static   509–515, 1202
as optimization   509–515, 
1147
INDEX 1228
static and dynamic binding in 
C++   513–515
versus typing   619–621
BIRD   627, 841, 843
Birtwistle, Graham M.   35, 1138
block (Simula)   1123
block structure   49–50, 281, 282
blocking  (in short forms)   996
blocking object   996
Bobrow, Daniel G.   1139
body
of class in Simula   1118
Boehm, Barry W.   19, 20, 878
boldface   900
boldface italics   900
Booch, Grady   744, 918, 922, 1097 , 
1135
book   221–222, 277
Bookman font   901
BOOKS   1048 , 1049
BOOK1   221
BOOK2   223
BOOK3   226
BOOLEAN   171, 220, 644, 1172
BOOLEAN_MATRICES  (Ada)   1180
BOOLEAN_MATRIX   1179
BOOLEAN_RING   1179
BOOLEAN_RING_ELEMENT   1180
booting procedure   197
Borges, Jorge-Luis   18, 672
Borland   211, 515, 1130 , 1143
Borland Pascal   1101 , 1131 , 1137
boundary cases   353
BOUNDED_ARITY_TREE   604
BOUNDED_BUFFER   967, 968, 
986, 992, 993, 994, 996, 1022 , 1031
BOUNDED_LIST   710
BOUNDED_QUEUE   992, 994, 
1031
BOUNDED_STACK   576
Boussard, Jean-Claude   948
Bouy, Reynald   1160
BOX   857
Box symbol (Ada)   1083
BOY   623, 634
Brachman, Ronald J.   517
Brandon, D.H.   878
Breu, Ruth and Michael   863Bright, Walter   515, 670
Britannicus   1135
browser   1153
browsing   32, 1156 –1159
Bruce, Kim B.   629, 642
Bruno, John   1034
Budde, Reinhardt   642
buffer   990–992, 1021 –1022
BUFFER   980, 981
BUFFER_ACCESS   1021
BUFFER_MANAGER  (Ada)   1091
Buffon, Georges-Louis Leclerc, 
Comte de   843, 865
bug  18, 409
Build graphical application builder  
 1076 , 1149 , 1150 , 1160
bulimia   314
Bull   1079
Burstall, Rod M.   160
Business Card principle   990, 1020 , 
1031 , 1035 , 1036
business card scheme   974, 975, 
984, 989, 990, 993, 996, 1002 , 
1011
Business Object Notation   271, 464, 
517, 805, 914, 919–922, 930, 1150
business rule   913
for a TV station   913
BUTLER   1005
button   533, 1071 , 1074
BUTTON   511, 1017
buttonhole   533–534
Buxton, John M.   99
bytecode   956, 1136 , 1145 , 1147 , 
1149
C
C  49, 56, 61, 89, 176, 211, 225, 230, 
265, 266, 269, 270, 278, 282, 285, 
306, 315, 327, 328, 333, 334, 386, 
439, 441, 442, 443, 447, 507, 509, 
510, 670, 714, 716, 737, 742, 753, 
758, 876, 877, 891, 956, 1056 , 
1065 , 1067 , 1106 –1111 , 1130 , 
1131 –1137 , 1144 , 1146 , 1161
and exceptions   414–415
and memory management   295calling object-oriented 
mechanisms from C   1144
compilation   1146
efficiency   510
emulating object technology  
 1106 –1111 , 1112
history   1106 –1107
need for comments   891
Obfuscated   876
object-oriented extensions  
 1131 –1137 , 1138
structure type   1109
C++   35, 46, 56, 100, 208, 209, 211, 
239, 278, 294, 295, 305, 306, 310, 
334, 443, 444, 513–515, 548, 566, 
585, 616, 620, 628, 668, 670, 742, 
876, 1050 , 1056 , 1057 , 1099 , 
1106 , 1107 , 1132 –1135 , 1136 , 
1144 , 1161 , 1167
and memory management   294, 
295, 305, 306, 310
and novariance   628
assessment   1135
binding policy   513–515
complexity   1134 –1135
concurrency   1033
Obfuscated   876
wrapping legacy C++ code  
 1144
CABIN_BUTTON   1017
cache or recentl y accessed objects  
 1056
CAD-CAM (computer-aided 
design and manufacturing of engineering products)
  1051 , 1054
calculator   522
California Museum of 
Paleontology (Berkeley)   864, 
865, 868
call  24, 183–184, 447–448
asynchronous   966, 1193
calling object-oriented 
mechanisms from C and other 
languages   1144
chain   418
dual semantics under 
concurrency   966
external   311, 439–444
and garbage collection   311
function   453
optimizing   208–209
qualified   186–187, 447
INDEX 1229
separate   967
synchronous   966, 1202
target   184
unqualified   186–187, 447
callback   440, 505
Campbell, Roy H.   1033
can-act-as-a relation   497
Cancel button   1074
Cannon, H. I.   1139
Canonical Reduction rule   158
Capability Maturity Model   55
capacity   710, 882
CAR   810
car metaphor for software   672
CAR_OWNER   810, 845, 863
Cardelli, Luca   629, 641, 642
Carnegie-Mellon University   1079
Caromel, Denis   987, 1033
Carriero, Nicholas   1033
Carroll, Martin   328
cartesian product   133, 134, 149, 
150, 160, 1052
cartesian_ready   760
Case analysis and design 
workbench   711, 805, 1150
Case instruction   449
CASE tools   271
Cassandra   671
cast  306, 618, 620, 628, 668, 670, 
1133
Castagna, Giuseppe   629, 642
CAT (Changing Availability or 
Type)   638
catalog of graphical abstractions  
 1066
catcall   636–638
definition   638
Catcall approach to the covariance 
issue   639, 642
Catcall type rule   637, 639
categories of object orientation 
criteria   22
Cattell, R.G.   1061
CCS (Communicating Concurrent 
Systems)   1033
CD-ROM accompanying this book  
 viii, xiv, 1076 , 1143 , 1165
Cecil library   1144
CELL   526, 604, 607Cépage   715
Ceres   269
Ceyx   1131 , 1139
CGI script   1152
CHAIN   567
challenger   999, 1000 , 1027 , 1031
Chambers, Craig   215, 1139
change in software development  
 81–82
change or redo dilemma   59
change, rule of   814–816
Changing Availability or Type   638
CHARACTER   171, 220, 565, 644
characteristic function   139
cheating clients   572
check   378–380
check instruction   378–380, 452
Check_instruction   432
checking input values   345–346
Chen, Peter P.S.   120
Cheshire Cat   733
choice   686
choose_initial   692
CHORUS   1034
CII-Honeywell Bull   1079
CIRCLE   329, 467, 483, 826, 838, 
858, 886
CIRCULAR_LIST   710
CITY   497, 729
cladistics   865, 866–868
cladogram   867
Clark, David   939
class   23, 165–216, 1194
abstracting   860
abstraction   860
analysis   732–733
as module and type   170, 185
avoiding useless classes   720–
721
basic conventions   177–181
categories   731–732
consistency   771–773
deferred   30, 142, 143–144, 165, 
482–494, 500–506, 518, 686–
688, 1174 –1188 , 1195
definition   486
role  143–144, 500–506
definition   142
design   734–735do not confuse with object   165–
169, 216
does not “perform” something  
 726–727
effective   142, 143, 165, 1195
definition   486
expanded   256
factoring   860
finding   117
finding the classes   719–746, 
754
general heuristics   731–740
the general method   741–743
through reuse   740–741
generic   320–325, 1197
how big?   770–774
implementation   733–734
deferred   734
interface   747–808, 1197
documenting   804
recommended style   752–754
is a new class necessary?   721–
723
missing important classes   723–
724
modeling external objects   732–
733
name
as class descriptor   1043
naming   879
no-command   729–730
note clause   78
obsolete   802–803
passive   776–779
reason for rejecting classes   726–
731
rejecting inadequate classes   725
role  169–170
set  196
simple example   172–177
single routine   728
size  770–774
definition   771
flat  771
immediate   771
incremental   771
small   714–715
specification   1201
the ideal class   730–731
universal   580–582
versioning   1054
versus record   150–151
INDEX 1230
versus type   324–325
class descriptor
for C implementation of object-
oriented concepts   1110 –1111
for schema evolution in 
persistent object structures  
 1043
Class Elicitation principle   725
class invariant   118, 146, 363–410, 
413, 465, 570, 579, 647, 784, 785, 
952, 982–983, 999, 1022 –1024 , 
1194
and creation procedures   371
and Design by Contract   368–
369
and generalization   930
and inheritance   465, 570
and manifest constants   647
and reference semantics   403–
406
implementation invariant   376–
377, 409, 532, 756
role in software engineering   367
violations   409
when it must be preserved, when 
not  366–367
Class Tool   1153 , 1154 , 1156 , 1159
class validity   627
Class_invariant   432
class_name   433
Class-ADT Consistency property  
 375
class-valid   627, 636
classes préparatoires   941
classification
premature   728–729
classwide operation (Ada 95)   1094
CLEAR   330
Clemenceau, Georges   932
clickable, clickability   1158 –1159
client   51, 118, 119, 175, 182–183, 
785–786, 907, 1194
and analysis   907
being honest with clients   573
cheating clients   572
definition   182
dynamic   572
independence   861
privileges on an attribute   206–
208
versus inheritance   812–817client-server   953, 968, 1039 , 1056 , 
1149 , 1151 , 1152
clone   245, 247, 274, 275, 276, 303, 
582, 584, 880, 976
defined in terms of copy   247
CLOS   1131 , 1139
close   1174 , 1175
CLOSED_ FIGURE   483
closure
for modules, why needed   57
clouds and precipice   905–906
CLU   46, 90, 99, 100, 806, 1081
cluster   24, 210, 920, 923–924, 925, 
926–928, 1194
CLU   1081
in the Business Object Notation  
 920
subcluster   923
cluster  (Lace)   198, 199
Cluster Model of  the software 
lifecycle   926–928
Coad-Yourdon method   917
Coad, Peter   167, 917, 922
Cobol   165, 442, 737, 742, 876, 
1099 , 1107
COBOL   1079
Codd, E.F.   1048 , 1061
Cohen, Bernard   945, 948
Cohen, Jacques   316
cohesion   64
collect_now   308, 314
COLLECTION   857
collection_off   308, 312, 314
collection_on   308
Collins, Allen G.   868
color, use in software texts   902, 
1152
column
in relational databases   1048
comb-like structure   892, 894
command   135, 699–718, 748, 987, 
1073
arguments   707–708
as a class   699–700
button   751
composite   529, 716
creating a command object   703–
704
executing   707
remembering   702–703COMMAND   71, 699, 714, 721, 724, 
731, 734
COMMAND_INSTANCE   709
command-query separation   748–
764, 1029
Command-Query Separation 
principle   751, 759
comment   891
as assertion   399
non-header   891
COMMERCIAL   911, 913
commercial for a TV station   911–
912
COMMON  (Fortran)   48, 656, 736, 
742, 1102 –1104
garbage   48, 736
Common Lisp   1131
communication   977, 979–980
comp.object  Usenet newsgroup   35, 
674
compaction   313
COMP ANY   913
COMP ANY_PLANE   521
COMP ARABLE   523, 590, 727, 831, 
832, 1176 , 1177 , 1178 , 1183 , 1185 , 
1186
comparing references   244
compatibility   8, 16, 115, 443–444
compatible   913
compilation technology   1144 –
1148
challenges   1144 –1145
speed   31, 618
Compilist   897
complementary formalisms   920
completeness
of a garbage collector   305
of a specification   153–159
sufficient   156–159
COMPLEX   647, 760, 858, 1186
complex number   408, 518
component manufacturer   297
component-level approach to 
memory management   297–301
composability   42–43, 48, 50, 54
COMPOSITE_COMMAND   716
COMPOSITE_FIGURE   528, 1071
Compostela   152
INDEX 1231
compromise in the software process  
 906
computation
ingredients   101–103
computational reflection   1130
ComputerWorld   14, 1136
computing time   1123
concrete state   756–758
concurrency   102, 951–1036 , 1056 –
1057 , 1059 –1060 , 1091 –1092 , 
1118 –1121
and inheritance   959–960, 1121 –
1122
examples   1003 –1022
in Ada   980, 1098
in object-oriented databases  
 1056 –1057
intra-application   954
library mechanisms   972–973, 
1027 , 1030
multi-layer architecture   970–
971
proof rule   1022 –1024
semantic specification   1026 –
1027
summary of mechanism   951–
952, 1025 –1027
summary of the mechanism  
 1025 –1027
syntax specification   1025
validity constraints   997, 1025 –
1026
validity rules   973–976
CONCURRENCY   998, 1000 , 1001 , 
1019 , 1027 , 1030
Concurrency Control File   971–972
concurrent   1194
accesses to an object   982–983, 
1031
precondition paradox   995, 1036
concurrent engineering   924–925
conditional instruction   448–449
configuration management   66, 
1042
CONFIRMATION   693
Conflicting Assignments To Actual  
 446
conformance   469, 474, 591, 598, 
616, 1194
conforms_to   582, 640
conjugate   600CONS  (Lisp)   282
consistency
in naming features and classes  
 883–884
of a library   69
of an abstract data type   155
of analysis models using 
different views   920
static-dynamic types   475
Const_value   650
constant   452–453, 643–660, 884–
886, 1081
how to use   645–646, 884–886
initialization   656–657
manifest   452–453, 646–647, 
885
and class types   646–647
of a basic type   643–645
of a class type   646–648
of string type   653–654, 657
where to put declarations   886
Constantine, Larry   120
constructor (C++)   1133
constructor function (abstract data 
type)   135
CONTAINER   857
container data structure   471, 472, 
496, 587, 1194
content-based search tool   1060
context (in graphical systems)  
 1072 –1076
Context-Event-Command-State 
model of interactive graphical applications
  1073 –1076 , 1150
continuity   44–45, 47, 48, 50, 51, 54, 
56, 65, 103
contour model of programming 
languages   315
contract   341–342, 1194
CONTRACT_EMPLOYEE   853
contracting   919
in BON   919
contravariance   624, 625, 626, 628, 
1194
control (for graphical applications)  
 1066 , 1067
control structure   346–347
control structure style for 
exceptions   1091
CONTROLLER  (Simula)   1120convenience inheritance   824
Cook, William R.   642
coordinates in GUI (Graphical User 
Interface) systems   1070
copy   247, 274, 275, 276, 582, 583, 
584
CORBA   8, 955, 970
CORBA 2   955
coroutine   1012 –1014 , 1030 , 1036 , 
1118 –1126 , 1139 , 1140
example   1119 –1121
Simula   1118 –1126 , 1139 , 1140
COROUTINE   1013
COROUTINE_CONTROLLER  
 1014
correct   681, 682, 686
correct ADT expression   154
correct_mismatch   1044 , 1045 , 1046
correctness   4–5, 16, 52, 331, 332, 
369–373, 389, 427–430
a relative notion   333–334
and exceptions   427–430
conditional   4–5, 52, 401
of a class   369–373
partial   337
total   337
versus efficiency   394–398
correctness formula   334–335, 369
Correctness property   333
cosmetics   875–879
Così fan tutte   1000
count   777, 882
COUNTABLE_SEQUENCE   755
coupling   64
weak   48
covariance   621–642, 1194
Anchoring approach   630–633, 
639, 642
Catcall approach   636–638, 639, 
642
Global approach   633–636, 639
Cox, Brad J.   34, 80, 100, 119, 672, 
715, 1112 , 1131 , 1138
CPU   965, 1014
CRC cards   740
creation   231–236, 236–239, 279–
316, 518, 752
and inheritance   465–467, 479–
480, 518
and overloading   239
INDEX 1232
by a function   752
call  236–239
instruction   232–239, 448
effect   233, 237
multiple creation procedures  
 236–239
patterns   316
polymorphic   479–480
three modes   280–291
why explicit   235–236
Creation Inheritance rule   466
creation procedure   196, 236–239, 
371, 430, 647
and class invariants   371
and exceptions   430
using a parent’s creation 
procedure   539–540
creativity   878–879
creator   135
Cristian, Flaviu   438
criteria of object orientation   21–36
critical region   978, 979, 980, 984, 
990
conditional   978, 990
cryptography   953
CSP (Communicating Sequential 
Processes)   979, 980, 1033 , 1091 –
1092
cuckoo   859
Cunningham, Ward   740
Current   181, 446, 452, 453, 602
role  185–186
Current  as anchor   602
current demo   927
Curry, Gael A.   99
currying   215, 1076
cursor   461, 462, 488, 489, 490, 504, 
752, 754, 755, 756, 759, 774–796
custom_independent_store   1040
customer, is always wrong   336, 
343, 347, 353, 393, 428, 572
Cuvier, Georges   864, 865
Cybele   269
cycles, first and second (France)  
 941
cyclic structures under reference 
counting   303–304D
Dahl, Ole-Johan   35, 745, 1114 , 
1138
Daigakuin   941
Dami, Laurent   642
Darwin, Charles   843, 860, 865, 866
Data Division (Cobol)   737, 742
data sharing   50
data transmission   684
database   32, 1047 –1062 , 1198
engine   1053
locking   1047 , 1054 , 1055 , 1057 , 
1061
avoiding locks in Matisse  
 1056
in Versant   1057
object-oriented   1037 , 1050 –
1062 , 1152
advanced concepts   1058 –
1060
an oxymoron?   1058 –1060
engine   1053
examples of object-oriented 
database management sys-
tems   1055 –1057
fundamental concepts   1050 –
1055
threshold model   1053
query   1049 , 1055 , 1057
in object-oriented database 
management systems   1055
in Versant   1057
relational   1037 , 1048 –1053
definition   1048
limitations   1051 –1053
operations   1048 –1049
used with object-oriented 
software   1050 –1053 , 1152
when not applicable   1051 –
1053
using unstructured information 
in lieu of databases   1060
DATABASE   968
DATE   910
Date, Chris J.   1048 , 1061
De Cindio, Fiorella   948
De Moel, Joost   1160
dead code removal   1147deadlock   989–990, 1004 , 1031 , 
1035
debug   452
debug instruction   452
debugging   392–398, 1153 –1159
decentralization   7, 498, 643
declaration
syntax   203
decomposability   40–41, 47, 48, 50, 
54
decomposition
functional   103–114, 197
object-based   114–115
deduction versus induction   859–
860
deep_clone   248, 276
deep_equal   248, 276
deep_import   976, 977, 1035
default_rescue   430, 1044
defect   347
defensive programming   343–345, 
1195
deferred   484, 486
Deferred Class No-Instantation rule  
 487
define  (C)  266
definitions (full list)   1189
Dekleva, Sasha M.   20
Delphi   211, 515, 1130 , 1143
delta  (in the Business Object 
Notation)   920
demand   1000
demanding style for preconditions  
 354–357
DeMarco, Tom   120
Demeter   269
dependency analysis for 
compilation   1146
dependent   250, 1146
direct   250
deposits_list   364, 368, 1046
Deramat, Frédéric   1160
DeRemer, Franklin D.   20
Dernbach, Frédéric   1160
Descartes, René   37, 43, 673
descendant   464, 1195
descendant hiding   626–627, 835–
843
INDEX 1233
and subtype inheritance   835–
843
avoiding   838–839
using   839–840, 843
why needed   837
describing objects and their 
relations   118
design   150, 506, 725, 734–735, 
936, 941, 1162 , 1198
class   734–735
reusability   70–71
role in education   936, 941
Design by Contract   127, 146, 331–
410, 411, 419, 435, 569–580, 617, 
756, 805, 907, 919, 941, 952, 981, 
994, 1022 , 1028 , 1029 , 1090 , 1195
and analysis   907, 919
and concurrency   952, 981, 994, 
1028 , 1029
and inheritance   569–580
and invariants   368–369
in the Business Object Notation  
 919
middleman   575
role in education   941
subcontracting   576
design patterns   71–72, 100, 529, 
675–718, 735, 745, 759–764, 817, 
855, 871–874, 991, 1068
destructor (C++)   310
detach  (Simula)   988, 1119
detachment   283–284
developer   933
developer_exception_code   434
developer_exception_context   435
developer_exception_name   434
development object   1153 –1159
DEVICE   602, 1173 , 1174 , 1184
diagonal   499, 591
Diderot, Denis   121, 148
Dijkstra, Edsger Wybe   xi, 72, 122, 
160, 316, 347, 407, 664, 665, 667, 
678, 750, 835, 1003 , 1033 , 1135 , 
1138
dining philosophers   1003 –1006 , 
1033
Dioscorides of Anazarbus   864
direct manipulation   1063
direct mapping   47, 54, 931
directory   199DIRECTORY   1174
dirty read   1056
disciplinary approach   1100 , 1101 , 
1108
discipline and creativity   878–879
Disciplined Exception Handling 
principle   417, 419, 427
Discrimination principle   655
DISK   1173 , 1175
DISP ATCHER   1018
dispenser   127
display   594, 681, 682, 686, 688, 
1071
display  (for a button)   555
display  (for composite figures)   529
DISPLAY_ITERATOR   529
dispose   310, 314, 316
disposing of objects when garbage-
collected   310
distribution formats for reusable 
software components   79–80
distribution of knowledge   63
Dittrich, Klaus   1061
divide   762
DLL (Dynamic Link Library)   440
do_if   849
documentation   14–15, 18, 32, 54–
55, 803–805
and generalization   930
external   14
interface   14
internal   14
system-level   805
Documentation principle   804
dogmatism in assessing object 
orientation   21–22
domain   138, 377, 580
domain analysis   947
Don’t mode me in   1075
DOOR   720
DOTTED_SEGMENT   829
DOUBLE   171, 220, 522
downcasting   1134
drag-and-drop   1156
typed   1157
DRAGOON   1034
DRIVER   544, 545
Drix, Philippe   869duality between actions and objects  
 102, 146
Dubois, Paul F.   xi, 642, 715, 718, 
765, 1034 , 1112 , 1160
duel   999–1000 , 1031
Dufour, Sylvain   1160
Duke, Roger   160
Duncan, Thomas   868
DURATION   910
dynamic   1195
client   572
IP address   1043
Dynamic Binding principle   511
DYNAMIC_LIBRARY   440
DYNAMIC_ROUTINE   440
E
E_CLASS   169
ease of use   11–12, 15, 16
eating car   522
EATING_CAR   522
Eco, Umberto   viii, 163
economic analogy for object-
oriented concepts   127
economics of software procurement  
 76
economy   14, 15, 16
ECOOP concurrency workshops  
 1034
editor   724, 1066 , 1074 –1075
for graphical abstractions   1066
effecting   485, 1195
efficiency   9–11, 15, 16, 19, 68, 
208–209, 307, 327, 394–398, 482, 
507–515, 548, 616, 773, 1043 , 
1146 , 1147 –1148
and dynamic binding   507–515
and genericity   327
and inheritance   507–515
and static typing   616
of garbage collection   307
of repeated inheritance   548
of the compilation process  
 1144 –1146
of the environment’s generated 
code   1144
versus correctness   394–398
egoful design   878
egoless expression   878
INDEX 1234
egoless programming   878
Eiffel   1162
Einstein, Albert   672
electronic collocation   925
elevator   720
ELEVATOR   720, 1016
elevator system (concurrency 
example)   1014 –1019 , 1036
Eliëns, Anton   34
Élinck, Philippe   642
ELKS   1150
ELLIPSE   483, 527, 826, 838
Ellis Island   538
Ellis, Margaret   328, 668, 1138
Elmasri, Ramez   1061
else  179, 448, 450
elseif   449
embedded SQL   1049
EMPLOYEE   853
empty   777, 883
empty structures   353
emu   859
emulation   1099 –1112
Encapsulate Repetition   984
encapsulation   53, 779–780, 1053 , 
1195
and assertions   779–780
and databases   1053
encapsulation language   53, 1079 –
1098 , 1099 , 1106
encapsulation level of object-
oriented support   1099
encapsulation of non-object-
oriented software   441–443
end user   109, 1064 , 1065 , 1071 , 
1074 , 1075
ending_time   909, 910
engine
execution   1147
for object-oriented database  
 1053
ENGINEER   815, 816, 853
engineering schools (France)   941
ENQUIRY_ON_FLIGHTS   688
ensure   112, 338
ensure then   578
enter   802
entity   1196operations on generic entities  
 323–324
polymorphic   469, 488
precise definition   213
entity-relationship   120, 737, 742
enumerated type
Ada  1175
Pascal   660
ENVIR   650
environment for developing object-
oriented software   1143 –1160
ÉPÉE   1034
epilogue   1161 –1162
equal   246, 247, 248, 265, 274, 275, 
276, 582, 584
EQUIVALENCE  (Fortran)   266
error   347
precise terminology   347–348
esprit de l’escalier   932
Euclid’s algorithm   877
European Space Agency   410, 1080
evaluating candidate 
decompositions   736
event
in interactive system   1071 –
1076
handling   1072 –1076
EVENT   1071
event list   1123 , 1124
event notice   1123 , 1124
EVENT_NOTICE   1140
event-driven computation   1071 –
1076 , 1196
Everham, Edwin McKay III   842, 
859, 863
evolution
in biology   859, 865, 866, 867, 
868
of the language   1144
evolutionary taxonomist   866–868
exception   25, 241, 411–438, 801, 
999, 1088 –1091 , 1134 , 1196
abnormal case style   1091
advanced exception handling  
 431–435
as object   436–437
basic concepts   411–414
causes   413–414
comparison of mechanisms  
 1089 –1091control structure style   1091
definition   412
developer   434–435, 1088 –1089
examples   422–427
handling   414–422, 1088 –1089
history table   420–422
in Ada   415–416, 438, 1088 –
1091
in C-Unix   414–415
queries   431–433
raising   434–435, 1088 –1089
recovering   423–424
role  801
sources   412–413
exception  (Ada)   415
exception handler   1089
exception to methodology rule  
 668–669
EXCEPTION_CONSTANTS   431
EXCEPTIONS   431, 998, 1000 , 1001
execute  (for APPLICATION )  691
execute  (for COMMAND )  699
execute  (for STATE )  687
execute_interruptibly   1001 , 1002
execute_session   680, 688
execute_state   681, 682
execution engine   1147
execution of a system   195, 234
remote   1147
exists  (in the Business Object 
Notation)   920
expanded   254
expanded client   259
Expanded Client rule   259
explicitness   876–877
export
to the class itself   193–194
unrestricted   191
export   582, 605
express message   999
expression   452–456
with operators   453–454
extend   882
extendibility   6–7, 15, 16, 115, 441, 
644, 735, 768, 905, 1066 , 1196
and symbolic constants   644
in analysis   905
in graphical applications   1066
extendible   883
INDEX 1235
extension and specialization   499–
500
extension inheritance   826–827
definition   826
external   373, 440, 1144
external class   458
extract  (potential feature)   610
F
facility inheritance   532–533, 832–
833, 847–851
constant   850
definition   832
forms   850
machine   850
factoring   85–88, 860, 930
factoring out common behaviors  
 85–88
failure   411–412, 1090 , 1196
definition   412
Failure principle   420
False   220, 452
false alarm   417, 1196
fault   347
fault tolerance   424–425
Faust   604
feasibility study   904, 926
feature   24, 90, 143, 172–216
call  24, 183–184
effect   184
classification   173–175
clause   191–192, 889–890
header comment   889–890
multiple clauses   191–192, 
889–890
deferred   30, 482–494, 686–688, 
1174 , 1195
effective   1195
exported   1196
feature history, displayed in the 
environment   1158
final name   549
frozen   583–585
when to use   585
how many arguments?   764–770
how to recognize various kinds  
 177–178
identifier   189
immediate   464, 771
infix   189, 327–328, 586inherited   464
joining   552–553
naming   127–128, 879–884
obsolete   802–803
of a package   90
operator   187–191
precursor   493
prefix   189
renaming   535–540, 834, 1196
and redeclaration   538
discussion   563–564
effects   537
replication   544–548
secret   192–193
selection under repeated 
inheritance   553–555
specification   1201
undefining   551–553
universal   276, 582
using the original version of a 
redefined feature   493–494, 
555–561
feature   177, 210
Feature Call principle   186
Feature Call rule   473, 591, 592, 
594, 613, 634
Feature Tool   1153 , 1155 , 1156 , 
1158
Feldman, Jerome A.   1034
Feldman, Michael B.   1097
Feldman, Stuart I.   65
Feynman, Richard   672
field   219, 220–221, 228, 1156 , 
1196
displaying in an object-oriented 
environment   1156
in relational databases   1048
simple   220–221
figure   1068 –1070
composite   527–529
FIGURE   329, 472, 480, 482, 483, 
505, 528, 591, 658, 858, 1071 , 1093
file  88, 737–738, 742, 1036 , 1139 , 
1150
FILE   310, 645, 1174
FILE_TABLE   831
filter module   345
final   689
final name   549
finalizationoptimized form of compilation  
 1148
Finalize   1154
finding the top   107–108
finish   782
Finkelstein, Sheldon   1061
Firesmith, Donald   919
Firesmith, Donald G.   34
fitted   640
FIXED_STACK   503
Fixing What is Broken   671
fixpoint   635
flat form   541–543, 579
uses   542–543
flat size   771
flat-short form   543, 803, 1147
Flavors   1131 , 1139
FLIGHT_DATABASE   1059
flight_details   1059
flights   1059
FLOOR   745
FLOOR_BUTTON   1018
Floyd, Robert W.   407
fly  627, 841, 843
focus_line   838, 839
font, use in software texts   900–902
forall  (in the Business Object 
Notation)   920
force   882
foresight   629
FORK   1005
form (Alphard)   99
formal methods   5, 52, 129–162, 
1022 –1024 , 1034
formal text for requirements   914
formal texts as a basis for natural-
language requirements   916–917
formats for storing objects   1038 –
1039
forth   755, 782, 789
forth1  (not retained)   788
Fortran   12, 45, 211, 266, 327, 439, 
441, 446, 510, 714, 736, 742, 876, 
947, 1081 , 1102 –1106 , 1111 , 1161
efficiency   510
emulating object technology  
 1102 –1106
Fortran II   1102
Fortran IV   1102
INDEX 1236
Fortran 77   657, 1104 , 1106
Fortran 90   1102
Fortran 95   1102
history   1102
Waterloo   947
forward engineering   1150
fragile input   422–423
FrameMaker   108, 391, 696, 1159
framework   72
France
university curriculum   941
Franceschi, Fabrice   316, 1160
Franklin, Benjamin   673
free  978
free memory management   280–
287
Free On-Line Dictionary of 
Computing   750
Freeze   1154
freezing   1145 , 1146 , 1148
FRENCH_DRIVER   544, 546
FRENCH_US_DRIVER   545, 546
fresh   298, 299
friend (C++)   1133
from   451
frozen   583
frozen elements of a system   1145
full  883
function   89, 105–106, 174, 203, 
447, 1196
and evolution   108–109
call  453
categories   134–135
creating an object   752
domain   580
finite   1076
in an assertion   400–403
more than one   105–106
of a system   105–106
of an abstract data type   132–135
redefined into attribute   491–
492, 579
result   179–180, 210–213
achieving the effect of multi-
ple results   446, 758
rationale for the convention  
 210–213
versus attribute   204
versus object   146functional   89, 103–114, 197, 678–
684, 714, 1100
functional level of object-oriented 
support   1099
functionality   12–13, 15, 16
Fusion method   918
Futatsugi, Kokichi   160
G
G_swap   1168
Gakubu   941
Gamma, Erich   71, 100, 735, 745
Gannon, John D.   898, 902
garbage collection   30, 304–314, 
332, 1133 , 1196
a practical environment   312–
314
advanced approaches   308–309
algorithm   313
all-or-nothing   306–307
and external calls   311
basis   306–307
complete   305
disposing of objects   310
efficiency   307
parallel   308–309
practical issues   309–311
requirements   305–306
role  304
sound   305
timely   305
garbage common block   48, 736
Gates, William Henry   1136
Gelernter, David   1033
Gemstone   1055
GENERAL   201, 580–582, 583, 584, 
976, 1044
general relativity   194
GENERAL_ACCOUNT   606
GENERAL_BOUNDARY_VALUE_
PROBLEM   766
GENERAL_PHILOSOPHER   1004 , 
1005
GENERAL_WINDOW   817, 818, 
819
general-purpose facilities   180–181
generalist   933
generalization   926, 928–930, 1196
generated code efficiency   1144generation scavenging   308, 313, 
316
generator   219, 582, 1196
generator   582
generic  (Ada)   1085 , 1169
generic derivation   96, 321, 322, 
324, 325, 586–587, 1197
constrained   586–587
genericity   26, 84, 96–98, 317–330, 
585–590, 617, 628–629, 877, 
1084 –1085 , 1128 , 1167 –1188 , 
1197
and efficiency   327–328
and inheritance   470–472, 585–
590, 1167 –1188
and once functions   652, 660
and repeated inheritance   561–
562
as a solution to the covariance 
issue   628–629
combining with inheritance  
 470–472, 585–590, 1184 –1187
constrained   27–28, 329, 330, 
585–590, 617, 1170 –1188 , 
1194
emulating   1176 –1181
how to achieve in the pres-
ence of inheritance   1185 –
1187
non-object-oriented equiva-
lents   587–588
used recursively   590
cost  328
emulating with inheritance  
 1176 –1183
for abstract data types   131–132, 
318
in Ada   1084 –1085
in C  1112
unconstrained   590, 1168 –1188 , 
1202
as special case of constrained  
 590, 1187
emulating   1181 –1183
how to achieve in the pres-
ence of inheritance   1184 –
1187
Geoffroy Saint-Hilaire, Étienne  
 865
Germany
university curriculum   941
INDEX 1237
Geschke, C.M.   64
Gessner, Conrad   864
get_and_remove   987
get_integer   423
getint  (C)  753
Ghezzi, Carlo   20, 1034
Gil, Yossi   863
Gindre, Cyrille   934
Giraudoux, Jean   671
GIRL   623, 631, 634
GIRL_ROOM   625
Girod, Xavier   823, 863
GKS   1064
GKS graphical standard   1112
Global approach to the covariance 
issue   634, 639
global type analysis   633–636
go  782, 790, 1070
Go To Statement Considered 
Harmful (Dijkstra)   664–665
go_before   789
Goethe, Johan Wolfgang von   843
Goguen, Joseph A.   99, 160, 408
Goldberg, Adele   35, 119, 824, 937, 
1075 , 1126 , 1138
Gore, Jacob   35, 497, 745, 948
Gosling, James   1139
goto instruction (in traditional 
approaches)   277, 519, 664, 677–
678, 835
Gouraud, Henri   72
graduate courses   941
Graham, Ian   271, 919
grammatical categories   742
grand mistake (in identifying 
classes)   726
graphical abstractions   1068 –1071
graphical classes and operations  
 1071
graphical conventions   271, 464, 
487, 537, 921–922, 1150
in the Business Object Notation  
 921–922, 1150
graphical form for requirements  
 914
graphics   33, 1063 –1076
Great Encyclopedia   148
Gries, David   xi, 407, 986
Grundstudium   941GUE electronic mailing list   869
GUI (Graphical User Interface)  
 818, 1063 –1076 , 1150
interaction mechanisms   1071 –
1076
mathematical model   1076
needed tools   1064 –1066
portability and platform 
adaptation   1066 –1068
principal abstractions   1068 –
1071
GUIDE   1034
Guidec, Frédéric   1034
Gulliver’s Travels   672
Guralnick, Robert   868
Gurvets, Joseph   674
Guttag, John V.   160, 408
Gymnasium   941
H
Hadamard, Jacques   672, 725
Halbert, Daniel C.   746
handle   817–820, 855
handling
an object (in concurrent 
computation)   965–966
handshake   958
Hansen, Wilfred J.   12
Harbison, Samuel P.   1139
hardware parallelism   1007 –1009
hardware support for object 
technology   309
hardware-software machine   11, 95, 
352
has  82, 86, 94, 883
HASHABLE   590
hashing function   587
Hauptstudium   941
have versus be   812–814
Hawksworth, D.L.   868
header comment   178, 886–891
header file (C)   1108
heir  118, 462, 1197
Helena of Troy   269
Heliotis, James   948
HELP   693
help facilities   15Henderson-Sellers, Brian   34, 65, 
408, 919, 922, 934, 948
Hennig, Willi   866, 868
Hercules   129
Hewitt, Carl   1033
Hewlett-Packard   1152
hidden  (Simula)   1115
hidden clause in contracts   994
hide  1071
HIN syndrome   75
history   704
history list   704–715
representation   710–711
history of a feature   1158
history of taxonomy   864–867
HISTORY_LIST   734
HISTORY_LOG   724
Hoare, C.A.R.   xi, 19, 64, 72, 160, 
335, 375, 395, 396, 407, 408, 449, 
979, 1023 , 1033 , 1138
Hocking, Geoff   811
hold  (construct not retained)   978, 
984
holder   999, 1000 , 1009 , 1027
hole   533, 1156 , 1159
Hollywood   953
honesty   573
Hopkins, Trevor   1138
Horning, Jim J.   160, 898
Horowitz, Ellis   99
HOUSE   522
HOUSTON   729
HP 9000   1152
HTML   108, 1159
HTML (HyperText Markup 
Language)   391, 818
Hugo, Victor   802
Hullot, Jean-Marie   1139
humility in software construction  
 673–674
Huxley, Julian   866
Hybrid   987, 1034
hybrid language   294, 443–444, 616
Hydra   129
HYDROPLANE   522
INDEX 1238
I
IBM   505, 1152
IBM 704   12, 1102
Ichbiah, Jean D.   xi, 1079 –1080 , 
1095 , 1096
identifier   457
IDL (Interface Definition 
Language)   955
idle process   1123
IEEE Computer Society   408
if  448
IFL (Intermediate Functional 
Language)   401, 402
Illustra   1055
image processing   1051
immediate
size  771
immigrant   1045 , 1046
impedance mismatch   931, 933, 
1050 , 1060 , 1061
imperative   145–146, 351–353
name   727–728
implementation   607–609, 713, 
844–846, 931, 931–933, 934, 936, 
1162 , 1198
class   733–734
helps analysis   713
partial   503–504
rehabilitated   608, 713, 931–933, 
934
role in education   936
role in the software process   713
implementation   1179
implementation inheritance   832–
833, 844–846
definition   832
implementation variation   84, 122–
125
implicitness   137, 149–150
implies   454, 456
import   210
importing an object structure   976–
977
IMS   505
in out  argument (in non-O-O 
approaches)   765, 1169
in_schedule   910
include  (C)  1108include file, should not be needed in 
object technology   1146
Incorrect_inspect_value   432
incremental size   771
incrementality
of a garbage collector   307
of the recompilation process  
 1145
indentation   894–895
independent_store   1038 , 1040 , 1151
index   1225
index   909
index word   78
indexing clause, see note clause
indexing , see note
Indirect Invariant Effect   405–406
induction versus deduction   859–
860
infix   189
INFOMERCIAL   911
information
unstructured   1060
information hiding   25, 51–53, 55, 
65, 144–145, 191–194, 205–208, 
605–609, 796, 804, 805, 1081 –
1087 , 1197
and abstract data types   144–145
and inheritance   605–609
and preconditions   357–359
in Ada   1081 –1087
not a security measure   52
Informix   1055
Ingalls, Daniel H. H.   1138
ingredients of computation   101–
103
Ingres   820, 1152
inherit   462
inheritance   26–30, 63, 119, 185, 
459–874, 877, 1097 , 1167 –1188 , 
1197
adaptation   735
and analysis   907
and assertions   569–580
and class invariants   465, 570
and concurrency   959–960, 
1028 –1029 , 1121 –1122
and configuration management  
 66
and creation   465–467, 479–480, 
518and decentralization   498
and efficiency   507–515
and genericity   470–472, 585–
590, 1167 –1188
and information hiding   605–609
and selective exports   609
anomaly   980, 981, 1028 , 1034 , 
1035
basic conventions and 
terminology   464–465
clause   462
combining with genericity   470–
472, 585–590, 1184 –1187
convenience   824
dealing with multiple 
inheritance criteria   851–858
efficiency consequences   482
emulating with genericity   1175
global inheritance structure  
 580–582
graphical conventions   464, 487
how not to use   809–812, 823–
824
how to design inheritance 
structures   858–861
mathematical model   828
meaning and usage   494–500, 
809–870
summary   862
methodology of applying   809–
870
summary   862
module and type views   494–
497, 1095 –1096
multiple   26–27, 519–568, 617, 
1198
examples   519–534
what not to use as introducto-
ry example   520–521
one mechanism or more?   833–
835, 1095 –1096
parallel hierarchies   625
redundant   549
relation between classes, not 
objects   814
repeated   27, 543–563, 834, 1128
and efficiency   548
and genericity   561–562
unobtrusive   548–549
single   26, 851, 1201
taxonomy of inheritance forms  
 822–835
deferred and effective classes  
INDEX 1239
 833
versus client   812–817
Inheritance rule   822
Inheritance Simplicity rule   823
inheriting general-purpose facilities  
 180–181
initial   689
initialization   233, 236–237, 656–
657
default values   233
overriding   236–237
of global constants and shared 
objects   656–657
inlining   510, 1147
Inmos   1033
inner  (Simula)   959, 1121 –1122
input   457
checking   345–346, 422–423
fragile   422–423
input   686
INRIA   1131
insist   1000 , 1035
inspect   450
Simula   1116
inspector   746
instance   166, 167, 168, 475, 1197
and mold   167–169
current   181–182, 453, 1194
direct   219, 475, 1195
variable (Smalltalk)   1197
instruction   447–452
int_minimum  (Ada)   1171
int_swap   1169
INTBINTREE   90, 91
INTEGER   171, 220, 319, 497, 522, 
644, 745, 831, 1172 , 1178
INTEGER_COMP ARABLE   1178 , 
1185 , 1186
INTEGER_QUEUABLE   1183 , 1184
INTEGER_STACK   318
INTEGER_swap   1168
INTEGER_TABLE_HANDLING   90
INTEGRABLE_FUNCTION   715, 
718
integration   927
integrity   14, 15
integrity constraint   1047
interactive systems   675–718interactive version of a system  
 108–109
intercontinental driver   544
interface   51, 109–110
Explicit Interfaces   50, 65
Few Interfaces   47–48, 65
Small Interfaces   48–50, 65
internal free list   302
Internet   78, 925, 951, 953, 954, 
955, 956, 969, 1015 , 1032 , 1136 , 
1147
interpretation   618
Intranet   78, 1147
invariant   364, 451
Invariant rule   366
inverse   799
invert   574, 579, 800
IP address   1043
is_assertion_violation   432
is_concurrency_interrupt   1000
is_developer_exception   435
is_developer_exception_of_name  
 435
is_equal   274, 275, 584
is_signal   432
is_system_exception   432
is-a relation   497, 811, 812, 813, 
816, 817, 824, 825, 844, 845
Is-a rule of inheritance   811
is-a-kind-of relation   497
ISE (Interactive Software 
Engineering Inc.)   xi
ISO certification   55
italics   900
Itasca   1055
item  755, 777, 791, 882, 1178 , 1179 , 
1180
iterative development   713
iterator   529, 567, 848–850, 1197
ITERATOR   849
J
Jackson, Michael   114, 120, 858
Jacobson, Ivar   738, 740
Jaeschke, Rex   1134
Jakobson, Roman   867, 933
Jalloul, Ghinwa   1033
Japanuniversity curriculum   941
Java   46, 56, 100, 208, 209, 211, 
239, 392, 443, 548, 566, 595, 616, 
670, 956, 957, 970, 1099 , 1106 , 
1136 –1137 , 1139 , 1147 , 1153 , 
1159 , 1161 , 1162
bytecode   956, 1136 , 1147
virtual machine   956, 1136 , 1147
Workshop (Sun)   1153 , 1159
Jazayeri, Mehdi   20
JEIDA (Japan Electronic Industry 
Development Association), http://
www.jeida.or.jp   80
Jenkins, Trevor   315
Jézéquel, Jean-Marc   35, 948, 1034
Johnson, Paul   316, 771, 772
Johnston, J.B.   315
join (in relational databases)   1048 , 
1051
joining features   552–553
Jones, Cliff B.   xi, 160, 408
Jones, John   316
Jones, T. Capers   99
Jonker, Dewi   1160
Journal of Object-Oriented 
Programming   35
JOVIAL (Jules’s Own Version of 
the International Algorithmic Language)
  1080
Junia   1135
Jussieu, Antoine-Laurent de   843, 
865, 868
JUSTIFIER   850
K
K&R   1107
Kansas City   976
Kay, Alan   1126
Kempe, Magnus   1097
Kemper, Alfons   1061
Kernel library   522–523, 580–582, 
592, 1150 , 1165
Kernighan, Brian   1107
Kerstholt, John   948
Khawam, Patrice   1160
Khoshafian, Setrag   1061
Kim, Won   1061
Kindsoul, Jill   670
INDEX 1240
kiwi   859
Know the User (Hansen)   12
knowledge, distribution of   63
Knox, Sandra L.   xiv
Knuth, Donald Ervin   xiv, 100, 409, 
745, 807, 808, 1112 , 1135
Kraemer, Vincent   1160
Krakowiak, Sacha   1034
Krief, Philippe   745
L
L’OBJET   35
Lace   198, 200, 393, 396
Lahire, Philippe   1160
laissez-faire polic y for the society 
of modules   127
Lalanne, Frédéric   1160
Lalonde, Wilf R.   1138
Lamarck, Jean-Baptiste   865
lambda calculus   642
Lampson, Butler W.   408
language for object-oriented 
software construction   1143 , 1144
languages
non-object-oriented   1099 –1112
object-oriented   1113 –1140
usable versus useful   613–614
Lano, Kevin   408
Larch   160, 400, 408
launch   988
launch_one   988
Laurin, Michel   863
Law of Demeter   668, 671, 674
law of inversion   684
layout and presentation of software 
texts   891–902
fonts   900–902
lazy evaluation   988
Le Vourch, Xavier   316, 1033 , 1160
Lea, Rodger   1034
League for Programming Freedom  
 79, 80, 100
Leeuw, Guus Jr.   1160
legacy software   441–443
Legacy++   1144
letter case   457, 881
levels paradox   506
Lex (Unix tool)   75Lex library   1149 , 1151
lexical conventions   457–458
Ley, Michael   1061
Lezard, Tony   316
library   33, 42, 72, 197, 666, 747, 
856, 941, 1065 –1071 , 1081 , 1143 , 
1150 –1152 , 1165 –1166
and analysis   907
consistency of design   69
evolution   33
for concurrency   1027
for GUI (Graphical User 
Interface)   1066 –1071
indexing   34
role in education   941–946
role in methodology   666
Lieberherr, Karl J.   668
Lieberman, Henry   965
Lientz, Bennet P.   17–18, 20, 125
lifecycle   85, 103, 923–934
steps and tasks   926
like  601
limited private  (Ada)   1085
Linda   970, 1033
LINE_DELETION   699, 700, 727
LINE_INSERTION   709
linear algebra   573
linear equation solver   799
LINEAR_ITERATOR   849, 850, 851
Linguistic Modular Units principle  
 53–54, 90, 1101
LINKABLE   298, 596, 597, 598, 600, 
602, 604, 624, 776, 796, 1165
linkable element   596–597
LINKABLE1   776
linked   123
linked list   297–301, 596–597, 774–
796
LINKED_LIST   297, 460, 466, 567, 
596, 598, 600, 625, 727, 775, 795, 
1165
LINKED_LIST1   777
LINKED_QUEUE   1188
LINKED_STACK   567
LINKED_TABLE   831
LINKED_TREE   542
Linné, Carl   734, 843, 852, 864, 
865, 867
lint  635Linux   1152
Lisa   1101
Liskov, Barbara H.   xi, 160, 408, 
438, 806, 1079 , 1097
Lisp   65, 265, 269, 282, 315, 564, 
988, 1126 , 1129 , 1130 –1131
object-oriented extensions   564, 
1130 –1131 , 1139
list  1150
circular   567
with cursor   488, 752, 754, 755–
759
LIST   472, 474, 489, 512, 526, 567, 
602, 607, 848, 908, 1071 , 1165
Liszt, Franz   1135
live  961, 962
local   213
lock   1009 –1012 , 1036
minimizing   1056
LOCKABLE   1009
LOCKER   1009
LOCKING_PROCESS   1036
Löhr, Peter   948, 1034
LONDON   535, 538
London Ambulance Service   292–
293, 302, 315–316
London, Ralph   1079
Long, Darrell D.E.   125
longjmp   414
Loomis, Mary E. S.   1061
loop   451
how to get right   380–388
proving   383–385
syntax   386–388
loop   451
loop invariant   380–388, 413, 1197
loop variant   380–388, 1197
Loop_invariant   432
Loop_variant   432
Loops   1131 , 1139
LOUISIANA_INSTITUTIONS   834
lowest common denominator 
approach for graphical libraries  
 1067
LPG   100, 330, 1167
Lukács, Georg   831
INDEX 1241
M
M  330
machine   751–752
abstract   792
Macintosh   696, 1101
macro   440
macro   440
Maddison, David   863
Madsen, Ole-Lehrmann   1139
Mail-A-Pet   474, 478
main program
no such notion in object-oriented 
development   197–198
maintenance   17–19, 43, 68
and reusability   68
Make   802
Make file, should not be needed in 
object technology   1146
make_cartesian   239, 762
make_philosophers   1006
make_polar   239
Mallet, Olivier   1160
Management Information Systems  
 6
manager   57, 59
MANAGER   852
Mandrioli, Dino   20, 1034
Manfredi, Raphaël   316, 1160
map
as model for graphical 
abstractions   1068 –1070
Marcus, Robert   1138
mark-and-sweep   313
marriage of convenience   530–532, 
844, 850
Martin-Odell method   918
Martin, James   271, 918
Math library   442–443, 1149 , 1152 , 
1160
Matisse   1055 , 1056 –1057 , 1061
MATRICES   1173
MATRICES  (Ada)   1172
MATRIX   171, 522, 573, 1179 , 1185 , 
1186 , 1188
Matsuoka, Satoshi   956, 1034
Maughan, Glenn   1160
max  756
maxdiag   593Maximum_interval   910
Mayr, Ernst   866, 868
McCall, James   19, 20
McGregor, John D.   863
McIlroy, M. Douglas   67, 99
McKim, James C.   xi, 215, 277, 
408, 642, 807, 948
McMenamin, Stephen M.   120
meaning   432
MEL library   442, 818, 1067 , 1149 , 
1150
Mellor, Steve   918, 922
Melt   1154
melting   1145
Melting Ice Technology   618, 
1145 –1146
melting software elements   1145
member_of  (in the Business Object 
Notation)   920
MEMORY   309, 314, 998
memory management   30, 279–316
and ease of development   295–
296
and reliability   294–295
automatic   301–314
rationale   301
casual approach   290, 291–293
compaction   313
component-level approach   297–
301
detection   293
free mode   280–287
manual reclamation   290, 294–
296
reclaiming memory   293–294
space reclamation   282–283
precise nature of task   302
stack-based mode   280–287
static mode   280–287
the problem in object-oriented 
development   290
three modes of object creation  
 280–291
Mencken, H.L.   608
Menger, Mario   1160
Mephistopheles   604
Mesa   99, 1081
message   592, 1127 –1128 , 1197
binary   1127
keyword   1127unary   1127
message   681, 682, 687
Message not understood 
(Smalltalk)   320
meta-object protocol   1130
metaclass   168–169, 1198
metaphor   671–673, 674, 751
on the Net   674
method
of object-oriented software 
construction   1143 , 1162
method (Smalltalk term)   1126 , 
1198
methodology   663–948
abstraction and precision in rules  
 669
exception to rules   668–669
limitations   670–671
of using inheritance   809–870
summary   862
role and principles   663–674
role of practice   665–666
role of reusability   666
role of theory   665
typology of rules   666
use of this word in the singular  
 664
useful O-O techniques summary  
 871–874
metrics for object technology   65–
66
Microsoft   8, 67, 955, 1043 , 1130 , 
1134
Foundation Classes   1134
Word   108, 696
middle initial   125
middleman in contracts   575
middleware   8
military-aerospace community  
 1080
millennium problem   18
Mills, Harlan D.   xi, 334, 341
Milner, Robin   641, 956, 957, 1033
Mingins, Christine   65, 948, 1160
minimum   1177
minimum  (Ada)   1170 , 1171
Minimum_duration   910
Minsky, Naftaly   948
mirroring   1056
INDEX 1242
MIS (Management Information 
Systems)   230
mismatch_information   1044
missionary   933
Mitchell, John G.   1097
Mitchell, Richard   948
mixed abstractions   730
ML  641
MML (FrameMaker)   391, 1159
moa   859
MOBILE_HOME   522
mode in interactive systems   1075 , 
1153 –1159
model inheritance   825
modeling   228–231
role of expanded types   256–258
modesty   441
modifier function   135
Modula   447
Modula-2   53, 84, 90, 99, 211, 265, 
1079 , 1081 , 1097 , 1106 , 1137
Modula-3   1137 , 1139
Modular Protection principle   345
modularity   16, 39–66, 83–98, 146, 
643
criteria   40–46
principles   53–63
rules   46–53
module   24, 39–66, 83–98, 209–
210, 494–497, 643, 923, 1198
abstracted   73, 90
and inheritance   495–497
and type   170, 185, 1095 –1096
as a syntactic concept   170
family   84, 99
generic   96
Mesa term   1081
Modula term   90, 1081
super-module   209–210, 923
traditional module structures  
 89–93
why closed   57
why open   57
module-type identification   185
Moffat, David V.   660
mold and instance   167–169
Monash University   1160
monitoring assertions at run time  
 392–399
Moon, David A.   1139MooZ   408
Morgan, David   1160
Morrison, R.   415
MORTGAGE   839
MOSES method   919
Motif   442, 818, 1064 , 1065 , 1067 , 
1150
MOTIF   818, 819
MOTOR   1015
mountain path   905
mouse   1071
move   880
move_ pixel   1070
move_ proportional   1070
MS_WINDOWS   818
multi-branch instruction   449–451
multi-launcher   988, 1006
multi-panel systems   675–694
multimedia   1051
multiple criteria for inheritance  
 851–858
multiple results for a function   446, 
758
multiple views   55, 836, 851–852, 
914–917
in analysis   914–917, 920
maintaining consistency   915
of software   55
multiple-entry subroutine (Fortran)  
 1104 –1106
multiprocessing   953
multiprogramming   954
Munch, Edvard   81
MUSE   1034
MVC model   734, 745
N
N-version programming   426–427
NAG library   443, 1151
name
adapting to the local context  
 538–539
name clash   535–540
and naming conventions   539
precise definition and rule   562
naming conventions   127–128, 539, 
879–884
and name clashes   539benefits   883–884
features   879–884
for classes   879
general rules   879–880
grammatical categories   881–
882
letter case   881
local entities and routine 
arguments   880
standard feature names   882–883
narrowing   595
NASA   1080
native   933
NATO Science Affairs Committee  
 99
natural-language requirements  
 914, 916–917
deduced from formal text   916–
917
needs   196, 198
needs directly   196
negotiation in analysis   906
Nero   864, 1135
Nerson, Jean-Marc   271, 277, 517, 
715, 772, 919, 922, 1034 , 1160
nesting   49–50, 209–210, 524–525, 
923, 1070
of windows   524–525, 1070
Net library   1039 , 1149 , 1151 , 1152
Neumann, Peter G.   315
new (Ada)   1085
new (Simula)   1115
NEW_MORTGAGE   840, 843
NEW_YORK   535, 536
Newton, Sir Isaac   864
next  909, 910
next_in_list   910
NEXTSTEP   1131 , 1132
Nierstrasz, Oscar   1034
NIH syndrome   75–76
no hidden clause principle   994
No_more_memory   432
No-Instantiation rule   487
nominal detection policy 
(persistence)   1042
NON_UNDOABLE   717
non-deterministic wait   979
non-object-oriented languages and 
environments   1099 –1112
INDEX 1243
Non-Redundancy principle   343, 
355
non-separate   1198
NONE   582
nonlinear_ode   765
NORMAL   1174
normalized relational database  
 1048
Norwegian Computing Center  
 1114
notation design   278
note   78, 177, 178
note clause   78, 178–179, 890
noun   720
novariance   628, 1198
null record  (Ada 95)   1092
NUMERIC   171, 522, 523, 589, 610, 
831
Nygaard, Kristen   35, 1114 , 1137 , 
1138
O
O’Brien, Patrick D.   746
Oberon   1137 , 1139
Obfuscated
C  876
C++   876
OBJ-2   160, 330, 400, 408
object   165, 1198
abstract   1103 , 1193
adopting   311
as a modeling tool   228–231
as machine   751–752
automatic duplication   1056
basic form   219–220
cache   1056
cloning   245–246, 247–249, 
274–275, 583–584
deep   247–249
shallow   247–249
composite   254–261
concurrent access   982–983, 
1031
conversion   1042
copying   247, 274–275, 583–584
created, external   968–969
creation and destruction   279–
316
deallocation   294–296definition   218–219
describing   118
do not confuse with class   165–
169, 216
equality   245–246, 264–265
and attachment   264–265
external   218, 219, 732–733
here for the picking   117, 720, 
733
identity   225, 1052 –1053 , 1061 , 
1197 , 1198
importing an object structure  
 976–977
integrity   513, 982–985, 999, 
1056
lifecycle   365
live  285
manipulating   231–236
mirroring   1056
mismatch   1041 , 1042 , 1043 , 
1044 , 1045 , 1046 , 1060
motto   116
moving   312–313
optimized placement on disks  
 1056
persistent   32, 225, 1037 –1062 , 
1199
pre-computing   708–709
reachable
definition   290
reserving   983–985, 1027
run-time object structure   227–
228
separate   967
shared   643–660
how to obtain   648–649
initialization   656–657
software   219
storing and retrieving object 
structures   250–253, 1037 –
1062
formats   1038 –1039
transient   1202
unreachable   284–290
definition   290
in classical approaches   285–
287
in object-oriented develop-
ment   288–290
user interface   1072
versioning   1054 , 1056 , 1057 , 
1059 , 1061in Matisse   1056
in Versant   1057
versus function   146
weaning   311
Object Currents   35
Object Magazine   35
Object Management Group   955
Object Pascal   443, 616, 1101 , 1161
Object Pursuit   720
object request broker   955
object technology
and Ada 95   1094 –1095
applied to graphical 
developments   1066
contribution to analysis   907
emulating in non-object-
oriented environments   1099 –
1112
for building search tools   1060
hardware support   309
levels of language support  
 1099 –1100
list of criteria   21–36
rationale   101–120
Object Tool   1153 , 1155 , 1156
object-based decomposition   114–
115
object-oriented   1198
computation, basic mechanism  
 611–612
contrasted with top-down 
architecture   684–693
environment   1143 –1160
languages   1053 , 1100 , 1113 –
1140
methodology   663–948
rearchitecturing   441–443
style of computation   181–191
object-oriented computation
basic mechanism   183
object-oriented software 
construction
definition   116, 147
issues   117–118
Object-Z   160, 400, 408
object.fm   217–278
Objective-C   294, 443, 1099 , 1106 , 
1107 , 1131 –1132
Objectivity   1055
ObjectStore   1055
ObjEdit library   1149 , 1152
INDEX 1244
Objekt Spektrum   35
obsolete   802
Occam   980, 1033
Occam2   1033
occurrence   777
OCX   67
Odell, Jim   271, 918, 919
ODMG standard (Object Database 
Management Group)   1055 , 1057
Ogor, Robert   948
OK button   1074
old  340
oldest   962
OLE-COM   8, 67, 955, 1043
OMT   917, 1162
on_item   784
on-the-fly
object conversion   1041 , 1042
once   648
once attribute?   660
once function   647–650
and anchored types   652–653
and genericity   652, 660
emulating unique values   660
returning result of basic type  
 650
Once Function rule   653
once procedure   651
once routine   647–660, 1036
and concurrency   1036
applications   648–653
one  522
one_command   425
Ong, C.L.   745
Ontos   1055
OOIE (Object-Oriented 
Information Engineering)   918
OOPSLA concurrency workshops  
 1034
OOSE method   918
OOZE   408
open   1174 , 1175
OPEN unified method   919
OPEN_FIGURE   483, 527
Open-Closed principle   57–61, 63, 
65, 83, 465, 495, 496, 511, 514, 
517, 536, 577, 583, 592, 607, 633, 
735, 768, 803, 830, 834, 837, 839, 
861, 869, 959, 1092 , 1116 , 1174and Ada 95   1092
openness for modules, why needed  
 57
openness of an object-oriented 
language   439–444, 1144
operand   766–770
definition   766
distinguishing from option   767
Operand principle   767
benefiting   769
checklist   770
possible exceptions   769
operating system   107–108, 197, 
413
booting procedure   197
signal   417
operator
binary   453
boolean
non-strict   454–456, 458
expression   453–454
precedence   897
unary   453
optimistic locking   1055 , 1057
in Matisse   1056
in Versant   1057
optimization   208–209, 509–511, 
1147 –1148
option   766–770
definition   766
distinguishing from operand  
 767
or  454
or else   454, 578
Oracle   820, 1055 , 1152
Oracle 8   1055
orange   147
order relation   523
ordering constraints   110–112, 202, 
738–740
organized hacking   60–61, 830, 869
organized panic   417, 1090 , 1198
origin   285
definition   290
reference   286
original_class_name   433
original_recipient_name   433
original_tag_name   432
Orr, Ken T.   120OS/2   201, 442, 818, 1064 , 1150 , 
1152
OSA method   918
Osmond curves   13, 20
Osmond, Roger F.   13, 20
ostrich   859
OSTRICH   627, 841, 843
others  (Ada)   415
output   457
over  961
overlay   282
overloading   93–98, 239, 564–566, 
1134 , 1199
and creation   239
semantic   95–96
syntactic   93–95
overspecification   125, 573
O2  1055
P
package   90–98, 209–210, 1081 , 
1169 –1188 , 1199
as abstracted module   90
assessment of contribution to 
reusability   92–93
generic (in Ada)   1084 –1085
implementation (in Ada)   1084
in Ada   392, 1081 –1096 , 1169 –
1188
in Java   392
interface (in Ada)   1082 –1083
not needed thanks to selective 
exports   209–210
package-class   1098
pattern   1170
use in a client (in Ada)   1083 –
1084
Paepcke, Andreas   1139
Page-Jones, Meilir   34, 119, 120, 
730, 745, 863
painting   198
pan  1070
panel-driven systems   675–694, 709
Papathomas, Michael   1033 , 1034
paradox of levels   506
P ARAGRAPH   850
parallel inherita nce hierarchies   625
parameter
actual   96, 321
INDEX 1245
formal   96, 318
constrained   588–590
term used only for genericity 
(see also argument, system parameter)
  322
parent   462, 500, 1199
Parents’ Invariant rule   570
Parnas, David Lorge   xi, 64, 160, 
806, 1113
Parse library   1149 , 1151
parse tree   115
parsing, object-oriented approach  
 1151
part of relation   907
partial correctness   337
partial function   138–139, 377, 580
alternatives   151–152
partial implementation   503–504
Pascal   45, 49, 56, 61, 64, 165, 176, 
211, 225, 230, 265, 269, 270, 282, 
285, 286, 315, 327, 346, 386, 439, 
443, 447, 449, 507, 616, 716, 737, 
876, 940, 947, 1100 –1101 , 1106 , 
1108 , 1130 , 1161 , 1168
emulating object technology  
 1100 –1101
modular extensions   1101
object-oriented extensions  
 1101 , 1136 , 1137
UCSD   947
path expression   979, 980, 1033
Pavarotti, Luciano   674
payroll system   105–106
Peano, Giuseppe   171
pebble   1156
PEL library   442, 1067 , 1150
PENTAGON   467
Pérec, Georges   672
perfect foresight   629
performance, synonym for 
efficiency (see this term)   9
perimeter   461, 834
Perl  754, 1152
Perlis, Alan J.   99
PERMANENT   853
persistence   32, 250–253, 1037 –
1062 , 1149 , 1199
closure   32, 252, 1037 –1038 , 
1039 –1040 , 1152
when not applicable   1039 –1040
correction   1042 , 1045 –1046
detection   1042 , 1042 –1043 , 
1044 , 1045 , 1046 , 1060
from the language   1037 –1039
notification   1042 , 1044 , 1060
schema evolution   1041 –1046 , 
1060 , 1201
naïve approaches   1041 –1042
Persistence Closure principle   252, 
1037 , 1038 , 1039 –1040 , 1152
person   277
PERSON   810
Petri net   979, 981
phenetics   866–868
PHIGS   1064
PHILOSOPHER   1004
pick-and-throw   1156 –1159
picking (objects here for the –)   117, 
720, 733
Pinson, Lewis J.   1138
pixel   1070
PL/I   46, 269, 270, 442, 898, 1080 , 
1107
PL/360   1111
place_ pixel   1070
place_ proportional   1070
plants, distinguishing from animals  
 841
PLATFORM_WINDOW   817
platitude versus principle   667
Pliny the Elder   864
plug-in   955, 956, 1147
Poet   1055
POINT   166, 172, 173, 175, 176, 
180, 216, 218, 859
POINT_2D   858
pointers   315
polar_ready   760
police chief   336
polygon   460–461
POLYGON   460, 465, 466, 474, 475, 
483, 497, 527, 626, 627, 633, 834, 
1122
Simula   1116
POLYLINE   483
polymorphic argument   637
polymorphic assignment   469
polymorphic attachment   467–470polymorphic call   638
polymorphic data structure   329, 
470–472, 512, 585, 593, 692, 1199
type-specific access   593
polymorphic entity   469, 488, 637
polymorphic perversity   625–626
polymorphism   28, 63, 467–472, 
570–580, 816–817, 1097 , 1174 , 
1175 , 1199
and assertions   570–580
limits   474
Polymorphism rule   817
polyonymy   269
POOL   1034
Pooley, Robert J.   1138
Popper, Karl R.   812, 867, 868
portability   11, 15, 16, 19, 1066 –
1068 , 1152
of GUI (Graphical User 
Interface) tools   1066 –1068
post_action   1040
post_retrieve   1040
post_store   1040
postal code   18
postcondition   338–410, 983, 993, 
994, 1022 –1024 , 1177 , 1199
and attributes   579
and generalization   930
and inheritance   570–580
under concurrency   995, 997
Postcondition   432
postcondition paradox   995
postgraduate   941
POSTGRES   1055
Postscript   108, 818
Potter, John   567, 948, 1033
practice, role in software 
methodology   665–666
pre_store   1040
pre-computing a polymorphic 
instance set   708–709
precedence of operators   897
precepts (full list)   1189
precipice and clouds   905–906
precision in methodology rules   669
precision versus abstraction   905–
906
precompilation   1146 –1147
INDEX 1246
precondition   146, 338–410, 838, 
1022 –1024 , 1199
abstract   576–577
and export status   357–359
and inheritance   570–580
in abstract data types   138–139
tolerant or demanding style  
 354–357, 359–363
under concurrent execution  
 993–997
Precondition   432
Precondition Availability rule   358
precondition checking paradox   397
Precondition Paradox   995, 1036
precursor   507
Precursor   1144
Precursor   493, 494, 507, 517, 555–
560, 1128 , 1140 , 1144
precursor of a feature   493
Pree, Wolfgang   71, 100
prefix   189
preorder   523
prepare_cartesian   761
preprocessor   42
Presentation Manager   442, 818, 
1064 , 1065 , 1067 , 1150
preserve   1040
Principle of Least Surprise   454, 
897
Principle of Modesty   441
principle of selfishness   722
principle of shelfishness   147–148
principle versus platitude   667
principles (full list)   1189
Principles of Truth   663
print   582, 963
PRINT_CONTROLLER   968
print_line   582
PRINTER   596, 602, 967, 1035
Simula   1120
PRINTER_1   960
private  (Ada)   1086 , 1087 , 1098
procedural
means “imperative” (not the 
antonym of “object-oriented”); 
see functional   1100
procedure   89, 174, 203, 447–448, 
1199
call  447–448process   956–963, 1123 –1126 , 
1139 , 1140
active   1123
idle  1123
in discrete-event simulation  
 1123 –1126 , 1139 , 1140
programmed as a class   960–963
suspended   1123
terminated   1123
process   681, 682, 687
Process   970
PROCESS   961, 962, 963, 1004 , 
1030 , 1036 , 1140
PROCESS  (Simula)   1123 –1126 , 
1139 , 1140
processor   964–1032 , 1199
definition   964
procurement of software   76
PRODUCER  (Simula)   1120
PROGRAM   912
PROGRAM_FRAGMENT   910, 911
programming a TV station   911–
912
programs with holes   72, 505–506
Project Tool   1153 , 1154 , 1155 , 
1156 , 1159
projecting software texts on a 
screen   901
projection (in relational databases)  
 1048
proof by analogy   672
proof rule   1022 –1024
proper ancestor   464, 500, 1200
proper descendant   464, 1200
protected  (Simula)   1115
protection   45–46, 47, 48, 54
prototyping   518
Proust, Marcel   887
proxy   968, 969, 989
prunable   883
prune   779, 882
pSather   1034 , 1137
pseudo-random number generation  
 754–755
public   51
Pugh, John R.   1138
put  778, 884, 1178 , 1179
put_left   783
put_right   298, 607, 783put_state   691
put_transition   692
PVM (Parallel Virtual Machine)  
 970
Q
qua (Simula)   1116
QUADRANGLE   467, 483, 858
Qualified Call rule   447, 453
quality   3–20, 294–296
external factors   4–16
factors   3–16
internal factors   3
tradeoffs   15
quasi_inverse   424
query   135, 748, 987
button   751
expression   154
property-based   1047
QUEUABLE   1181 , 1183 , 1184
queue   127, 162, 410, 710–711, 734, 
990–992, 1150 , 1169 , 1183
bounded   710–711, 992, 1183
QUEUE   734, 882, 1181 , 1184 , 1187 , 
1188
QUEUES  (Ada)   1170
Quicksort   72, 877
QUOTATION   232
R
Racine, Jean   1135
raise   1072
raise  (Ada)   415, 436, 1090
raise_mismatch_exception   1044
Ramaekers, Jean   315
Randell, Brian   438
RANKED_GIRL   641
Rannou, Robert   948
rapid prototyping   518
rating   910
Ray, John   864, 865
reactivate  (Simula)   1124
read   681, 682, 687
readability   615, 644
and static typing   615
and symbolic constants   644
readable   883
INDEX 1247
REAL   171, 174, 188, 189, 220, 522, 
644
REAL_STACK   318
REAL_STACKS  (Ada)   1082 , 1084
reality   230–231
virtual   231
rearchitecturing   441–443, 1151
Reasonable Precondition principle  
 356, 357
reattachment   231–232
Réaumur, René Antoine Ferchault 
de  673
recipient_name   433
reclaim   297
recompilation
time   1144
reconciliation   1150
record
in relational databases   1048
record type (Pascal)   737
with variants   61–63
recovering from operating system 
signals   423–424
recovery block   438
rectangle   462–463, 524–525
RECTANGLE   463, 465, 466, 483, 
511, 513, 525, 527, 591, 626, 627, 
633, 634, 826, 858, 1122
recursion   170, 212, 235, 247, 248, 
252, 253, 259, 277, 280, 295
recursive dispose   295
recycle   299
recycling objects   299–300
redeclaration   491–494, 1200
and assertions   570–580
and renaming   538
and typing   595–598
conflicting under repeated 
inheritance   551–561
definition   485
redeem   839, 843
redeemable   839
redefine   462, 507, 538
redefinition   28, 204, 834, 1200
and once routines   648
how to prohibit   583
of an argument type   621–641
using the original version   493–
494
redo   706ref (Simula)   1115
reference   222–225, 226–228, 240–
253, 265–270, 272–274, 445, 815, 
1053 , 1200
and class invariants   403–406
comparison   244
declaring   226
definition   224
disciplined approach   277
encapsulating reference 
manipulations   269–270
in databases   1053
no references to subobjects  
 260–261
not sufficient   254
operations   242–253
origin   286
self-reference   226–227
semantics   261–265
separate   967
states   240
versus simple values   272–274
void   240–241, 244–245
reference  (notation not retained)  
 272, 286
reference counting   302–304
referential transparency   749–751, 
752, 753, 754, 756
definition   750
reflection   1130
registration mechanism for 
detection of object mismatches in persistence
  1042
reification inheritance   831
definition   831
relation
in relational databases   1048
relational algebra   1048
relativity   194
reliability   16, 68, 294–295, 331, 
332, 441, 615, 1043
and memory management   294–
295
and static typing   615
remembered   710
remote execution   955–956, 1147
across the Internet   1147
remove   298, 783, 880, 882
remove_all_right   710
remove_left   298
remove_oldest   963remove_right   298
remove_two   987
rename   536, 538
renaming rule   549–550, 562–563
rendez-vous   958
repairability   14
Repeated Inheritance rule   546
repetition in software development  
 74
replace   783, 882
replication under repeated 
inheritance   544–548
representation independence   84–
85, 98, 499
require   112, 338
require else   578
requirements document   116, 720–
725, 914–917
various forms (natural language, 
graphical, formal)   914–917
rescue   419, 452
rescue clause   419–422, 452
correctness   427–430
role  429–430
tasks   427–430
when absent   430
RESERVATION   692, 693
reserve   978
reserving an object   983–985, 1027
restaurant   522
restore   1040
restriction inheritance   826
definition   826
Result   179, 210–213, 452
resume   1013 , 1014
resume  (Simula)   1119
retain   1000
retrieved   252, 1039 , 1045 , 1047
retry   419, 420, 452
retrying   419–422, 424–425, 452, 
1090 , 1200
RETURN  (Fortran)   1104
return  instruction (not retained)  
 211
reusability   7, 15, 16, 67–100, 112–
113, 115, 441, 607–609, 666, 735, 
740–741, 773, 830, 856, 905, 908, 
928–930, 1066 , 1146 –1147 , 1200
and methodology   666
INDEX 1248
and the software development 
process   928–930
benefits   68–69
goals   68–70
in analysis   905, 908
in graphical applications   1066
nature of reusable components  
 70–73
obstacle
non-technical   74–81
obstacles
technical   81–83
of abstracted modules   73
of designs and specifications  
 70–71, 89
of implementation   607–609
of interface   607–609
of non-concurrent software  
 1031
of personnel   70
of source code   72–73
styles   608–609
reusability culture   929
reusable component
what form?   70–98
reusable software component   67–
100, 1200
distribution formats   79–80
how to find and access   77–79
indexing   78–79
reuse
consumers   69–70
producers   69–70
reuse-redo dilemma   82–83, 735
reuser of the month   929
reverse engineering   1150
reversibility   919, 930, 931–933, 
1150 , 1200
in BON   919
reversion   860
rewind   1173 , 1174
Rich, Charles   99
Riehle, Richard   1097
right   607
Riley, David   948
Rine, David   948
ring  827, 1173 , 1180 , 1185
RING_ELEMENT   1176 , 1177 , 1178 , 
1179 , 1180 , 1184 , 1185 , 1188
Risks forum   8, 125, 315–316
Web address   316Rist, Robert   35, 948
Ritchie, Dennis   1107
robustness   5–6, 16, 331, 332, 389
roman   901
ROOM   629
roommate   622
root
as synonym for “origin” (see that 
word) in memory management  
 285
class   196, 1200
creation procedure   196
directory   199
object   195, 285, 288, 289, 290, 
1200
root (Lace)   199
Roscoe, A. William   1033
Rosenbaum, Sarah   xiv
Ross, Herbert H.   868
rotate   1071
Rousseau, Roger   948
routine   89–90, 173–176, 1200
body   178
cannot modify its arguments  
 446
routine grouping   84, 90
Routine_failure   432
RS/6000   1152
RTF (Microsoft’s Rich Text 
Format)   391, 1159
rule
self practice   878
rule of change   814–816
rules
full list of methodological rules  
 1189
on library design   674
rules on rules   664–671
Rumbaugh, James   934
run time   1201
runtime   30, 291, 293, 294, 297, 
304, 1148 , 1200
definition   304, 1200
S
Sacks, Oliver   167
safe_share   640
Sagan, Carl   672
same_type   582, 640SAN_FRANCISCO   497, 729
SANTA_BARBARA   535, 538
Santiago de Compostela   152
Sarkis, Jean-Pierre   1160
Sather   642, 1137 , 1139
satisfiable call   1026
SAVE  (Fortran)   1104
Scaife, Ross   277
Schaffert, Craig   330, 1188
schedule   909, 910
SCHEDULE   908, 909, 913
schedule for a TV station   908–909
Schiller, Friedrich   1141
Schmidt, Heinz   1160
Schubert, Franz   1135
Schwartz, Laurent   672
Schweitzer, Michael   301, 567
Scott-Ram, N.R.   868
scripting languages   754
seamlessness   22–23, 506, 919, 
930–933, 941, 1150 , 1162 , 1201
in BON   919
role in education   941
search   791
secondary education   941
secret   51
secretary-receptionist algorithm  
 1000 –1002
security issues   956
SEGMENT   483, 829, 858, 909, 910, 
911, 913
segment for a TV station   909–911
select   554
select  (SQL)   1049
selecting a feature under repeated 
inheritance   553–555
selection (in relational databases)  
 1048
selective export   191–194, 209–
210, 609, 796–797, 1201
and inheritance   609
architectural role   209–210
Selective Export Inheritance rule  
 609
Self  215, 641, 1137 , 1139
self (Smalltalk)   453
self practice   878
Self-Documentation principle   54–
55, 78, 79, 179, 804, 890
INDEX 1249
semaphore   978, 1009 –1012 , 1036
semicolon
use as separator, terminator, or 
optional element   897–899, 
1088
Semicolon Style principle   899
Semicolon Syntax rule   898
sentinel   784, 787, 788, 789, 791, 
792–796
merging with list header   792–
796
separate   1201
call  967
class   967
entity   967–968
object   967, 982–990
reference   967
type   967
separate   952, 967
Separateness consistency rule   973, 
974, 975
Separatist   897–899
separator   897–899
SEQUENCE   848, 857
sequential   102, 1201
dependency   44
SEQUENTIAL_TABLE   504, 505, 
831
set  410
SET  857
set_developer_exception_context  
 435
set_mismatch_information   1044
setjmp   414
setup   961
Shang, David L.   629, 642
Shapiro, Marc   1034
share   622, 633
shared memory area   742
sharing in databases   1047
sharing under repeated inheritance  
 544–548
Shaw, Mary   xi, 408, 1079 , 1097
Shelf   1149
Shell   42
Shlaer-Mellor method   918
Shlaer, Sally   918, 922
Shneiderman, Ben   20
Shopping List advice   772shopping list approach to class 
design   111, 770–774
short form   176, 204, 389–392, 803–
804, 955, 1147 , 1158 , 1201
displaying in the environment  
 1158
side effect   748–764
abstract   757
concrete   749
forms   748–749
legitimate   759–764
signal   414
signature   1201
Silicon Graphics   1152
Simons, Anthony J. H.   629, 642
SIMPLE   201
Simpson, G.G.   866
Simula   35, 49, 57, 81, 209, 211, 
215, 272, 509, 517, 732, 988, 1080 , 
1099 , 1113 –1126 , 1138 , 1139 , 
1140 , 1167
Simula 1   1114
Standards Group   1114
simulated time   1123
simulation   732, 1122 –1126 , 1139 , 
1140
continuous   1122
discrete-event   1122 –1126 , 
1139 , 1140
SIMULATION  (Simula)   1123 –
1126 , 1139 , 1140
sinecure   336
Single Choice principle   61–63, 65, 
592, 1175
Single Name rule   549
Single Target principle   184, 185, 
215
SIS (Swedish Standards Institute)  
 1138
Sisyphus syndrome   59
ski team   621
SKIER   622, 631, 641
SKIER1   625, 628
skip  716
sleeping car   522
slice (of an array)   383
small classes   714–715
Smalltalk   35, 208, 320, 453, 517, 
585, 611, 734, 1050 , 1056 , 1057 , 1075 , 1099 , 1114 , 1126 –1130 , 
1132 , 1138 , 1140 , 1161 , 1162
assessment   1129 –1130
efficiency issues   1129
Smalltalk 72   1138
Smalltalk 76   1138
SmallVDM   408
Smith, Glen   1160
sneaky   750
Sneath, Peter H.A.   866, 868
Snyder, Alan   610
software
and reality   230–231
as operational model   732
companies   76–77
four worlds of software 
development   229–230
Software Correctness property   333
software developer as arsonist  
 201–202
Software Engineering Institute   55
software IC™   672
software inheritance   825
SOFTWARE_ENGINEER   813
SOFTWARE_ENGINEER_1   815, 
816
SOFTWARE_ENGINEER_2   815
SOFTWARE_ENGINEER_3   815
Sokal, Robert P.   866, 868
SOL (Société des Outils du 
Logiciel)   xi
Solaris   1152
solve   765
SOMA (Semantic Object Modeling 
Approach)   919
Sommerville, Ian   415, 809
SORTABLE_LIST   1186
SORTED_LIST   1186
soundness
of a garbage collector   305
source of an attachment   262
spaces, use in software texts   896–
897
special service   998–1002
specialization and extension   499–
500
specialization versus abstraction  
 858–859
SPECIALTY_EMPLOYEE   853
INDEX 1250
specification   5, 150, 1201
completeness   153–159
reusability   70–71
Speer, Brian R.   868
spiral lifecycle   713, 925
Spivey, J. Michael   160
sponsor   909, 912
SQL   1049 , 1050
embedded   1049
SQUARE   467, 483, 826
st_number   692
stable times of an object’s lifecycle  
 364
stack   123–162, 280–281, 285, 286, 
287, 329, 338–340, 348–364, 500–
502, 530–532, 576–577, 610, 857, 
1081 –1091 , 1150
bounded   576–577
complete abstract data type 
specification   139
package in Ada   1081 –1091
protected   359–363, 610
representations   123–124
STACK   166, 318, 329, 500, 502, 
530, 540, 576, 610, 857, 882, 989
STACK_OF_LINKABLES   299, 300
stack-based memory management  
 280–287
stackexp   140
STACKS  (Ada)   1086
STACK1   339
STACK2   349, 532
STACK3   359, 610
STACK4   364
stalactite development process  
 925, 930
Stallman, Richard   100
standard names for features   882–
883
standard_clone   584
standard_copy   583
Standish, Thomas A.   99
STARS program (Software 
Technology for Adaptable, Reliable Systems)
  81
start   782, 789
starting_time   909
state   1073 –1076
abstract   756–758as a class   684–686
concrete   756–758
in data structures   782–783
STATE   685, 686, 689, 690, 694, 731, 
734, 1075
Simula   1117
STATE_INSTITUTIONS   834
state-based concurrency model   979
static   1201
memory management   280–287
static-dynamic type consistency  
 475
statically typed language   612
statism   682–683
Steel, Thomas B.   79
Stein, Jacob   1061
Stendhal   121, 148, 269
step  961, 962
Stephan, Philippe   1160
Stephenson, Ian   294, 305
Stevens, Peter F.   843, 868
Stop Point   1159
stop_requested   962
STORABLE   252–253, 592, 1038 , 
1039 , 1045 , 1047 , 1152
store   252, 253
Store library   1149 , 1152
Store library for object-oriented-
relational combination   1050
store_ignore   1040
str_swap   1169
Strether, Lambert   301
string   456–457
constant   653–654
STRING   220, 456, 565, 583, 657, 
1186
STRING_COMP ARABLE   1185
STRING_swap   1168
strong condition   335–337, 573
Stroustrup, Bjarne   35, 557, 1132 , 
1138
structural detection policy 
(persistence)   1042
structure inheritance   532, 727, 
831–832
definition   831
structure type (C)   737, 1109
structured design   64
structured programming   334, 1131control structures   277
Stuessy, Tod F.   868
style   180, 875–902
and creativity   878
applying rules in practice   180, 
875–876
assertions   900
for comments and note clauses  
 886–891
for constants   884–886
importance of rules   877–878
naming rules   879–884
self practice in this book   878
terseness and expliciteness   876–
877
text layout and presentation  
 891–902
subcontract, subcontracting   332, 
576, 1201
subobject   255–261
no references to subobjects  
 260–261
subroutine, see routine
Fortran   1104 –1106
multiple-entry   1104 –1106
subtype   835–836
subtype inheritance   825–826, 835–
843
definition   825
subtyping
enforcing the subtype view  
 836–837
versus other forms of inheritance  
 833–835
subversion of software architecture  
 682, 683
subwindow   524–525, 1070
success   412
successive approximation   382, 384
sufficient completeness   156–159
sufficient_duration   910
SunOS   1152
super  (Smalltalk)   517, 1128 , 1140
supplier   182–183, 862, 1201
definition   182
suspended process   1123
Suzuki, Norihisa   270, 277
Swanson, E. Burton   17–18, 20, 125
swap   1168
Swift, Jonathan   104, 672, 750
INDEX 1251
Switzer, Robert   948, 1034
Sybase   820, 1152
Sylla, Karl-Heinz   642
symbolic constant   45, 644, 884–
886
Symbolic Constant principle   644, 
884
synchronization   977–982
versus communication   977
synchronous call   966, 1202
Syntropy method   918
system   196–197, 688–690, 1202
assembling   198–200
closure   196
execution   195
no main program in object-
oriented development   197–198
putting together   194–202
retrieving   1041
storing   1041
system parameter   650
System Tool   1153 , 1156
system validity   627, 628–641
error   627
System Validity rule   634
system-valid   627, 636
T
tab characters   894
table
in relational databases   1048
TABLE   82, 504
table searching   74, 81–98
TABLE_HANDLING   97
Tabourier, Yves   120
tabular form for requirements   914, 
920
tag_name   432
tagged  (Ada 95)   1092
tagged_out   582
Tang, Terry   1033 , 1160
tangent_from   887
TAPE   1173 , 1174 , 1175
Tardieu, Hubert   120
target
of a call   184
of a tool in the object-oriented 
environment   1154 –1158
of an attachment   262single   184–185
target   849
targeting a tool   1154 –1159
task
in Ada   980, 1091 –1092
to emulate classes   1098
tasks of object-oriented 
development   922
taxomania   728, 743, 820–821
taxon (pl. taxa)   866, 867
taxonomy
bibliography   868
history   864–867
in the biological sciences   864–
868
limitations   841–843
of inheritance   824–825
premature   728–729
taxonomy exception   837
yoyo approach   860
teaching object technology   935–
948
industrial training   935–937
introductory courses   937–940
non-introductory courses   940–
942
pedagogy   942–946
plan   946–947
TEACHING_ASSISTANT   520
template (C++)   1134 , 1202
TEMPORARY_EMPLOYEE   852
tenuring   308
terminated process   1123
Terminatist   897–899
terminator   897–899
terseness   328, 876–877
Tesler, Larry   715
test  849
TEST   533
testing   392–398
TEX   108, 391, 1159
text editor   715
TEXT_FILE   1174
textual form for requirements   920
Thatcher. J. W.   160
then   448, 450
Theophrastus of Eresos   864
theorem prover   578
theory, role in software 
methodology   665theta   763
Thomas, Pete   948
thrashing   292
thread   969, 970, 972, 1012 , 1032
threshold model for object-oriented 
databases   1053
time
computing   1123
simulated   1123
TIME   910
time (Simula)   1123
time-sharing   954
TIMED   1019
timeliness   14, 15, 16, 68
garbage collector property   305
token sequence   115
TOKENIZER   848
Tokoro, Mario   1033 , 1034
tolerant style for preconditions  
 354–357, 359–363
tool
in an object-oriented 
environment   1153 –1159
tool developer   1064 , 1067
toolkit   1064 –1065 , 1073
TOOLKIT   818, 819
TOOLS conferences (Technology 
of Object-Oriented Languages and Systems)
  641, 642, 674, 1033 , 
1034
tools for object-oriented software 
construction   1143 , 1148 –1150
top  679
finding   107–108
top-down design   41, 43, 89, 103–
114, 678–684, 1086
as a technique for describing 
rather than producing system architectures
  114
topmost function   41, 104, 116
total correctness   337
total function   138
total order   523
Toy Story  (movie)   953
train car   522
Training Topics principle   936
traitor   973–976, 977, 989, 1032 , 
1202
transaction   1047 , 1054 –1057 , 1061
INDEX 1252
in Versant   1057
long   1054 –1055
transition   689, 692
transition diagram   676–678, 1075 , 
1076
transition function   678–679
transition label   1072 , 1076
translate   172, 181, 1071
transparencies containing software 
texts, choice of layout and font  
 901
TRAVERSABLE   857
tree  524–527, 1150
abstract syntax tree   1038
definition   526
TREE   525, 567, 607
tree of life   859, 863
Trellis   330, 1137 , 1188
TRIANGLE   467, 483
triangle of computation   101–103, 
964
trigger   434
troff   391, 1159
Trojan War   671
True   220, 452
trying a type   592
tuple
in relational databases   1048
Turing, Alan   407
TV station programming (example)  
 907–913
twin, not needed   274–275
TWO_WAY_LIST   596, 599, 600, 
625, 710, 880, 1166
TWO_WAY_TREE   796, 1070 , 1166
type   24, 167, 497, 1202
and inheritance   497
and module   170, 185, 1095 –
1096
application to development 
environments   1157
as a semantic concept   170
base class   325, 602–603
basic   93, 171, 190, 191, 220, 
222, 226, 228, 234, 254, 256, 
257, 258, 263, 265, 272, 276, 
616, 636, 650, 656, 881
consistency   472–473
expanded   254–261, 263–265, 
412, 445, 470, 616, 975–976and analysis   907
and concurrency   975–976
definition   255
effect on attachment and 
comparison   263–265, 412, 
445
properties   258–261
role  256–258
forcing   478, 591–595
generalization   317–318
parameterization   318–320
protected (Ada 95)   1094
redefinition   621–641
reference   254, 256
definition   256
role  319–320
rule  323, 613
separate   967
static, dynamic   475–476
tagged (Ada 95)   1094
trying   592
type system   171–172
variable   629–630, 642
variation (reusability issue)   84, 
97
versus class   324–325
violation   612, 613, 614, 626, 
627, 628, 630, 632, 634, 635, 
636, 639, 641
Type Conformance rule   474, 591, 
613
Type Redeclaration rule   624
typed pick-and-throw   1157
typeset   634, 635
typing   322–323, 595–604, 611–642
a little bit typed   618–619
and efficiency   616
and inheritance   472–480
and readability   615
and redeclaration   595–598
and reliability   615
application to development 
environments   1157
becoming obnoxious?   591–592
dynamic   612–613, 616, 1128 , 
1195
arguments   616
definition   612–613
in Smalltalk   1128
pessimism   636–638
realism   613–614, 632
role  319–320static   25–26, 595–604, 612–613, 
615–642, 835, 1202
basic definitions   612–613
definition and advantages  
 615–621
the issue   611–614
versus binding   619–621
U
UCSD Pascal   947
UML (Unified Modeling 
Language)   919
UNARY_TREE   604
UNCOL   79
undefine   552
undefinition   485, 551–553
undergraduate courses   941
underline the nouns   700, 720–724
understandability   43–44, 48, 50, 54
undo   699
UNDOABLE   717
undoing   695–718, 932, 991
implementation   705–707, 707–
711
multi-level   696, 704–707, 716
practical issues   696–697
purpose and usefulness   695–
698
requirements on an undo-redo 
mechanism   697–698
user interface   711–712
uneffecting inheritance   830
definition   830
Ungar, David   316, 641, 1139
Unified Modeling Language   919
uniform access   55–57, 64, 175–
176, 203–208, 775, 779, 888
Uniform Access principle   57
unique value   654–655, 657–659
compared to enumerated types  
 657–659
emulated by once function   660
UniSQL   1055
United Kingdom
university curriculum   941
unity   1180
Universal Class rule   580
universal machine   79, 1137
universe   198
INDEX 1253
Università degli Studi di Milano   xi
University of Technology, Sydney  
 xi
UNIVERSITY_PERSON   520
Unix   12, 72, 199, 414–415, 533, 
737, 802, 818, 1063 , 1064 , 1074 , 
1152
and exceptions   414–415
folklore   802, 1063
pipe   44
Shell   42
Unixware   1152
unstructured information   1060
until   451
US Department of Defense (DoD)  
 55, 81, 1079 –1080
US_DRIVER   544, 545, 546
usable language   613–614
use (Ada)   1083 , 1085
use case   112, 738–740
Use Case principle   739
useful language   613–614
Usenet   35, 674
user interface   109–110, 711–712, 
713, 1152 –1159
interaction mechanisms   1071 –
1076 , 1152 –1159
object   1072
V
Valente, Dino   1160
Valéry, Paul   725
value
semantics   261–265
van Ommeren, Robin   1160
van Wijngaarden, Aad   100
variant   451
variation inheritance   828–830
definition   829
functional   829
type   829
Vax  1152
VBX   67
VDM   160, 400, 408, 831
VDM++   408
vector   585–587
VECTOR   585, 588, 589, 610
VEHICLE   522VENTILATION_SYSTEM   831
verb   720
verifiability   14
Versant   1055 , 1057 , 1061
Vi editor (Unix)   696, 1074 –1075 , 
1076
view inheritance   851–858
criteria   856–858
not a beginner’s mechanism   854
when appropriate   854–855
VIP client   999, 1031
virtual
function (C++)   514, 620, 1133
machine   956, 1136
reality   231
routine (Simula)   1116
virtual
C++   514, 620
Simula   1116
Vision library   820, 1039 , 1067 , 
1146 , 1149 , 1150 , 1152
Visual Basic   67, 1130
Vladivostok   976
VMS   199, 1152
VOCATION   815
Void  244, 582
Voltaire   498
W
Wagner, E. W.   160
wait by necessity   952, 987–988, 
989, 990, 1006 , 1007 –1009 , 1015 , 
1027 , 1033
wait condition   990–998
wait_ for_ job   963
wait_turn   1000
Waldén, Kim   34, 271, 277, 517, 
642, 745, 772, 902, 919, 921, 922, 
934, 1034 , 1061
walking menu   568
War of the Semicolons   897–899
Warnier, Jean-Dominique   120
watch-calculator   522
WATCHDOG   1020
watchdog mechanism   1019 –1021
waterfall model of the software 
lifecycle   924–925
Waterloo Fortran   947Waters, Richard C.   99
weak condition   335–337, 573
Weak Coupling   48
wean   311
weaning an object   311
Web browser   3, 954, 955, 968, 
1134
Web Crawler   1060
Web library   1149 , 1152
Weber, Franz   628, 629, 642
Weber, Mats   1096 , 1097
Weedon, Ray   948
Wegner, Peter   642, 1100
weight   157
Weight Consistency rule   156
Weiser, Mark   100
WEL library   442, 818, 1067 , 1068 , 
1149 , 1150
well-formed expression   153–155
Welsh, Jim   660
Wexelblat, Richard L.   1112
Wheeler, David A.   1095 , 1097
when   450
Ada  1089
widget (for graphical applications)  
 1066
Wiener, Richard S.   xi, 35, 902, 948, 
1138
Wiley, E.O.   868
WIMP (Windows, Icons, Menus, 
Pointing device)   1063
window   524–525, 1070 –1071
operations   1070 –1071
window system   1064 –1065
WINDOW   511, 512, 524, 560, 561, 
567, 817, 818, 1070
WINDOW_WITH_BORDER   558, 
560, 561
WINDOW_WITH_BORDER_AND_
MENU   560, 561
WINDOW_WITH_MENU   559, 560, 
561
Windows   199, 201, 442, 533, 1064 , 
1065 , 1067 , 1068 , 1150 , 1152
Windows NT   xiv, 1067 , 1152
Windows 3.1   1152
Windows 95   xiv, 1152
Wing, Jeannette M.   160
Wintel   11
INDEX 1254
wipe_out   298, 882
Wirfs-Brock, Rebecca   744
Wirth, Niklaus   xi, 64, 119, 408, 
1079 , 1097 , 1111 , 1137 , 1139
with  (Ada)   91, 1171
withdrawals_list   364, 368, 369, 
1046
WORK_CONTRACT   855
World-Wide Web   35, 954, 955–
956, 968, 1032 , 1060 , 1147
replacing databases?   1060
wrapper   441, 1144 , 1178 –1187
class   1178 –1187
object   1178 –1187
wrapup   962
wristwatch   522
writable   883
write-back   1042
writer   222
Wulf, William   1079
Wyatt, Barbara B.   1033
WYSIWYG (What You See Is 
What You Get)   1063 , 1065
X
x  763
X Window system   947
Xerox PARC (Palo Alto Research 
Center)   1126 , 1129 , 1131
Xlib   1064
XmPushButtonCallbackStruct  
(example of C/Motif name)   1065
xor  454
Y
Yacc   75
Yahoo   78, 1060
Yates, Warren   948
Yehudai, Amiram   642
yield   1000 , 1035
Yokote, Yasuhiko   1034
Yonezawa, Akinori   999, 1033 , 
1034
YOOCC (Yes! An Object-Oriented 
Compiler-Compiler)   1151 , 1160
Yourdon, Edward Nash   64, 120, 
917, 922yoyo approach to classification  
 860, 863
Yuksel, Deniz   1160
yy-bubble   1150
yy-table   1150
Z
Z  100, 160, 330, 400, 408, 1167
Z++   408
Zdonik, Stanley B.   1061
Zen  342–345
zero  522, 1180
Zero Weight rule   157
Zilles, Stephen   160
zooming   1150
2167 standard (US Department of 
Defense)   55
3E (Environment’s Execution 
Engine)   1147